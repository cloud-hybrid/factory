"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineGoModuleName = exports.ConstructsMaker = exports.ConstructsMakerProviderTarget = exports.ConstructsMakerModuleTarget = exports.ConstructsMakerTarget = exports.generateJsiiLanguage = exports.LANGUAGES = exports.Language = void 0;
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const codemaker_1 = require("codemaker");
const util_1 = require("../util");
const srcmak = __importStar(require("jsii-srcmak"));
const config_1 = require("../config");
const provider_schema_1 = require("./generator/provider-schema");
const provider_generator_1 = require("./generator/provider-generator");
const module_generator_1 = require("./generator/module-generator");
var Language;
(function (Language) {
    Language["TYPESCRIPT"] = "typescript";
    Language["PYTHON"] = "python";
    Language["CSHARP"] = "csharp";
    Language["JAVA"] = "java";
    Language["GO"] = "go";
})(Language = exports.Language || (exports.Language = {}));
exports.LANGUAGES = [
    Language.TYPESCRIPT,
    Language.PYTHON,
    Language.JAVA,
    Language.CSHARP,
    Language.GO,
];
async function generateJsiiLanguage(code, opts) {
    await util_1.mkdtemp(async (staging) => {
        // this is not typescript, so we generate in a staging directory and
        // use jsii-srcmak to compile and extract the language-specific source
        // into our project.
        await code.save(staging);
        await srcmak.srcmak(staging, opts);
    });
}
exports.generateJsiiLanguage = generateJsiiLanguage;
class ConstructsMakerTarget {
    constructor(constraint, targetLanguage) {
        this.constraint = constraint;
        this.targetLanguage = targetLanguage;
        if (this.constraint instanceof config_1.TerraformModuleConstraint) {
            this.fileName = `${this.typesPath(this.constraint.fileName)}.ts`;
        }
        else {
            this.fileName = `${this.typesPath(this.constraint.name)}.ts`;
        }
    }
    static from(constraint, targetLanguage) {
        if (constraint instanceof config_1.TerraformModuleConstraint) {
            return new ConstructsMakerModuleTarget(constraint, targetLanguage);
        }
        else {
            return new ConstructsMakerProviderTarget(constraint, targetLanguage);
        }
    }
    get version() {
        return this.constraint.version;
    }
    get source() {
        return this.constraint.source;
    }
    get name() {
        return this.constraint.name;
    }
    get fqn() {
        return this.constraint.fqn;
    }
    get namespace() {
        return this.constraint.namespace;
    }
    get moduleKey() {
        return this.fqn.replace(/\//gi, "_");
    }
}
exports.ConstructsMakerTarget = ConstructsMakerTarget;
class ConstructsMakerModuleTarget extends ConstructsMakerTarget {
    get isModule() {
        return true;
    }
    get isProvider() {
        return false;
    }
    get srcMakName() {
        switch (this.targetLanguage) {
            case Language.GO:
                return this.name;
            case Language.JAVA:
            case Language.CSHARP:
            case Language.PYTHON:
            default:
                return this.simplifiedName;
        }
    }
    get trackingPayload() {
        return {
            name: this.name,
            fullName: this.fqn,
            version: this.version,
            type: "module",
        };
    }
    typesPath(name) {
        return `modules/${name}`;
    }
    get simplifiedName() {
        var _a, _b;
        return ((_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.replace(/\//gi, ".").replace(/-/gi, "_")) !== null && _b !== void 0 ? _b : this.name);
    }
}
exports.ConstructsMakerModuleTarget = ConstructsMakerModuleTarget;
class ConstructsMakerProviderTarget extends ConstructsMakerTarget {
    get isModule() {
        return false;
    }
    get isProvider() {
        return true;
    }
    get srcMakName() {
        switch (this.targetLanguage) {
            case Language.JAVA:
                // "null" is a reserved keyword and can't be used as a package name
                return this.isNullProvider ? "nullprovider" : this.simplifiedName;
            case Language.CSHARP:
                // "null" is a reserved keyword and can't be used as a namespace
                return this.isNullProvider ? "Providers.Null" : this.simplifiedName;
            case Language.PYTHON:
                return this.simplifiedName;
            case Language.GO:
                return this.name.replace(/-/gi, "_");
            default:
                return this.constraint.fqn;
        }
    }
    get trackingPayload() {
        return {
            name: this.name,
            fullName: this.source,
            version: this.version,
            type: "provider",
        };
    }
    typesPath(name) {
        return `providers/${name}/index`;
    }
    get isNullProvider() {
        return this.constraint.name === "null";
    }
    get simplifiedName() {
        return this.name.replace(/\//gi, ".").replace(/-/gi, "_");
    }
}
exports.ConstructsMakerProviderTarget = ConstructsMakerProviderTarget;
class ConstructsMaker {
    constructor(options, constraints, reportTelemetry = () => { }) {
        this.options = options;
        this.constraints = constraints;
        this.reportTelemetry = reportTelemetry;
        this.codeMakerOutdir = path.resolve(this.options.codeMakerOutput);
        fs.mkdirpSync(this.codeMakerOutdir);
        this.code = new codemaker_1.CodeMaker();
        this.targets = this.constraints.map((constraint) => ConstructsMakerTarget.from(constraint, this.options.targetLanguage));
    }
    async generateTypeScript() {
        const schema = await provider_schema_1.readSchema(this.targets);
        const moduleTargets = this.targets.filter((target) => target instanceof ConstructsMakerModuleTarget);
        for (const target of moduleTargets) {
            target.spec = schema.moduleSchema[target.moduleKey];
        }
        const providerTargets = this.targets.filter((target) => target instanceof ConstructsMakerProviderTarget);
        if (providerTargets.length > 0) {
            new provider_generator_1.TerraformProviderGenerator(this.code, schema.providerSchema, providerTargets);
        }
        if (moduleTargets.length > 0) {
            new module_generator_1.ModuleGenerator(this.code, moduleTargets);
        }
    }
    async generate() {
        var _a;
        await this.generateTypeScript();
        if (this.isJavascriptTarget) {
            await this.save();
        }
        if (!this.isJavascriptTarget || this.options.outputJsii) {
            for (const target of this.targets) {
                // these are the module dependencies we compile against
                const deps = ["@types/node", "constructs", "cdktf"];
                const opts = {
                    entrypoint: target.fileName,
                    deps: deps.map((dep) => path.dirname(require.resolve(`${dep}/package.json`))),
                    moduleKey: target.moduleKey,
                };
                // used for testing.
                if (this.options.outputJsii) {
                    opts.jsii = { path: this.options.outputJsii };
                }
                if (this.isPythonTarget) {
                    opts.python = {
                        outdir: this.codeMakerOutdir,
                        moduleName: target.srcMakName,
                    };
                }
                if (this.isJavaTarget) {
                    opts.java = {
                        outdir: ".",
                        package: `imports.${target.srcMakName}`,
                    };
                }
                if (this.isCsharpTarget) {
                    opts.csharp = {
                        outdir: this.codeMakerOutdir,
                        namespace: target.srcMakName,
                    };
                }
                if (this.isGoTarget) {
                    // TODO: check if needed for modules somehow
                    // const targetType = target.isProvider ? 'provider' : 'module';
                    // jsii-srcmac will produce a folder inside this dir named after "packageName"
                    // so this results in e.g. .gen/hashicorp/random
                    const outdir = path.join(this.codeMakerOutdir, (_a = target.namespace) !== null && _a !== void 0 ? _a : "");
                    opts.golang = {
                        outdir,
                        moduleName: await exports.determineGoModuleName(outdir),
                        packageName: target.srcMakName,
                    };
                }
                if (process.env.NODE_OPTIONS &&
                    !process.env.NODE_OPTIONS.includes(`--max-old-space-size`)) {
                    console.warn(`found NODE_OPTIONS environment variable without a setting for --max-old-space-size.
The provider generation needs a substantial amount of memory (~13GB) for some providers and languages.
So cdktf-cli sets it to NODE_OPTIONS="--max-old-space-size=16384" by default. As your environment already contains
a NODE_OPTIONS variable, we won't override it. Hence, the provider generation might fail with an out of memory error.`);
                }
                else {
                    // increase memory to allow generating large providers (i.e. aws or azurerm for Go)
                    // srcmak is going to spawn a childprocess (for jsii-pacmak) which is going to be affected by this env var
                    process.env.NODE_OPTIONS = "--max-old-space-size=16384";
                }
                await generateJsiiLanguage(this.code, opts);
            }
        }
        for (const target of this.targets) {
            await this.reportTelemetry({
                payload: target.trackingPayload,
                language: target.targetLanguage,
            });
        }
    }
    async save(outdir = this.codeMakerOutdir) {
        await this.code.save(outdir);
    }
    get isJavascriptTarget() {
        return this.options.targetLanguage === Language.TYPESCRIPT;
    }
    get isPythonTarget() {
        return this.options.targetLanguage === Language.PYTHON;
    }
    get isJavaTarget() {
        return this.options.targetLanguage === Language.JAVA;
    }
    get isCsharpTarget() {
        return this.options.targetLanguage === Language.CSHARP;
    }
    get isGoTarget() {
        return this.options.targetLanguage === Language.GO;
    }
}
exports.ConstructsMaker = ConstructsMaker;
/**
 * searches for the closest `go.mod` file and returns the nested go module name for `dir`
 * e.g. (/dir/.gen/) => cdk.tf/stack/.gen if the parent dir of .gen has a go.mod for "module cdk.tf/stack"
 *
 * @param dir the directory to start the search from (searches upwards)
 * @returns the package name for `dir`
 * @throws an Error if no go.mod was found
 */
exports.determineGoModuleName = async (dir) => {
    let previousDir;
    let currentDir = path.resolve(dir);
    do {
        let files = [];
        try {
            files = await fs.readdir(currentDir);
        }
        catch (e) {
            // directory might not exist yet, but we still walk upwards from there, so ignore 'ENOENT'
            if (e.code !== "ENOENT") {
                throw e;
            }
        }
        if (files.includes("go.mod")) {
            const file = path.resolve(currentDir, "go.mod");
            const gomod = await fs.readFile(file);
            const match = /^module\s*(\S*)\s*$/m.exec(gomod.toString());
            if (match && match[1]) {
                const childdir = path.relative(currentDir, dir).replace(/\\/g, "/"); // replace '\' with '/' for windows paths
                return childdir.length > 0 ? `${match[1]}/${childdir}` : match[1];
            }
            throw new Error(`Could not determine the root Go module name. Found ${file} but failed to regex match the module name directive`);
        }
        // go up one directory. As dirname('/') will return '/' we cancel the loop
        // as soon as the dir does not change anymore.
        previousDir = currentDir;
        currentDir = path.dirname(currentDir);
    } while (currentDir !== previousDir);
    throw new Error(`Could not determine the root Go module name. No go.mod found in ${dir} and any parent directories`);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0cy1tYWtlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnN0cnVjdHMtbWFrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUErQjtBQUMvQiwyQ0FBNkI7QUFDN0IseUNBQXNDO0FBQ3RDLGtDQUFrQztBQUNsQyxvREFBc0M7QUFDdEMsc0NBR21CO0FBQ25CLGlFQUF5RTtBQUN6RSx1RUFBNEU7QUFDNUUsbUVBQStEO0FBRy9ELElBQVksUUFNWDtBQU5ELFdBQVksUUFBUTtJQUNsQixxQ0FBeUIsQ0FBQTtJQUN6Qiw2QkFBaUIsQ0FBQTtJQUNqQiw2QkFBaUIsQ0FBQTtJQUNqQix5QkFBYSxDQUFBO0lBQ2IscUJBQVMsQ0FBQTtBQUNYLENBQUMsRUFOVyxRQUFRLEdBQVIsZ0JBQVEsS0FBUixnQkFBUSxRQU1uQjtBQUVZLFFBQUEsU0FBUyxHQUFHO0lBQ3ZCLFFBQVEsQ0FBQyxVQUFVO0lBQ25CLFFBQVEsQ0FBQyxNQUFNO0lBQ2YsUUFBUSxDQUFDLElBQUk7SUFDYixRQUFRLENBQUMsTUFBTTtJQUNmLFFBQVEsQ0FBQyxFQUFFO0NBQ1osQ0FBQztBQUVLLEtBQUssVUFBVSxvQkFBb0IsQ0FDeEMsSUFBZSxFQUNmLElBQW9CO0lBRXBCLE1BQU0sY0FBTyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBRTtRQUM5QixvRUFBb0U7UUFDcEUsc0VBQXNFO1FBQ3RFLG9CQUFvQjtRQUNwQixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekIsTUFBTSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFYRCxvREFXQztBQVlELE1BQXNCLHFCQUFxQjtJQUd6QyxZQUNrQixVQUF5QyxFQUN6QyxjQUF3QjtRQUR4QixlQUFVLEdBQVYsVUFBVSxDQUErQjtR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QyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNuRTtZQUNELE1BQU0sSUFBSSxLQUFLLENBQ2Isc0RBQXNELElBQUksc0RBQXNELENBQ2pILENBQUM7U0FDSDtRQUNELDBFQUEwRTtRQUMxRSw4Q0FBOEM7UUFDOUMsV0FBVyxHQUFHLFVBQVUsQ0FBQztRQUN6QixVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUN2QyxRQUFRLFVBQVUsS0FBSyxXQUFXLEVBQUU7SUFFckMsTUFBTSxJQUFJLEtBQUssQ0FDYixtRUFBbUUsR0FBRyw2QkFBNkIsQ0FDcEcsQ0FBQztBQUNKLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgQ29kZU1ha2VyIH0gZnJvbSBcImNvZGVtYWtlclwiO1xuaW1wb3J0IHsgbWtkdGVtcCB9IGZyb20gXCIuLi91dGlsXCI7XG5pbXBvcnQgKiBhcyBzcmNtYWsgZnJvbSBcImpzaWktc3JjbWFrXCI7XG5pbXBvcnQge1xuICBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50LFxuICBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludCxcbn0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuaW1wb3J0IHsgUHJvdmlkZXJTY2hlbWEsIHJlYWRTY2hlbWEgfSBmcm9tIFwiLi9nZW5lcmF0b3IvcHJvdmlkZXItc2NoZW1hXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1Qcm92aWRlckdlbmVyYXRvciB9IGZyb20gXCIuL2dlbmVyYXRvci9wcm92aWRlci1nZW5lcmF0b3JcIjtcbmltcG9ydCB7IE1vZHVsZUdlbmVyYXRvciB9IGZyb20gXCIuL2dlbmVyYXRvci9tb2R1bGUtZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyBNb2R1bGVTY2hlbWEgfSBmcm9tIFwiLi9nZW5lcmF0b3IvbW9kdWxlLXNjaGVtYVwiO1xuXG5leHBvcnQgZW51bSBMYW5ndWFnZSB7XG4gIFRZUEVTQ1JJUFQgPSBcInR5cGVzY3JpcHRcIixcbiAgUFlUSE9OID0gXCJweXRob25cIixcbiAgQ1NIQVJQID0gXCJjc2hhcnBcIixcbiAgSkFWQSA9IFwiamF2YVwiLFxuICBHTyA9IFwiZ29cIixcbn1cblxuZXhwb3J0IGNvbnN0IExBTkdVQUdFUyA9IFtcbiAgTGFuZ3VhZ2UuVFlQRVNDUklQVCxcbiAgTGFuZ3VhZ2UuUFlUSE9OLFxuICBMYW5ndWFnZS5KQVZBLFxuICBMYW5ndWFnZS5DU0hBUlAsXG4gIExhbmd1YWdlLkdPLFxuXTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSnNpaUxhbmd1YWdlKFxuICBjb2RlOiBDb2RlTWFrZXIsXG4gIG9wdHM6IHNyY21hay5PcHRpb25zXG4pIHtcbiAgYXdhaXQgbWtkdGVtcChhc3luYyAoc3RhZ2luZykgPT4ge1xuICAgIC8vIHRoaXMgaXMgbm90IHR5cGVzY3JpcHQsIHNvIHdlIGdlbmVyYXRlIGluIGEgc3RhZ2luZyBkaXJlY3RvcnkgYW5kXG4gICAgLy8gdXNlIGpzaWktc3JjbWFrIHRvIGNvbXBpbGUgYW5kIGV4dHJhY3QgdGhlIGxhbmd1YWdlLXNwZWNpZmljIHNvdXJjZVxuICAgIC8vIGludG8gb3VyIHByb2plY3QuXG4gICAgYXdhaXQgY29kZS5zYXZlKHN0YWdpbmcpO1xuICAgIGF3YWl0IHNyY21hay5zcmNtYWsoc3RhZ2luZywgb3B0cyk7XG4gIH0pO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldE9wdGlvbnMge1xuICByZWFkb25seSB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2U7XG4gIHJlYWRvbmx5IGNvZGVNYWtlck91dHB1dDogc3RyaW5nO1xuICAvKipcbiAgICogUGF0aCB0byBjb3B5IHRoZSBvdXRwdXQgLmpzaWkgZmlsZS5cbiAgICogQGRlZmF1bHQgLSBqc2lpIGZpbGUgaXMgbm90IGVtaXR0ZWRcbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dEpzaWk/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb25zdHJ1Y3RzTWFrZXJUYXJnZXQge1xuICBwdWJsaWMgcmVhZG9ubHkgZmlsZU5hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgY29uc3RyYWludDogVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnQsXG4gICAgcHVibGljIHJlYWRvbmx5IHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZVxuICApIHtcbiAgICBpZiAodGhpcy5jb25zdHJhaW50IGluc3RhbmNlb2YgVGVycmFmb3JtTW9kdWxlQ29uc3RyYWludCkge1xuICAgICAgdGhpcy5maWxlTmFtZSA9IGAke3RoaXMudHlwZXNQYXRoKHRoaXMuY29uc3RyYWludC5maWxlTmFtZSl9LnRzYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maWxlTmFtZSA9IGAke3RoaXMudHlwZXNQYXRoKHRoaXMuY29uc3RyYWludC5uYW1lKX0udHNgO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbShcbiAgICBjb25zdHJhaW50OiBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludCxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2VcbiAgKSB7XG4gICAgaWYgKGNvbnN0cmFpbnQgaW5zdGFuY2VvZiBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50KSB7XG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdHNNYWtlck1vZHVsZVRhcmdldChjb25zdHJhaW50LCB0YXJnZXRMYW5ndWFnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0c01ha2VyUHJvdmlkZXJUYXJnZXQoY29uc3RyYWludCwgdGFyZ2V0TGFuZ3VhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50LnZlcnNpb247XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50LnNvdXJjZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50Lm5hbWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGZxbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50LmZxbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZXNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnQubmFtZXNwYWNlO1xuICB9XG5cbiAgcHVibGljIGdldCBtb2R1bGVLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnFuLnJlcGxhY2UoL1xcLy9naSwgXCJfXCIpO1xuICB9XG5cbiAgcHVibGljIGFic3RyYWN0IGdldCBzcmNNYWtOYW1lKCk6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IGdldCBpc01vZHVsZSgpOiBib29sZWFuO1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0IGlzUHJvdmlkZXIoKTogYm9vbGVhbjtcbiAgcHVibGljIGFic3RyYWN0IGdldCB0cmFja2luZ1BheWxvYWQoKTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCBzaW1wbGlmaWVkTmFtZSgpOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHR5cGVzUGF0aChuYW1lOiBzdHJpbmcpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RzTWFrZXJNb2R1bGVUYXJnZXQgZXh0ZW5kcyBDb25zdHJ1Y3RzTWFrZXJUYXJnZXQge1xuICBwdWJsaWMgc3BlYz86IE1vZHVsZVNjaGVtYTtcblxuICBwdWJsaWMgZ2V0IGlzTW9kdWxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGdldCBpc1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3JjTWFrTmFtZSgpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAodGhpcy50YXJnZXRMYW5ndWFnZSkge1xuICAgICAgY2FzZSBMYW5ndWFnZS5HTzpcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuSkFWQTpcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuQ1NIQVJQOlxuICAgICAgY2FzZSBMYW5ndWFnZS5QWVRIT046XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGlmaWVkTmFtZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IHRyYWNraW5nUGF5bG9hZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgZnVsbE5hbWU6IHRoaXMuZnFuLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgdHlwZTogXCJtb2R1bGVcIixcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIHR5cGVzUGF0aChuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgbW9kdWxlcy8ke25hbWV9YDtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgc2ltcGxpZmllZE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5uYW1lc3BhY2U/LnJlcGxhY2UoL1xcLy9naSwgXCIuXCIpLnJlcGxhY2UoLy0vZ2ksIFwiX1wiKSA/PyB0aGlzLm5hbWVcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldCBleHRlbmRzIENvbnN0cnVjdHNNYWtlclRhcmdldCB7XG4gIHB1YmxpYyBzcGVjPzogUHJvdmlkZXJTY2hlbWE7XG5cbiAgcHVibGljIGdldCBpc01vZHVsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNyY01ha05hbWUoKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKHRoaXMudGFyZ2V0TGFuZ3VhZ2UpIHtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuSkFWQTpcbiAgICAgICAgLy8gXCJudWxsXCIgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGFuZCBjYW4ndCBiZSB1c2VkIGFzIGEgcGFja2FnZSBuYW1lXG4gICAgICAgIHJldHVybiB0aGlzLmlzTnVsbFByb3ZpZGVyID8gXCJudWxscHJvdmlkZXJcIiA6IHRoaXMuc2ltcGxpZmllZE5hbWU7XG4gICAgICBjYXNlIExhbmd1YWdlLkNTSEFSUDpcbiAgICAgICAgLy8gXCJudWxsXCIgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGFuZCBjYW4ndCBiZSB1c2VkIGFzIGEgbmFtZXNwYWNlXG4gICAgICAgIHJldHVybiB0aGlzLmlzTnVsbFByb3ZpZGVyID8gXCJQcm92aWRlcnMuTnVsbFwiIDogdGhpcy5zaW1wbGlmaWVkTmFtZTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuUFlUSE9OOlxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGlmaWVkTmFtZTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuR086XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUucmVwbGFjZSgvLS9naSwgXCJfXCIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5mcW47XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCB0cmFja2luZ1BheWxvYWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGZ1bGxOYW1lOiB0aGlzLnNvdXJjZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIHR5cGU6IFwicHJvdmlkZXJcIixcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIHR5cGVzUGF0aChuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgcHJvdmlkZXJzLyR7bmFtZX0vaW5kZXhgO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNOdWxsUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5uYW1lID09PSBcIm51bGxcIjtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgc2ltcGxpZmllZE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lLnJlcGxhY2UoL1xcLy9naSwgXCIuXCIpLnJlcGxhY2UoLy0vZ2ksIFwiX1wiKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29uc3RydWN0c01ha2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb2RlTWFrZXJPdXRkaXI6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBjb2RlOiBDb2RlTWFrZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgdGFyZ2V0czogQ29uc3RydWN0c01ha2VyVGFyZ2V0W107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBHZXRPcHRpb25zLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uc3RyYWludHM6IFRlcnJhZm9ybURlcGVuZGVuY3lDb25zdHJhaW50W10sXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXBvcnRUZWxlbWV0cnk6IChwYXJhbXM6IGFueSkgPT4gdm9pZCA9ICgpID0+IHt9XG4gICkge1xuICAgIHRoaXMuY29kZU1ha2VyT3V0ZGlyID0gcGF0aC5yZXNvbHZlKHRoaXMub3B0aW9ucy5jb2RlTWFrZXJPdXRwdXQpO1xuICAgIGZzLm1rZGlycFN5bmModGhpcy5jb2RlTWFrZXJPdXRkaXIpO1xuICAgIHRoaXMuY29kZSA9IG5ldyBDb2RlTWFrZXIoKTtcbiAgICB0aGlzLnRhcmdldHMgPSB0aGlzLmNvbnN0cmFpbnRzLm1hcCgoY29uc3RyYWludCkgPT5cbiAgICAgIENvbnN0cnVjdHNNYWtlclRhcmdldC5mcm9tKGNvbnN0cmFpbnQsIHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVR5cGVTY3JpcHQoKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gYXdhaXQgcmVhZFNjaGVtYSh0aGlzLnRhcmdldHMpO1xuXG4gICAgY29uc3QgbW9kdWxlVGFyZ2V0czogQ29uc3RydWN0c01ha2VyTW9kdWxlVGFyZ2V0W10gPSB0aGlzLnRhcmdldHMuZmlsdGVyKFxuICAgICAgKHRhcmdldCkgPT4gdGFyZ2V0IGluc3RhbmNlb2YgQ29uc3RydWN0c01ha2VyTW9kdWxlVGFyZ2V0XG4gICAgKSBhcyBDb25zdHJ1Y3RzTWFrZXJNb2R1bGVUYXJnZXRbXTtcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBtb2R1bGVUYXJnZXRzKSB7XG4gICAgICB0YXJnZXQuc3BlYyA9IHNjaGVtYS5tb2R1bGVTY2hlbWFbdGFyZ2V0Lm1vZHVsZUtleV07XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdmlkZXJUYXJnZXRzOiBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldFtdID1cbiAgICAgIHRoaXMudGFyZ2V0cy5maWx0ZXIoXG4gICAgICAgICh0YXJnZXQpID0+IHRhcmdldCBpbnN0YW5jZW9mIENvbnN0cnVjdHNNYWtlclByb3ZpZGVyVGFyZ2V0XG4gICAgICApIGFzIENvbnN0cnVjdHNNYWtlclByb3ZpZGVyVGFyZ2V0W107XG5cbiAgICBpZiAocHJvdmlkZXJUYXJnZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5ldyBUZXJyYWZvcm1Qcm92aWRlckdlbmVyYXRvcihcbiAgICAgICAgdGhpcy5jb2RlLFxuICAgICAgICBzY2hlbWEucHJvdmlkZXJTY2hlbWEsXG4gICAgICAgIHByb3ZpZGVyVGFyZ2V0c1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAobW9kdWxlVGFyZ2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICBuZXcgTW9kdWxlR2VuZXJhdG9yKHRoaXMuY29kZSwgbW9kdWxlVGFyZ2V0cyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdlbmVyYXRlKCkge1xuICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVUeXBlU2NyaXB0KCk7XG5cbiAgICBpZiAodGhpcy5pc0phdmFzY3JpcHRUYXJnZXQpIHtcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0phdmFzY3JpcHRUYXJnZXQgfHwgdGhpcy5vcHRpb25zLm91dHB1dEpzaWkpIHtcbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRoaXMudGFyZ2V0cykge1xuICAgICAgICAvLyB0aGVzZSBhcmUgdGhlIG1vZHVsZSBkZXBlbmRlbmNpZXMgd2UgY29tcGlsZSBhZ2FpbnN0XG4gICAgICAgIGNvbnN0IGRlcHMgPSBbXCJAdHlwZXMvbm9kZVwiLCBcImNvbnN0cnVjdHNcIiwgXCJjZGt0ZlwiXTtcbiAgICAgICAgY29uc3Qgb3B0czogc3JjbWFrLk9wdGlvbnMgPSB7XG4gICAgICAgICAgZW50cnlwb2ludDogdGFyZ2V0LmZpbGVOYW1lLFxuICAgICAgICAgIGRlcHM6IGRlcHMubWFwKChkZXApID0+XG4gICAgICAgICAgICBwYXRoLmRpcm5hbWUocmVxdWlyZS5yZXNvbHZlKGAke2RlcH0vcGFja2FnZS5qc29uYCkpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBtb2R1bGVLZXk6IHRhcmdldC5tb2R1bGVLZXksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdXNlZCBmb3IgdGVzdGluZy5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdXRwdXRKc2lpKSB7XG4gICAgICAgICAgb3B0cy5qc2lpID0geyBwYXRoOiB0aGlzLm9wdGlvbnMub3V0cHV0SnNpaSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNQeXRob25UYXJnZXQpIHtcbiAgICAgICAgICBvcHRzLnB5dGhvbiA9IHtcbiAgICAgICAgICAgIG91dGRpcjogdGhpcy5jb2RlTWFrZXJPdXRkaXIsXG4gICAgICAgICAgICBtb2R1bGVOYW1lOiB0YXJnZXQuc3JjTWFrTmFtZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNKYXZhVGFyZ2V0KSB7XG4gICAgICAgICAgb3B0cy5qYXZhID0ge1xuICAgICAgICAgICAgb3V0ZGlyOiBcIi5cIiwgLy8gZ2VuZXJhdGVkIGphdmEgZmlsZXMgYXJlbid0IHBhY2thZ2VkLCBzbyBqdXN0IGluY2x1ZGUgZGlyZWN0bHkgaW4gYXBwXG4gICAgICAgICAgICBwYWNrYWdlOiBgaW1wb3J0cy4ke3RhcmdldC5zcmNNYWtOYW1lfWAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzQ3NoYXJwVGFyZ2V0KSB7XG4gICAgICAgICAgb3B0cy5jc2hhcnAgPSB7XG4gICAgICAgICAgICBvdXRkaXI6IHRoaXMuY29kZU1ha2VyT3V0ZGlyLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiB0YXJnZXQuc3JjTWFrTmFtZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNHb1RhcmdldCkge1xuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIG5lZWRlZCBmb3IgbW9kdWxlcyBzb21laG93XG4gICAgICAgICAgLy8gY29uc3QgdGFyZ2V0VHlwZSA9IHRhcmdldC5pc1Byb3ZpZGVyID8gJ3Byb3ZpZGVyJyA6ICdtb2R1bGUnO1xuXG4gICAgICAgICAgLy8ganNpaS1zcmNtYWMgd2lsbCBwcm9kdWNlIGEgZm9sZGVyIGluc2lkZSB0aGlzIGRpciBuYW1lZCBhZnRlciBcInBhY2thZ2VOYW1lXCJcbiAgICAgICAgICAvLyBzbyB0aGlzIHJlc3VsdHMgaW4gZS5nLiAuZ2VuL2hhc2hpY29ycC9yYW5kb21cbiAgICAgICAgICBjb25zdCBvdXRkaXIgPSBwYXRoLmpvaW4oXG4gICAgICAgICAgICB0aGlzLmNvZGVNYWtlck91dGRpcixcbiAgICAgICAgICAgIHRhcmdldC5uYW1lc3BhY2UgPz8gXCJcIlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBvcHRzLmdvbGFuZyA9IHtcbiAgICAgICAgICAgIG91dGRpcixcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IGF3YWl0IGRldGVybWluZUdvTW9kdWxlTmFtZShvdXRkaXIpLCAvLyBlLmcuIGBnaXRodWIuY29tL29yZy91c2VycHJvamVjdC8uZ2VuL2hhc2hpY29ycGBcbiAgICAgICAgICAgIHBhY2thZ2VOYW1lOiB0YXJnZXQuc3JjTWFrTmFtZSwgLy8gcGFja2FnZSB3aWxsIGJlIG5hbWVkIGUuZy4gcmFuZG9tIGZvciBoYXNoaWNvcnAvcmFuZG9tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX09QVElPTlMgJiZcbiAgICAgICAgICAhcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TLmluY2x1ZGVzKGAtLW1heC1vbGQtc3BhY2Utc2l6ZWApXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgZm91bmQgTk9ERV9PUFRJT05TIGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGhvdXQgYSBzZXR0aW5nIGZvciAtLW1heC1vbGQtc3BhY2Utc2l6ZS5cblRoZSBwcm92aWRlciBnZW5lcmF0aW9uIG5lZWRzIGEgc3Vic3RhbnRpYWwgYW1vdW50IG9mIG1lbW9yeSAofjEzR0IpIGZvciBzb21lIHByb3ZpZGVycyBhbmQgbGFuZ3VhZ2VzLlxuU28gY2RrdGYtY2xpIHNldHMgaXQgdG8gTk9ERV9PUFRJT05TPVwiLS1tYXgtb2xkLXNwYWNlLXNpemU9MTYzODRcIiBieSBkZWZhdWx0LiBBcyB5b3VyIGVudmlyb25tZW50IGFscmVhZHkgY29udGFpbnNcbmEgTk9ERV9PUFRJT05TIHZhcmlhYmxlLCB3ZSB3b24ndCBvdmVycmlkZSBpdC4gSGVuY2UsIHRoZSBwcm92aWRlciBnZW5lcmF0aW9uIG1pZ2h0IGZhaWwgd2l0aCBhbiBvdXQgb2YgbWVtb3J5IGVycm9yLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluY3JlYXNlIG1lbW9yeSB0byBhbGxvdyBnZW5lcmF0aW5nIGxhcmdlIHByb3ZpZGVycyAoaS5lLiBhd3Mgb3IgYXp1cmVybSBmb3IgR28pXG4gICAgICAgICAgLy8gc3JjbWFrIGlzIGdvaW5nIHRvIHNwYXduIGEgY2hpbGRwcm9jZXNzIChmb3IganNpaS1wYWNtYWspIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGFmZmVjdGVkIGJ5IHRoaXMgZW52IHZhclxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfT1BUSU9OUyA9IFwiLS1tYXgtb2xkLXNwYWNlLXNpemU9MTYzODRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGdlbmVyYXRlSnNpaUxhbmd1YWdlKHRoaXMuY29kZSwgb3B0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGhpcy50YXJnZXRzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgIHBheWxvYWQ6IHRhcmdldC50cmFja2luZ1BheWxvYWQsXG4gICAgICAgIGxhbmd1YWdlOiB0YXJnZXQudGFyZ2V0TGFuZ3VhZ2UsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNhdmUob3V0ZGlyID0gdGhpcy5jb2RlTWFrZXJPdXRkaXIpIHtcbiAgICBhd2FpdCB0aGlzLmNvZGUuc2F2ZShvdXRkaXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNKYXZhc2NyaXB0VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgPT09IExhbmd1YWdlLlRZUEVTQ1JJUFQ7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc1B5dGhvblRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5QWVRIT047XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0phdmFUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuSkFWQTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzQ3NoYXJwVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgPT09IExhbmd1YWdlLkNTSEFSUDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzR29UYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuR087XG4gIH1cbn1cblxuLyoqXG4gKiBzZWFyY2hlcyBmb3IgdGhlIGNsb3Nlc3QgYGdvLm1vZGAgZmlsZSBhbmQgcmV0dXJucyB0aGUgbmVzdGVkIGdvIG1vZHVsZSBuYW1lIGZvciBgZGlyYFxuICogZS5nLiAoL2Rpci8uZ2VuLykgPT4gY2RrLnRmL3N0YWNrLy5nZW4gaWYgdGhlIHBhcmVudCBkaXIgb2YgLmdlbiBoYXMgYSBnby5tb2QgZm9yIFwibW9kdWxlIGNkay50Zi9zdGFja1wiXG4gKlxuICogQHBhcmFtIGRpciB0aGUgZGlyZWN0b3J5IHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbSAoc2VhcmNoZXMgdXB3YXJkcylcbiAqIEByZXR1cm5zIHRoZSBwYWNrYWdlIG5hbWUgZm9yIGBkaXJgXG4gKiBAdGhyb3dzIGFuIEVycm9yIGlmIG5vIGdvLm1vZCB3YXMgZm91bmRcbiAqL1xuZXhwb3J0IGNvbnN0IGRldGVybWluZUdvTW9kdWxlTmFtZSA9IGFzeW5jIChkaXI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGxldCBwcmV2aW91c0RpcjtcbiAgbGV0IGN1cnJlbnREaXIgPSBwYXRoLnJlc29sdmUoZGlyKTtcblxuICBkbyB7XG4gICAgbGV0IGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBmaWxlcyA9IGF3YWl0IGZzLnJlYWRkaXIoY3VycmVudERpcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZGlyZWN0b3J5IG1pZ2h0IG5vdCBleGlzdCB5ZXQsIGJ1dCB3ZSBzdGlsbCB3YWxrIHVwd2FyZHMgZnJvbSB0aGVyZSwgc28gaWdub3JlICdFTk9FTlQnXG4gICAgICBpZiAoZS5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaWxlcy5pbmNsdWRlcyhcImdvLm1vZFwiKSkge1xuICAgICAgY29uc3QgZmlsZSA9IHBhdGgucmVzb2x2ZShjdXJyZW50RGlyLCBcImdvLm1vZFwiKTtcbiAgICAgIGNvbnN0IGdvbW9kID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZSk7XG4gICAgICBjb25zdCBtYXRjaCA9IC9ebW9kdWxlXFxzKihcXFMqKVxccyokL20uZXhlYyhnb21vZC50b1N0cmluZygpKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBjaGlsZGRpciA9IHBhdGgucmVsYXRpdmUoY3VycmVudERpciwgZGlyKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTsgLy8gcmVwbGFjZSAnXFwnIHdpdGggJy8nIGZvciB3aW5kb3dzIHBhdGhzXG4gICAgICAgIHJldHVybiBjaGlsZGRpci5sZW5ndGggPiAwID8gYCR7bWF0Y2hbMV19LyR7Y2hpbGRkaXJ9YCA6IG1hdGNoWzFdO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgcm9vdCBHbyBtb2R1bGUgbmFtZS4gRm91bmQgJHtmaWxlfSBidXQgZmFpbGVkIHRvIHJlZ2V4IG1hdGNoIHRoZSBtb2R1bGUgbmFtZSBkaXJlY3RpdmVgXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBnbyB1cCBvbmUgZGlyZWN0b3J5LiBBcyBkaXJuYW1lKCcvJykgd2lsbCByZXR1cm4gJy8nIHdlIGNhbmNlbCB0aGUgbG9vcFxuICAgIC8vIGFzIHNvb24gYXMgdGhlIGRpciBkb2VzIG5vdCBjaGFuZ2UgYW55bW9yZS5cbiAgICBwcmV2aW91c0RpciA9IGN1cnJlbnREaXI7XG4gICAgY3VycmVudERpciA9IHBhdGguZGlybmFtZShjdXJyZW50RGlyKTtcbiAgfSB3aGlsZSAoY3VycmVudERpciAhPT0gcHJldmlvdXNEaXIpO1xuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgcm9vdCBHbyBtb2R1bGUgbmFtZS4gTm8gZ28ubW9kIGZvdW5kIGluICR7ZGlyfSBhbmQgYW55IHBhcmVudCBkaXJlY3Rvcmllc2BcbiAgKTtcbn07XG4iXX0=