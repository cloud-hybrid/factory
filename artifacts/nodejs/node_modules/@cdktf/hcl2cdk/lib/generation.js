"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gen = exports.moduleImports = exports.providerImports = exports.cdktfImport = exports.provider = exports.modules = exports.local = exports.variable = exports.output = exports.resource = exports.backendToExpression = exports.valueToTs = void 0;
const generator_1 = __importDefault(require("@babel/generator"));
const template_1 = __importDefault(require("@babel/template"));
const t = __importStar(require("@babel/types"));
const prettier_1 = __importDefault(require("prettier"));
const utils_1 = require("./utils");
const expressions_1 = require("./expressions");
const provider_generator_1 = require("@cdktf/provider-generator");
const provider_1 = require("./provider");
function getReference(graph, id) {
    const neighbors = graph.outNeighbors(id);
    if (neighbors.length > 0) {
        const edge = graph.directedEdge(id, neighbors[0]);
        if (edge) {
            return graph.getEdgeAttribute(edge, "ref");
        }
        else {
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
exports.valueToTs = (scope, item, path, nodeIds, scopedIds = []) => {
    var _a;
    switch (typeof item) {
        case "string":
            return expressions_1.referencesToAst(scope, item, expressions_1.extractReferencesFromExpression(item, nodeIds, scopedIds), scopedIds);
        case "boolean":
            return t.booleanLiteral(item);
        case "number":
            return t.numericLiteral(item);
        case "object":
            if (item === undefined || item === null) {
                return t.nullLiteral();
            }
            const unwrappedItem = ((_a = provider_1.getBlockTypeAtPath(scope.providerSchema, path)) === null || _a === void 0 ? void 0 : _a.max_items) === 1 &&
                Array.isArray(item)
                ? item[0]
                : item;
            if (Array.isArray(unwrappedItem)) {
                return t.arrayExpression(unwrappedItem.map((i) => exports.valueToTs(scope, i, path, nodeIds, scopedIds)));
            }
            return t.objectExpression(Object.entries(unwrappedItem)
                .map(([key, value]) => {
                if (key === "lifecycle" || value === undefined) {
                    return undefined;
                }
                if (key === "dynamic") {
                    const { for_each, ...others } = value;
                    const dynamicRef = Object.keys(others)[0];
                    return t.objectProperty(t.identifier(dynamicRef), t.arrayExpression());
                }
                const itemPath = `${path}.${key}`;
                const shouldBeArray = typeof value === "object" &&
                    !Array.isArray(value) &&
                    key !== "tags";
                return t.objectProperty(t.stringLiteral(key !== "for_each" ? utils_1.camelCase(key) : key), shouldBeArray
                    ? t.arrayExpression([
                        exports.valueToTs(scope, value, itemPath, nodeIds, scopedIds),
                    ])
                    : exports.valueToTs(scope, value, itemPath, nodeIds, scopedIds));
            })
                .filter((expr) => expr !== undefined));
    }
    throw new Error("Unsupported type " + item);
};
function backendToExpression(scope, tf, nodeIds) {
    return Object.entries(tf || {}).reduce((carry, [type, [config]]) => [
        ...carry,
        t.expressionStatement(t.newExpression(t.memberExpression(t.identifier("cdktf"), t.identifier(utils_1.pascalCase(`${type}Backend`))), [
            t.thisExpression(),
            t.objectExpression(Object.entries(config).reduce((arr, [property, value]) => [
                ...arr,
                t.objectProperty(t.identifier(utils_1.camelCase(property)), exports.valueToTs(scope, value, "path-for-backends-can-be-ignored", nodeIds)),
            ], [])),
        ])),
    ], []);
}
exports.backendToExpression = backendToExpression;
function addOverrideExpression(variable, path, value, explanatoryComment) {
    const ast = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(variable), t.identifier("addOverride")), [t.stringLiteral(path), value]));
    if (explanatoryComment) {
        t.addComment(ast, "leading", explanatoryComment);
    }
    return ast;
}
function addOverrideLogicalIdExpression(variable, logicalId) {
    const ast = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(variable), t.identifier("overrideLogicalId")), [t.stringLiteral(logicalId)]));
    t.addComment(ast, "leading", "This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.");
    return ast;
}
function getRemoteStateType(item) {
    const backendRecord = item.find((val) => val.backend);
    if (backendRecord) {
        const backend = backendRecord.backend;
        switch (backend) {
            case "remote":
                return "";
            case "etcdv3":
                return "_etcd_v3";
            default:
                return `_${backend}`;
        }
    }
    else {
        return "";
    }
}
function resourceType(provider, name, item) {
    switch (provider) {
        case "data.terraform":
            return `cdktf.data_terraform_${name.join("_")}${getRemoteStateType(item)}`;
        case "null":
            return `NullProvider.${name.join("_")}`;
        default:
            return `${provider}.${name.join("_")}`;
    }
}
function resource(scope, type, key, id, item, graph) {
    const [provider, ...name] = type.split("_");
    const nodeIds = graph.nodes();
    const resource = resourceType(provider, name, item);
    const { for_each, count, ...config } = item[0];
    const dynBlocks = expressions_1.extractDynamicBlocks(config);
    const overrideReference = dynBlocks.length || count || for_each
        ? {
            start: 0,
            end: 0,
            referencee: {
                id: `${type}.${key}`,
                full: `${type}.${key}`,
            },
        }
        : undefined;
    const expressions = [
        ...asExpression(scope, resource, key, config, nodeIds, false, false, getReference(graph, id) || overrideReference),
    ];
    const varName = expressions_1.variableName(scope, resource, key);
    const loopComment = `In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.`;
    if (for_each) {
        const references = expressions_1.extractReferencesFromExpression(for_each, nodeIds, [
            "each",
        ]);
        expressions.push(addOverrideExpression(varName, "for_each", expressions_1.referencesToAst(scope, for_each, references), loopComment));
    }
    if (count) {
        if (typeof count === "number") {
            expressions.push(addOverrideExpression(varName, "count", exports.valueToTs(scope, count, "path-for-counts-can-be-ignored", nodeIds), loopComment));
        }
        else {
            const references = expressions_1.extractReferencesFromExpression(count, nodeIds, [
                "count",
            ]);
            expressions.push(addOverrideExpression(varName, "count", expressions_1.referencesToAst(scope, count, references), loopComment));
        }
    }
    // Check for dynamic blocks
    return [
        ...expressions,
        ...dynBlocks.map(({ path, for_each, content, scopedVar }) => {
            return addOverrideExpression(varName, path.substring(1), // The path starts with a dot that we don't want
            exports.valueToTs(scope, {
                for_each,
                content,
            }, "path-for-dynamic-blocks-can-be-ignored", nodeIds, [scopedVar]), loopComment);
        }),
    ];
}
exports.resource = resource;
function asExpression(scope, type, name, config, nodeIds, isModuleImport, isProvider, reference) {
    const { provider, providers, lifecycle, ...otherOptions } = config;
    const constructId = utils_1.uniqueId(scope.constructs, name);
    const overrideId = !isProvider && constructId !== name;
    const expression = t.newExpression(expressions_1.constructAst(type, isModuleImport), [
        t.thisExpression(),
        t.stringLiteral(constructId),
        exports.valueToTs(scope, otherOptions, `${type}`, nodeIds),
    ]);
    const statements = [];
    const varName = reference
        ? expressions_1.referenceToVariableName(scope, reference)
        : expressions_1.variableName(scope, type, name);
    if (reference || providers || provider || lifecycle || overrideId) {
        statements.push(t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(varName), expression),
        ]));
    }
    else {
        statements.push(t.expressionStatement(expression));
    }
    if (provider) {
        statements.push(addOverrideExpression(varName, "provider", exports.valueToTs(scope, provider, "path-for-provider-blocks-can-be-ignored", nodeIds)));
    }
    if (providers) {
        statements.push(addOverrideExpression(varName, "providers", exports.valueToTs(scope, providers, "path-for-providers-blocks-can-be-ignored", nodeIds)));
    }
    if (lifecycle) {
        statements.push(addOverrideExpression(varName, "lifecycle", exports.valueToTs(scope, lifecycle, "path-for-lifecycle-blocks-can-be-ignored", nodeIds)));
    }
    if (overrideId) {
        statements.push(addOverrideLogicalIdExpression(varName, name));
    }
    return statements;
}
function output(scope, key, _id, item, graph) {
    const nodeIds = graph.nodes();
    const [{ value, description, sensitive }] = item;
    return asExpression(scope, "cdktf.TerraformOutput", key, {
        value,
        description,
        sensitive,
    }, nodeIds, false, false);
}
exports.output = output;
function variable(scope, key, id, item, graph) {
    // We don't handle type information right now
    const [{ type, ...props }] = item;
    const nodeIds = graph.nodes();
    if (!getReference(graph, id)) {
        return [];
    }
    return asExpression(scope, "cdktf.TerraformVariable", key, props, nodeIds, false, false, getReference(graph, id));
}
exports.variable = variable;
function local(scope, key, id, item, graph) {
    const nodeIds = graph.nodes();
    if (!getReference(graph, id)) {
        return [];
    }
    return t.variableDeclaration("const", [
        t.variableDeclarator(t.identifier(expressions_1.variableName(scope, "local", key)), exports.valueToTs(scope, item, "path-for-local-blocks-can-be-ignored", nodeIds)),
    ]);
}
exports.local = local;
function modules(scope, key, id, item, graph) {
    const [{ source, version, ...props }] = item;
    const nodeIds = graph.nodes();
    const moduleConstraint = new provider_generator_1.TerraformModuleConstraint(source);
    return asExpression(scope, moduleConstraint.className, key, props, nodeIds, true, false, getReference(graph, id));
}
exports.modules = modules;
function provider(scope, key, _id, item, graph) {
    const nodeIds = graph.nodes();
    const { version, ...props } = item;
    const importKey = key === "null" ? "NullProvider" : key;
    return asExpression(scope, `${importKey}.${utils_1.pascalCase(key + "Provider")}`, key, props, nodeIds, false, true);
}
exports.provider = provider;
exports.cdktfImport = template_1.default(`import * as cdktf from "cdktf"`)();
exports.providerImports = (providers) => providers.map((providerName) => {
    const parts = providerName.split("/");
    const name = parts.length > 1 ? parts[1] : parts[0];
    const importName = name === "null" ? "NullProvider" : name;
    return template_1.default(`import * as ${importName} from "./.gen/providers/${name.replace("./", "")}"`)();
});
exports.moduleImports = (modules) => {
    const uniqueModules = new Set();
    Object.values(modules || {}).map(([module]) => uniqueModules.add(module.source));
    const imports = [];
    uniqueModules.forEach((m) => {
        const moduleConstraint = new provider_generator_1.TerraformModuleConstraint(m);
        imports.push(template_1.default.ast(`import * as ${moduleConstraint.className} from "./.gen/modules/${moduleConstraint.fileName}"`));
    });
    return imports;
};
function gen(statements) {
    return prettier_1.default.format(generator_1.default(t.program(statements)).code, {
        parser: "babel",
    });
}
exports.gen = gen;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdlbmVyYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlFQUF3QztBQUN4QywrREFBdUM7QUFDdkMsZ0RBQWtDO0FBRWxDLHdEQUFnQztBQUdoQyxtQ0FBMEQ7QUFTMUQsK0NBUXVCO0FBQ3ZCLGtFQUFzRTtBQUN0RSx5Q0FBZ0Q7QUFFaEQsU0FBUyxZQUFZLENBQUMsS0FBb0IsRUFBRSxFQUFVO0lBQ3BELE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDekMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN4QixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRCxJQUFJLElBQUksRUFBRTtZQUNSLE9BQU8sS0FBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxLQUFLLENBQWMsQ0FBQztTQUN6RDthQUFNO1lBQ0wsT0FBTyxTQUFTLENBQUM7U0FDbEI7S0FDRjtTQUFNO1FBQ0wsT0FBTyxTQUFTLENBQUM7S0FDbEI7QUFDSCxDQUFDO0FBRVksUUFBQSxTQUFTLEdBQUcsQ0FDdkIsS0FBWSxFQUNaLElBQTRCLEVBQzVCLElBQVksRUFDWixPQUFpQixFQUNqQixZQUFzQixFQUFFLEVBQ1YsRUFBRTs7SUFDaEIsUUFBUSxPQUFPLElBQUksRUFBRTtRQUNuQixLQUFLLFFBQVE7WUFDWCxPQUFPLDZCQUFlLENBQ3BCLEtBQUssRUFDTCxJQUFJLEVBQ0osNkNBQStCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsRUFDekQsU0FBUyxDQUNWLENBQUM7UUFDSixLQUFLLFNBQVM7WUFDWixPQUFPLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFD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YixlQUFlLFVBQVUsMkJBQTJCLElBQUksQ0FBQyxPQUFPLENBQzlELElBQUksRUFDSixFQUFFLENBQ0gsR0FBRyxDQUNMLEVBQWlCLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUM7QUFFUSxRQUFBLGFBQWEsR0FBRyxDQUFDLE9BQTJDLEVBQUUsRUFBRTtJQUMzRSxNQUFNLGFBQWEsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO0lBQ3hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUM1QyxhQUFhLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FDakMsQ0FBQztJQUVGLE1BQU0sT0FBTyxHQUFrQixFQUFFLENBQUM7SUFDbEMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1FBQzFCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSw4Q0FBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxRCxPQUFPLENBQUMsSUFBSSxDQUNWLGtCQUFRLENBQUMsR0FBRyxDQUNWLGVBQWUsZ0JBQWdCLENBQUMsU0FBUyx5QkFBeUIsZ0JBQWdCLENBQUMsUUFBUSxHQUFHLENBQ2hGLENBQ2pCLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sT0FBTyxDQUFDO0FBQ2pCLENBQUMsQ0FBQztBQUVGLFNBQWdCLEdBQUcsQ0FBQyxVQUF5QjtJQUMzQyxPQUFPLGtCQUFRLENBQUMsTUFBTSxDQUFDLG1CQUFRLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQVEsQ0FBQyxDQUFDLElBQUksRUFBRTtRQUNsRSxNQUFNLEVBQUUsT0FBTztLQUNoQixDQUFDLENBQUM7QUFDTCxDQUFDO0FBSkQsa0JBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2VuZXJhdGUgZnJvbSBcIkBiYWJlbC9nZW5lcmF0b3JcIjtcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tIFwiQGJhYmVsL3RlbXBsYXRlXCI7XG5pbXBvcnQgKiBhcyB0IGZyb20gXCJAYmFiZWwvdHlwZXNcIjtcbmltcG9ydCB7IERpcmVjdGVkR3JhcGggfSBmcm9tIFwiZ3JhcGhvbG9neVwiO1xuaW1wb3J0IHByZXR0aWVyIGZyb20gXCJwcmV0dGllclwiO1xuXG5pbXBvcnQgeyBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLCBTY29wZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBjYW1lbENhc2UsIHBhc2NhbENhc2UsIHVuaXF1ZUlkIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIFJlc291cmNlLFxuICBUZXJyYWZvcm1Db25maWcsXG4gIE1vZHVsZSxcbiAgUHJvdmlkZXIsXG4gIFZhcmlhYmxlLFxuICBPdXRwdXQsXG59IGZyb20gXCIuL3NjaGVtYVwiO1xuaW1wb3J0IHtcbiAgcmVmZXJlbmNlc1RvQXN0LFxuICBleHRyYWN0UmVmZXJlbmNlc0Zyb21FeHByZXNzaW9uLFxuICBSZWZlcmVuY2UsXG4gIHZhcmlhYmxlTmFtZSxcbiAgcmVmZXJlbmNlVG9WYXJpYWJsZU5hbWUsXG4gIGV4dHJhY3REeW5hbWljQmxvY2tzLFxuICBjb25zdHJ1Y3RBc3QsXG59IGZyb20gXCIuL2V4cHJlc3Npb25zXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50IH0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1nZW5lcmF0b3JcIjtcbmltcG9ydCB7IGdldEJsb2NrVHlwZUF0UGF0aCB9IGZyb20gXCIuL3Byb3ZpZGVyXCI7XG5cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZShncmFwaDogRGlyZWN0ZWRHcmFwaCwgaWQ6IHN0cmluZykge1xuICBjb25zdCBuZWlnaGJvcnMgPSBncmFwaC5vdXROZWlnaGJvcnMoaWQpO1xuICBpZiAobmVpZ2hib3JzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBlZGdlID0gZ3JhcGguZGlyZWN0ZWRFZGdlKGlkLCBuZWlnaGJvcnNbMF0pO1xuICAgIGlmIChlZGdlKSB7XG4gICAgICByZXR1cm4gZ3JhcGguZ2V0RWRnZUF0dHJpYnV0ZShlZGdlLCBcInJlZlwiKSBhcyBSZWZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHZhbHVlVG9UcyA9IChcbiAgc2NvcGU6IFNjb3BlLFxuICBpdGVtOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLFxuICBwYXRoOiBzdHJpbmcsXG4gIG5vZGVJZHM6IHN0cmluZ1tdLFxuICBzY29wZWRJZHM6IHN0cmluZ1tdID0gW11cbik6IHQuRXhwcmVzc2lvbiA9PiB7XG4gIHN3aXRjaCAodHlwZW9mIGl0ZW0pIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gcmVmZXJlbmNlc1RvQXN0KFxuICAgICAgICBzY29wZSxcbiAgICAgICAgaXRlbSxcbiAgICAgICAgZXh0cmFjdFJlZmVyZW5jZXNGcm9tRXhwcmVzc2lvbihpdGVtLCBub2RlSWRzLCBzY29wZWRJZHMpLFxuICAgICAgICBzY29wZWRJZHNcbiAgICAgICk7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiB0LmJvb2xlYW5MaXRlcmFsKGl0ZW0pO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiB0Lm51bWVyaWNMaXRlcmFsKGl0ZW0pO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdC5udWxsTGl0ZXJhbCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdW53cmFwcGVkSXRlbSA9XG4gICAgICAgIGdldEJsb2NrVHlwZUF0UGF0aChzY29wZS5wcm92aWRlclNjaGVtYSwgcGF0aCk/Lm1heF9pdGVtcyA9PT0gMSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGl0ZW0pXG4gICAgICAgICAgPyBpdGVtWzBdXG4gICAgICAgICAgOiBpdGVtO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1bndyYXBwZWRJdGVtKSkge1xuICAgICAgICByZXR1cm4gdC5hcnJheUV4cHJlc3Npb24oXG4gICAgICAgICAgdW53cmFwcGVkSXRlbS5tYXAoKGkpID0+XG4gICAgICAgICAgICB2YWx1ZVRvVHMoc2NvcGUsIGksIHBhdGgsIG5vZGVJZHMsIHNjb3BlZElkcylcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0Lm9iamVjdEV4cHJlc3Npb24oXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHVud3JhcHBlZEl0ZW0pXG4gICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImxpZmVjeWNsZVwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBmb3JfZWFjaCwgLi4ub3RoZXJzIH0gPSB2YWx1ZSBhcyBhbnk7XG4gICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZWYgPSBPYmplY3Qua2V5cyhvdGhlcnMpWzBdO1xuICAgICAgICAgICAgICByZXR1cm4gdC5vYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICB0LmlkZW50aWZpZXIoZHluYW1pY1JlZiksXG4gICAgICAgICAgICAgICAgdC5hcnJheUV4cHJlc3Npb24oKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpdGVtUGF0aCA9IGAke3BhdGh9LiR7a2V5fWA7XG5cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEJlQXJyYXkgPVxuICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgICAgICAgIGtleSAhPT0gXCJ0YWdzXCI7XG5cbiAgICAgICAgICAgIHJldHVybiB0Lm9iamVjdFByb3BlcnR5KFxuICAgICAgICAgICAgICB0LnN0cmluZ0xpdGVyYWwoa2V5ICE9PSBcImZvcl9lYWNoXCIgPyBjYW1lbENhc2Uoa2V5KSA6IGtleSksXG4gICAgICAgICAgICAgIHNob3VsZEJlQXJyYXlcbiAgICAgICAgICAgICAgICA/IHQuYXJyYXlFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVUb1RzKHNjb3BlLCB2YWx1ZSwgaXRlbVBhdGgsIG5vZGVJZHMsIHNjb3BlZElkcyksXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIDogdmFsdWVUb1RzKHNjb3BlLCB2YWx1ZSwgaXRlbVBhdGgsIG5vZGVJZHMsIHNjb3BlZElkcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKChleHByKSA9PiBleHByICE9PSB1bmRlZmluZWQpIGFzIHQuT2JqZWN0UHJvcGVydHlbXVxuICAgICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIFwiICsgaXRlbSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYmFja2VuZFRvRXhwcmVzc2lvbihcbiAgc2NvcGU6IFNjb3BlLFxuICB0ZjogVGVycmFmb3JtQ29uZmlnW1wiYmFja2VuZFwiXSxcbiAgbm9kZUlkczogc3RyaW5nW11cbik6IHQuU3RhdGVtZW50W10ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXModGYgfHwge30pLnJlZHVjZShcbiAgICAoY2FycnksIFt0eXBlLCBbY29uZmlnXV0pID0+IFtcbiAgICAgIC4uLmNhcnJ5LFxuICAgICAgdC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgICB0Lm5ld0V4cHJlc3Npb24oXG4gICAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgICAgdC5pZGVudGlmaWVyKFwiY2RrdGZcIiksXG4gICAgICAgICAgICB0LmlkZW50aWZpZXIocGFzY2FsQ2FzZShgJHt0eXBlfUJhY2tlbmRgKSlcbiAgICAgICAgICApLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgICAgICAgIHQub2JqZWN0RXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnKS5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKGFyciwgW3Byb3BlcnR5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgICAgICAgIC4uLmFycixcbiAgICAgICAgICAgICAgICAgIHQub2JqZWN0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgIHQuaWRlbnRpZmllcihjYW1lbENhc2UocHJvcGVydHkpKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVUb1RzKFxuICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIFwicGF0aC1mb3ItYmFja2VuZHMtY2FuLWJlLWlnbm9yZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICBub2RlSWRzXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBbXSBhcyB0Lk9iamVjdFByb3BlcnR5W11cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdXG4gICAgICAgIClcbiAgICAgICksXG4gICAgXSxcbiAgICBbXSBhcyB0LlN0YXRlbWVudFtdXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJyaWRlRXhwcmVzc2lvbihcbiAgdmFyaWFibGU6IHN0cmluZyxcbiAgcGF0aDogc3RyaW5nLFxuICB2YWx1ZTogdC5FeHByZXNzaW9uLFxuICBleHBsYW5hdG9yeUNvbW1lbnQ/OiBzdHJpbmdcbikge1xuICBjb25zdCBhc3QgPSB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgIHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIodmFyaWFibGUpLCB0LmlkZW50aWZpZXIoXCJhZGRPdmVycmlkZVwiKSksXG4gICAgICBbdC5zdHJpbmdMaXRlcmFsKHBhdGgpLCB2YWx1ZV1cbiAgICApXG4gICk7XG5cbiAgaWYgKGV4cGxhbmF0b3J5Q29tbWVudCkge1xuICAgIHQuYWRkQ29tbWVudChhc3QsIFwibGVhZGluZ1wiLCBleHBsYW5hdG9yeUNvbW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGFzdDtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcnJpZGVMb2dpY2FsSWRFeHByZXNzaW9uKHZhcmlhYmxlOiBzdHJpbmcsIGxvZ2ljYWxJZDogc3RyaW5nKSB7XG4gIGNvbnN0IGFzdCA9IHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICB0LmlkZW50aWZpZXIodmFyaWFibGUpLFxuICAgICAgICB0LmlkZW50aWZpZXIoXCJvdmVycmlkZUxvZ2ljYWxJZFwiKVxuICAgICAgKSxcbiAgICAgIFt0LnN0cmluZ0xpdGVyYWwobG9naWNhbElkKV1cbiAgICApXG4gICk7XG5cbiAgdC5hZGRDb21tZW50KFxuICAgIGFzdCxcbiAgICBcImxlYWRpbmdcIixcbiAgICBcIlRoaXMgYWxsb3dzIHRoZSBUZXJyYWZvcm0gcmVzb3VyY2UgbmFtZSB0byBtYXRjaCB0aGUgb3JpZ2luYWwgbmFtZS4gWW91IGNhbiByZW1vdmUgdGhlIGNhbGwgaWYgeW91IGRvbid0IG5lZWQgdGhlbSB0byBtYXRjaC5cIlxuICApO1xuXG4gIHJldHVybiBhc3Q7XG59XG5cbmZ1bmN0aW9uIGdldFJlbW90ZVN0YXRlVHlwZShpdGVtOiBSZXNvdXJjZSkge1xuICBjb25zdCBiYWNrZW5kUmVjb3JkID0gaXRlbS5maW5kKCh2YWwpID0+IHZhbC5iYWNrZW5kKTtcbiAgaWYgKGJhY2tlbmRSZWNvcmQpIHtcbiAgICBjb25zdCBiYWNrZW5kID0gYmFja2VuZFJlY29yZC5iYWNrZW5kO1xuICAgIHN3aXRjaCAoYmFja2VuZCkge1xuICAgICAgY2FzZSBcInJlbW90ZVwiOlxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGNhc2UgXCJldGNkdjNcIjpcbiAgICAgICAgcmV0dXJuIFwiX2V0Y2RfdjNcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgXyR7YmFja2VuZH1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvdXJjZVR5cGUocHJvdmlkZXI6IHN0cmluZywgbmFtZTogc3RyaW5nW10sIGl0ZW06IFJlc291cmNlKSB7XG4gIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICBjYXNlIFwiZGF0YS50ZXJyYWZvcm1cIjpcbiAgICAgIHJldHVybiBgY2RrdGYuZGF0YV90ZXJyYWZvcm1fJHtuYW1lLmpvaW4oXCJfXCIpfSR7Z2V0UmVtb3RlU3RhdGVUeXBlKFxuICAgICAgICBpdGVtXG4gICAgICApfWA7XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICAgIHJldHVybiBgTnVsbFByb3ZpZGVyLiR7bmFtZS5qb2luKFwiX1wiKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCR7cHJvdmlkZXJ9LiR7bmFtZS5qb2luKFwiX1wiKX1gO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvdXJjZShcbiAgc2NvcGU6IFNjb3BlLFxuICB0eXBlOiBzdHJpbmcsXG4gIGtleTogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBpdGVtOiBSZXNvdXJjZSxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbik6IHQuU3RhdGVtZW50W10ge1xuICBjb25zdCBbcHJvdmlkZXIsIC4uLm5hbWVdID0gdHlwZS5zcGxpdChcIl9cIik7XG4gIGNvbnN0IG5vZGVJZHMgPSBncmFwaC5ub2RlcygpO1xuICBjb25zdCByZXNvdXJjZSA9IHJlc291cmNlVHlwZShwcm92aWRlciwgbmFtZSwgaXRlbSk7XG5cbiAgY29uc3QgeyBmb3JfZWFjaCwgY291bnQsIC4uLmNvbmZpZyB9ID0gaXRlbVswXTtcbiAgY29uc3QgZHluQmxvY2tzID0gZXh0cmFjdER5bmFtaWNCbG9ja3MoY29uZmlnKTtcbiAgY29uc3Qgb3ZlcnJpZGVSZWZlcmVuY2UgPVxuICAgIGR5bkJsb2Nrcy5sZW5ndGggfHwgY291bnQgfHwgZm9yX2VhY2hcbiAgICAgID8ge1xuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICByZWZlcmVuY2VlOiB7XG4gICAgICAgICAgICBpZDogYCR7dHlwZX0uJHtrZXl9YCxcbiAgICAgICAgICAgIGZ1bGw6IGAke3R5cGV9LiR7a2V5fWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXG4gICAgLi4uYXNFeHByZXNzaW9uKFxuICAgICAgc2NvcGUsXG4gICAgICByZXNvdXJjZSxcbiAgICAgIGtleSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG5vZGVJZHMsXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlLFxuICAgICAgZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZCkgfHwgb3ZlcnJpZGVSZWZlcmVuY2VcbiAgICApLFxuICBdO1xuICBjb25zdCB2YXJOYW1lID0gdmFyaWFibGVOYW1lKHNjb3BlLCByZXNvdXJjZSwga2V5KTtcblxuICBjb25zdCBsb29wQ29tbWVudCA9IGBJbiBtb3N0IGNhc2VzIGxvb3BzIHNob3VsZCBiZSBoYW5kbGVkIGluIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZSBjb250ZXh0IGFuZCBcbm5vdCBpbnNpZGUgb2YgdGhlIFRlcnJhZm9ybSBjb250ZXh0LiBJZiB5b3UgYXJlIGxvb3Bpbmcgb3ZlciBzb21ldGhpbmcgZXh0ZXJuYWwsIGUuZy4gYSB2YXJpYWJsZSBvciBhIGZpbGUgaW5wdXRcbnlvdSBzaG91bGQgY29uc2lkZXIgdXNpbmcgYSBmb3IgbG9vcC4gSWYgeW91IGFyZSBsb29waW5nIG92ZXIgc29tZXRoaW5nIG9ubHkga25vd24gdG8gVGVycmFmb3JtLCBlLmcuIGEgcmVzdWx0IG9mIGEgZGF0YSBzb3VyY2VcbnlvdSBuZWVkIHRvIGtlZXAgdGhpcyBsaWtlIGl0IGlzLmA7XG4gIGlmIChmb3JfZWFjaCkge1xuICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBleHRyYWN0UmVmZXJlbmNlc0Zyb21FeHByZXNzaW9uKGZvcl9lYWNoLCBub2RlSWRzLCBbXG4gICAgICBcImVhY2hcIixcbiAgICBdKTtcbiAgICBleHByZXNzaW9ucy5wdXNoKFxuICAgICAgYWRkT3ZlcnJpZGVFeHByZXNzaW9uKFxuICAgICAgICB2YXJOYW1lLFxuICAgICAgICBcImZvcl9lYWNoXCIsXG4gICAgICAgIHJlZmVyZW5jZXNUb0FzdChzY29wZSwgZm9yX2VhY2gsIHJlZmVyZW5jZXMpLFxuICAgICAgICBsb29wQ29tbWVudFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBpZiAoY291bnQpIHtcbiAgICBpZiAodHlwZW9mIGNvdW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBleHByZXNzaW9ucy5wdXNoKFxuICAgICAgICBhZGRPdmVycmlkZUV4cHJlc3Npb24oXG4gICAgICAgICAgdmFyTmFtZSxcbiAgICAgICAgICBcImNvdW50XCIsXG4gICAgICAgICAgdmFsdWVUb1RzKHNjb3BlLCBjb3VudCwgXCJwYXRoLWZvci1jb3VudHMtY2FuLWJlLWlnbm9yZWRcIiwgbm9kZUlkcyksXG4gICAgICAgICAgbG9vcENvbW1lbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IGV4dHJhY3RSZWZlcmVuY2VzRnJvbUV4cHJlc3Npb24oY291bnQsIG5vZGVJZHMsIFtcbiAgICAgICAgXCJjb3VudFwiLFxuICAgICAgXSk7XG4gICAgICBleHByZXNzaW9ucy5wdXNoKFxuICAgICAgICBhZGRPdmVycmlkZUV4cHJlc3Npb24oXG4gICAgICAgICAgdmFyTmFtZSxcbiAgICAgICAgICBcImNvdW50XCIsXG4gICAgICAgICAgcmVmZXJlbmNlc1RvQXN0KHNjb3BlLCBjb3VudCwgcmVmZXJlbmNlcyksXG4gICAgICAgICAgbG9vcENvbW1lbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZHluYW1pYyBibG9ja3NcbiAgcmV0dXJuIFtcbiAgICAuLi5leHByZXNzaW9ucyxcbiAgICAuLi5keW5CbG9ja3MubWFwKCh7IHBhdGgsIGZvcl9lYWNoLCBjb250ZW50LCBzY29wZWRWYXIgfSkgPT4ge1xuICAgICAgcmV0dXJuIGFkZE92ZXJyaWRlRXhwcmVzc2lvbihcbiAgICAgICAgdmFyTmFtZSxcbiAgICAgICAgcGF0aC5zdWJzdHJpbmcoMSksIC8vIFRoZSBwYXRoIHN0YXJ0cyB3aXRoIGEgZG90IHRoYXQgd2UgZG9uJ3Qgd2FudFxuICAgICAgICB2YWx1ZVRvVHMoXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yX2VhY2gsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwYXRoLWZvci1keW5hbWljLWJsb2Nrcy1jYW4tYmUtaWdub3JlZFwiLFxuICAgICAgICAgIG5vZGVJZHMsXG4gICAgICAgICAgW3Njb3BlZFZhcl1cbiAgICAgICAgKSxcbiAgICAgICAgbG9vcENvbW1lbnRcbiAgICAgICk7XG4gICAgfSksXG4gIF07XG59XG5cbmZ1bmN0aW9uIGFzRXhwcmVzc2lvbihcbiAgc2NvcGU6IFNjb3BlLFxuICB0eXBlOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgY29uZmlnOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLFxuICBub2RlSWRzOiBzdHJpbmdbXSxcbiAgaXNNb2R1bGVJbXBvcnQ6IGJvb2xlYW4sXG4gIGlzUHJvdmlkZXI6IGJvb2xlYW4sXG4gIHJlZmVyZW5jZT86IFJlZmVyZW5jZVxuKSB7XG4gIGNvbnN0IHsgcHJvdmlkZXIsIHByb3ZpZGVycywgbGlmZWN5Y2xlLCAuLi5vdGhlck9wdGlvbnMgfSA9IGNvbmZpZyBhcyBhbnk7XG5cbiAgY29uc3QgY29uc3RydWN0SWQgPSB1bmlxdWVJZChzY29wZS5jb25zdHJ1Y3RzLCBuYW1lKTtcbiAgY29uc3Qgb3ZlcnJpZGVJZCA9ICFpc1Byb3ZpZGVyICYmIGNvbnN0cnVjdElkICE9PSBuYW1lO1xuXG4gIGNvbnN0IGV4cHJlc3Npb24gPSB0Lm5ld0V4cHJlc3Npb24oY29uc3RydWN0QXN0KHR5cGUsIGlzTW9kdWxlSW1wb3J0KSwgW1xuICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICB0LnN0cmluZ0xpdGVyYWwoY29uc3RydWN0SWQpLFxuICAgIHZhbHVlVG9UcyhzY29wZSwgb3RoZXJPcHRpb25zLCBgJHt0eXBlfWAsIG5vZGVJZHMpLFxuICBdKTtcblxuICBjb25zdCBzdGF0ZW1lbnRzID0gW107XG4gIGNvbnN0IHZhck5hbWUgPSByZWZlcmVuY2VcbiAgICA/IHJlZmVyZW5jZVRvVmFyaWFibGVOYW1lKHNjb3BlLCByZWZlcmVuY2UpXG4gICAgOiB2YXJpYWJsZU5hbWUoc2NvcGUsIHR5cGUsIG5hbWUpO1xuXG4gIGlmIChyZWZlcmVuY2UgfHwgcHJvdmlkZXJzIHx8IHByb3ZpZGVyIHx8IGxpZmVjeWNsZSB8fCBvdmVycmlkZUlkKSB7XG4gICAgc3RhdGVtZW50cy5wdXNoKFxuICAgICAgdC52YXJpYWJsZURlY2xhcmF0aW9uKFwiY29uc3RcIiwgW1xuICAgICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcih0LmlkZW50aWZpZXIodmFyTmFtZSksIGV4cHJlc3Npb24pLFxuICAgICAgXSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlbWVudHMucHVzaCh0LmV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikpO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyKSB7XG4gICAgc3RhdGVtZW50cy5wdXNoKFxuICAgICAgYWRkT3ZlcnJpZGVFeHByZXNzaW9uKFxuICAgICAgICB2YXJOYW1lLFxuICAgICAgICBcInByb3ZpZGVyXCIsXG4gICAgICAgIHZhbHVlVG9UcyhcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICBcInBhdGgtZm9yLXByb3ZpZGVyLWJsb2Nrcy1jYW4tYmUtaWdub3JlZFwiLFxuICAgICAgICAgIG5vZGVJZHNcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgaWYgKHByb3ZpZGVycykge1xuICAgIHN0YXRlbWVudHMucHVzaChcbiAgICAgIGFkZE92ZXJyaWRlRXhwcmVzc2lvbihcbiAgICAgICAgdmFyTmFtZSxcbiAgICAgICAgXCJwcm92aWRlcnNcIixcbiAgICAgICAgdmFsdWVUb1RzKFxuICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgIHByb3ZpZGVycyxcbiAgICAgICAgICBcInBhdGgtZm9yLXByb3ZpZGVycy1ibG9ja3MtY2FuLWJlLWlnbm9yZWRcIixcbiAgICAgICAgICBub2RlSWRzXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgaWYgKGxpZmVjeWNsZSkge1xuICAgIHN0YXRlbWVudHMucHVzaChcbiAgICAgIGFkZE92ZXJyaWRlRXhwcmVzc2lvbihcbiAgICAgICAgdmFyTmFtZSxcbiAgICAgICAgXCJsaWZlY3ljbGVcIixcbiAgICAgICAgdmFsdWVUb1RzKFxuICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgIGxpZmVjeWNsZSxcbiAgICAgICAgICBcInBhdGgtZm9yLWxpZmVjeWNsZS1ibG9ja3MtY2FuLWJlLWlnbm9yZWRcIixcbiAgICAgICAgICBub2RlSWRzXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgaWYgKG92ZXJyaWRlSWQpIHtcbiAgICBzdGF0ZW1lbnRzLnB1c2goYWRkT3ZlcnJpZGVMb2dpY2FsSWRFeHByZXNzaW9uKHZhck5hbWUsIG5hbWUpKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3V0cHV0KFxuICBzY29wZTogU2NvcGUsXG4gIGtleTogc3RyaW5nLFxuICBfaWQ6IHN0cmluZyxcbiAgaXRlbTogT3V0cHV0LFxuICBncmFwaDogRGlyZWN0ZWRHcmFwaFxuKSB7XG4gIGNvbnN0IG5vZGVJZHMgPSBncmFwaC5ub2RlcygpO1xuICBjb25zdCBbeyB2YWx1ZSwgZGVzY3JpcHRpb24sIHNlbnNpdGl2ZSB9XSA9IGl0ZW07XG5cbiAgcmV0dXJuIGFzRXhwcmVzc2lvbihcbiAgICBzY29wZSxcbiAgICBcImNka3RmLlRlcnJhZm9ybU91dHB1dFwiLFxuICAgIGtleSxcbiAgICB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgc2Vuc2l0aXZlLFxuICAgIH0sXG4gICAgbm9kZUlkcyxcbiAgICBmYWxzZSxcbiAgICBmYWxzZVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGUoXG4gIHNjb3BlOiBTY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIGlkOiBzdHJpbmcsXG4gIGl0ZW06IFZhcmlhYmxlLFxuICBncmFwaDogRGlyZWN0ZWRHcmFwaFxuKSB7XG4gIC8vIFdlIGRvbid0IGhhbmRsZSB0eXBlIGluZm9ybWF0aW9uIHJpZ2h0IG5vd1xuICBjb25zdCBbeyB0eXBlLCAuLi5wcm9wcyB9XSA9IGl0ZW07XG4gIGNvbnN0IG5vZGVJZHMgPSBncmFwaC5ub2RlcygpO1xuXG4gIGlmICghZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIFwiY2RrdGYuVGVycmFmb3JtVmFyaWFibGVcIixcbiAgICBrZXksXG4gICAgcHJvcHMsXG4gICAgbm9kZUlkcyxcbiAgICBmYWxzZSxcbiAgICBmYWxzZSxcbiAgICBnZXRSZWZlcmVuY2UoZ3JhcGgsIGlkKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9jYWwoXG4gIHNjb3BlOiBTY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIGlkOiBzdHJpbmcsXG4gIGl0ZW06IFRlcnJhZm9ybVJlc291cmNlQmxvY2ssXG4gIGdyYXBoOiBEaXJlY3RlZEdyYXBoXG4pIHtcbiAgY29uc3Qgbm9kZUlkcyA9IGdyYXBoLm5vZGVzKCk7XG4gIGlmICghZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHQudmFyaWFibGVEZWNsYXJhdGlvbihcImNvbnN0XCIsIFtcbiAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgIHQuaWRlbnRpZmllcih2YXJpYWJsZU5hbWUoc2NvcGUsIFwibG9jYWxcIiwga2V5KSksXG4gICAgICB2YWx1ZVRvVHMoc2NvcGUsIGl0ZW0sIFwicGF0aC1mb3ItbG9jYWwtYmxvY2tzLWNhbi1iZS1pZ25vcmVkXCIsIG5vZGVJZHMpXG4gICAgKSxcbiAgXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2R1bGVzKFxuICBzY29wZTogU2NvcGUsXG4gIGtleTogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBpdGVtOiBNb2R1bGUsXG4gIGdyYXBoOiBEaXJlY3RlZEdyYXBoXG4pIHtcbiAgY29uc3QgW3sgc291cmNlLCB2ZXJzaW9uLCAuLi5wcm9wcyB9XSA9IGl0ZW07XG4gIGNvbnN0IG5vZGVJZHMgPSBncmFwaC5ub2RlcygpO1xuXG4gIGNvbnN0IG1vZHVsZUNvbnN0cmFpbnQgPSBuZXcgVGVycmFmb3JtTW9kdWxlQ29uc3RyYWludChzb3VyY2UpO1xuXG4gIHJldHVybiBhc0V4cHJlc3Npb24oXG4gICAgc2NvcGUsXG4gICAgbW9kdWxlQ29uc3RyYWludC5jbGFzc05hbWUsXG4gICAga2V5LFxuICAgIHByb3BzLFxuICAgIG5vZGVJZHMsXG4gICAgdHJ1ZSxcbiAgICBmYWxzZSxcbiAgICBnZXRSZWZlcmVuY2UoZ3JhcGgsIGlkKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvdmlkZXIoXG4gIHNjb3BlOiBTY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIF9pZDogc3RyaW5nLFxuICBpdGVtOiBQcm92aWRlclswXSxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbikge1xuICBjb25zdCBub2RlSWRzID0gZ3JhcGgubm9kZXMoKTtcbiAgY29uc3QgeyB2ZXJzaW9uLCAuLi5wcm9wcyB9ID0gaXRlbTtcblxuICBjb25zdCBpbXBvcnRLZXkgPSBrZXkgPT09IFwibnVsbFwiID8gXCJOdWxsUHJvdmlkZXJcIiA6IGtleTtcblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIGAke2ltcG9ydEtleX0uJHtwYXNjYWxDYXNlKGtleSArIFwiUHJvdmlkZXJcIil9YCxcbiAgICBrZXksXG4gICAgcHJvcHMsXG4gICAgbm9kZUlkcyxcbiAgICBmYWxzZSxcbiAgICB0cnVlXG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBjZGt0ZkltcG9ydCA9IHRlbXBsYXRlKFxuICBgaW1wb3J0ICogYXMgY2RrdGYgZnJvbSBcImNka3RmXCJgXG4pKCkgYXMgdC5TdGF0ZW1lbnQ7XG5cbmV4cG9ydCBjb25zdCBwcm92aWRlckltcG9ydHMgPSAocHJvdmlkZXJzOiBzdHJpbmdbXSkgPT5cbiAgcHJvdmlkZXJzLm1hcCgocHJvdmlkZXJOYW1lKSA9PiB7XG4gICAgY29uc3QgcGFydHMgPSBwcm92aWRlck5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IG5hbWUgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0gOiBwYXJ0c1swXTtcbiAgICBjb25zdCBpbXBvcnROYW1lID0gbmFtZSA9PT0gXCJudWxsXCIgPyBcIk51bGxQcm92aWRlclwiIDogbmFtZTtcbiAgICByZXR1cm4gdGVtcGxhdGUoXG4gICAgICBgaW1wb3J0ICogYXMgJHtpbXBvcnROYW1lfSBmcm9tIFwiLi8uZ2VuL3Byb3ZpZGVycy8ke25hbWUucmVwbGFjZShcbiAgICAgICAgXCIuL1wiLFxuICAgICAgICBcIlwiXG4gICAgICApfVwiYFxuICAgICkoKSBhcyB0LlN0YXRlbWVudDtcbiAgfSk7XG5cbmV4cG9ydCBjb25zdCBtb2R1bGVJbXBvcnRzID0gKG1vZHVsZXM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZT4gfCB1bmRlZmluZWQpID0+IHtcbiAgY29uc3QgdW5pcXVlTW9kdWxlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBPYmplY3QudmFsdWVzKG1vZHVsZXMgfHwge30pLm1hcCgoW21vZHVsZV0pID0+XG4gICAgdW5pcXVlTW9kdWxlcy5hZGQobW9kdWxlLnNvdXJjZSlcbiAgKTtcblxuICBjb25zdCBpbXBvcnRzOiB0LlN0YXRlbWVudFtdID0gW107XG4gIHVuaXF1ZU1vZHVsZXMuZm9yRWFjaCgobSkgPT4ge1xuICAgIGNvbnN0IG1vZHVsZUNvbnN0cmFpbnQgPSBuZXcgVGVycmFmb3JtTW9kdWxlQ29uc3RyYWludChtKTtcbiAgICBpbXBvcnRzLnB1c2goXG4gICAgICB0ZW1wbGF0ZS5hc3QoXG4gICAgICAgIGBpbXBvcnQgKiBhcyAke21vZHVsZUNvbnN0cmFpbnQuY2xhc3NOYW1lfSBmcm9tIFwiLi8uZ2VuL21vZHVsZXMvJHttb2R1bGVDb25zdHJhaW50LmZpbGVOYW1lfVwiYFxuICAgICAgKSBhcyB0LlN0YXRlbWVudFxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gaW1wb3J0cztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW4oc3RhdGVtZW50czogdC5TdGF0ZW1lbnRbXSkge1xuICByZXR1cm4gcHJldHRpZXIuZm9ybWF0KGdlbmVyYXRlKHQucHJvZ3JhbShzdGF0ZW1lbnRzKSBhcyBhbnkpLmNvZGUsIHtcbiAgICBwYXJzZXI6IFwiYmFiZWxcIixcbiAgfSk7XG59XG4iXX0=