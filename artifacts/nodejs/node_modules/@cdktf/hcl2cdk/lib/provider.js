"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProviderRequirements = exports.getBlockTypeAtPath = void 0;
function getBlockTypeAtPath(schema, path) {
    var _a;
    const parts = path.split(".");
    if (parts.length < 2) {
        // Too short to be a valid path
        return null;
    }
    const isDataSource = parts[0] === "data";
    if (isDataSource) {
        parts.shift();
    }
    const providerName = parts.shift();
    const resourceName = parts.shift();
    const fullProviderName = Object.keys((schema === null || schema === void 0 ? void 0 : schema.provider_schemas) || {}).find((name) => name.endsWith(providerName));
    const fullResourceName = `${providerName}_${resourceName}`;
    if (!fullProviderName) {
        // No provider found with that name
        return null;
    }
    const provider = (_a = schema.provider_schemas) === null || _a === void 0 ? void 0 : _a[fullProviderName];
    if (!provider) {
        // Could not find provider
        return null;
    }
    const resources = isDataSource
        ? provider.data_source_schemas
        : provider.resource_schemas;
    let resource = resources[fullResourceName];
    if (!resource) {
        // Could not find resource
        return null;
    }
    if (parts.length === 0) {
        // No property specified
        return null;
    }
    // We don't care for
    let currentSchema = resource;
    do {
        const part = parts.shift();
        // console.log("Doing part", part);
        if (!currentSchema.block.block_types ||
            !currentSchema.block.block_types.hasOwnProperty(part)) {
            // console.log("didnt find it");
            // Found no block property with this name, there could be an attribute, but we don't care at this point
            return null;
        }
        currentSchema = currentSchema.block.block_types[part];
        // console.log("New schema", currentSchema);
    } while (parts.length > 0);
    return currentSchema;
}
exports.getBlockTypeAtPath = getBlockTypeAtPath;
function getProviderRequirements(plan) {
    var _a;
    // In Terraform one can implicitly define the provider by using resources of that type
    const explicitProviders = Object.keys(plan.provider || {});
    const implicitProviders = Object.keys({ ...plan.resource, ...plan.data })
        .filter((type) => type !== "terraform_remote_state")
        .map((type) => type.split("_")[0]);
    const providerRequirements = Array.from(new Set([...explicitProviders, ...implicitProviders])).reduce((carry, req) => ({ ...carry, [req]: "*" }), {});
    (_a = plan.terraform) === null || _a === void 0 ? void 0 : _a.forEach(({ required_providers }) => (required_providers || []).forEach((providerBlock) => Object.entries(providerBlock).forEach(([key, value]) => {
        let name, version;
        if (typeof value === "string") {
            name = key;
            version = value;
        }
        else {
            name = value.source;
            version = value.version;
        }
        if (!name) {
            return;
        }
        // implicitly only the last part of the path is used (e.g. docker for kreuzwerker/docker)
        const parts = name.split("/");
        if (parts.length > 1) {
            delete providerRequirements[parts.pop() || ""];
        }
        providerRequirements[name] = version || "*";
    })));
    return providerRequirements;
}
exports.getProviderRequirements = getProviderRequirements;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFLQSxTQUFnQixrQkFBa0IsQ0FDaEMsTUFBc0IsRUFDdEIsSUFBWTs7SUFFWixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTlCLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDcEIsK0JBQStCO1FBQy9CLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDO0lBQ3pDLElBQUksWUFBWSxFQUFFO1FBQ2hCLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUNmO0lBRUQsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBWSxDQUFDO0lBQzdDLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQVksQ0FBQztJQUM3QyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQSxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsZ0JBQWdCLEtBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUN2RSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FDdEMsQ0FBQztJQUNGLE1BQU0sZ0JBQWdCLEdBQUcsR0FBRyxZQUFZLElBQUksWUFBWSxFQUFFLENBQUM7SUFFM0QsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1FBQ3JCLG1DQUFtQztRQUNuQyxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxRQUFRLFNBQUcsTUFBTSxDQUFDLGdCQUFnQiwwQ0FBRyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzdELElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDYiwwQkFBMEI7UUFDMUIsT0FBTyxJQUFJLENB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QUMsSUFBSSxFQUFFO1lBQ1QsT0FBTztTQUNSO1FBQ0QseUZBQXlGO1FBQ3pGLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUIsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNwQixPQUFPLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUNoRDtRQUNELG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sSUFBSSxHQUFHLENBQUM7SUFDOUMsQ0FBQyxDQUFDLENBQ0gsRUFDRDtJQUVGLE9BQU8sb0JBQW9CLENBQUM7QUFDOUIsQ0FBQztBQXhDRCwwREF3Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB6IGZyb20gXCJ6b2RcIjtcbmltcG9ydCB7IFByb3ZpZGVyU2NoZW1hLCBCbG9ja1R5cGUgfSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLWdlbmVyYXRvclwiO1xuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hXCI7XG5cbnR5cGUgRXh0ZW5kZWRCbG9ja1R5cGUgPSBCbG9ja1R5cGUgJiB7IG1heF9pdGVtcz86IG51bWJlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJsb2NrVHlwZUF0UGF0aChcbiAgc2NoZW1hOiBQcm92aWRlclNjaGVtYSxcbiAgcGF0aDogc3RyaW5nXG4pOiBFeHRlbmRlZEJsb2NrVHlwZSB8IG51bGwge1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuXG4gIGlmIChwYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgLy8gVG9vIHNob3J0IHRvIGJlIGEgdmFsaWQgcGF0aFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgaXNEYXRhU291cmNlID0gcGFydHNbMF0gPT09IFwiZGF0YVwiO1xuICBpZiAoaXNEYXRhU291cmNlKSB7XG4gICAgcGFydHMuc2hpZnQoKTtcbiAgfVxuXG4gIGNvbnN0IHByb3ZpZGVyTmFtZSA9IHBhcnRzLnNoaWZ0KCkgYXMgc3RyaW5nO1xuICBjb25zdCByZXNvdXJjZU5hbWUgPSBwYXJ0cy5zaGlmdCgpIGFzIHN0cmluZztcbiAgY29uc3QgZnVsbFByb3ZpZGVyTmFtZSA9IE9iamVjdC5rZXlzKHNjaGVtYT8ucHJvdmlkZXJfc2NoZW1hcyB8fCB7fSkuZmluZChcbiAgICAobmFtZSkgPT4gbmFtZS5lbmRzV2l0aChwcm92aWRlck5hbWUpXG4gICk7XG4gIGNvbnN0IGZ1bGxSZXNvdXJjZU5hbWUgPSBgJHtwcm92aWRlck5hbWV9XyR7cmVzb3VyY2VOYW1lfWA7XG5cbiAgaWYgKCFmdWxsUHJvdmlkZXJOYW1lKSB7XG4gICAgLy8gTm8gcHJvdmlkZXIgZm91bmQgd2l0aCB0aGF0IG5hbWVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHByb3ZpZGVyID0gc2NoZW1hLnByb3ZpZGVyX3NjaGVtYXM/LltmdWxsUHJvdmlkZXJOYW1lXTtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIC8vIENvdWxkIG5vdCBmaW5kIHByb3ZpZGVyXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCByZXNvdXJjZXMgPSBpc0RhdGFTb3VyY2VcbiAgICA/IHByb3ZpZGVyLmRhdGFfc291cmNlX3NjaGVtYXNcbiAgICA6IHByb3ZpZGVyLnJlc291cmNlX3NjaGVtYXM7XG5cbiAgbGV0IHJlc291cmNlID0gcmVzb3VyY2VzW2Z1bGxSZXNvdXJjZU5hbWVdO1xuICBpZiAoIXJlc291cmNlKSB7XG4gICAgLy8gQ291bGQgbm90IGZpbmQgcmVzb3VyY2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBObyBwcm9wZXJ0eSBzcGVjaWZpZWRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IGNhcmUgZm9yXG4gIGxldCBjdXJyZW50U2NoZW1hOiBCbG9ja1R5cGUgfCB0eXBlb2YgcmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgZG8ge1xuICAgIGNvbnN0IHBhcnQgPSBwYXJ0cy5zaGlmdCgpIGFzIHN0cmluZztcbiAgICAvLyBjb25zb2xlLmxvZyhcIkRvaW5nIHBhcnRcIiwgcGFydCk7XG4gICAgaWYgKFxuICAgICAgIWN1cnJlbnRTY2hlbWEuYmxvY2suYmxvY2tfdHlwZXMgfHxcbiAgICAgICFjdXJyZW50U2NoZW1hLmJsb2NrLmJsb2NrX3R5cGVzLmhhc093blByb3BlcnR5KHBhcnQpXG4gICAgKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImRpZG50IGZpbmQgaXRcIik7XG4gICAgICAvLyBGb3VuZCBubyBibG9jayBwcm9wZXJ0eSB3aXRoIHRoaXMgbmFtZSwgdGhlcmUgY291bGQgYmUgYW4gYXR0cmlidXRlLCBidXQgd2UgZG9uJ3QgY2FyZSBhdCB0aGlzIHBvaW50XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjdXJyZW50U2NoZW1hID0gY3VycmVudFNjaGVtYS5ibG9jay5ibG9ja190eXBlc1twYXJ0XTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIk5ldyBzY2hlbWFcIiwgY3VycmVudFNjaGVtYSk7XG4gIH0gd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDApO1xuXG4gIHJldHVybiBjdXJyZW50U2NoZW1hO1xufVxuXG50eXBlIFBsYW4gPSB6LmluZmVyPHR5cGVvZiBzY2hlbWE+O1xuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3ZpZGVyUmVxdWlyZW1lbnRzKHBsYW46IFBsYW4pIHtcbiAgLy8gSW4gVGVycmFmb3JtIG9uZSBjYW4gaW1wbGljaXRseSBkZWZpbmUgdGhlIHByb3ZpZGVyIGJ5IHVzaW5nIHJlc291cmNlcyBvZiB0aGF0IHR5cGVcbiAgY29uc3QgZXhwbGljaXRQcm92aWRlcnMgPSBPYmplY3Qua2V5cyhwbGFuLnByb3ZpZGVyIHx8IHt9KTtcbiAgY29uc3QgaW1wbGljaXRQcm92aWRlcnMgPSBPYmplY3Qua2V5cyh7IC4uLnBsYW4ucmVzb3VyY2UsIC4uLnBsYW4uZGF0YSB9KVxuICAgIC5maWx0ZXIoKHR5cGUpID0+IHR5cGUgIT09IFwidGVycmFmb3JtX3JlbW90ZV9zdGF0ZVwiKVxuICAgIC5tYXAoKHR5cGUpID0+IHR5cGUuc3BsaXQoXCJfXCIpWzBdKTtcblxuICBjb25zdCBwcm92aWRlclJlcXVpcmVtZW50cyA9IEFycmF5LmZyb20oXG4gICAgbmV3IFNldChbLi4uZXhwbGljaXRQcm92aWRlcnMsIC4uLmltcGxpY2l0UHJvdmlkZXJzXSlcbiAgKS5yZWR1Y2UoXG4gICAgKGNhcnJ5LCByZXEpID0+ICh7IC4uLmNhcnJ5LCBbcmVxXTogXCIqXCIgfSksXG4gICAge30gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICApO1xuXG4gIHBsYW4udGVycmFmb3JtPy5mb3JFYWNoKCh7IHJlcXVpcmVkX3Byb3ZpZGVycyB9KSA9PlxuICAgIChyZXF1aXJlZF9wcm92aWRlcnMgfHwgW10pLmZvckVhY2goKHByb3ZpZGVyQmxvY2spID0+XG4gICAgICBPYmplY3QuZW50cmllcyhwcm92aWRlckJsb2NrKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgbGV0IG5hbWUsIHZlcnNpb247XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBuYW1lID0ga2V5O1xuICAgICAgICAgIHZlcnNpb24gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gdmFsdWUuc291cmNlO1xuICAgICAgICAgIHZlcnNpb24gPSB2YWx1ZS52ZXJzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGltcGxpY2l0bHkgb25seSB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBwYXRoIGlzIHVzZWQgKGUuZy4gZG9ja2VyIGZvciBrcmV1endlcmtlci9kb2NrZXIpXG4gICAgICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgZGVsZXRlIHByb3ZpZGVyUmVxdWlyZW1lbnRzW3BhcnRzLnBvcCgpIHx8IFwiXCJdO1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVyUmVxdWlyZW1lbnRzW25hbWVdID0gdmVyc2lvbiB8fCBcIipcIjtcbiAgICAgIH0pXG4gICAgKVxuICApO1xuXG4gIHJldHVybiBwcm92aWRlclJlcXVpcmVtZW50cztcbn1cbiJdfQ==