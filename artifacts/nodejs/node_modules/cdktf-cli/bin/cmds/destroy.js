"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const destroy_1 = require("./ui/destroy");
const provider_generator_1 = require("@cdktf/provider-generator");
const render_ink_1 = require("./helper/render-ink");
const version_check_1 = require("./helper/version-check");
const check_directory_1 = require("./helper/check-directory");
const check_environment_1 = require("./helper/check-environment");
const config = provider_generator_1.config.readConfigSync();
class Command {
    constructor() {
        this.command = "destroy [stack] [OPTIONS]";
        this.describe = "Destroy the given stack";
        this.builder = (args) => args
            .positional("stack", {
            desc: "Destroy stack which matches the given id only. Required when more than one stack is present in the app",
            type: "string",
        })
            .option("app", {
            default: config.app,
            required: true,
            desc: "Command to use in order to execute cdktf app",
            alias: "a",
        })
            .option("output", {
            default: config.output,
            required: true,
            desc: "Output directory",
            alias: "o",
        })
            .option("auto-approve", {
            type: "boolean",
            default: false,
            required: false,
            desc: "Auto approve",
        })
            .showHelpOnFail(true);
    }
    async handler(argv) {
        check_directory_1.throwIfNotProjectDirectory("destroy");
        await version_check_1.displayVersionMessage();
        await check_environment_1.checkEnvironment("destroy");
        const command = argv.app;
        const outdir = argv.output;
        const autoApprove = argv.autoApprove;
        const stack = argv.stack;
        await render_ink_1.renderInk(react_1.default.createElement(destroy_1.Destroy, {
            targetDir: outdir,
            targetStack: stack,
            synthCommand: command,
            autoApprove,
        }));
    }
}
module.exports = new Command();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVzdHJveS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlc3Ryb3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxrREFBMEI7QUFDMUIsMENBQXVDO0FBQ3ZDLGtFQUEwRDtBQUMxRCxvREFBZ0Q7QUFDaEQsMERBQStEO0FBQy9ELDhEQUFzRTtBQUN0RSxrRUFBOEQ7QUFFOUQsTUFBTSxNQUFNLEdBQUcsMkJBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUVwQyxNQUFNLE9BQU87SUFBYjtRQUNrQixZQUFPLEdBQUcsMkJBQTJCLENBQUM7UUFDdEMsYUFBUSxHQUFHLHlCQUF5QixDQUFDO1FBRXJDLFlBQU8sR0FBRyxDQUFDLElBQWdCLEVBQUUsRUFBRSxDQUM3QyxJQUFJO2FBQ0QsVUFBVSxDQUFDLE9BQU8sRUFBRTtZQUNuQixJQUFJLEVBQUUsd0dBQXdHO1lBQzlHLElBQUksRUFBRSxRQUFRO1NBQ2YsQ0FBQzthQUNELE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDYixPQUFPLEVBQUUsTUFBTSxDQUFDLEdBQUc7WUFDbkIsUUFBUSxFQUFFLElBQUk7WUFDZCxJQUFJLEVBQUUsOENBQThDO1lBQ3BELEtBQUssRUFBRSxHQUFHO1NBQ1gsQ0FBQzthQUNELE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDaEIsT0FBTyxFQUFFLE1BQU0sQ0FBQyxNQUFNO1lBQ3RCLFFBQVEsRUFBRSxJQUFJO1lBQ2QsSUFBSSxFQUFFLGtCQUFrQjtZQUN4QixLQUFLLEVBQUUsR0FBRztTQUNYLENBQUM7YUFDRCxNQUFNLENBQUMsY0FBYyxFQUFFO1lBQ3RCLElBQUksRUFBRSxTQUFTO1lBQ2YsT0FBTyxFQUFFLEtBQUs7WUFDZCxRQUFRLEVBQUUsS0FBSztZQUNmLElBQUksRUFBRSxjQUFjO1NBQ3JCLENBQUM7YUFDRCxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7SUFvQjVCLENBQUM7SUFsQlEsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFTO1FBQzVCLDRDQUEwQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0scUNBQXFCLEVBQUUsQ0FBQztRQUM5QixNQUFNLG9DQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2xDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDekIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMzQixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ3JDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFFekIsTUFBTSxzQkFBUyxDQUNiLGVBQUssQ0FBQyxhQUFhLENBQUMsaUJBQU8sRUFBRTtZQUMzQixTQUFTLEVBQUUsTUFBTTtZQUNqQixXQUFXLEVBQUUsS0FBSztZQUNsQixZQUFZLEVBQUUsT0FBTztZQUNyQixXQUFXO1NBQ1osQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB5YXJncyBmcm9tIFwieWFyZ3NcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IERlc3Ryb3kgfSBmcm9tIFwiLi91aS9kZXN0cm95XCI7XG5pbXBvcnQgeyBjb25maWcgYXMgY2ZnIH0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1nZW5lcmF0b3JcIjtcbmltcG9ydCB7IHJlbmRlckluayB9IGZyb20gXCIuL2hlbHBlci9yZW5kZXItaW5rXCI7XG5pbXBvcnQgeyBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UgfSBmcm9tIFwiLi9oZWxwZXIvdmVyc2lvbi1jaGVja1wiO1xuaW1wb3J0IHsgdGhyb3dJZk5vdFByb2plY3REaXJlY3RvcnkgfSBmcm9tIFwiLi9oZWxwZXIvY2hlY2stZGlyZWN0b3J5XCI7XG5pbXBvcnQgeyBjaGVja0Vudmlyb25tZW50IH0gZnJvbSBcIi4vaGVscGVyL2NoZWNrLWVudmlyb25tZW50XCI7XG5cbmNvbnN0IGNvbmZpZyA9IGNmZy5yZWFkQ29uZmlnU3luYygpO1xuXG5jbGFzcyBDb21tYW5kIGltcGxlbWVudHMgeWFyZ3MuQ29tbWFuZE1vZHVsZSB7XG4gIHB1YmxpYyByZWFkb25seSBjb21tYW5kID0gXCJkZXN0cm95IFtzdGFja10gW09QVElPTlNdXCI7XG4gIHB1YmxpYyByZWFkb25seSBkZXNjcmliZSA9IFwiRGVzdHJveSB0aGUgZ2l2ZW4gc3RhY2tcIjtcblxuICBwdWJsaWMgcmVhZG9ubHkgYnVpbGRlciA9IChhcmdzOiB5YXJncy5Bcmd2KSA9PlxuICAgIGFyZ3NcbiAgICAgIC5wb3NpdGlvbmFsKFwic3RhY2tcIiwge1xuICAgICAgICBkZXNjOiBcIkRlc3Ryb3kgc3RhY2sgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gaWQgb25seS4gUmVxdWlyZWQgd2hlbiBtb3JlIHRoYW4gb25lIHN0YWNrIGlzIHByZXNlbnQgaW4gdGhlIGFwcFwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgfSlcbiAgICAgIC5vcHRpb24oXCJhcHBcIiwge1xuICAgICAgICBkZWZhdWx0OiBjb25maWcuYXBwLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgZGVzYzogXCJDb21tYW5kIHRvIHVzZSBpbiBvcmRlciB0byBleGVjdXRlIGNka3RmIGFwcFwiLFxuICAgICAgICBhbGlhczogXCJhXCIsXG4gICAgICB9KVxuICAgICAgLm9wdGlvbihcIm91dHB1dFwiLCB7XG4gICAgICAgIGRlZmF1bHQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICBkZXNjOiBcIk91dHB1dCBkaXJlY3RvcnlcIixcbiAgICAgICAgYWxpYXM6IFwib1wiLFxuICAgICAgfSlcbiAgICAgIC5vcHRpb24oXCJhdXRvLWFwcHJvdmVcIiwge1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgZGVzYzogXCJBdXRvIGFwcHJvdmVcIixcbiAgICAgIH0pXG4gICAgICAuc2hvd0hlbHBPbkZhaWwodHJ1ZSk7XG5cbiAgcHVibGljIGFzeW5jIGhhbmRsZXIoYXJndjogYW55KSB7XG4gICAgdGhyb3dJZk5vdFByb2plY3REaXJlY3RvcnkoXCJkZXN0cm95XCIpO1xuICAgIGF3YWl0IGRpc3BsYXlWZXJzaW9uTWVzc2FnZSgpO1xuICAgIGF3YWl0IGNoZWNrRW52aXJvbm1lbnQoXCJkZXN0cm95XCIpO1xuICAgIGNvbnN0IGNvbW1hbmQgPSBhcmd2LmFwcDtcbiAgICBjb25zdCBvdXRkaXIgPSBhcmd2Lm91dHB1dDtcbiAgICBjb25zdCBhdXRvQXBwcm92ZSA9IGFyZ3YuYXV0b0FwcHJvdmU7XG4gICAgY29uc3Qgc3RhY2sgPSBhcmd2LnN0YWNrO1xuXG4gICAgYXdhaXQgcmVuZGVySW5rKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEZXN0cm95LCB7XG4gICAgICAgIHRhcmdldERpcjogb3V0ZGlyLFxuICAgICAgICB0YXJnZXRTdGFjazogc3RhY2ssXG4gICAgICAgIHN5bnRoQ29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgYXV0b0FwcHJvdmUsXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ29tbWFuZCgpO1xuIl19