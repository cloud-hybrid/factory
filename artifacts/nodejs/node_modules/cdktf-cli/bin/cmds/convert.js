"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = __importDefault(require("yargs"));
const hcl2cdk_1 = require("@cdktf/hcl2cdk");
const version_check_1 = require("./helper/version-check");
const checkpoint_1 = require("../../lib/checkpoint");
const errors_1 = require("../../lib/errors");
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const provider_generator_1 = require("@cdktf/provider-generator");
function readStreamAsString(stream) {
    return new Promise((ok, ko) => {
        if (stream.isTTY) {
            ko("No stdin was passed, please use it like this: cat main.tf | cdktf convert > imported.ts");
        }
        else {
            let string = "";
            stream.on("data", (data) => (string += data.toString()));
            stream.on("close", () => ok(string));
            stream.on("error", (err) => ko(err));
        }
    });
}
function findFileAboveCwd(file, rootPath = process.cwd()) {
    const fullPath = path.resolve(rootPath, file);
    if (fs.existsSync(fullPath)) {
        return fullPath;
    }
    const parentDir = path.resolve(rootPath, "..");
    if (fs.existsSync(parentDir) && parentDir !== rootPath) {
        return findFileAboveCwd(file, parentDir);
    }
    return null;
}
class Command {
    constructor() {
        this.command = "convert [OPTIONS]";
        this.describe = "Converts a single file of HCL configuration to CDK for Terraform. Takes the file to be converted on stdin.";
        this.builder = (args) => args
            .example("cat main.tf | cdktf convert  --provider integrations/github", "Takes the HCL content of main.tf and converts it to CDK for Terraform content and prints it")
            .example("cat main.tf | cdktf convert --provider hashicorp/aws > imported.ts", "Takes the HCL content of main.tf and converts it to CDK for Terraform content in imported.ts")
            .example("cat main.tf | cdktf convert --provider 'hashicorp/aws@ ~>3.62.0' 'integrations/github@ ~>4.16.0' --language python > imported.py", "Takes the HCL content of main.tf and converts it to CDK for Terraform content in imported.ts")
            .option("language", {
            choices: ["typescript", "python", "csharp", "java"],
            default: "typescript",
        })
            .option("provider", {
            describe: "The conversion needs to know which providers are used in addition to the ones in your cdktf.json file. We search for a cdktf.json below your current working directory.",
            type: "array",
            default: [],
        })
            .showHelpOnFail(true);
    }
    async handler({ language }) {
        await version_check_1.displayVersionMessage();
        const providerRequirements = yargs_1.default.argv.provider;
        const cdktfJsonPath = findFileAboveCwd("cdktf.json");
        if (cdktfJsonPath) {
            const cdktfJson = await fs.readJson(cdktfJsonPath);
            providerRequirements.push(...cdktfJson.terraformProviders);
        }
        // Get all the provider schemas
        const { providerSchema } = await provider_generator_1.readSchema(providerRequirements.map((spec) => provider_generator_1.ConstructsMakerProviderTarget.from(new provider_generator_1.config.TerraformProviderConstraint(spec), provider_generator_1.LANGUAGES[0])));
        const input = await readStreamAsString(process.stdin);
        let output;
        try {
            const { all, stats } = await hcl2cdk_1.convert(input, {
                language,
                providerSchema,
            });
            output = all;
            await checkpoint_1.sendTelemetry("convert", { ...stats, error: false });
        }
        catch (err) {
            throw errors_1.Errors.Internal("convert", err.message, { language });
        }
        console.log(output);
    }
}
module.exports = new Command();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnZlcnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0RBQTBCO0FBQzFCLDRDQUF5QztBQUN6QywwREFBK0Q7QUFDL0QscURBQXFEO0FBQ3JELDZDQUEwQztBQUMxQyw2Q0FBK0I7QUFDL0IsMkNBQTZCO0FBQzdCLGtFQUttQztBQUVuQyxTQUFTLGtCQUFrQixDQUFDLE1BQTRCO0lBQ3RELE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7UUFDNUIsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2hCLEVBQUUsQ0FDQSx5RkFBeUYsQ0FDMUYsQ0FBQztTQUNIO2FBQU07WUFDTCxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7WUFDaEIsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFekQsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDckMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3RDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsU0FBUyxnQkFBZ0IsQ0FDdkIsSUFBWSxFQUNaLFFBQVEsR0FBRyxPQUFPLENBQUMsR0FBRyxFQUFFO0lBRXhCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlDLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENB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QU8sRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHlhcmdzIGZyb20gXCJ5YXJnc1wiO1xuaW1wb3J0IHsgY29udmVydCB9IGZyb20gXCJAY2RrdGYvaGNsMmNka1wiO1xuaW1wb3J0IHsgZGlzcGxheVZlcnNpb25NZXNzYWdlIH0gZnJvbSBcIi4vaGVscGVyL3ZlcnNpb24tY2hlY2tcIjtcbmltcG9ydCB7IHNlbmRUZWxlbWV0cnkgfSBmcm9tIFwiLi4vLi4vbGliL2NoZWNrcG9pbnRcIjtcbmltcG9ydCB7IEVycm9ycyB9IGZyb20gXCIuLi8uLi9saWIvZXJyb3JzXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7XG4gIHJlYWRTY2hlbWEsXG4gIENvbnN0cnVjdHNNYWtlclByb3ZpZGVyVGFyZ2V0LFxuICBMQU5HVUFHRVMsXG4gIGNvbmZpZyxcbn0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1nZW5lcmF0b3JcIjtcblxuZnVuY3Rpb24gcmVhZFN0cmVhbUFzU3RyaW5nKHN0cmVhbTogdHlwZW9mIHByb2Nlc3Muc3RkaW4pOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKG9rLCBrbykgPT4ge1xuICAgIGlmIChzdHJlYW0uaXNUVFkpIHtcbiAgICAgIGtvKFxuICAgICAgICBcIk5vIHN0ZGluIHdhcyBwYXNzZWQsIHBsZWFzZSB1c2UgaXQgbGlrZSB0aGlzOiBjYXQgbWFpbi50ZiB8IGNka3RmIGNvbnZlcnQgPiBpbXBvcnRlZC50c1wiXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3RyaW5nID0gXCJcIjtcbiAgICAgIHN0cmVhbS5vbihcImRhdGFcIiwgKGRhdGEpID0+IChzdHJpbmcgKz0gZGF0YS50b1N0cmluZygpKSk7XG5cbiAgICAgIHN0cmVhbS5vbihcImNsb3NlXCIsICgpID0+IG9rKHN0cmluZykpO1xuICAgICAgc3RyZWFtLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ga28oZXJyKSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZmluZEZpbGVBYm92ZUN3ZChcbiAgZmlsZTogc3RyaW5nLFxuICByb290UGF0aCA9IHByb2Nlc3MuY3dkKClcbik6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShyb290UGF0aCwgZmlsZSk7XG4gIGlmIChmcy5leGlzdHNTeW5jKGZ1bGxQYXRoKSkge1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudERpciA9IHBhdGgucmVzb2x2ZShyb290UGF0aCwgXCIuLlwiKTtcbiAgaWYgKGZzLmV4aXN0c1N5bmMocGFyZW50RGlyKSAmJiBwYXJlbnREaXIgIT09IHJvb3RQYXRoKSB7XG4gICAgcmV0dXJuIGZpbmRGaWxlQWJvdmVDd2QoZmlsZSwgcGFyZW50RGlyKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5jbGFzcyBDb21tYW5kIGltcGxlbWVudHMgeWFyZ3MuQ29tbWFuZE1vZHVsZSB7XG4gIHB1YmxpYyByZWFkb25seSBjb21tYW5kID0gXCJjb252ZXJ0IFtPUFRJT05TXVwiO1xuICBwdWJsaWMgcmVhZG9ubHkgZGVzY3JpYmUgPVxuICAgIFwiQ29udmVydHMgYSBzaW5nbGUgZmlsZSBvZiBIQ0wgY29uZmlndXJhdGlvbiB0byBDREsgZm9yIFRlcnJhZm9ybS4gVGFrZXMgdGhlIGZpbGUgdG8gYmUgY29udmVydGVkIG9uIHN0ZGluLlwiO1xuXG4gIHB1YmxpYyByZWFkb25seSBidWlsZGVyID0gKGFyZ3M6IHlhcmdzLkFyZ3YpID0+XG4gICAgYXJnc1xuICAgICAgLmV4YW1wbGUoXG4gICAgICAgIFwiY2F0IG1haW4udGYgfCBjZGt0ZiBjb252ZXJ0ICAtLXByb3ZpZGVyIGludGVncmF0aW9ucy9naXRodWJcIixcbiAgICAgICAgXCJUYWtlcyB0aGUgSENMIGNvbnRlbnQgb2YgbWFpbi50ZiBhbmQgY29udmVydHMgaXQgdG8gQ0RLIGZvciBUZXJyYWZvcm0gY29udGVudCBhbmQgcHJpbnRzIGl0XCJcbiAgICAgIClcbiAgICAgIC5leGFtcGxlKFxuICAgICAgICBcImNhdCBtYWluLnRmIHwgY2RrdGYgY29udmVydCAtLXByb3ZpZGVyIGhhc2hpY29ycC9hd3MgPiBpbXBvcnRlZC50c1wiLFxuICAgICAgICBcIlRha2VzIHRoZSBIQ0wgY29udGVudCBvZiBtYWluLnRmIGFuZCBjb252ZXJ0cyBpdCB0byBDREsgZm9yIFRlcnJhZm9ybSBjb250ZW50IGluIGltcG9ydGVkLnRzXCJcbiAgICAgIClcbiAgICAgIC5leGFtcGxlKFxuICAgICAgICBcImNhdCBtYWluLnRmIHwgY2RrdGYgY29udmVydCAtLXByb3ZpZGVyICdoYXNoaWNvcnAvYXdzQCB+PjMuNjIuMCcgJ2ludGVncmF0aW9ucy9naXRodWJAIH4+NC4xNi4wJyAtLWxhbmd1YWdlIHB5dGhvbiA+IGltcG9ydGVkLnB5XCIsXG4gICAgICAgIFwiVGFrZXMgdGhlIEhDTCBjb250ZW50IG9mIG1haW4udGYgYW5kIGNvbnZlcnRzIGl0IHRvIENESyBmb3IgVGVycmFmb3JtIGNvbnRlbnQgaW4gaW1wb3J0ZWQudHNcIlxuICAgICAgKVxuICAgICAgLm9wdGlvbihcImxhbmd1YWdlXCIsIHtcbiAgICAgICAgY2hvaWNlczogW1widHlwZXNjcmlwdFwiLCBcInB5dGhvblwiLCBcImNzaGFycFwiLCBcImphdmFcIl0sXG4gICAgICAgIGRlZmF1bHQ6IFwidHlwZXNjcmlwdFwiLFxuICAgICAgfSlcbiAgICAgIC5vcHRpb24oXCJwcm92aWRlclwiLCB7XG4gICAgICAgIGRlc2NyaWJlOlxuICAgICAgICAgIFwiVGhlIGNvbnZlcnNpb24gbmVlZHMgdG8ga25vdyB3aGljaCBwcm92aWRlcnMgYXJlIHVzZWQgaW4gYWRkaXRpb24gdG8gdGhlIG9uZXMgaW4geW91ciBjZGt0Zi5qc29uIGZpbGUuIFdlIHNlYXJjaCBmb3IgYSBjZGt0Zi5qc29uIGJlbG93IHlvdXIgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS5cIixcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBkZWZhdWx0OiBbXSxcbiAgICAgIH0pXG4gICAgICAuc2hvd0hlbHBPbkZhaWwodHJ1ZSk7XG5cbiAgcHVibGljIGFzeW5jIGhhbmRsZXIoeyBsYW5ndWFnZSB9OiBhbnkpIHtcbiAgICBhd2FpdCBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcblxuICAgIGNvbnN0IHByb3ZpZGVyUmVxdWlyZW1lbnRzOiBzdHJpbmdbXSA9IHlhcmdzLmFyZ3YucHJvdmlkZXIgYXMgc3RyaW5nW107XG4gICAgY29uc3QgY2RrdGZKc29uUGF0aCA9IGZpbmRGaWxlQWJvdmVDd2QoXCJjZGt0Zi5qc29uXCIpO1xuICAgIGlmIChjZGt0Zkpzb25QYXRoKSB7XG4gICAgICBjb25zdCBjZGt0Zkpzb24gPSBhd2FpdCBmcy5yZWFkSnNvbihjZGt0Zkpzb25QYXRoKTtcbiAgICAgIHByb3ZpZGVyUmVxdWlyZW1lbnRzLnB1c2goLi4uY2RrdGZKc29uLnRlcnJhZm9ybVByb3ZpZGVycyk7XG4gICAgfVxuICAgIC8vIEdldCBhbGwgdGhlIHByb3ZpZGVyIHNjaGVtYXNcbiAgICBjb25zdCB7IHByb3ZpZGVyU2NoZW1hIH0gPSBhd2FpdCByZWFkU2NoZW1hKFxuICAgICAgcHJvdmlkZXJSZXF1aXJlbWVudHMubWFwKChzcGVjKSA9PlxuICAgICAgICBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldC5mcm9tKFxuICAgICAgICAgIG5ldyBjb25maWcuVGVycmFmb3JtUHJvdmlkZXJDb25zdHJhaW50KHNwZWMpLFxuICAgICAgICAgIExBTkdVQUdFU1swXVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcblxuICAgIGNvbnN0IGlucHV0ID0gYXdhaXQgcmVhZFN0cmVhbUFzU3RyaW5nKHByb2Nlc3Muc3RkaW4pO1xuICAgIGxldCBvdXRwdXQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgYWxsLCBzdGF0cyB9ID0gYXdhaXQgY29udmVydChpbnB1dCwge1xuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgcHJvdmlkZXJTY2hlbWEsXG4gICAgICB9KTtcbiAgICAgIG91dHB1dCA9IGFsbDtcbiAgICAgIGF3YWl0IHNlbmRUZWxlbWV0cnkoXCJjb252ZXJ0XCIsIHsgLi4uc3RhdHMsIGVycm9yOiBmYWxzZSB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IEVycm9ycy5JbnRlcm5hbChcImNvbnZlcnRcIiwgZXJyLm1lc3NhZ2UsIHsgbGFuZ3VhZ2UgfSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2cob3V0cHV0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDb21tYW5kKCk7XG4iXX0=