"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const watch_1 = require("./ui/watch");
const provider_generator_1 = require("@cdktf/provider-generator");
const render_ink_1 = require("./helper/render-ink");
const chalk = __importStar(require("chalk"));
const version_check_1 = require("./helper/version-check");
const react_2 = require("../../lib/client/react");
const check_directory_1 = require("./helper/check-directory");
const chalkColour = new chalk.Instance();
const config = provider_generator_1.config.readConfigSync();
class Command {
    constructor() {
        this.command = "watch [stack] [OPTIONS]";
        this.describe = "[experimental] Watch for file changes and automatically trigger a deploy";
        this.builder = (args) => args
            .positional("stack", {
            desc: "Deploy stack which matches the given id only. Required when more than one stack is present in the app",
            type: "string",
        })
            .option("app", {
            default: config.app,
            required: true,
            desc: "Command to use in order to execute cdktf app",
            alias: "a",
        })
            .option("output", {
            default: config.output,
            required: true,
            desc: "Output directory",
            alias: "o",
        })
            .option("auto-approve", {
            type: "boolean",
            default: false,
            required: false,
            desc: "Auto approve",
        })
            .showHelpOnFail(true);
    }
    async handler(argv) {
        check_directory_1.throwIfNotProjectDirectory("watch");
        await version_check_1.displayVersionMessage();
        const command = argv.app;
        const outdir = argv.output;
        const autoApprove = argv.autoApprove;
        const stack = argv.stack;
        if (!autoApprove) {
            console.error(chalkColour `{redBright ERROR: The watch command always automatically deploys and approves changes. To make this behaviour explicit the --auto-approve flag must be set}`);
            process.exit(1);
        }
        await render_ink_1.renderInk(react_1.default.createElement(react_2.GraphQLServerProvider, undefined, react_1.default.createElement(watch_1.Watch, {
            targetDir: outdir,
            targetStack: stack,
            synthCommand: command,
            autoApprove,
        })));
    }
}
module.exports = new Command();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2F0Y2guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ3YXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxrREFBMEI7QUFDMUIsc0NBQW1DO0FBQ25DLGtFQUEwRDtBQUMxRCxvREFBZ0Q7QUFDaEQsNkNBQStCO0FBQy9CLDBEQUErRDtBQUMvRCxrREFBK0Q7QUFDL0QsOERBQXNFO0FBRXRFLE1BQU0sV0FBVyxHQUFHLElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBRXpDLE1BQU0sTUFBTSxHQUFHLDJCQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7QUFFcEMsTUFBTSxPQUFPO0lBQWI7UUFDa0IsWUFBTyxHQUFHLHlCQUF5QixDQUFDO1FBQ3BDLGFBQVEsR0FDdEIsMEVBQTBFLENBQUM7UUFFN0QsWUFBTyxHQUFHLENBQUMsSUFBZ0IsRUFBRSxFQUFFLENBQzdDLElBQUk7YUFDRCxVQUFVLENBQUMsT0FBTyxFQUFFO1lBQ25CLElBQUksRUFBRSx1R0FBdUc7WUFDN0csSUFBSSxFQUFFLFFBQVE7U0FDZixDQUFDO2FBQ0QsTUFBTSxDQUFDLEtBQUssRUFBRTtZQUNiLE9BQU8sRUFBRSxNQUFNLENBQUMsR0FBRztZQUNuQixRQUFRLEVBQUUsSUFBSTtZQUNkLElBQUksRUFBRSw4Q0FBOEM7WUFDcEQsS0FBSyxFQUFFLEdBQUc7U0FDWCxDQUFDO2FBQ0QsTUFBTSxDQUFDLFFBQVEsRUFBRTtZQUNoQixPQUFPLEVBQUUsTUFBTSxDQUFDLE1BQU07WUFDdEIsUUFBUSxFQUFFLElBQUk7WUFDZCxJQUFJLEVBQUUsa0JBQWtCO1lBQ3hCLEtBQUssRUFBRSxHQUFHO1NBQ1gsQ0FBQzthQUNELE1BQU0sQ0FBQyxjQUFjLEVBQUU7WUFDdEIsSUFBSSxFQUFFLFNBQVM7WUFDZixPQUFPLEVBQUUsS0FBSztZQUNkLFFBQVEsRUFBRSxLQUFLO1lBQ2YsSUFBSSxFQUFFLGNBQWM7U0FDckIsQ0FBQzthQUNELGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQThCNUIsQ0FBQztJQTVCUSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQVM7UUFDNUIsNENBQTBCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEMsTUFBTSxxQ0FBcUIsRUFBRSxDQUFDO1FBQzlCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDekIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMzQixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ3JDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFFekIsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixPQUFPLENBQUMsS0FBSyxDQUNYLFdBQVcsQ0FBQSw2SkFBNkosQ0FDekssQ0FBQztZQUNGLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakI7UUFFRCxNQUFNLHNCQUFTLENBQ2IsZUFBSyxDQUFDLGFBQWEsQ0FDakIsNkJBQXFCLEVBQ3JCLFNBQVMsRUFDVCxlQUFLLENBQUMsYUFBYSxDQUFDLGFBQUssRUFBRTtZQUN6QixTQUFTLEVBQUUsTUFBTTtZQUNqQixXQUFXLEVBQUUsS0FBSztZQUNsQixZQUFZLEVBQUUsT0FBTztZQUNyQixXQUFXO1NBQ1osQ0FBQyxDQUNILENBQ0YsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHlhcmdzIGZyb20gXCJ5YXJnc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgV2F0Y2ggfSBmcm9tIFwiLi91aS93YXRjaFwiO1xuaW1wb3J0IHsgY29uZmlnIGFzIGNmZyB9IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyByZW5kZXJJbmsgfSBmcm9tIFwiLi9oZWxwZXIvcmVuZGVyLWlua1wiO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgeyBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UgfSBmcm9tIFwiLi9oZWxwZXIvdmVyc2lvbi1jaGVja1wiO1xuaW1wb3J0IHsgR3JhcGhRTFNlcnZlclByb3ZpZGVyIH0gZnJvbSBcIi4uLy4uL2xpYi9jbGllbnQvcmVhY3RcIjtcbmltcG9ydCB7IHRocm93SWZOb3RQcm9qZWN0RGlyZWN0b3J5IH0gZnJvbSBcIi4vaGVscGVyL2NoZWNrLWRpcmVjdG9yeVwiO1xuXG5jb25zdCBjaGFsa0NvbG91ciA9IG5ldyBjaGFsay5JbnN0YW5jZSgpO1xuXG5jb25zdCBjb25maWcgPSBjZmcucmVhZENvbmZpZ1N5bmMoKTtcblxuY2xhc3MgQ29tbWFuZCBpbXBsZW1lbnRzIHlhcmdzLkNvbW1hbmRNb2R1bGUge1xuICBwdWJsaWMgcmVhZG9ubHkgY29tbWFuZCA9IFwid2F0Y2ggW3N0YWNrXSBbT1BUSU9OU11cIjtcbiAgcHVibGljIHJlYWRvbmx5IGRlc2NyaWJlID1cbiAgICBcIltleHBlcmltZW50YWxdIFdhdGNoIGZvciBmaWxlIGNoYW5nZXMgYW5kIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciBhIGRlcGxveVwiO1xuXG4gIHB1YmxpYyByZWFkb25seSBidWlsZGVyID0gKGFyZ3M6IHlhcmdzLkFyZ3YpID0+XG4gICAgYXJnc1xuICAgICAgLnBvc2l0aW9uYWwoXCJzdGFja1wiLCB7XG4gICAgICAgIGRlc2M6IFwiRGVwbG95IHN0YWNrIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIGlkIG9ubHkuIFJlcXVpcmVkIHdoZW4gbW9yZSB0aGFuIG9uZSBzdGFjayBpcyBwcmVzZW50IGluIHRoZSBhcHBcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIH0pXG4gICAgICAub3B0aW9uKFwiYXBwXCIsIHtcbiAgICAgICAgZGVmYXVsdDogY29uZmlnLmFwcCxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIGRlc2M6IFwiQ29tbWFuZCB0byB1c2UgaW4gb3JkZXIgdG8gZXhlY3V0ZSBjZGt0ZiBhcHBcIixcbiAgICAgICAgYWxpYXM6IFwiYVwiLFxuICAgICAgfSlcbiAgICAgIC5vcHRpb24oXCJvdXRwdXRcIiwge1xuICAgICAgICBkZWZhdWx0OiBjb25maWcub3V0cHV0LFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgZGVzYzogXCJPdXRwdXQgZGlyZWN0b3J5XCIsXG4gICAgICAgIGFsaWFzOiBcIm9cIixcbiAgICAgIH0pXG4gICAgICAub3B0aW9uKFwiYXV0by1hcHByb3ZlXCIsIHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIGRlc2M6IFwiQXV0byBhcHByb3ZlXCIsXG4gICAgICB9KVxuICAgICAgLnNob3dIZWxwT25GYWlsKHRydWUpO1xuXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVyKGFyZ3Y6IGFueSkge1xuICAgIHRocm93SWZOb3RQcm9qZWN0RGlyZWN0b3J5KFwid2F0Y2hcIik7XG4gICAgYXdhaXQgZGlzcGxheVZlcnNpb25NZXNzYWdlKCk7XG4gICAgY29uc3QgY29tbWFuZCA9IGFyZ3YuYXBwO1xuICAgIGNvbnN0IG91dGRpciA9IGFyZ3Yub3V0cHV0O1xuICAgIGNvbnN0IGF1dG9BcHByb3ZlID0gYXJndi5hdXRvQXBwcm92ZTtcbiAgICBjb25zdCBzdGFjayA9IGFyZ3Yuc3RhY2s7XG5cbiAgICBpZiAoIWF1dG9BcHByb3ZlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBjaGFsa0NvbG91cmB7cmVkQnJpZ2h0IEVSUk9SOiBUaGUgd2F0Y2ggY29tbWFuZCBhbHdheXMgYXV0b21hdGljYWxseSBkZXBsb3lzIGFuZCBhcHByb3ZlcyBjaGFuZ2VzLiBUbyBtYWtlIHRoaXMgYmVoYXZpb3VyIGV4cGxpY2l0IHRoZSAtLWF1dG8tYXBwcm92ZSBmbGFnIG11c3QgYmUgc2V0fWBcbiAgICAgICk7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxuXG4gICAgYXdhaXQgcmVuZGVySW5rKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JhcGhRTFNlcnZlclByb3ZpZGVyLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2F0Y2gsIHtcbiAgICAgICAgICB0YXJnZXREaXI6IG91dGRpcixcbiAgICAgICAgICB0YXJnZXRTdGFjazogc3RhY2ssXG4gICAgICAgICAgc3ludGhDb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgIGF1dG9BcHByb3ZlLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ29tbWFuZCgpO1xuIl19