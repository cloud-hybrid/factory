"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runInit = exports.checkForEmptyDirectory = exports.templates = void 0;
const fs = __importStar(require("fs-extra"));
const chalk = __importStar(require("chalk"));
const inquirer = __importStar(require("inquirer"));
const extract_zip_1 = __importDefault(require("extract-zip"));
const terraform_login_1 = require("../helper/terraform-login");
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const sscaff_1 = require("sscaff");
const terraformCloudClient = __importStar(require("../helper/terraform-cloud-client"));
const features_1 = require("cdktf/lib/features");
const util_1 = require("../../../lib/util");
const logging_1 = require("../../../lib/logging");
const errors_1 = require("../../../lib/errors");
const hcl2cdk_1 = require("@cdktf/hcl2cdk");
const provider_generator_1 = require("@cdktf/provider-generator");
const child_process_1 = require("child_process");
const checkpoint_1 = require("../../../lib/checkpoint");
const uuid_1 = require("uuid");
const provider_generator_2 = require("@cdktf/provider-generator");
const utilities_1 = require("./utilities");
const chalkColour = new chalk.Instance();
const templatesDir = path.join(utilities_1.projectRootPath(), "templates");
const availableTemplates = fs
    .readdirSync(templatesDir)
    .filter((x) => !x.startsWith("."));
exports.templates = [];
for (const template of availableTemplates) {
    exports.templates.push(template);
}
const pkg = utilities_1.readPackageJson();
const constructsVersion = pkg.dependencies.constructs;
function checkForEmptyDirectory(dir) {
    if (fs.readdirSync(dir).filter((f) => !f.startsWith(".") && f !== logging_1.logFileName)
        .length > 0) {
        console.error(chalkColour `{redBright ERROR: Cannot initialize a project in a non-empty directory}`);
        process.exit(1);
    }
}
exports.checkForEmptyDirectory = checkForEmptyDirectory;
async function runInit(argv) {
    const telemetryData = {};
    const destination = argv.destination || ".";
    let token = "";
    if (!argv.local) {
        // We ask the user to login to Terraform Cloud and set a token
        // If the user chooses not to use Terraform Cloud, we continue
        // without a token and set up the project.
        const terraformLogin = new terraform_login_1.TerraformLogin();
        token = await terraformLogin.askToLogin();
    }
    else {
        console.log(chalkColour `{yellow Note: By supplying '--local' option you have chosen local storage mode for storing the state of your stack.
This means that your Terraform state file will be stored locally on disk in a file 'terraform.<STACK NAME>.tfstate' in the root of your project.}`);
    }
    // Check if template was specified by the user
    let template = "";
    if (argv.template) {
        template = argv.template;
    }
    // Gather information about the template and the project
    const templateInfo = await getTemplate(template);
    telemetryData.template = templateInfo.Name;
    const projectInfo = await gatherInfo(token, templateInfo.Name, argv.projectName, argv.projectDescription);
    const projectId = uuid_1.v4();
    telemetryData.projectId = projectId;
    // Check if token is set so we can set up Terraform Cloud workspace
    // only set with the '--local' option is specified the user.
    if (token != "") {
        telemetryData.isRemote = Boolean(token);
        console.log(chalkColour `\n{whiteBright Setting up remote state backend and workspace in Terraform Cloud.}`);
        try {
            await terraformCloudClient.createWorkspace(projectInfo.OrganizationName, projectInfo.WorkspaceName, token);
        }
        catch (error) {
            console.error(chalkColour `{redBright ERROR: Could not create Terraform Cloud Workspace: ${error.message}}`);
            process.exit(1);
        }
    }
    const deps = await determineDeps(argv.cdktfVersion, argv.dist);
    const futureFlags = Object.entries(features_1.FUTURE_FLAGS)
        .map(([key, value]) => `"${key}": "${value}"`)
        .join(`,\n`);
    await sscaff_1.sscaff(templateInfo.Path, destination, {
        ...deps,
        ...projectInfo,
        futureFlags,
        projectId,
    });
    if (argv.fromTerraformProject) {
        if (argv.template === "typescript") {
            const mainTs = fs.readFileSync(path.resolve(destination, "main.ts"), "utf8");
            const importPath = path.resolve(process.cwd(), argv.fromTerraformProject);
            const combinedTfFile = hcl2cdk_1.getTerraformConfigFromDir(importPath);
            // Fetch all provider requirements from the project
            const providerRequirements = await hcl2cdk_1.parseProviderRequirements(combinedTfFile);
            // Get all the provider schemas
            const { providerSchema } = await provider_generator_2.readSchema(Object.entries(providerRequirements).map(([name, version]) => provider_generator_2.ConstructsMakerProviderTarget.from(new provider_generator_2.config.TerraformProviderConstraint(`${name}@ ${version}`), provider_generator_2.LANGUAGES[0])));
            try {
                const { code, cdktfJson, stats } = await hcl2cdk_1.convertProject(combinedTfFile, mainTs, require(path.resolve(destination, "cdktf.json")), {
                    language: "typescript",
                    providerSchema,
                });
                fs.writeFileSync(path.resolve(destination, "main.ts"), code, "utf8");
                fs.writeFileSync(path.resolve(destination, "cdktf.json"), JSON.stringify(cdktfJson, null, 2), "utf8");
                const { terraformModules, terraformProviders } = cdktfJson;
                if (terraformModules.length > 0) {
                    copyLocalModules(terraformModules, importPath, destination);
                }
                if (terraformModules.length + terraformProviders.length > 0) {
                    child_process_1.execSync("npm run get", { cwd: destination });
                }
                telemetryData.conversionStats = stats;
            }
            catch (err) {
                throw errors_1.Errors.Internal("init", err, { fromTerraformProject: true });
            }
        }
        else {
            console.error(`The --from-terraform-project flag is only supported with the typescript template. The command will continue and ignore the flag.`);
        }
    }
    if (templateInfo.cleanupTemporaryFiles) {
        await templateInfo.cleanupTemporaryFiles();
    }
    await checkpoint_1.sendTelemetry("init", telemetryData);
}
exports.runInit = runInit;
function copyLocalModules(modules, sourcePath, destination) {
    modules
        .filter((m) => provider_generator_1.isLocalModule(m))
        .map((m) => fs.copySync(path.resolve(sourcePath, m), path.resolve(destination, m), {
        recursive: true,
    }));
}
async function determineDeps(version = pkg.version, dist) {
    const pythonVersion = version.replace(/-pre\./g, ".dev");
    if (dist) {
        const ret = {
            npm_cdktf: path.resolve(dist, "js", `cdktf@${version}.jsii.tgz`),
            npm_cdktf_cli: path.resolve(dist, "js", `cdktf-cli-${version}.tgz`),
            pypi_cdktf: path.resolve(dist, "python", `cdktf-${pythonVersion}.tar.gz`),
            mvn_cdktf: path.resolve(dist, "java", `com/hashicorp/cdktf/${version}/cdktf-${version}.jar`),
            nuget_cdktf: path.resolve(dist, "dotnet", `HashiCorp.Cdktf.${version}.nupkg`),
            go_cdktf: path.resolve(dist, "go", `cdktf`),
        };
        for (const file of Object.values(ret)) {
            if (!(await fs.pathExists(file))) {
                throw errors_1.Errors.Internal("init", `unable to find ${file} under the "dist" directory (${dist})`, { version });
            }
        }
        const versions = {
            cdktf_version: version,
            constructs_version: constructsVersion,
        };
        return {
            ...ret,
            ...versions,
        };
    }
    if (version === "0.0.0") {
        throw errors_1.Errors.Usage("init", chalkColour `{redBright cannot use version 0.0.0, use --cdktf-version, --dist or CDKTF_DIST to install from a "dist" directory}`, {});
    }
    // determine if we want a specific pinned version or a version range we take
    // a pinned version if version includes a hyphen which means it is a
    // pre-release (e.g. "0.12.0-pre.e6834d3"). otherwise, we require a caret
    // version.
    const ver = version.includes("-") ? version : `^${version}`;
    return {
        cdktf_version: version,
        constructs_version: constructsVersion,
        npm_cdktf: `cdktf@${ver}`,
        npm_cdktf_cli: `cdktf-cli@${ver}`,
        pypi_cdktf: `cdktf~=${pythonVersion}`,
        mvn_cdktf: version,
        nuget_cdktf: version,
        go_cdktf: `v${version}`,
    };
}
async function gatherInfo(token, templateName, projectName, projectDescription) {
    const currentDirectory = path.basename(process.cwd());
    const projectDescriptionDefault = "A simple getting started project for cdktf.";
    const questions = [];
    if (!projectName) {
        questions.push({
            name: "projectName",
            default: currentDirectory,
        });
    }
    if (!projectDescription) {
        questions.push({
            name: "projectDescription",
            default: projectDescriptionDefault,
        });
    }
    const answers = questions.length > 0 ? await inquirer.prompt(questions) : {};
    const project = {
        Name: projectName || answers.projectName || "",
        Description: projectDescription || answers.projectDescription || "",
        OrganizationName: "",
        WorkspaceName: "",
    };
    if (token != "") {
        console.log(chalkColour `\nDetected {blueBright Terraform Cloud} token.`);
        console.log(chalkColour `\nWe will now set up {blueBright Terraform Cloud} for your project.\n`);
        const organizationNames = await terraformCloudClient.getOrganizationNames(token);
        const organizationData = organizationNames.data;
        const organizationOptions = [];
        for (const organization of organizationData) {
            organizationOptions.push(organization.id);
        }
        // todo: add validation for the organization name and workspace. add error handling
        const { organization: organizationSelect } = await inquirer.prompt([
            {
                type: "list",
                name: "organization",
                message: "Terraform Cloud Organization Name",
                choices: organizationOptions,
            },
        ]);
        console.log(chalkColour `\nWe are going to create a new {blueBright Terraform Cloud Workspace} for your project.\n`);
        const { workspace: workspaceName } = await inquirer.prompt([
            {
                name: "workspace",
                message: "Terraform Cloud Workspace Name",
                default: templateName,
            },
        ]);
        project.OrganizationName = organizationSelect;
        project.WorkspaceName = workspaceName;
    }
    return project;
}
/**
 *
 * @param templateName either the name of built-in templates or an url pointing to a zip archive
 */
async function getTemplate(templateName) {
    if (templateName == "") {
        const templateOptionRemote = "<remote zip file>";
        const options = [...exports.templates, templateOptionRemote];
        // Prompt for template
        const { template: selection } = await inquirer.prompt([
            {
                type: "list",
                name: "template",
                message: "What template do you want to use?",
                choices: options,
            },
        ]);
        if (selection === templateOptionRemote) {
            const { templateName: remoteTemplateName } = await inquirer.prompt([
                {
                    name: "templateName",
                    message: "Please enter an URL pointing to the template zip file you want to use:",
                    validate: (value) => {
                        if (value === "") {
                            return "Url can not be empty";
                        }
                        else {
                            return true;
                        }
                    },
                },
            ]);
            templateName = remoteTemplateName;
        }
        else {
            templateName = selection;
            console.log(chalkColour `\n{whiteBright Initializing a project using the {greenBright ${templateName}} template.}`);
        }
    }
    // treat as remote url
    if (!exports.templates.includes(templateName)) {
        return fetchRemoteTemplate(templateName);
    }
    else {
        return {
            Name: templateName,
            Path: path.join(templatesDir, templateName),
        };
    }
}
async function fetchRemoteTemplate(templateUrl) {
    console.log(chalkColour `Fetching remote template from: {whiteBright ${templateUrl}}`);
    try {
        const url = new URL(templateUrl);
        const remoteFileName = path.basename(url.pathname) || "template.zip";
        logging_1.logger.trace(`Detected remote file name to be "${remoteFileName}" out of template URL "${templateUrl}"`);
        const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "cdktf."));
        const tmpZipFile = path.join(tmpDir, remoteFileName);
        const zipExtractDir = path.join(tmpDir, "extracted");
        logging_1.logger.trace(`Downloading "${remoteFileName}" to temporary directory "${tmpDir}"`);
        console.log(chalkColour `Downloading "{whiteBright ${remoteFileName}}" to temporary directory`);
        await util_1.downloadFile(url.href, tmpZipFile);
        console.log("Extracting zip file");
        await extract_zip_1.default(tmpZipFile, { dir: zipExtractDir });
        // walk directory to find cdktf.json as the extracted directory contains a root directory with unknown name
        // this also allows nesting the template itself into a sub directory and having a root directory with an unrelated README
        console.log(chalkColour `Looking for directory containing {whiteBright cdktf.json}`);
        const templatePath = await findCdkTfJsonDirectory(zipExtractDir);
        if (!templatePath) {
            throw errors_1.Errors.Usage("init", chalkColour `Could not find a {whiteBright cdktf.json} in the extracted directory`, {});
        }
        return {
            Name: path.parse(remoteFileName).name,
            Path: templatePath,
            cleanupTemporaryFiles: async () => {
                console.log("Clearing up temporary directory of remote template");
                await fs.remove(tmpDir);
            },
        };
    }
    catch (e) {
        if (e.code === "ERR_INVALID_URL") {
            console.error(chalkColour `Could not download template: {redBright the supplied url is invalid}`);
            console.error(chalkColour `Please supply a valid url (including the protocol) or use one of the built-in templates.`);
            process.exit(1);
        }
        if (e instanceof util_1.HttpError) {
            console.error(chalkColour `Could not download template: {redBright ${e.message}}`);
            process.exit(1);
        }
        console.error(e);
        process.exit(1);
    }
}
async function findCdkTfJsonDirectory(rootDir) {
    const files = await fs.readdir(rootDir);
    if (files.includes("cdktf.json")) {
        return rootDir;
    }
    for (const file of files) {
        const fullPath = path.join(rootDir, file);
        if ((await fs.stat(fullPath)).isDirectory()) {
            const dir = findCdkTfJsonDirectory(fullPath);
            if (dir)
                return dir;
            // else continue with next sub directory
        }
    }
    return null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUErQjtBQUMvQiw2Q0FBK0I7QUFDL0IsbURBQXFDO0FBQ3JDLDhEQUFrQztBQUNsQywrREFBMkQ7QUFFM0QsdUNBQXlCO0FBQ3pCLDJDQUE2QjtBQUM3QixtQ0FBZ0M7QUFDaEMsdUZBQXlFO0FBQ3pFLGlEQUFrRDtBQUNsRCw0Q0FBNEQ7QUFDNUQsa0RBQTJEO0FBQzNELGdEQUE2QztBQUM3Qyw0Q0FJd0I7QUFDeEIsa0VBQTBEO0FBQzFELGlEQUF5QztBQUN6Qyx3REFBd0Q7QUFDeEQsK0JBQWtDO0FBQ2xDLGtFQUttQztBQUNuQywyQ0FBK0Q7QUFFL0QsTUFBTSxXQUFXLEdBQUcsSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7QUFFekMsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQywyQkFBZSxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDL0QsTUFBTSxrQkFBa0IsR0FBRyxFQUFFO0tBQzFCLFdBQVcsQ0FBQyxZQUFZLENBQUM7S0FDekIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN4QixRQUFBLFNBQVMsR0FBYSxFQUFFLENBQUM7QUFDdEMsS0FBSyxNQUFNLFFBQVEsSUFBSSxrQkFBa0IsRUFBRTtJQUN6QyxpQkFBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUMxQjtBQUVELE1BQU0sR0FBRyxHQUFHLDJCQUFlLEVBQUUsQ0FBQztBQUM5QixNQUFNLGlCQUFpQixHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDO0FBRXRELFNBQWdCLHNCQUFzQixDQUFDLEdBQVc7SUFDaEQsSUFDRSxFQUFFLENBQUMsV0FBVyxD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QUFDO0tBQ2pCO0FBQ0gsQ0FBQztBQUVELEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxPQUFlO0lBQ25ELE1BQU0sS0FBSyxHQUFHLE1BQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUV4QyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQUU7UUFDaEMsT0FBTyxPQUFPLENBQUM7S0FDaEI7SUFDRCxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtRQUN4QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMxQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFDM0MsTUFBTSxHQUFHLEdBQUcsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDN0MsSUFBSSxHQUFHO2dCQUFFLE9BQU8sR0FBRyxDQUFDO1lBQ3BCLHdDQUF3QztTQUN6QztLQUNGO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCAqIGFzIGlucXVpcmVyIGZyb20gXCJpbnF1aXJlclwiO1xuaW1wb3J0IGV4dHJhY3QgZnJvbSBcImV4dHJhY3QtemlwXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1Mb2dpbiB9IGZyb20gXCIuLi9oZWxwZXIvdGVycmFmb3JtLWxvZ2luXCI7XG5cbmltcG9ydCAqIGFzIG9zIGZyb20gXCJvc1wiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgc3NjYWZmIH0gZnJvbSBcInNzY2FmZlwiO1xuaW1wb3J0ICogYXMgdGVycmFmb3JtQ2xvdWRDbGllbnQgZnJvbSBcIi4uL2hlbHBlci90ZXJyYWZvcm0tY2xvdWQtY2xpZW50XCI7XG5pbXBvcnQgeyBGVVRVUkVfRkxBR1MgfSBmcm9tIFwiY2RrdGYvbGliL2ZlYXR1cmVzXCI7XG5pbXBvcnQgeyBkb3dubG9hZEZpbGUsIEh0dHBFcnJvciB9IGZyb20gXCIuLi8uLi8uLi9saWIvdXRpbFwiO1xuaW1wb3J0IHsgbG9nRmlsZU5hbWUsIGxvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi9saWIvbG9nZ2luZ1wiO1xuaW1wb3J0IHsgRXJyb3JzIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9lcnJvcnNcIjtcbmltcG9ydCB7XG4gIGNvbnZlcnRQcm9qZWN0LFxuICBnZXRUZXJyYWZvcm1Db25maWdGcm9tRGlyLFxuICBwYXJzZVByb3ZpZGVyUmVxdWlyZW1lbnRzLFxufSBmcm9tIFwiQGNka3RmL2hjbDJjZGtcIjtcbmltcG9ydCB7IGlzTG9jYWxNb2R1bGUgfSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLWdlbmVyYXRvclwiO1xuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgc2VuZFRlbGVtZXRyeSB9IGZyb20gXCIuLi8uLi8uLi9saWIvY2hlY2twb2ludFwiO1xuaW1wb3J0IHsgdjQgYXMgdXVpZCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQge1xuICByZWFkU2NoZW1hLFxuICBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldCxcbiAgTEFOR1VBR0VTLFxuICBjb25maWcsXG59IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyByZWFkUGFja2FnZUpzb24sIHByb2plY3RSb290UGF0aCB9IGZyb20gXCIuL3V0aWxpdGllc1wiO1xuXG5jb25zdCBjaGFsa0NvbG91ciA9IG5ldyBjaGFsay5JbnN0YW5jZSgpO1xuXG5jb25zdCB0ZW1wbGF0ZXNEaXIgPSBwYXRoLmpvaW4ocHJvamVjdFJvb3RQYXRoKCksIFwidGVtcGxhdGVzXCIpO1xuY29uc3QgYXZhaWxhYmxlVGVtcGxhdGVzID0gZnNcbiAgLnJlYWRkaXJTeW5jKHRlbXBsYXRlc0RpcilcbiAgLmZpbHRlcigoeCkgPT4gIXguc3RhcnRzV2l0aChcIi5cIikpO1xuZXhwb3J0IGNvbnN0IHRlbXBsYXRlczogc3RyaW5nW10gPSBbXTtcbmZvciAoY29uc3QgdGVtcGxhdGUgb2YgYXZhaWxhYmxlVGVtcGxhdGVzKSB7XG4gIHRlbXBsYXRlcy5wdXNoKHRlbXBsYXRlKTtcbn1cblxuY29uc3QgcGtnID0gcmVhZFBhY2thZ2VKc29uKCk7XG5jb25zdCBjb25zdHJ1Y3RzVmVyc2lvbiA9IHBrZy5kZXBlbmRlbmNpZXMuY29uc3RydWN0cztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRm9yRW1wdHlEaXJlY3RvcnkoZGlyOiBzdHJpbmcpIHtcbiAgaWYgKFxuICAgIGZzLnJlYWRkaXJTeW5jKGRpcikuZmlsdGVyKChmKSA9PiAhZi5zdGFydHNXaXRoKFwiLlwiKSAmJiBmICE9PSBsb2dGaWxlTmFtZSlcbiAgICAgIC5sZW5ndGggPiAwXG4gICkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBjaGFsa0NvbG91cmB7cmVkQnJpZ2h0IEVSUk9SOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHByb2plY3QgaW4gYSBub24tZW1wdHkgZGlyZWN0b3J5fWBcbiAgICApO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxufVxuXG50eXBlIE9wdGlvbnMgPSB7XG4gIGxvY2FsPzogYm9vbGVhbjtcbiAgdGVtcGxhdGU/OiBzdHJpbmc7XG4gIHByb2plY3ROYW1lPzogc3RyaW5nO1xuICBwcm9qZWN0RGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGNka3RmVmVyc2lvbj86IHN0cmluZztcbiAgZGlzdD86IHN0cmluZztcbiAgZGVzdGluYXRpb246IHN0cmluZztcbiAgZnJvbVRlcnJhZm9ybVByb2plY3Q/OiBzdHJpbmc7XG59O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkluaXQoYXJndjogT3B0aW9ucykge1xuICBjb25zdCB0ZWxlbWV0cnlEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGFyZ3YuZGVzdGluYXRpb24gfHwgXCIuXCI7XG4gIGxldCB0b2tlbiA9IFwiXCI7XG4gIGlmICghYXJndi5sb2NhbCkge1xuICAgIC8vIFdlIGFzayB0aGUgdXNlciB0byBsb2dpbiB0byBUZXJyYWZvcm0gQ2xvdWQgYW5kIHNldCBhIHRva2VuXG4gICAgLy8gSWYgdGhlIHVzZXIgY2hvb3NlcyBub3QgdG8gdXNlIFRlcnJhZm9ybSBDbG91ZCwgd2UgY29udGludWVcbiAgICAvLyB3aXRob3V0IGEgdG9rZW4gYW5kIHNldCB1cCB0aGUgcHJvamVjdC5cbiAgICBjb25zdCB0ZXJyYWZvcm1Mb2dpbiA9IG5ldyBUZXJyYWZvcm1Mb2dpbigpO1xuICAgIHRva2VuID0gYXdhaXQgdGVycmFmb3JtTG9naW4uYXNrVG9Mb2dpbigpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGNoYWxrQ29sb3VyYHt5ZWxsb3cgTm90ZTogQnkgc3VwcGx5aW5nICctLWxvY2FsJyBvcHRpb24geW91IGhhdmUgY2hvc2VuIGxvY2FsIHN0b3JhZ2UgbW9kZSBmb3Igc3RvcmluZyB0aGUgc3RhdGUgb2YgeW91ciBzdGFjay5cblRoaXMgbWVhbnMgdGhhdCB5b3VyIFRlcnJhZm9ybSBzdGF0ZSBmaWxlIHdpbGwgYmUgc3RvcmVkIGxvY2FsbHkgb24gZGlzayBpbiBhIGZpbGUgJ3RlcnJhZm9ybS48U1RBQ0sgTkFNRT4udGZzdGF0ZScgaW4gdGhlIHJvb3Qgb2YgeW91ciBwcm9qZWN0Ln1gKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRlbXBsYXRlIHdhcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXJcbiAgbGV0IHRlbXBsYXRlID0gXCJcIjtcbiAgaWYgKGFyZ3YudGVtcGxhdGUpIHtcbiAgICB0ZW1wbGF0ZSA9IGFyZ3YudGVtcGxhdGU7XG4gIH1cblxuICAvLyBHYXRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRlbXBsYXRlIGFuZCB0aGUgcHJvamVjdFxuICBjb25zdCB0ZW1wbGF0ZUluZm8gPSBhd2FpdCBnZXRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIHRlbGVtZXRyeURhdGEudGVtcGxhdGUgPSB0ZW1wbGF0ZUluZm8uTmFtZTtcblxuICBjb25zdCBwcm9qZWN0SW5mbzogUHJvamVjdCA9IGF3YWl0IGdhdGhlckluZm8oXG4gICAgdG9rZW4sXG4gICAgdGVtcGxhdGVJbmZvLk5hbWUsXG4gICAgYXJndi5wcm9qZWN0TmFtZSxcbiAgICBhcmd2LnByb2plY3REZXNjcmlwdGlvblxuICApO1xuICBjb25zdCBwcm9qZWN0SWQgPSB1dWlkKCk7XG4gIHRlbGVtZXRyeURhdGEucHJvamVjdElkID0gcHJvamVjdElkO1xuXG4gIC8vIENoZWNrIGlmIHRva2VuIGlzIHNldCBzbyB3ZSBjYW4gc2V0IHVwIFRlcnJhZm9ybSBDbG91ZCB3b3Jrc3BhY2VcbiAgLy8gb25seSBzZXQgd2l0aCB0aGUgJy0tbG9jYWwnIG9wdGlvbiBpcyBzcGVjaWZpZWQgdGhlIHVzZXIuXG4gIGlmICh0b2tlbiAhPSBcIlwiKSB7XG4gICAgdGVsZW1ldHJ5RGF0YS5pc1JlbW90ZSA9IEJvb2xlYW4odG9rZW4pO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgY2hhbGtDb2xvdXJgXFxue3doaXRlQnJpZ2h0IFNldHRpbmcgdXAgcmVtb3RlIHN0YXRlIGJhY2tlbmQgYW5kIHdvcmtzcGFjZSBpbiBUZXJyYWZvcm0gQ2xvdWQufWBcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0ZXJyYWZvcm1DbG91ZENsaWVudC5jcmVhdGVXb3Jrc3BhY2UoXG4gICAgICAgIHByb2plY3RJbmZvLk9yZ2FuaXphdGlvbk5hbWUsXG4gICAgICAgIHByb2plY3RJbmZvLldvcmtzcGFjZU5hbWUsXG4gICAgICAgIHRva2VuXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBjaGFsa0NvbG91cmB7cmVkQnJpZ2h0IEVSUk9SOiBDb3VsZCBub3QgY3JlYXRlIFRlcnJhZm9ybSBDbG91ZCBXb3Jrc3BhY2U6ICR7ZXJyb3IubWVzc2FnZX19YFxuICAgICAgKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXBzOiBhbnkgPSBhd2FpdCBkZXRlcm1pbmVEZXBzKGFyZ3YuY2RrdGZWZXJzaW9uLCBhcmd2LmRpc3QpO1xuXG4gIGNvbnN0IGZ1dHVyZUZsYWdzID0gT2JqZWN0LmVudHJpZXMoRlVUVVJFX0ZMQUdTKVxuICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYFwiJHtrZXl9XCI6IFwiJHt2YWx1ZX1cImApXG4gICAgLmpvaW4oYCxcXG5gKTtcblxuICBhd2FpdCBzc2NhZmYodGVtcGxhdGVJbmZvLlBhdGgsIGRlc3RpbmF0aW9uLCB7XG4gICAgLi4uZGVwcyxcbiAgICAuLi5wcm9qZWN0SW5mbyxcbiAgICBmdXR1cmVGbGFncyxcbiAgICBwcm9qZWN0SWQsXG4gIH0pO1xuXG4gIGlmIChhcmd2LmZyb21UZXJyYWZvcm1Qcm9qZWN0KSB7XG4gICAgaWYgKGFyZ3YudGVtcGxhdGUgPT09IFwidHlwZXNjcmlwdFwiKSB7XG4gICAgICBjb25zdCBtYWluVHMgPSBmcy5yZWFkRmlsZVN5bmMoXG4gICAgICAgIHBhdGgucmVzb2x2ZShkZXN0aW5hdGlvbiwgXCJtYWluLnRzXCIpLFxuICAgICAgICBcInV0ZjhcIlxuICAgICAgKTtcblxuICAgICAgY29uc3QgaW1wb3J0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBhcmd2LmZyb21UZXJyYWZvcm1Qcm9qZWN0KTtcblxuICAgICAgY29uc3QgY29tYmluZWRUZkZpbGUgPSBnZXRUZXJyYWZvcm1Db25maWdGcm9tRGlyKGltcG9ydFBhdGgpO1xuXG4gICAgICAvLyBGZXRjaCBhbGwgcHJvdmlkZXIgcmVxdWlyZW1lbnRzIGZyb20gdGhlIHByb2plY3RcbiAgICAgIGNvbnN0IHByb3ZpZGVyUmVxdWlyZW1lbnRzID0gYXdhaXQgcGFyc2VQcm92aWRlclJlcXVpcmVtZW50cyhcbiAgICAgICAgY29tYmluZWRUZkZpbGVcbiAgICAgICk7XG5cbiAgICAgIC8vIEdldCBhbGwgdGhlIHByb3ZpZGVyIHNjaGVtYXNcbiAgICAgIGNvbnN0IHsgcHJvdmlkZXJTY2hlbWEgfSA9IGF3YWl0IHJlYWRTY2hlbWEoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVyUmVxdWlyZW1lbnRzKS5tYXAoKFtuYW1lLCB2ZXJzaW9uXSkgPT5cbiAgICAgICAgICBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldC5mcm9tKFxuICAgICAgICAgICAgbmV3IGNvbmZpZy5UZXJyYWZvcm1Qcm92aWRlckNvbnN0cmFpbnQoYCR7bmFtZX1AICR7dmVyc2lvbn1gKSxcbiAgICAgICAgICAgIExBTkdVQUdFU1swXVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgY29kZSwgY2RrdGZKc29uLCBzdGF0cyB9ID0gYXdhaXQgY29udmVydFByb2plY3QoXG4gICAgICAgICAgY29tYmluZWRUZkZpbGUsXG4gICAgICAgICAgbWFpblRzLFxuICAgICAgICAgIHJlcXVpcmUocGF0aC5yZXNvbHZlKGRlc3RpbmF0aW9uLCBcImNka3RmLmpzb25cIikpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhbmd1YWdlOiBcInR5cGVzY3JpcHRcIixcbiAgICAgICAgICAgIHByb3ZpZGVyU2NoZW1hLFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGgucmVzb2x2ZShkZXN0aW5hdGlvbiwgXCJtYWluLnRzXCIpLCBjb2RlLCBcInV0ZjhcIik7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoXG4gICAgICAgICAgcGF0aC5yZXNvbHZlKGRlc3RpbmF0aW9uLCBcImNka3RmLmpzb25cIiksXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoY2RrdGZKc29uLCBudWxsLCAyKSxcbiAgICAgICAgICBcInV0ZjhcIlxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHsgdGVycmFmb3JtTW9kdWxlcywgdGVycmFmb3JtUHJvdmlkZXJzIH0gPSBjZGt0Zkpzb247XG5cbiAgICAgICAgaWYgKHRlcnJhZm9ybU1vZHVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvcHlMb2NhbE1vZHVsZXModGVycmFmb3JtTW9kdWxlcywgaW1wb3J0UGF0aCwgZGVzdGluYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRlcnJhZm9ybU1vZHVsZXMubGVuZ3RoICsgdGVycmFmb3JtUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBleGVjU3luYyhcIm5wbSBydW4gZ2V0XCIsIHsgY3dkOiBkZXN0aW5hdGlvbiB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbGVtZXRyeURhdGEuY29udmVyc2lvblN0YXRzID0gc3RhdHM7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKFwiaW5pdFwiLCBlcnIsIHsgZnJvbVRlcnJhZm9ybVByb2plY3Q6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBUaGUgLS1mcm9tLXRlcnJhZm9ybS1wcm9qZWN0IGZsYWcgaXMgb25seSBzdXBwb3J0ZWQgd2l0aCB0aGUgdHlwZXNjcmlwdCB0ZW1wbGF0ZS4gVGhlIGNvbW1hbmQgd2lsbCBjb250aW51ZSBhbmQgaWdub3JlIHRoZSBmbGFnLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRlbXBsYXRlSW5mby5jbGVhbnVwVGVtcG9yYXJ5RmlsZXMpIHtcbiAgICBhd2FpdCB0ZW1wbGF0ZUluZm8uY2xlYW51cFRlbXBvcmFyeUZpbGVzKCk7XG4gIH1cblxuICBhd2FpdCBzZW5kVGVsZW1ldHJ5KFwiaW5pdFwiLCB0ZWxlbWV0cnlEYXRhKTtcbn1cblxuZnVuY3Rpb24gY29weUxvY2FsTW9kdWxlcyhcbiAgbW9kdWxlczogYW55W10sXG4gIHNvdXJjZVBhdGg6IHN0cmluZyxcbiAgZGVzdGluYXRpb246IHN0cmluZ1xuKSB7XG4gIG1vZHVsZXNcbiAgICAuZmlsdGVyKChtKSA9PiBpc0xvY2FsTW9kdWxlKG0pKVxuICAgIC5tYXAoKG0pID0+XG4gICAgICBmcy5jb3B5U3luYyhwYXRoLnJlc29sdmUoc291cmNlUGF0aCwgbSksIHBhdGgucmVzb2x2ZShkZXN0aW5hdGlvbiwgbSksIHtcbiAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgfSlcbiAgICApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVEZXBzKFxuICB2ZXJzaW9uOiBzdHJpbmcgPSBwa2cudmVyc2lvbixcbiAgZGlzdD86IHN0cmluZ1xuKTogUHJvbWlzZTxEZXBzPiB7XG4gIGNvbnN0IHB5dGhvblZlcnNpb24gPSB2ZXJzaW9uLnJlcGxhY2UoLy1wcmVcXC4vZywgXCIuZGV2XCIpO1xuXG4gIGlmIChkaXN0KSB7XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgbnBtX2Nka3RmOiBwYXRoLnJlc29sdmUoZGlzdCwgXCJqc1wiLCBgY2RrdGZAJHt2ZXJzaW9ufS5qc2lpLnRnemApLFxuICAgICAgbnBtX2Nka3RmX2NsaTogcGF0aC5yZXNvbHZlKGRpc3QsIFwianNcIiwgYGNka3RmLWNsaS0ke3ZlcnNpb259LnRnemApLFxuICAgICAgcHlwaV9jZGt0ZjogcGF0aC5yZXNvbHZlKGRpc3QsIFwicHl0aG9uXCIsIGBjZGt0Zi0ke3B5dGhvblZlcnNpb259LnRhci5nemApLFxuICAgICAgbXZuX2Nka3RmOiBwYXRoLnJlc29sdmUoXG4gICAgICAgIGRpc3QsXG4gICAgICAgIFwiamF2YVwiLFxuICAgICAgICBgY29tL2hhc2hpY29ycC9jZGt0Zi8ke3ZlcnNpb259L2Nka3RmLSR7dmVyc2lvbn0uamFyYFxuICAgICAgKSxcbiAgICAgIG51Z2V0X2Nka3RmOiBwYXRoLnJlc29sdmUoXG4gICAgICAgIGRpc3QsXG4gICAgICAgIFwiZG90bmV0XCIsXG4gICAgICAgIGBIYXNoaUNvcnAuQ2RrdGYuJHt2ZXJzaW9ufS5udXBrZ2BcbiAgICAgICksXG4gICAgICBnb19jZGt0ZjogcGF0aC5yZXNvbHZlKGRpc3QsIFwiZ29cIiwgYGNka3RmYCksXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBPYmplY3QudmFsdWVzKHJldCkpIHtcbiAgICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMoZmlsZSkpKSB7XG4gICAgICAgIHRocm93IEVycm9ycy5JbnRlcm5hbChcbiAgICAgICAgICBcImluaXRcIixcbiAgICAgICAgICBgdW5hYmxlIHRvIGZpbmQgJHtmaWxlfSB1bmRlciB0aGUgXCJkaXN0XCIgZGlyZWN0b3J5ICgke2Rpc3R9KWAsXG4gICAgICAgICAgeyB2ZXJzaW9uIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2ZXJzaW9ucyA9IHtcbiAgICAgIGNka3RmX3ZlcnNpb246IHZlcnNpb24sXG4gICAgICBjb25zdHJ1Y3RzX3ZlcnNpb246IGNvbnN0cnVjdHNWZXJzaW9uLFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmV0LFxuICAgICAgLi4udmVyc2lvbnMsXG4gICAgfTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uID09PSBcIjAuMC4wXCIpIHtcbiAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICBcImluaXRcIixcbiAgICAgIGNoYWxrQ29sb3VyYHtyZWRCcmlnaHQgY2Fubm90IHVzZSB2ZXJzaW9uIDAuMC4wLCB1c2UgLS1jZGt0Zi12ZXJzaW9uLCAtLWRpc3Qgb3IgQ0RLVEZfRElTVCB0byBpbnN0YWxsIGZyb20gYSBcImRpc3RcIiBkaXJlY3Rvcnl9YCxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBpZiB3ZSB3YW50IGEgc3BlY2lmaWMgcGlubmVkIHZlcnNpb24gb3IgYSB2ZXJzaW9uIHJhbmdlIHdlIHRha2VcbiAgLy8gYSBwaW5uZWQgdmVyc2lvbiBpZiB2ZXJzaW9uIGluY2x1ZGVzIGEgaHlwaGVuIHdoaWNoIG1lYW5zIGl0IGlzIGFcbiAgLy8gcHJlLXJlbGVhc2UgKGUuZy4gXCIwLjEyLjAtcHJlLmU2ODM0ZDNcIikuIG90aGVyd2lzZSwgd2UgcmVxdWlyZSBhIGNhcmV0XG4gIC8vIHZlcnNpb24uXG4gIGNvbnN0IHZlciA9IHZlcnNpb24uaW5jbHVkZXMoXCItXCIpID8gdmVyc2lvbiA6IGBeJHt2ZXJzaW9ufWA7XG5cbiAgcmV0dXJuIHtcbiAgICBjZGt0Zl92ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGNvbnN0cnVjdHNfdmVyc2lvbjogY29uc3RydWN0c1ZlcnNpb24sXG4gICAgbnBtX2Nka3RmOiBgY2RrdGZAJHt2ZXJ9YCxcbiAgICBucG1fY2RrdGZfY2xpOiBgY2RrdGYtY2xpQCR7dmVyfWAsXG4gICAgcHlwaV9jZGt0ZjogYGNka3Rmfj0ke3B5dGhvblZlcnNpb259YCxcbiAgICBtdm5fY2RrdGY6IHZlcnNpb24sXG4gICAgbnVnZXRfY2RrdGY6IHZlcnNpb24sXG4gICAgZ29fY2RrdGY6IGB2JHt2ZXJzaW9ufWAsXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdhdGhlckluZm8oXG4gIHRva2VuOiBzdHJpbmcsXG4gIHRlbXBsYXRlTmFtZTogc3RyaW5nLFxuICBwcm9qZWN0TmFtZT86IHN0cmluZyxcbiAgcHJvamVjdERlc2NyaXB0aW9uPzogc3RyaW5nXG4pOiBQcm9taXNlPFByb2plY3Q+IHtcbiAgY29uc3QgY3VycmVudERpcmVjdG9yeSA9IHBhdGguYmFzZW5hbWUocHJvY2Vzcy5jd2QoKSk7XG4gIGNvbnN0IHByb2plY3REZXNjcmlwdGlvbkRlZmF1bHQgPVxuICAgIFwiQSBzaW1wbGUgZ2V0dGluZyBzdGFydGVkIHByb2plY3QgZm9yIGNka3RmLlwiO1xuICBjb25zdCBxdWVzdGlvbnMgPSBbXTtcbiAgaWYgKCFwcm9qZWN0TmFtZSkge1xuICAgIHF1ZXN0aW9ucy5wdXNoKHtcbiAgICAgIG5hbWU6IFwicHJvamVjdE5hbWVcIixcbiAgICAgIGRlZmF1bHQ6IGN1cnJlbnREaXJlY3RvcnksXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFwcm9qZWN0RGVzY3JpcHRpb24pIHtcbiAgICBxdWVzdGlvbnMucHVzaCh7XG4gICAgICBuYW1lOiBcInByb2plY3REZXNjcmlwdGlvblwiLFxuICAgICAgZGVmYXVsdDogcHJvamVjdERlc2NyaXB0aW9uRGVmYXVsdCxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGFuc3dlcnM6IHtcbiAgICBwcm9qZWN0TmFtZT86IHN0cmluZztcbiAgICBwcm9qZWN0RGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIH0gPSBxdWVzdGlvbnMubGVuZ3RoID4gMCA/IGF3YWl0IGlucXVpcmVyLnByb21wdChxdWVzdGlvbnMpIDoge307XG5cbiAgY29uc3QgcHJvamVjdDogUHJvamVjdCA9IHtcbiAgICBOYW1lOiBwcm9qZWN0TmFtZSB8fCBhbnN3ZXJzLnByb2plY3ROYW1lIHx8IFwiXCIsXG4gICAgRGVzY3JpcHRpb246IHByb2plY3REZXNjcmlwdGlvbiB8fCBhbnN3ZXJzLnByb2plY3REZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgIE9yZ2FuaXphdGlvbk5hbWU6IFwiXCIsXG4gICAgV29ya3NwYWNlTmFtZTogXCJcIixcbiAgfTtcblxuICBpZiAodG9rZW4gIT0gXCJcIikge1xuICAgIGNvbnNvbGUubG9nKGNoYWxrQ29sb3VyYFxcbkRldGVjdGVkIHtibHVlQnJpZ2h0IFRlcnJhZm9ybSBDbG91ZH0gdG9rZW4uYCk7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBjaGFsa0NvbG91cmBcXG5XZSB3aWxsIG5vdyBzZXQgdXAge2JsdWVCcmlnaHQgVGVycmFmb3JtIENsb3VkfSBmb3IgeW91ciBwcm9qZWN0LlxcbmBcbiAgICApO1xuICAgIGNvbnN0IG9yZ2FuaXphdGlvbk5hbWVzID0gYXdhaXQgdGVycmFmb3JtQ2xvdWRDbGllbnQuZ2V0T3JnYW5pemF0aW9uTmFtZXMoXG4gICAgICB0b2tlblxuICAgICk7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9uRGF0YSA9IG9yZ2FuaXphdGlvbk5hbWVzLmRhdGE7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9uT3B0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb3JnYW5pemF0aW9uIG9mIG9yZ2FuaXphdGlvbkRhdGEpIHtcbiAgICAgIG9yZ2FuaXphdGlvbk9wdGlvbnMucHVzaChvcmdhbml6YXRpb24uaWQpO1xuICAgIH1cblxuICAgIC8vIHRvZG86IGFkZCB2YWxpZGF0aW9uIGZvciB0aGUgb3JnYW5pemF0aW9uIG5hbWUgYW5kIHdvcmtzcGFjZS4gYWRkIGVycm9yIGhhbmRsaW5nXG4gICAgY29uc3QgeyBvcmdhbml6YXRpb246IG9yZ2FuaXphdGlvblNlbGVjdCB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICAgIG5hbWU6IFwib3JnYW5pemF0aW9uXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiVGVycmFmb3JtIENsb3VkIE9yZ2FuaXphdGlvbiBOYW1lXCIsXG4gICAgICAgIGNob2ljZXM6IG9yZ2FuaXphdGlvbk9wdGlvbnMsXG4gICAgICB9LFxuICAgIF0pO1xuXG4gICAgY29uc29sZS5sb2coXG4gICAgICBjaGFsa0NvbG91cmBcXG5XZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGEgbmV3IHtibHVlQnJpZ2h0IFRlcnJhZm9ybSBDbG91ZCBXb3Jrc3BhY2V9IGZvciB5b3VyIHByb2plY3QuXFxuYFxuICAgICk7XG5cbiAgICBjb25zdCB7IHdvcmtzcGFjZTogd29ya3NwYWNlTmFtZSB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJ3b3Jrc3BhY2VcIixcbiAgICAgICAgbWVzc2FnZTogXCJUZXJyYWZvcm0gQ2xvdWQgV29ya3NwYWNlIE5hbWVcIixcbiAgICAgICAgZGVmYXVsdDogdGVtcGxhdGVOYW1lLFxuICAgICAgfSxcbiAgICBdKTtcbiAgICBwcm9qZWN0Lk9yZ2FuaXphdGlvbk5hbWUgPSBvcmdhbml6YXRpb25TZWxlY3Q7XG4gICAgcHJvamVjdC5Xb3Jrc3BhY2VOYW1lID0gd29ya3NwYWNlTmFtZTtcbiAgfVxuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGVOYW1lIGVpdGhlciB0aGUgbmFtZSBvZiBidWlsdC1pbiB0ZW1wbGF0ZXMgb3IgYW4gdXJsIHBvaW50aW5nIHRvIGEgemlwIGFyY2hpdmVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0VGVtcGxhdGUodGVtcGxhdGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPFRlbXBsYXRlPiB7XG4gIGlmICh0ZW1wbGF0ZU5hbWUgPT0gXCJcIikge1xuICAgIGNvbnN0IHRlbXBsYXRlT3B0aW9uUmVtb3RlID0gXCI8cmVtb3RlIHppcCBmaWxlPlwiO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBbLi4udGVtcGxhdGVzLCB0ZW1wbGF0ZU9wdGlvblJlbW90ZV07XG4gICAgLy8gUHJvbXB0IGZvciB0ZW1wbGF0ZVxuICAgIGNvbnN0IHsgdGVtcGxhdGU6IHNlbGVjdGlvbiB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICAgIG5hbWU6IFwidGVtcGxhdGVcIixcbiAgICAgICAgbWVzc2FnZTogXCJXaGF0IHRlbXBsYXRlIGRvIHlvdSB3YW50IHRvIHVzZT9cIixcbiAgICAgICAgY2hvaWNlczogb3B0aW9ucyxcbiAgICAgIH0sXG4gICAgXSk7XG5cbiAgICBpZiAoc2VsZWN0aW9uID09PSB0ZW1wbGF0ZU9wdGlvblJlbW90ZSkge1xuICAgICAgY29uc3QgeyB0ZW1wbGF0ZU5hbWU6IHJlbW90ZVRlbXBsYXRlTmFtZSB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwidGVtcGxhdGVOYW1lXCIsXG4gICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgIFwiUGxlYXNlIGVudGVyIGFuIFVSTCBwb2ludGluZyB0byB0aGUgdGVtcGxhdGUgemlwIGZpbGUgeW91IHdhbnQgdG8gdXNlOlwiLFxuICAgICAgICAgIHZhbGlkYXRlOiAodmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlVybCBjYW4gbm90IGJlIGVtcHR5XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXSk7XG5cbiAgICAgIHRlbXBsYXRlTmFtZSA9IHJlbW90ZVRlbXBsYXRlTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGxhdGVOYW1lID0gc2VsZWN0aW9uO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGNoYWxrQ29sb3VyYFxcbnt3aGl0ZUJyaWdodCBJbml0aWFsaXppbmcgYSBwcm9qZWN0IHVzaW5nIHRoZSB7Z3JlZW5CcmlnaHQgJHt0ZW1wbGF0ZU5hbWV9fSB0ZW1wbGF0ZS59YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyB0cmVhdCBhcyByZW1vdGUgdXJsXG4gIGlmICghdGVtcGxhdGVzLmluY2x1ZGVzKHRlbXBsYXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmV0Y2hSZW1vdGVUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBOYW1lOiB0ZW1wbGF0ZU5hbWUsXG4gICAgICBQYXRoOiBwYXRoLmpvaW4odGVtcGxhdGVzRGlyLCB0ZW1wbGF0ZU5hbWUpLFxuICAgIH07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZW1vdGVUZW1wbGF0ZSh0ZW1wbGF0ZVVybDogc3RyaW5nKTogUHJvbWlzZTxUZW1wbGF0ZT4ge1xuICBjb25zb2xlLmxvZyhcbiAgICBjaGFsa0NvbG91cmBGZXRjaGluZyByZW1vdGUgdGVtcGxhdGUgZnJvbToge3doaXRlQnJpZ2h0ICR7dGVtcGxhdGVVcmx9fWBcbiAgKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRlbXBsYXRlVXJsKTtcbiAgICBjb25zdCByZW1vdGVGaWxlTmFtZSA9IHBhdGguYmFzZW5hbWUodXJsLnBhdGhuYW1lKSB8fCBcInRlbXBsYXRlLnppcFwiO1xuICAgIGxvZ2dlci50cmFjZShcbiAgICAgIGBEZXRlY3RlZCByZW1vdGUgZmlsZSBuYW1lIHRvIGJlIFwiJHtyZW1vdGVGaWxlTmFtZX1cIiBvdXQgb2YgdGVtcGxhdGUgVVJMIFwiJHt0ZW1wbGF0ZVVybH1cImBcbiAgICApO1xuXG4gICAgY29uc3QgdG1wRGlyID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksIFwiY2RrdGYuXCIpKTtcbiAgICBjb25zdCB0bXBaaXBGaWxlID0gcGF0aC5qb2luKHRtcERpciwgcmVtb3RlRmlsZU5hbWUpO1xuICAgIGNvbnN0IHppcEV4dHJhY3REaXIgPSBwYXRoLmpvaW4odG1wRGlyLCBcImV4dHJhY3RlZFwiKTtcblxuICAgIGxvZ2dlci50cmFjZShcbiAgICAgIGBEb3dubG9hZGluZyBcIiR7cmVtb3RlRmlsZU5hbWV9XCIgdG8gdGVtcG9yYXJ5IGRpcmVjdG9yeSBcIiR7dG1wRGlyfVwiYFxuICAgICk7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBjaGFsa0NvbG91cmBEb3dubG9hZGluZyBcInt3aGl0ZUJyaWdodCAke3JlbW90ZUZpbGVOYW1lfX1cIiB0byB0ZW1wb3JhcnkgZGlyZWN0b3J5YFxuICAgICk7XG4gICAgYXdhaXQgZG93bmxvYWRGaWxlKHVybC5ocmVmLCB0bXBaaXBGaWxlKTtcblxuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyB6aXAgZmlsZVwiKTtcbiAgICBhd2FpdCBleHRyYWN0KHRtcFppcEZpbGUsIHsgZGlyOiB6aXBFeHRyYWN0RGlyIH0pO1xuXG4gICAgLy8gd2FsayBkaXJlY3RvcnkgdG8gZmluZCBjZGt0Zi5qc29uIGFzIHRoZSBleHRyYWN0ZWQgZGlyZWN0b3J5IGNvbnRhaW5zIGEgcm9vdCBkaXJlY3Rvcnkgd2l0aCB1bmtub3duIG5hbWVcbiAgICAvLyB0aGlzIGFsc28gYWxsb3dzIG5lc3RpbmcgdGhlIHRlbXBsYXRlIGl0c2VsZiBpbnRvIGEgc3ViIGRpcmVjdG9yeSBhbmQgaGF2aW5nIGEgcm9vdCBkaXJlY3Rvcnkgd2l0aCBhbiB1bnJlbGF0ZWQgUkVBRE1FXG4gICAgY29uc29sZS5sb2coXG4gICAgICBjaGFsa0NvbG91cmBMb29raW5nIGZvciBkaXJlY3RvcnkgY29udGFpbmluZyB7d2hpdGVCcmlnaHQgY2RrdGYuanNvbn1gXG4gICAgKTtcbiAgICBjb25zdCB0ZW1wbGF0ZVBhdGggPSBhd2FpdCBmaW5kQ2RrVGZKc29uRGlyZWN0b3J5KHppcEV4dHJhY3REaXIpO1xuXG4gICAgaWYgKCF0ZW1wbGF0ZVBhdGgpIHtcbiAgICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgICAgXCJpbml0XCIsXG4gICAgICAgIGNoYWxrQ29sb3VyYENvdWxkIG5vdCBmaW5kIGEge3doaXRlQnJpZ2h0IGNka3RmLmpzb259IGluIHRoZSBleHRyYWN0ZWQgZGlyZWN0b3J5YCxcbiAgICAgICAge31cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIE5hbWU6IHBhdGgucGFyc2UocmVtb3RlRmlsZU5hbWUpLm5hbWUsIC8vIHN0cmlwcyAuemlwIGZyb20gZmlsZW5hbWVcbiAgICAgIFBhdGg6IHRlbXBsYXRlUGF0aCxcbiAgICAgIGNsZWFudXBUZW1wb3JhcnlGaWxlczogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNsZWFyaW5nIHVwIHRlbXBvcmFyeSBkaXJlY3Rvcnkgb2YgcmVtb3RlIHRlbXBsYXRlXCIpO1xuICAgICAgICBhd2FpdCBmcy5yZW1vdmUodG1wRGlyKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgPT09IFwiRVJSX0lOVkFMSURfVVJMXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGNoYWxrQ29sb3VyYENvdWxkIG5vdCBkb3dubG9hZCB0ZW1wbGF0ZToge3JlZEJyaWdodCB0aGUgc3VwcGxpZWQgdXJsIGlzIGludmFsaWR9YFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGNoYWxrQ29sb3VyYFBsZWFzZSBzdXBwbHkgYSB2YWxpZCB1cmwgKGluY2x1ZGluZyB0aGUgcHJvdG9jb2wpIG9yIHVzZSBvbmUgb2YgdGhlIGJ1aWx0LWluIHRlbXBsYXRlcy5gXG4gICAgICApO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cbiAgICBpZiAoZSBpbnN0YW5jZW9mIEh0dHBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgY2hhbGtDb2xvdXJgQ291bGQgbm90IGRvd25sb2FkIHRlbXBsYXRlOiB7cmVkQnJpZ2h0ICR7ZS5tZXNzYWdlfX1gXG4gICAgICApO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbmRDZGtUZkpzb25EaXJlY3Rvcnkocm9vdERpcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGNvbnN0IGZpbGVzID0gYXdhaXQgZnMucmVhZGRpcihyb290RGlyKTtcblxuICBpZiAoZmlsZXMuaW5jbHVkZXMoXCJjZGt0Zi5qc29uXCIpKSB7XG4gICAgcmV0dXJuIHJvb3REaXI7XG4gIH1cbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4ocm9vdERpciwgZmlsZSk7XG4gICAgaWYgKChhd2FpdCBmcy5zdGF0KGZ1bGxQYXRoKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY29uc3QgZGlyID0gZmluZENka1RmSnNvbkRpcmVjdG9yeShmdWxsUGF0aCk7XG4gICAgICBpZiAoZGlyKSByZXR1cm4gZGlyO1xuICAgICAgLy8gZWxzZSBjb250aW51ZSB3aXRoIG5leHQgc3ViIGRpcmVjdG9yeVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuaW50ZXJmYWNlIERlcHMge1xuICBucG1fY2RrdGY6IHN0cmluZztcbiAgbnBtX2Nka3RmX2NsaTogc3RyaW5nO1xuICBweXBpX2Nka3RmOiBzdHJpbmc7XG4gIG12bl9jZGt0Zjogc3RyaW5nO1xuICBudWdldF9jZGt0Zjogc3RyaW5nO1xuICBnb19jZGt0Zjogc3RyaW5nO1xuICBjZGt0Zl92ZXJzaW9uOiBzdHJpbmc7XG4gIGNvbnN0cnVjdHNfdmVyc2lvbjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUHJvamVjdCB7XG4gIE5hbWU6IHN0cmluZztcbiAgRGVzY3JpcHRpb246IHN0cmluZztcbiAgT3JnYW5pemF0aW9uTmFtZTogc3RyaW5nO1xuICBXb3Jrc3BhY2VOYW1lOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUZW1wbGF0ZSB7XG4gIE5hbWU6IHN0cmluZztcbiAgUGF0aDogc3RyaW5nO1xuICBjbGVhbnVwVGVtcG9yYXJ5RmlsZXM/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuIl19