"use strict";
/**
 * Helper routines for use with the jsii compiler
 *
 * These are mostly used for testing, but all projects that need to exercise
 * the JSII compiler to test something need to share this code, so might as
 * well put it in one reusable place.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestWorkspace = exports.compileJsiiForTest = exports.sourceToAssemblyHelper = void 0;
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const typescript_1 = require("typescript");
const compiler_1 = require("./compiler");
const project_info_1 = require("./project-info");
const utils_1 = require("./utils");
/**
 * Compile a piece of source and return the JSII assembly for it
 *
 * Only usable for trivial cases and tests.
 *
 * @param source can either be a single `string` (the content of `index.ts`), or
 *               a map of fileName to content, which *must* include `index.ts`.
 * @param options accepts a callback for historical reasons but really expects to
 *                take an options object.
 */
async function sourceToAssemblyHelper(source, options) {
    return (await compileJsiiForTest(source, options)).assembly;
}
exports.sourceToAssemblyHelper = sourceToAssemblyHelper;
/**
 * Compile a piece of source and return the assembly and compiled sources for it
 *
 * Only usable for trivial cases and tests.
 *
 * @param source can either be a single `string` (the content of `index.ts`), or
 *               a map of fileName to content, which *must* include `index.ts`.
 * @param options accepts a callback for historical reasons but really expects to
 *                take an options object.
 */
async function compileJsiiForTest(source, options, compilerOptions) {
    if (typeof source === 'string') {
        source = { 'index.ts': source };
    }
    const inSomeLocation = isOptionsObject(options) && options.compilationDirectory
        ? inOtherDir(options.compilationDirectory)
        : inTempDir;
    // Easiest way to get the source into the compiler is to write it to disk somewhere.
    // I guess we could make an in-memory compiler host but that seems like work...
    return inSomeLocation(async () => {
        var _a;
        await Promise.all(Object.entries(source).map(async ([fileName, content]) => {
            await fs.mkdirp(path.dirname(fileName));
            return fs.writeFile(fileName, content, { encoding: 'utf-8' });
        }));
        const { projectInfo, packageJson } = await makeProjectInfo('index.ts', typeof options === 'function'
            ? options
            : (pi) => {
                var _a, _b;
                Object.assign(pi, (_b = (_a = options === null || options === void 0 ? void 0 : options.packageJson) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.projectInfo) !== null && _b !== void 0 ? _b : {});
            });
        const compiler = new compiler_1.Compiler({
            projectInfo,
            ...compilerOptions,
        });
        const emitResult = await compiler.emit();
        const errors = emitResult.diagnostics.filter((d) => d.category === typescript_1.DiagnosticCategory.Error);
        for (const error of errors) {
            console.error(utils_1.formatDiagnostic(error, projectInfo.projectRoot));
            // logDiagnostic() doesn't work out of the box, so console.error() it is.
        }
        if (errors.length > 0 || emitResult.emitSkipped) {
            throw new Error('There were compiler errors');
        }
        const assembly = await fs.readJSON('.jsii', { encoding: 'utf-8' });
        const files = {};
        for (const filename of Object.keys(source)) {
            let jsFile = filename.replace(/\.ts$/, '.js');
            let dtsFile = filename.replace(/\.ts$/, '.d.ts');
            if (((_a = projectInfo.tsc) === null || _a === void 0 ? void 0 : _a.outDir) && filename !== 'README.md') {
                jsFile = path.join(projectInfo.tsc.outDir, jsFile);
                dtsFile = path.join(projectInfo.tsc.outDir, dtsFile);
            }
            // eslint-disable-next-line no-await-in-loop
            files[jsFile] = await fs.readFile(jsFile, { encoding: 'utf-8' });
            // eslint-disable-next-line no-await-in-loop
            files[dtsFile] = await fs.readFile(dtsFile, { encoding: 'utf-8' });
            const warningsFileName = '.warnings.jsii.js';
            if (fs.existsSync(warningsFileName)) {
                // eslint-disable-next-line no-await-in-loop
                files[warningsFileName] = await fs.readFile(warningsFileName, {
                    encoding: 'utf-8',
                });
            }
        }
        return { assembly, files, packageJson };
    });
}
exports.compileJsiiForTest = compileJsiiForTest;
async function inTempDir(block) {
    const origDir = process.cwd();
    const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'jsii'));
    process.chdir(tmpDir);
    const ret = await block();
    process.chdir(origDir);
    await fs.remove(tmpDir);
    return ret;
}
function inOtherDir(dir) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-constraint
    return async (block) => {
        const origDir = process.cwd();
        process.chdir(dir);
        try {
            return await block();
        }
        finally {
            process.chdir(origDir);
        }
    };
}
/**
 * Obtain project info so we can call the compiler
 *
 * Creating this directly in-memory leads to slightly different behavior from calling
 * jsii from the command-line, and I don't want to figure out right now.
 *
 * Most consistent behavior seems to be to write a package.json to disk and
 * then calling the same functions as the CLI would.
 */
async function makeProjectInfo(types, cb) {
    const packageJson = {
        types,
        main: types.replace(/(?:\.d)?\.ts(x?)/, '.js$1'),
        name: 'testpkg',
        version: '0.0.1',
        license: 'Apache-2.0',
        author: { name: 'John Doe' },
        repository: { type: 'git', url: 'https://github.com/aws/jsii.git' },
        jsii: {},
    };
    if (cb) {
        await cb(packageJson);
    }
    await fs.writeJson('package.json', packageJson, {
        encoding: 'utf-8',
        replacer: (_, v) => v,
        spaces: 2,
    });
    const { projectInfo } = await project_info_1.loadProjectInfo(path.resolve(process.cwd(), '.'));
    return { projectInfo, packageJson };
}
function isOptionsObject(x) {
    return x ? typeof x === 'object' : false;
}
/**
 * An NPM-ready workspace where we can install test-compile dependencies and compile new assemblies
 */
class TestWorkspace {
    constructor(rootDirectory) {
        this.rootDirectory = rootDirectory;
        this.installed = new Set();
    }
    /**
     * Create a new workspace.
     *
     * Creates a temporary directory, don't forget to call cleanUp
     */
    static async create() {
        const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'jsii-testworkspace'));
        await fs.ensureDir(tmpDir);
        return new TestWorkspace(tmpDir);
    }
    /**
     * Execute a block with a temporary workspace
     */
    static async withWorkspace(block) {
        const ws = await TestWorkspace.create();
        try {
            return await block(ws);
        }
        finally {
            await ws.cleanup();
        }
    }
    /**
     * Add a test-compiled jsii assembly as a dependency
     */
    async addDependency(dependencyAssembly) {
        if (this.installed.has(dependencyAssembly.assembly.name)) {
            throw new Error(`A dependency with name '${dependencyAssembly.assembly.name}' was already installed. Give one a different name.`);
        }
        this.installed.add(dependencyAssembly.assembly.name);
        // The following is silly, however: the helper has compiled the given source to
        // an assembly, and output files, and then removed their traces from disk.
        // We need those files back on disk, so write them back out again.
        //
        // We will drop them in 'node_modules/<name>' so they can be imported
        // as if they were installed.
        const modDir = path.join(this.rootDirectory, 'node_modules', dependencyAssembly.assembly.name);
        await fs.ensureDir(modDir);
        await fs.writeJSON(path.join(modDir, '.jsii'), dependencyAssembly.assembly);
        await fs.writeJSON(path.join(modDir, 'package.json'), dependencyAssembly.packageJson);
        for (const [fileName, fileContents] of Object.entries(dependencyAssembly.files)) {
            // eslint-disable-next-line no-await-in-loop
            await fs.ensureDir(path.dirname(path.join(modDir, fileName)));
            // eslint-disable-next-line no-await-in-loop
            await fs.writeFile(path.join(modDir, fileName), fileContents);
        }
    }
    dependencyDir(name) {
        if (!this.installed.has(name)) {
            throw new Error(`No dependency with name '${name}' has been installed`);
        }
        return path.join(this.rootDirectory, 'node_modules', name);
    }
    async cleanup() {
        await fs.remove(this.rootDirectory);
    }
}
exports.TestWorkspace = TestWorkspace;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7R0FNRzs7O0FBSUgsK0JBQStCO0FBQy9CLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsMkNBQWdEO0FBRWhELHlDQUF1RDtBQUN2RCxpREFBOEQ7QUFDOUQsbUNBQTJDO0FBVTNDOzs7Ozs7Ozs7R0FTRztBQUNJLEtBQUssVUFBVSxzQkFBc0IsQ0FDMUMsTUFBb0MsRUFDcEMsT0FBK0Q7SUFFL0QsT0FBTyxDQUFDLE1BQU0sa0JBQWtCLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQzlELENBQUM7QUFMRCx3REFLQztBQWtCRDs7Ozs7Ozs7O0dBU0c7QUFDSSxLQUFLLFVBQVUsa0JBQWtCLENBQ3RDLE1BQStELEVBQy9ELE9BQStELEVBQy9ELGVBQWdFO0lBRWhFLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1FBQzlCLE1BQU0sR0FBRyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQztLQUNqQztJQUVELE1BQU0sY0FBYyxHQUNsQixlQUFlLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLG9CQUFvQjtRQUN0RCxDQUFDLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztRQUMxQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBRWhCLG9GQUFvRjtJQUNwRiwrRUFBK0U7SUFDL0UsT0FBTyxjQUFjLENBQUMsS0FBSyxJQUFJLEVBQUU7O1FBQy9CLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FDZixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLEVBQUUsRUFBRTtZQUN2RCxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FB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SUFDN0QsQ0FBQztJQUVNLEtBQUssQ0FBQyxPQUFPO1FBQ2xCLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDdEMsQ0FBQztDQUNGO0FBbEZELHNDQWtGQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVyIHJvdXRpbmVzIGZvciB1c2Ugd2l0aCB0aGUganNpaSBjb21waWxlclxuICpcbiAqIFRoZXNlIGFyZSBtb3N0bHkgdXNlZCBmb3IgdGVzdGluZywgYnV0IGFsbCBwcm9qZWN0cyB0aGF0IG5lZWQgdG8gZXhlcmNpc2VcbiAqIHRoZSBKU0lJIGNvbXBpbGVyIHRvIHRlc3Qgc29tZXRoaW5nIG5lZWQgdG8gc2hhcmUgdGhpcyBjb2RlLCBzbyBtaWdodCBhc1xuICogd2VsbCBwdXQgaXQgaW4gb25lIHJldXNhYmxlIHBsYWNlLlxuICovXG5cbmltcG9ydCAqIGFzIHNwZWMgZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgeyBQYWNrYWdlSnNvbiB9IGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IERpYWdub3N0aWNDYXRlZ29yeSB9IGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQgeyBDb21waWxlciwgQ29tcGlsZXJPcHRpb25zIH0gZnJvbSAnLi9jb21waWxlcic7XG5pbXBvcnQgeyBsb2FkUHJvamVjdEluZm8sIFByb2plY3RJbmZvIH0gZnJvbSAnLi9wcm9qZWN0LWluZm8nO1xuaW1wb3J0IHsgZm9ybWF0RGlhZ25vc3RpYyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEEgc2V0IG9mIHNvdXJjZSBmaWxlcyBmb3IgYHNvdXJjZVRvQXNzZW1ibHlIZWxwZXJgLCBhdCBsZWFzdCBjb250YWluaW5nICdpbmRleC50cydcbiAqL1xuZXhwb3J0IHR5cGUgTXVsdGlwbGVTb3VyY2VGaWxlcyA9IHtcbiAgJ2luZGV4LnRzJzogc3RyaW5nO1xuICBbbmFtZTogc3RyaW5nXTogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBDb21waWxlIGEgcGllY2Ugb2Ygc291cmNlIGFuZCByZXR1cm4gdGhlIEpTSUkgYXNzZW1ibHkgZm9yIGl0XG4gKlxuICogT25seSB1c2FibGUgZm9yIHRyaXZpYWwgY2FzZXMgYW5kIHRlc3RzLlxuICpcbiAqIEBwYXJhbSBzb3VyY2UgY2FuIGVpdGhlciBiZSBhIHNpbmdsZSBgc3RyaW5nYCAodGhlIGNvbnRlbnQgb2YgYGluZGV4LnRzYCksIG9yXG4gKiAgICAgICAgICAgICAgIGEgbWFwIG9mIGZpbGVOYW1lIHRvIGNvbnRlbnQsIHdoaWNoICptdXN0KiBpbmNsdWRlIGBpbmRleC50c2AuXG4gKiBAcGFyYW0gb3B0aW9ucyBhY2NlcHRzIGEgY2FsbGJhY2sgZm9yIGhpc3RvcmljYWwgcmVhc29ucyBidXQgcmVhbGx5IGV4cGVjdHMgdG9cbiAqICAgICAgICAgICAgICAgIHRha2UgYW4gb3B0aW9ucyBvYmplY3QuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzb3VyY2VUb0Fzc2VtYmx5SGVscGVyKFxuICBzb3VyY2U6IHN0cmluZyB8IE11bHRpcGxlU291cmNlRmlsZXMsXG4gIG9wdGlvbnM/OiBUZXN0Q29tcGlsYXRpb25PcHRpb25zIHwgKChvYmo6IFBhY2thZ2VKc29uKSA9PiB2b2lkKSxcbik6IFByb21pc2U8c3BlYy5Bc3NlbWJseT4ge1xuICByZXR1cm4gKGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChzb3VyY2UsIG9wdGlvbnMpKS5hc3NlbWJseTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWxwZXJDb21waWxhdGlvblJlc3VsdCB7XG4gIC8qKlxuICAgKiBUaGUgZ2VuZXJhdGVkIGFzc2VtYmx5XG4gICAqL1xuICByZWFkb25seSBhc3NlbWJseTogc3BlYy5Bc3NlbWJseTtcbiAgLyoqXG4gICAqIEdlbmVyYXRlZCAuanMvLmQudHMgZmlsZShzKVxuICAgKi9cbiAgcmVhZG9ubHkgZmlsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFRoZSBwYWNrYWdlSW5mbyB1c2VkXG4gICAqL1xuICByZWFkb25seSBwYWNrYWdlSnNvbjogUGFja2FnZUpzb247XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHBpZWNlIG9mIHNvdXJjZSBhbmQgcmV0dXJuIHRoZSBhc3NlbWJseSBhbmQgY29tcGlsZWQgc291cmNlcyBmb3IgaXRcbiAqXG4gKiBPbmx5IHVzYWJsZSBmb3IgdHJpdmlhbCBjYXNlcyBhbmQgdGVzdHMuXG4gKlxuICogQHBhcmFtIHNvdXJjZSBjYW4gZWl0aGVyIGJlIGEgc2luZ2xlIGBzdHJpbmdgICh0aGUgY29udGVudCBvZiBgaW5kZXgudHNgKSwgb3JcbiAqICAgICAgICAgICAgICAgYSBtYXAgb2YgZmlsZU5hbWUgdG8gY29udGVudCwgd2hpY2ggKm11c3QqIGluY2x1ZGUgYGluZGV4LnRzYC5cbiAqIEBwYXJhbSBvcHRpb25zIGFjY2VwdHMgYSBjYWxsYmFjayBmb3IgaGlzdG9yaWNhbCByZWFzb25zIGJ1dCByZWFsbHkgZXhwZWN0cyB0b1xuICogICAgICAgICAgICAgICAgdGFrZSBhbiBvcHRpb25zIG9iamVjdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgc291cmNlOiBzdHJpbmcgfCB7ICdpbmRleC50cyc6IHN0cmluZzsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9LFxuICBvcHRpb25zPzogVGVzdENvbXBpbGF0aW9uT3B0aW9ucyB8ICgob2JqOiBQYWNrYWdlSnNvbikgPT4gdm9pZCksXG4gIGNvbXBpbGVyT3B0aW9ucz86IE9taXQ8Q29tcGlsZXJPcHRpb25zLCAncHJvamVjdEluZm8nIHwgJ3dhdGNoJz4sXG4pOiBQcm9taXNlPEhlbHBlckNvbXBpbGF0aW9uUmVzdWx0PiB7XG4gIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZSA9IHsgJ2luZGV4LnRzJzogc291cmNlIH07XG4gIH1cblxuICBjb25zdCBpblNvbWVMb2NhdGlvbiA9XG4gICAgaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMuY29tcGlsYXRpb25EaXJlY3RvcnlcbiAgICAgID8gaW5PdGhlckRpcihvcHRpb25zLmNvbXBpbGF0aW9uRGlyZWN0b3J5KVxuICAgICAgOiBpblRlbXBEaXI7XG5cbiAgLy8gRWFzaWVzdCB3YXkgdG8gZ2V0IHRoZSBzb3VyY2UgaW50byB0aGUgY29tcGlsZXIgaXMgdG8gd3JpdGUgaXQgdG8gZGlzayBzb21ld2hlcmUuXG4gIC8vIEkgZ3Vlc3Mgd2UgY291bGQgbWFrZSBhbiBpbi1tZW1vcnkgY29tcGlsZXIgaG9zdCBidXQgdGhhdCBzZWVtcyBsaWtlIHdvcmsuLi5cbiAgcmV0dXJuIGluU29tZUxvY2F0aW9uKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkubWFwKGFzeW5jIChbZmlsZU5hbWUsIGNvbnRlbnRdKSA9PiB7XG4gICAgICAgIGF3YWl0IGZzLm1rZGlycChwYXRoLmRpcm5hbWUoZmlsZU5hbWUpKTtcbiAgICAgICAgcmV0dXJuIGZzLndyaXRlRmlsZShmaWxlTmFtZSwgY29udGVudCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAgIH0pLFxuICAgICk7XG4gICAgY29uc3QgeyBwcm9qZWN0SW5mbywgcGFja2FnZUpzb24gfSA9IGF3YWl0IG1ha2VQcm9qZWN0SW5mbyhcbiAgICAgICdpbmRleC50cycsXG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdGlvbnNcbiAgICAgICAgOiAocGkpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHBpLFxuICAgICAgICAgICAgICBvcHRpb25zPy5wYWNrYWdlSnNvbiA/PyBvcHRpb25zPy5wcm9qZWN0SW5mbyA/PyB7fSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICApO1xuICAgIGNvbnN0IGNvbXBpbGVyID0gbmV3IENvbXBpbGVyKHtcbiAgICAgIHByb2plY3RJbmZvLFxuICAgICAgLi4uY29tcGlsZXJPcHRpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IGVtaXRSZXN1bHQgPSBhd2FpdCBjb21waWxlci5lbWl0KCk7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBlbWl0UmVzdWx0LmRpYWdub3N0aWNzLmZpbHRlcihcbiAgICAgIChkKSA9PiBkLmNhdGVnb3J5ID09PSBEaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IsXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgICAgY29uc29sZS5lcnJvcihmb3JtYXREaWFnbm9zdGljKGVycm9yLCBwcm9qZWN0SW5mby5wcm9qZWN0Um9vdCkpO1xuICAgICAgLy8gbG9nRGlhZ25vc3RpYygpIGRvZXNuJ3Qgd29yayBvdXQgb2YgdGhlIGJveCwgc28gY29uc29sZS5lcnJvcigpIGl0IGlzLlxuICAgIH1cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDAgfHwgZW1pdFJlc3VsdC5lbWl0U2tpcHBlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSB3ZXJlIGNvbXBpbGVyIGVycm9ycycpO1xuICAgIH1cbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGZzLnJlYWRKU09OKCcuanNpaScsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgY29uc3QgZmlsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAgIGZvciAoY29uc3QgZmlsZW5hbWUgb2YgT2JqZWN0LmtleXMoc291cmNlKSkge1xuICAgICAgbGV0IGpzRmlsZSA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcLnRzJC8sICcuanMnKTtcbiAgICAgIGxldCBkdHNGaWxlID0gZmlsZW5hbWUucmVwbGFjZSgvXFwudHMkLywgJy5kLnRzJyk7XG4gICAgICBpZiAocHJvamVjdEluZm8udHNjPy5vdXREaXIgJiYgZmlsZW5hbWUgIT09ICdSRUFETUUubWQnKSB7XG4gICAgICAgIGpzRmlsZSA9IHBhdGguam9pbihwcm9qZWN0SW5mby50c2Mub3V0RGlyLCBqc0ZpbGUpO1xuICAgICAgICBkdHNGaWxlID0gcGF0aC5qb2luKHByb2plY3RJbmZvLnRzYy5vdXREaXIsIGR0c0ZpbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgZmlsZXNbanNGaWxlXSA9IGF3YWl0IGZzLnJlYWRGaWxlKGpzRmlsZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICBmaWxlc1tkdHNGaWxlXSA9IGF3YWl0IGZzLnJlYWRGaWxlKGR0c0ZpbGUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG5cbiAgICAgIGNvbnN0IHdhcm5pbmdzRmlsZU5hbWUgPSAnLndhcm5pbmdzLmpzaWkuanMnO1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMod2FybmluZ3NGaWxlTmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgZmlsZXNbd2FybmluZ3NGaWxlTmFtZV0gPSBhd2FpdCBmcy5yZWFkRmlsZSh3YXJuaW5nc0ZpbGVOYW1lLCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGFzc2VtYmx5LCBmaWxlcywgcGFja2FnZUpzb24gfSBhcyBIZWxwZXJDb21waWxhdGlvblJlc3VsdDtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluVGVtcERpcjxUPihibG9jazogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICBjb25zdCBvcmlnRGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgY29uc3QgdG1wRGlyID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICdqc2lpJykpO1xuICBwcm9jZXNzLmNoZGlyKHRtcERpcik7XG4gIGNvbnN0IHJldCA9IGF3YWl0IGJsb2NrKCk7XG4gIHByb2Nlc3MuY2hkaXIob3JpZ0Rpcik7XG4gIGF3YWl0IGZzLnJlbW92ZSh0bXBEaXIpO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbk90aGVyRGlyKGRpcjogc3RyaW5nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1jb25zdHJhaW50XG4gIHJldHVybiBhc3luYyA8VCBleHRlbmRzIHVua25vd24+KGJsb2NrOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiA9PiB7XG4gICAgY29uc3Qgb3JpZ0RpciA9IHByb2Nlc3MuY3dkKCk7XG4gICAgcHJvY2Vzcy5jaGRpcihkaXIpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYmxvY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcHJvY2Vzcy5jaGRpcihvcmlnRGlyKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT2J0YWluIHByb2plY3QgaW5mbyBzbyB3ZSBjYW4gY2FsbCB0aGUgY29tcGlsZXJcbiAqXG4gKiBDcmVhdGluZyB0aGlzIGRpcmVjdGx5IGluLW1lbW9yeSBsZWFkcyB0byBzbGlnaHRseSBkaWZmZXJlbnQgYmVoYXZpb3IgZnJvbSBjYWxsaW5nXG4gKiBqc2lpIGZyb20gdGhlIGNvbW1hbmQtbGluZSwgYW5kIEkgZG9uJ3Qgd2FudCB0byBmaWd1cmUgb3V0IHJpZ2h0IG5vdy5cbiAqXG4gKiBNb3N0IGNvbnNpc3RlbnQgYmVoYXZpb3Igc2VlbXMgdG8gYmUgdG8gd3JpdGUgYSBwYWNrYWdlLmpzb24gdG8gZGlzayBhbmRcbiAqIHRoZW4gY2FsbGluZyB0aGUgc2FtZSBmdW5jdGlvbnMgYXMgdGhlIENMSSB3b3VsZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWFrZVByb2plY3RJbmZvKFxuICB0eXBlczogc3RyaW5nLFxuICBjYj86IChvYmo6IFBhY2thZ2VKc29uKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZCxcbik6IFByb21pc2U8eyBwcm9qZWN0SW5mbzogUHJvamVjdEluZm87IHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiB9PiB7XG4gIGNvbnN0IHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiA9IHtcbiAgICB0eXBlcyxcbiAgICBtYWluOiB0eXBlcy5yZXBsYWNlKC8oPzpcXC5kKT9cXC50cyh4PykvLCAnLmpzJDEnKSxcbiAgICBuYW1lOiAndGVzdHBrZycsIC8vIFRoYXQncyB3aGF0IHBhY2thZ2UuanNvbiB3b3VsZCB0ZWxsIGlmIHdlIGxvb2sgdXAuLi5cbiAgICB2ZXJzaW9uOiAnMC4wLjEnLFxuICAgIGxpY2Vuc2U6ICdBcGFjaGUtMi4wJyxcbiAgICBhdXRob3I6IHsgbmFtZTogJ0pvaG4gRG9lJyB9LFxuICAgIHJlcG9zaXRvcnk6IHsgdHlwZTogJ2dpdCcsIHVybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS5naXQnIH0sXG4gICAganNpaToge30sXG4gIH07XG5cbiAgaWYgKGNiKSB7XG4gICAgYXdhaXQgY2IocGFja2FnZUpzb24pO1xuICB9XG5cbiAgYXdhaXQgZnMud3JpdGVKc29uKCdwYWNrYWdlLmpzb24nLCBwYWNrYWdlSnNvbiwge1xuICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgIHJlcGxhY2VyOiAoXzogc3RyaW5nLCB2OiBhbnkpID0+IHYsXG4gICAgc3BhY2VzOiAyLFxuICB9KTtcblxuICBjb25zdCB7IHByb2plY3RJbmZvIH0gPSBhd2FpdCBsb2FkUHJvamVjdEluZm8oXG4gICAgcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICcuJyksXG4gICk7XG4gIHJldHVybiB7IHByb2plY3RJbmZvLCBwYWNrYWdlSnNvbiB9O1xufVxuZXhwb3J0IGludGVyZmFjZSBUZXN0Q29tcGlsYXRpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RvcnkgaW4gd2hpY2ggd2Ugd3JpdGUgYW5kIGNvbXBpbGUgdGhlIGZpbGVzXG4gICAqL1xuICByZWFkb25seSBjb21waWxhdGlvbkRpcmVjdG9yeT86IHN0cmluZztcblxuICAvKipcbiAgICogUGFydHMgb2YgcHJvamVjdEluZm8gdG8gb3ZlcnJpZGUgKHBhY2thZ2UgbmFtZSBldGMpXG4gICAqL1xuICByZWFkb25seSBwcm9qZWN0SW5mbz86IFBhcnRpYWw8UGFja2FnZUpzb24+O1xuXG4gIC8qKlxuICAgKiBQYXJ0cyBvZiBwcm9qZWN0SW5mbyB0byBvdmVycmlkZSAocGFja2FnZSBuYW1lIGV0YylcbiAgICovXG4gIHJlYWRvbmx5IHBhY2thZ2VKc29uPzogUGFydGlhbDxQYWNrYWdlSnNvbj47XG59XG5cbmZ1bmN0aW9uIGlzT3B0aW9uc09iamVjdChcbiAgeDogVGVzdENvbXBpbGF0aW9uT3B0aW9ucyB8ICgob2JqOiBQYWNrYWdlSnNvbikgPT4gdm9pZCkgfCB1bmRlZmluZWQsXG4pOiB4IGlzIFRlc3RDb21waWxhdGlvbk9wdGlvbnMge1xuICByZXR1cm4geCA/IHR5cGVvZiB4ID09PSAnb2JqZWN0JyA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEFuIE5QTS1yZWFkeSB3b3Jrc3BhY2Ugd2hlcmUgd2UgY2FuIGluc3RhbGwgdGVzdC1jb21waWxlIGRlcGVuZGVuY2llcyBhbmQgY29tcGlsZSBuZXcgYXNzZW1ibGllc1xuICovXG5leHBvcnQgY2xhc3MgVGVzdFdvcmtzcGFjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgd29ya3NwYWNlLlxuICAgKlxuICAgKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeSwgZG9uJ3QgZm9yZ2V0IHRvIGNhbGwgY2xlYW5VcFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBjcmVhdGUoKTogUHJvbWlzZTxUZXN0V29ya3NwYWNlPiB7XG4gICAgY29uc3QgdG1wRGlyID0gYXdhaXQgZnMubWtkdGVtcChcbiAgICAgIHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2pzaWktdGVzdHdvcmtzcGFjZScpLFxuICAgICk7XG4gICAgYXdhaXQgZnMuZW5zdXJlRGlyKHRtcERpcik7XG4gICAgcmV0dXJuIG5ldyBUZXN0V29ya3NwYWNlKHRtcERpcik7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGJsb2NrIHdpdGggYSB0ZW1wb3Jhcnkgd29ya3NwYWNlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIHdpdGhXb3Jrc3BhY2U8QT4oXG4gICAgYmxvY2s6ICh3czogVGVzdFdvcmtzcGFjZSkgPT4gQSB8IFByb21pc2U8QT4sXG4gICk6IFByb21pc2U8QT4ge1xuICAgIGNvbnN0IHdzID0gYXdhaXQgVGVzdFdvcmtzcGFjZS5jcmVhdGUoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGJsb2NrKHdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgd3MuY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgaW5zdGFsbGVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgcm9vdERpcmVjdG9yeTogc3RyaW5nKSB7fVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0ZXN0LWNvbXBpbGVkIGpzaWkgYXNzZW1ibHkgYXMgYSBkZXBlbmRlbmN5XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYWRkRGVwZW5kZW5jeShkZXBlbmRlbmN5QXNzZW1ibHk6IEhlbHBlckNvbXBpbGF0aW9uUmVzdWx0KSB7XG4gICAgaWYgKHRoaXMuaW5zdGFsbGVkLmhhcyhkZXBlbmRlbmN5QXNzZW1ibHkuYXNzZW1ibHkubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEEgZGVwZW5kZW5jeSB3aXRoIG5hbWUgJyR7ZGVwZW5kZW5jeUFzc2VtYmx5LmFzc2VtYmx5Lm5hbWV9JyB3YXMgYWxyZWFkeSBpbnN0YWxsZWQuIEdpdmUgb25lIGEgZGlmZmVyZW50IG5hbWUuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuaW5zdGFsbGVkLmFkZChkZXBlbmRlbmN5QXNzZW1ibHkuYXNzZW1ibHkubmFtZSk7XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHNpbGx5LCBob3dldmVyOiB0aGUgaGVscGVyIGhhcyBjb21waWxlZCB0aGUgZ2l2ZW4gc291cmNlIHRvXG4gICAgLy8gYW4gYXNzZW1ibHksIGFuZCBvdXRwdXQgZmlsZXMsIGFuZCB0aGVuIHJlbW92ZWQgdGhlaXIgdHJhY2VzIGZyb20gZGlzay5cbiAgICAvLyBXZSBuZWVkIHRob3NlIGZpbGVzIGJhY2sgb24gZGlzaywgc28gd3JpdGUgdGhlbSBiYWNrIG91dCBhZ2Fpbi5cbiAgICAvL1xuICAgIC8vIFdlIHdpbGwgZHJvcCB0aGVtIGluICdub2RlX21vZHVsZXMvPG5hbWU+JyBzbyB0aGV5IGNhbiBiZSBpbXBvcnRlZFxuICAgIC8vIGFzIGlmIHRoZXkgd2VyZSBpbnN0YWxsZWQuXG4gICAgY29uc3QgbW9kRGlyID0gcGF0aC5qb2luKFxuICAgICAgdGhpcy5yb290RGlyZWN0b3J5LFxuICAgICAgJ25vZGVfbW9kdWxlcycsXG4gICAgICBkZXBlbmRlbmN5QXNzZW1ibHkuYXNzZW1ibHkubmFtZSxcbiAgICApO1xuICAgIGF3YWl0IGZzLmVuc3VyZURpcihtb2REaXIpO1xuXG4gICAgYXdhaXQgZnMud3JpdGVKU09OKHBhdGguam9pbihtb2REaXIsICcuanNpaScpLCBkZXBlbmRlbmN5QXNzZW1ibHkuYXNzZW1ibHkpO1xuICAgIGF3YWl0IGZzLndyaXRlSlNPTihcbiAgICAgIHBhdGguam9pbihtb2REaXIsICdwYWNrYWdlLmpzb24nKSxcbiAgICAgIGRlcGVuZGVuY3lBc3NlbWJseS5wYWNrYWdlSnNvbixcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBbZmlsZU5hbWUsIGZpbGVDb250ZW50c10gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICBkZXBlbmRlbmN5QXNzZW1ibHkuZmlsZXMsXG4gICAgKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgIGF3YWl0IGZzLmVuc3VyZURpcihwYXRoLmRpcm5hbWUocGF0aC5qb2luKG1vZERpciwgZmlsZU5hbWUpKSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHBhdGguam9pbihtb2REaXIsIGZpbGVOYW1lKSwgZmlsZUNvbnRlbnRzKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVwZW5kZW5jeURpcihuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuaW5zdGFsbGVkLmhhcyhuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXBlbmRlbmN5IHdpdGggbmFtZSAnJHtuYW1lfScgaGFzIGJlZW4gaW5zdGFsbGVkYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLmpvaW4odGhpcy5yb290RGlyZWN0b3J5LCAnbm9kZV9tb2R1bGVzJywgbmFtZSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYW51cCgpIHtcbiAgICBhd2FpdCBmcy5yZW1vdmUodGhpcy5yb290RGlyZWN0b3J5KTtcbiAgfVxufVxuXG4vLyBBbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmV4cG9ydCB0eXBlIFBhY2thZ2VJbmZvID0gUGFja2FnZUpzb247XG4iXX0=