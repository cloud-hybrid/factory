"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findUp = exports.findPackageJsonUp = exports.findDependencyDirectory = exports.parseRepository = exports.parsePerson = exports.logDiagnostic = exports._formatDiagnostic = exports.formatDiagnostic = exports.diagnosticsLogger = exports.JSII_DIAGNOSTICS_CODE = exports.DIAGNOSTICS = void 0;
const fs = require("fs-extra");
const log4js = require("log4js");
const path = require("path");
const ts = require("typescript");
const jsii_diagnostic_1 = require("./jsii-diagnostic");
/**
 * Name of the logger for diagnostics information
 */
exports.DIAGNOSTICS = 'diagnostics';
/**
 * Diagnostic code for JSII-generated messages.
 */
exports.JSII_DIAGNOSTICS_CODE = 9999;
/**
 * Obtains the relevant logger to be used for a given diagnostic message.
 *
 * @param logger     the ``log4js.Logger`` to use for emitting the message.
 * @param diagnostic the message for which a logger is requested.
 *
 * @returns a logger method of the ``logger`` for the appropriate level.
 */
function diagnosticsLogger(logger, diagnostic) {
    switch (diagnostic.category) {
        case ts.DiagnosticCategory.Error:
            if (!logger.isErrorEnabled()) {
                return undefined;
            }
            return logger.error.bind(logger);
        case ts.DiagnosticCategory.Warning:
            if (!logger.isWarnEnabled()) {
                return undefined;
            }
            return logger.warn.bind(logger);
        case ts.DiagnosticCategory.Message:
            if (!logger.isDebugEnabled()) {
                return undefined;
            }
            return logger.debug.bind(logger);
        case ts.DiagnosticCategory.Suggestion:
        default:
            if (!logger.isTraceEnabled()) {
                return undefined;
            }
            return logger.trace.bind(logger);
    }
}
exports.diagnosticsLogger = diagnosticsLogger;
/**
 * Formats a diagnostic message with color and context, if possible.
 *
 * @param diagnostic  the diagnostic message ot be formatted.
 * @param projectRoot the root of the TypeScript project.
 *
 * @returns a formatted string.
 */
function formatDiagnostic(diagnostic, projectRoot) {
    if (jsii_diagnostic_1.JsiiDiagnostic.isJsiiDiagnostic(diagnostic)) {
        // Ensure we leverage pre-rendered diagnostics where available.
        return diagnostic.format(projectRoot);
    }
    return _formatDiagnostic(diagnostic, projectRoot);
}
exports.formatDiagnostic = formatDiagnostic;
/**
 * Formats a diagnostic message with color and context, if possible. Users
 * should use `formatDiagnostic` instead, as this implementation is inteded for
 * internal usafe only.
 *
 * @param diagnostic  the diagnostic message ot be formatted.
 * @param projectRoot the root of the TypeScript project.
 *
 * @returns a formatted string.
 */
function _formatDiagnostic(diagnostic, projectRoot) {
    const formatDiagnosticsHost = {
        getCurrentDirectory: () => projectRoot,
        getCanonicalFileName: (fileName) => fileName,
        getNewLine: () => ts.sys.newLine,
    };
    const message = diagnostic.file != null
        ? ts.formatDiagnosticsWithColorAndContext([diagnostic], formatDiagnosticsHost)
        : ts.formatDiagnostic(diagnostic, formatDiagnosticsHost);
    if (!jsii_diagnostic_1.JsiiDiagnostic.isJsiiDiagnostic(diagnostic)) {
        return message;
    }
    // This is our own diagnostics, so we'll format appropriately (replacing TS#### with JSII####).
    return message.replace(` TS${exports.JSII_DIAGNOSTICS_CODE}: `, ` JSII${diagnostic.jsiiCode}: `);
}
exports._formatDiagnostic = _formatDiagnostic;
function logDiagnostic(diagnostic, projectRoot) {
    const logFunc = diagnosticsLogger(log4js.getLogger(exports.DIAGNOSTICS), diagnostic);
    if (!logFunc) {
        return;
    }
    logFunc(formatDiagnostic(diagnostic, projectRoot).trim());
}
exports.logDiagnostic = logDiagnostic;
const PERSON_REGEX = /^\s*(.+?)(?:\s*<([^>]+)>)?(?:\s*\(([^)]+)\))?\s*$/;
/**
 * Parses a string-formatted person entry from `package.json`.
 * @param value the string-formatted person entry.
 *
 * @example
 *  parsePerson("Barney Rubble <b@rubble.com> (http://barnyrubble.tumblr.com/)");
 *  // => { name: "Barney Rubble", email: "b@rubble.com", url: "http://barnyrubble.tumblr.com/" }
 */
function parsePerson(value) {
    const match = PERSON_REGEX.exec(value);
    if (!match) {
        throw new Error(`Invalid stringified "person" value: ${value}`);
    }
    const [, name, email, url] = match;
    const result = {
        name: name.trim(),
    };
    if (email) {
        result.email = email.trim();
    }
    if (url) {
        result.url = url.trim();
    }
    return result;
}
exports.parsePerson = parsePerson;
const REPOSITORY_REGEX = /^(?:(github|gist|bitbucket|gitlab):)?([A-Za-z\d_-]+\/[A-Za-z\d_-]+)$/;
function parseRepository(value) {
    const match = REPOSITORY_REGEX.exec(value);
    if (!match) {
        return { url: value };
    }
    const [, host, slug] = match;
    switch (host !== null && host !== void 0 ? host : 'github') {
        case 'github':
            return { url: `https://github.com/${slug}.git` };
        case 'gist':
            return { url: `https://gist.github.com/${slug}.git` };
        case 'bitbucket':
            return { url: `https://bitbucket.org/${slug}.git` };
        case 'gitlab':
            return { url: `https://gitlab.com/${slug}.git` };
        default:
            throw new Error(`Unknown host service: ${host}`);
    }
}
exports.parseRepository = parseRepository;
/**
 * Find the directory that contains a given dependency, identified by its 'package.json', from a starting search directory
 *
 * (This code is duplicated among jsii/jsii-pacmak/jsii-reflect. Changes should be done in all
 * 3 locations, and we should unify these at some point: https://github.com/aws/jsii/issues/3236)
 */
async function findDependencyDirectory(dependencyName, searchStart) {
    // Explicitly do not use 'require("dep/package.json")' because that will fail if the
    // package does not export that particular file.
    const entryPoint = require.resolve(dependencyName, {
        paths: [searchStart],
    });
    // Search up from the given directory, looking for a package.json that matches
    // the dependency name (so we don't accidentally find stray 'package.jsons').
    const depPkgJsonPath = await findPackageJsonUp(dependencyName, path.dirname(entryPoint));
    if (!depPkgJsonPath) {
        throw new Error(`Could not find dependency '${dependencyName}' from '${searchStart}'`);
    }
    return depPkgJsonPath;
}
exports.findDependencyDirectory = findDependencyDirectory;
/**
 * Find the package.json for a given package upwards from the given directory
 *
 * (This code is duplicated among jsii/jsii-pacmak/jsii-reflect. Changes should be done in all
 * 3 locations, and we should unify these at some point: https://github.com/aws/jsii/issues/3236)
 */
async function findPackageJsonUp(packageName, directory) {
    return findUp(directory, async (dir) => {
        const pjFile = path.join(dir, 'package.json');
        return ((await fs.pathExists(pjFile)) &&
            (await fs.readJson(pjFile)).name === packageName);
    });
}
exports.findPackageJsonUp = findPackageJsonUp;
// eslint-disable-next-line @typescript-eslint/promise-function-async
function findUp(directory, pred) {
    const result = pred(directory);
    if (isPromise(result)) {
        return result.then((thisDirectory) => thisDirectory ? directory : recurse());
    }
    return result ? directory : recurse();
    function recurse() {
        const parent = path.dirname(directory);
        if (parent === directory) {
            return undefined;
        }
        return findUp(parent, pred);
    }
}
exports.findUp = findUp;
function isPromise(x) {
    return typeof x === 'object' && x.then;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ1dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFFakMsdURBQW1EO0FBRW5EOztHQUVHO0FBQ1UsUUFBQSxXQUFXLEdBQUcsYUFBYSxDQUFDO0FBQ3pDOztHQUVHO0FBQ1UsUUFBQSxxQkFBcUIsR0FBRyxJQUFJLENBQUM7QUFFMUM7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLGlCQUFpQixDQUMvQixNQUFxQixFQUNyQixVQUF5QjtJQUV6QixRQUFRLFVBQVUsQ0FBQyxRQUFRLEVBQUU7UUFDM0IsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsS0FBSztZQUM5QixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxFQUFFO2dCQUM1QixPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTztZQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFFO2dCQUMzQixPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbEMsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTztZQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxFQUFFO2dCQUM1QixPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDO1FBQ3RDO1lBQ0UsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFj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LE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUN4QixPQUFPLFNBQVMsQ0FBQztTQUNsQjtRQUNELE9BQU8sTUFBTSxDQUFDLE1BQU0sRUFBRSxJQUFXLENBQUMsQ0FBQztJQUNyQyxDQUFDO0FBQ0gsQ0FBQztBQXBCRCx3QkFvQkM7QUFFRCxTQUFTLFNBQVMsQ0FBSSxDQUFpQjtJQUNyQyxPQUFPLE9BQU8sQ0FBQyxLQUFLLFFBQVEsSUFBSyxDQUFTLENBQUMsSUFBSSxDQUFDO0FBQ2xELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBsb2c0anMgZnJvbSAnbG9nNGpzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHsgSnNpaURpYWdub3N0aWMgfSBmcm9tICcuL2pzaWktZGlhZ25vc3RpYyc7XG5cbi8qKlxuICogTmFtZSBvZiB0aGUgbG9nZ2VyIGZvciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgY29uc3QgRElBR05PU1RJQ1MgPSAnZGlhZ25vc3RpY3MnO1xuLyoqXG4gKiBEaWFnbm9zdGljIGNvZGUgZm9yIEpTSUktZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgY29uc3QgSlNJSV9ESUFHTk9TVElDU19DT0RFID0gOTk5OTtcblxuLyoqXG4gKiBPYnRhaW5zIHRoZSByZWxldmFudCBsb2dnZXIgdG8gYmUgdXNlZCBmb3IgYSBnaXZlbiBkaWFnbm9zdGljIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGxvZ2dlciAgICAgdGhlIGBgbG9nNGpzLkxvZ2dlcmBgIHRvIHVzZSBmb3IgZW1pdHRpbmcgdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gZGlhZ25vc3RpYyB0aGUgbWVzc2FnZSBmb3Igd2hpY2ggYSBsb2dnZXIgaXMgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm5zIGEgbG9nZ2VyIG1ldGhvZCBvZiB0aGUgYGBsb2dnZXJgYCBmb3IgdGhlIGFwcHJvcHJpYXRlIGxldmVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlhZ25vc3RpY3NMb2dnZXIoXG4gIGxvZ2dlcjogbG9nNGpzLkxvZ2dlcixcbiAgZGlhZ25vc3RpYzogdHMuRGlhZ25vc3RpYyxcbik6ICgobWVzc2FnZTogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCkgfCB1bmRlZmluZWQge1xuICBzd2l0Y2ggKGRpYWdub3N0aWMuY2F0ZWdvcnkpIHtcbiAgICBjYXNlIHRzLkRpYWdub3N0aWNDYXRlZ29yeS5FcnJvcjpcbiAgICAgIGlmICghbG9nZ2VyLmlzRXJyb3JFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2dnZXIuZXJyb3IuYmluZChsb2dnZXIpO1xuICAgIGNhc2UgdHMuRGlhZ25vc3RpY0NhdGVnb3J5Lldhcm5pbmc6XG4gICAgICBpZiAoIWxvZ2dlci5pc1dhcm5FbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlcik7XG4gICAgY2FzZSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuTWVzc2FnZTpcbiAgICAgIGlmICghbG9nZ2VyLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2dnZXIuZGVidWcuYmluZChsb2dnZXIpO1xuICAgIGNhc2UgdHMuRGlhZ25vc3RpY0NhdGVnb3J5LlN1Z2dlc3Rpb246XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICghbG9nZ2VyLmlzVHJhY2VFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2dnZXIudHJhY2UuYmluZChsb2dnZXIpO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0cyBhIGRpYWdub3N0aWMgbWVzc2FnZSB3aXRoIGNvbG9yIGFuZCBjb250ZXh0LCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0gZGlhZ25vc3RpYyAgdGhlIGRpYWdub3N0aWMgbWVzc2FnZSBvdCBiZSBmb3JtYXR0ZWQuXG4gKiBAcGFyYW0gcHJvamVjdFJvb3QgdGhlIHJvb3Qgb2YgdGhlIFR5cGVTY3JpcHQgcHJvamVjdC5cbiAqXG4gKiBAcmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREaWFnbm9zdGljKFxuICBkaWFnbm9zdGljOiB0cy5EaWFnbm9zdGljLFxuICBwcm9qZWN0Um9vdDogc3RyaW5nLFxuKSB7XG4gIGlmIChKc2lpRGlhZ25vc3RpYy5pc0pzaWlEaWFnbm9zdGljKGRpYWdub3N0aWMpKSB7XG4gICAgLy8gRW5zdXJlIHdlIGxldmVyYWdlIHByZS1yZW5kZXJlZCBkaWFnbm9zdGljcyB3aGVyZSBhdmFpbGFibGUuXG4gICAgcmV0dXJuIGRpYWdub3N0aWMuZm9ybWF0KHByb2plY3RSb290KTtcbiAgfVxuICByZXR1cm4gX2Zvcm1hdERpYWdub3N0aWMoZGlhZ25vc3RpYywgcHJvamVjdFJvb3QpO1xufVxuXG4vKipcbiAqIEZvcm1hdHMgYSBkaWFnbm9zdGljIG1lc3NhZ2Ugd2l0aCBjb2xvciBhbmQgY29udGV4dCwgaWYgcG9zc2libGUuIFVzZXJzXG4gKiBzaG91bGQgdXNlIGBmb3JtYXREaWFnbm9zdGljYCBpbnN0ZWFkLCBhcyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGludGVkZWQgZm9yXG4gKiBpbnRlcm5hbCB1c2FmZSBvbmx5LlxuICpcbiAqIEBwYXJhbSBkaWFnbm9zdGljICB0aGUgZGlhZ25vc3RpYyBtZXNzYWdlIG90IGJlIGZvcm1hdHRlZC5cbiAqIEBwYXJhbSBwcm9qZWN0Um9vdCB0aGUgcm9vdCBvZiB0aGUgVHlwZVNjcmlwdCBwcm9qZWN0LlxuICpcbiAqIEByZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9mb3JtYXREaWFnbm9zdGljKFxuICBkaWFnbm9zdGljOiB0cy5EaWFnbm9zdGljLFxuICBwcm9qZWN0Um9vdDogc3RyaW5nLFxuKSB7XG4gIGNvbnN0IGZvcm1hdERpYWdub3N0aWNzSG9zdDogdHMuRm9ybWF0RGlhZ25vc3RpY3NIb3N0ID0ge1xuICAgIGdldEN1cnJlbnREaXJlY3Rvcnk6ICgpID0+IHByb2plY3RSb290LFxuICAgIGdldENhbm9uaWNhbEZpbGVOYW1lOiAoZmlsZU5hbWUpID0+IGZpbGVOYW1lLFxuICAgIGdldE5ld0xpbmU6ICgpID0+IHRzLnN5cy5uZXdMaW5lLFxuICB9O1xuXG4gIGNvbnN0IG1lc3NhZ2UgPVxuICAgIGRpYWdub3N0aWMuZmlsZSAhPSBudWxsXG4gICAgICA/IHRzLmZvcm1hdERpYWdub3N0aWNzV2l0aENvbG9yQW5kQ29udGV4dChcbiAgICAgICAgICBbZGlhZ25vc3RpY10sXG4gICAgICAgICAgZm9ybWF0RGlhZ25vc3RpY3NIb3N0LFxuICAgICAgICApXG4gICAgICA6IHRzLmZvcm1hdERpYWdub3N0aWMoZGlhZ25vc3RpYywgZm9ybWF0RGlhZ25vc3RpY3NIb3N0KTtcblxuICBpZiAoIUpzaWlEaWFnbm9zdGljLmlzSnNpaURpYWdub3N0aWMoZGlhZ25vc3RpYykpIHtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgb3VyIG93biBkaWFnbm9zdGljcywgc28gd2UnbGwgZm9ybWF0IGFwcHJvcHJpYXRlbHkgKHJlcGxhY2luZyBUUyMjIyMgd2l0aCBKU0lJIyMjIykuXG4gIHJldHVybiBtZXNzYWdlLnJlcGxhY2UoXG4gICAgYCBUUyR7SlNJSV9ESUFHTk9TVElDU19DT0RFfTogYCxcbiAgICBgIEpTSUkke2RpYWdub3N0aWMuanNpaUNvZGV9OiBgLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nRGlhZ25vc3RpYyhkaWFnbm9zdGljOiB0cy5EaWFnbm9zdGljLCBwcm9qZWN0Um9vdDogc3RyaW5nKSB7XG4gIGNvbnN0IGxvZ0Z1bmMgPSBkaWFnbm9zdGljc0xvZ2dlcihsb2c0anMuZ2V0TG9nZ2VyKERJQUdOT1NUSUNTKSwgZGlhZ25vc3RpYyk7XG4gIGlmICghbG9nRnVuYykge1xuICAgIHJldHVybjtcbiAgfVxuICBsb2dGdW5jKGZvcm1hdERpYWdub3N0aWMoZGlhZ25vc3RpYywgcHJvamVjdFJvb3QpLnRyaW0oKSk7XG59XG5cbmNvbnN0IFBFUlNPTl9SRUdFWCA9IC9eXFxzKiguKz8pKD86XFxzKjwoW14+XSspPik/KD86XFxzKlxcKChbXildKylcXCkpP1xccyokLztcbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nLWZvcm1hdHRlZCBwZXJzb24gZW50cnkgZnJvbSBgcGFja2FnZS5qc29uYC5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgc3RyaW5nLWZvcm1hdHRlZCBwZXJzb24gZW50cnkuXG4gKlxuICogQGV4YW1wbGVcbiAqICBwYXJzZVBlcnNvbihcIkJhcm5leSBSdWJibGUgPGJAcnViYmxlLmNvbT4gKGh0dHA6Ly9iYXJueXJ1YmJsZS50dW1ibHIuY29tLylcIik7XG4gKiAgLy8gPT4geyBuYW1lOiBcIkJhcm5leSBSdWJibGVcIiwgZW1haWw6IFwiYkBydWJibGUuY29tXCIsIHVybDogXCJodHRwOi8vYmFybnlydWJibGUudHVtYmxyLmNvbS9cIiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBlcnNvbih2YWx1ZTogc3RyaW5nKSB7XG4gIGNvbnN0IG1hdGNoID0gUEVSU09OX1JFR0VYLmV4ZWModmFsdWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmluZ2lmaWVkIFwicGVyc29uXCIgdmFsdWU6ICR7dmFsdWV9YCk7XG4gIH1cbiAgY29uc3QgWywgbmFtZSwgZW1haWwsIHVybF0gPSBtYXRjaDtcbiAgY29uc3QgcmVzdWx0OiB7IG5hbWU6IHN0cmluZzsgZW1haWw/OiBzdHJpbmc7IHVybD86IHN0cmluZyB9ID0ge1xuICAgIG5hbWU6IG5hbWUudHJpbSgpLFxuICB9O1xuICBpZiAoZW1haWwpIHtcbiAgICByZXN1bHQuZW1haWwgPSBlbWFpbC50cmltKCk7XG4gIH1cbiAgaWYgKHVybCkge1xuICAgIHJlc3VsdC51cmwgPSB1cmwudHJpbSgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IFJFUE9TSVRPUllfUkVHRVggPVxuICAvXig/OihnaXRodWJ8Z2lzdHxiaXRidWNrZXR8Z2l0bGFiKTopPyhbQS1aYS16XFxkXy1dK1xcL1tBLVphLXpcXGRfLV0rKSQvO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVwb3NpdG9yeSh2YWx1ZTogc3RyaW5nKTogeyB1cmw6IHN0cmluZyB9IHtcbiAgY29uc3QgbWF0Y2ggPSBSRVBPU0lUT1JZX1JFR0VYLmV4ZWModmFsdWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHsgdXJsOiB2YWx1ZSB9O1xuICB9XG4gIGNvbnN0IFssIGhvc3QsIHNsdWddID0gbWF0Y2g7XG4gIHN3aXRjaCAoaG9zdCA/PyAnZ2l0aHViJykge1xuICAgIGNhc2UgJ2dpdGh1Yic6XG4gICAgICByZXR1cm4geyB1cmw6IGBodHRwczovL2dpdGh1Yi5jb20vJHtzbHVnfS5naXRgIH07XG4gICAgY2FzZSAnZ2lzdCc6XG4gICAgICByZXR1cm4geyB1cmw6IGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke3NsdWd9LmdpdGAgfTtcbiAgICBjYXNlICdiaXRidWNrZXQnOlxuICAgICAgcmV0dXJuIHsgdXJsOiBgaHR0cHM6Ly9iaXRidWNrZXQub3JnLyR7c2x1Z30uZ2l0YCB9O1xuICAgIGNhc2UgJ2dpdGxhYic6XG4gICAgICByZXR1cm4geyB1cmw6IGBodHRwczovL2dpdGxhYi5jb20vJHtzbHVnfS5naXRgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBob3N0IHNlcnZpY2U6ICR7aG9zdH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGEgZ2l2ZW4gZGVwZW5kZW5jeSwgaWRlbnRpZmllZCBieSBpdHMgJ3BhY2thZ2UuanNvbicsIGZyb20gYSBzdGFydGluZyBzZWFyY2ggZGlyZWN0b3J5XG4gKlxuICogKFRoaXMgY29kZSBpcyBkdXBsaWNhdGVkIGFtb25nIGpzaWkvanNpaS1wYWNtYWsvanNpaS1yZWZsZWN0LiBDaGFuZ2VzIHNob3VsZCBiZSBkb25lIGluIGFsbFxuICogMyBsb2NhdGlvbnMsIGFuZCB3ZSBzaG91bGQgdW5pZnkgdGhlc2UgYXQgc29tZSBwb2ludDogaHR0cHM6Ly9naXRodWIuY29tL2F3cy9qc2lpL2lzc3Vlcy8zMjM2KVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluZERlcGVuZGVuY3lEaXJlY3RvcnkoXG4gIGRlcGVuZGVuY3lOYW1lOiBzdHJpbmcsXG4gIHNlYXJjaFN0YXJ0OiBzdHJpbmcsXG4pIHtcbiAgLy8gRXhwbGljaXRseSBkbyBub3QgdXNlICdyZXF1aXJlKFwiZGVwL3BhY2thZ2UuanNvblwiKScgYmVjYXVzZSB0aGF0IHdpbGwgZmFpbCBpZiB0aGVcbiAgLy8gcGFja2FnZSBkb2VzIG5vdCBleHBvcnQgdGhhdCBwYXJ0aWN1bGFyIGZpbGUuXG4gIGNvbnN0IGVudHJ5UG9pbnQgPSByZXF1aXJlLnJlc29sdmUoZGVwZW5kZW5jeU5hbWUsIHtcbiAgICBwYXRoczogW3NlYXJjaFN0YXJ0XSxcbiAgfSk7XG5cbiAgLy8gU2VhcmNoIHVwIGZyb20gdGhlIGdpdmVuIGRpcmVjdG9yeSwgbG9va2luZyBmb3IgYSBwYWNrYWdlLmpzb24gdGhhdCBtYXRjaGVzXG4gIC8vIHRoZSBkZXBlbmRlbmN5IG5hbWUgKHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBmaW5kIHN0cmF5ICdwYWNrYWdlLmpzb25zJykuXG4gIGNvbnN0IGRlcFBrZ0pzb25QYXRoID0gYXdhaXQgZmluZFBhY2thZ2VKc29uVXAoXG4gICAgZGVwZW5kZW5jeU5hbWUsXG4gICAgcGF0aC5kaXJuYW1lKGVudHJ5UG9pbnQpLFxuICApO1xuXG4gIGlmICghZGVwUGtnSnNvblBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ291bGQgbm90IGZpbmQgZGVwZW5kZW5jeSAnJHtkZXBlbmRlbmN5TmFtZX0nIGZyb20gJyR7c2VhcmNoU3RhcnR9J2AsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBkZXBQa2dKc29uUGF0aDtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBwYWNrYWdlLmpzb24gZm9yIGEgZ2l2ZW4gcGFja2FnZSB1cHdhcmRzIGZyb20gdGhlIGdpdmVuIGRpcmVjdG9yeVxuICpcbiAqIChUaGlzIGNvZGUgaXMgZHVwbGljYXRlZCBhbW9uZyBqc2lpL2pzaWktcGFjbWFrL2pzaWktcmVmbGVjdC4gQ2hhbmdlcyBzaG91bGQgYmUgZG9uZSBpbiBhbGxcbiAqIDMgbG9jYXRpb25zLCBhbmQgd2Ugc2hvdWxkIHVuaWZ5IHRoZXNlIGF0IHNvbWUgcG9pbnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9pc3N1ZXMvMzIzNilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbmRQYWNrYWdlSnNvblVwKFxuICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuICBkaXJlY3Rvcnk6IHN0cmluZyxcbikge1xuICByZXR1cm4gZmluZFVwKGRpcmVjdG9yeSwgYXN5bmMgKGRpcikgPT4ge1xuICAgIGNvbnN0IHBqRmlsZSA9IHBhdGguam9pbihkaXIsICdwYWNrYWdlLmpzb24nKTtcbiAgICByZXR1cm4gKFxuICAgICAgKGF3YWl0IGZzLnBhdGhFeGlzdHMocGpGaWxlKSkgJiZcbiAgICAgIChhd2FpdCBmcy5yZWFkSnNvbihwakZpbGUpKS5uYW1lID09PSBwYWNrYWdlTmFtZVxuICAgICk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEZpbmQgYSBkaXJlY3RvcnkgdXAgdGhlIHRyZWUgZnJvbSBhIHN0YXJ0aW5nIGRpcmVjdG9yeSBtYXRjaGluZyBhIGNvbmRpdGlvblxuICpcbiAqIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmIG5vIGRpcmVjdG9yeSBtYXRjaGVzXG4gKlxuICogKFRoaXMgY29kZSBpcyBkdXBsaWNhdGVkIGFtb25nIGpzaWkvanNpaS1wYWNtYWsvanNpaS1yZWZsZWN0LiBDaGFuZ2VzIHNob3VsZCBiZSBkb25lIGluIGFsbFxuICogMyBsb2NhdGlvbnMsIGFuZCB3ZSBzaG91bGQgdW5pZnkgdGhlc2UgYXQgc29tZSBwb2ludDogaHR0cHM6Ly9naXRodWIuY29tL2F3cy9qc2lpL2lzc3Vlcy8zMjM2KVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFVwKFxuICBkaXJlY3Rvcnk6IHN0cmluZyxcbiAgcHJlZDogKGRpcjogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+LFxuKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVcChcbiAgZGlyZWN0b3J5OiBzdHJpbmcsXG4gIHByZWQ6IChkaXI6IHN0cmluZykgPT4gYm9vbGVhbixcbik6IHN0cmluZyB8IHVuZGVmaW5lZDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luY1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVcChcbiAgZGlyZWN0b3J5OiBzdHJpbmcsXG4gIHByZWQ6ICgoZGlyOiBzdHJpbmcpID0+IGJvb2xlYW4pIHwgKChkaXI6IHN0cmluZykgPT4gUHJvbWlzZTxib29sZWFuPiksXG4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4gfCBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBjb25zdCByZXN1bHQgPSBwcmVkKGRpcmVjdG9yeSk7XG4gIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgIHJldHVybiByZXN1bHQudGhlbigodGhpc0RpcmVjdG9yeSkgPT5cbiAgICAgIHRoaXNEaXJlY3RvcnkgPyBkaXJlY3RvcnkgOiByZWN1cnNlKCksXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgPyBkaXJlY3RvcnkgOiByZWN1cnNlKCk7XG5cbiAgZnVuY3Rpb24gcmVjdXJzZSgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGlyZWN0b3J5KTtcbiAgICBpZiAocGFyZW50ID09PSBkaXJlY3RvcnkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBmaW5kVXAocGFyZW50LCBwcmVkIGFzIGFueSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlPEE+KHg6IEEgfCBQcm9taXNlPEE+KTogeCBpcyBQcm9taXNlPEE+IHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAoeCBhcyBhbnkpLnRoZW47XG59XG4iXX0=