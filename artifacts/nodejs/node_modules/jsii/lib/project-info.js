"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadProjectInfo = void 0;
const spec = require("@jsii/spec");
const fs = require("fs-extra");
const log4js = require("log4js");
const path = require("path");
const semver = require("semver");
const ts = require("typescript");
const jsii_diagnostic_1 = require("./jsii-diagnostic");
const utils_1 = require("./utils");
// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
const spdx = require('spdx-license-list/simple');
const LOG = log4js.getLogger('jsii/package-info');
async function loadProjectInfo(projectRoot) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const packageJsonPath = path.join(projectRoot, 'package.json');
    // eslint-disable-next-line @typescript-eslint/no-var-requires,@typescript-eslint/no-require-imports
    const pkg = await fs.readJson(packageJsonPath);
    const diagnostics = [];
    let bundleDependencies;
    for (const name of (_b = (_a = pkg.bundleDependencies) !== null && _a !== void 0 ? _a : pkg.bundledDependencies) !== null && _b !== void 0 ? _b : []) {
        const version = (_c = pkg.dependencies) === null || _c === void 0 ? void 0 : _c[name];
        if (!version) {
            throw new Error(`The "package.json" file has "${name}" in "bundleDependencies", but it is not declared in "dependencies"`);
        }
        if (pkg.peerDependencies && name in pkg.peerDependencies) {
            throw new Error(`The "package.json" file has "${name}" in "bundleDependencies", and also in "peerDependencies"`);
        }
        bundleDependencies = bundleDependencies !== null && bundleDependencies !== void 0 ? bundleDependencies : {};
        bundleDependencies[name] = _resolveVersion(version, projectRoot).version;
    }
    // Check peerDependencies are also in devDependencies
    // You need this to write tests properly. There are probably cases where
    // it makes sense to have this different, so most of what this checking
    // produces is warnings, not errors.
    const devDependencies = (_d = pkg.devDependencies) !== null && _d !== void 0 ? _d : {};
    for (const [name, rng] of Object.entries((_e = pkg.peerDependencies) !== null && _e !== void 0 ? _e : {})) {
        const range = new semver.Range(_resolveVersion(rng, projectRoot).version);
        const minVersion = (_f = semver.minVersion(range)) === null || _f === void 0 ? void 0 : _f.raw;
        if (!(name in devDependencies) ||
            devDependencies[name] !== `${minVersion}`) {
            diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0006_MISSING_DEV_DEPENDENCY.createDetached(name, `${rng}`, `${minVersion}`, `${devDependencies[name]}`));
            continue;
        }
    }
    const bundled = new Set(Object.keys(bundleDependencies !== null && bundleDependencies !== void 0 ? bundleDependencies : {}));
    const dependencies = filterDictByKey((_g = pkg.dependencies) !== null && _g !== void 0 ? _g : {}, (depName) => !bundled.has(depName));
    const peerDependencies = (_h = pkg.peerDependencies) !== null && _h !== void 0 ? _h : {};
    const resolver = new DependencyResolver();
    const resolved = await resolver.discoverDependencyTree(projectRoot, {
        ...dependencies,
        ...peerDependencies,
    });
    const transitiveDependencies = resolver.assemblyClosure(resolved);
    const metadata = mergeMetadata({
        jsii: {
            pacmak: {
                // When `true`, `jsii-pacmak` will use the `Jsii$Default` implementation in code generation even for dependencies.
                hasDefaultInterfaces: true,
            },
        },
    }, (_j = pkg.jsii) === null || _j === void 0 ? void 0 : _j.metadata);
    const projectInfo = {
        projectRoot,
        packageJson: pkg,
        name: _required(pkg.name, 'The "package.json" file must specify the "name" attribute'),
        version: _required(pkg.version, 'The "package.json" file must specify the "version" attribute'),
        deprecated: pkg.deprecated,
        stability: _validateStability(pkg.stability, pkg.deprecated),
        author: _toPerson(_required(pkg.author, 'The "package.json" file must specify the "author" attribute'), 'author'),
        repository: _toRepository(_required(pkg.repository, 'The "package.json" file must specify the "repository" attribute')),
        license: _validateLicense(pkg.license),
        keywords: pkg.keywords,
        main: _required(pkg.main, 'The "package.json" file must specify the "main" attribute'),
        types: _required(pkg.types, 'The "package.json" file must specify the "types" attribute'),
        dependencies,
        peerDependencies,
        dependencyClosure: transitiveDependencies,
        bundleDependencies,
        targets: {
            ..._required(pkg.jsii, 'The "package.json" file must specify the "jsii" attribute').targets,
            js: { npm: pkg.name },
        },
        metadata,
        jsiiVersionFormat: _validateVersionFormat((_k = pkg.jsii.versionFormat) !== null && _k !== void 0 ? _k : 'full'),
        description: pkg.description,
        homepage: pkg.homepage,
        contributors: (_l = pkg.contributors) === null || _l === void 0 ? void 0 : _l.map((contrib, index) => _toPerson(contrib, `contributors[${index}]`, 'contributor')),
        excludeTypescript: (_o = (_m = pkg.jsii) === null || _m === void 0 ? void 0 : _m.excludeTypescript) !== null && _o !== void 0 ? _o : [],
        projectReferences: (_p = pkg.jsii) === null || _p === void 0 ? void 0 : _p.projectReferences,
        tsc: {
            outDir: (_r = (_q = pkg.jsii) === null || _q === void 0 ? void 0 : _q.tsc) === null || _r === void 0 ? void 0 : _r.outDir,
            rootDir: (_t = (_s = pkg.jsii) === null || _s === void 0 ? void 0 : _s.tsc) === null || _t === void 0 ? void 0 : _t.rootDir,
        },
        bin: pkg.bin,
        exports: pkg.exports,
        diagnostics: _loadDiagnostics((_u = pkg.jsii) === null || _u === void 0 ? void 0 : _u.diagnostics),
    };
    return { projectInfo, diagnostics };
}
exports.loadProjectInfo = loadProjectInfo;
function _guessRepositoryType(url) {
    if (url.endsWith('.git')) {
        return 'git';
    }
    const parts = /^([^:]+):\/\//.exec(url);
    if ((parts === null || parts === void 0 ? void 0 : parts[1]) !== 'http' && (parts === null || parts === void 0 ? void 0 : parts[1]) !== 'https') {
        return parts[1];
    }
    throw new Error(`The "package.json" file must specify the "repository.type" attribute (could not guess from ${url})`);
}
class DependencyResolver {
    constructor() {
        this.cache = new Map();
    }
    /**
     * Discover the dependency tree starting at 'root', validating versions as we go along
     *
     * This primes the data structures in this class and should be called first.
     *
     * Return the resolved jsii dependency paths
     */
    async discoverDependencyTree(root, dependencies) {
        const ret = {};
        for (const [name, declaration] of Object.entries(dependencies)) {
            // eslint-disable-next-line no-await-in-loop
            const resolved = await this.resolveDependency(root, name, declaration);
            const actualVersion = resolved.dependencyInfo.assembly.version;
            if (!semver.satisfies(actualVersion, declaration)) {
                throw new Error(`Declared dependency on version ${declaration} of ${name}, but version ${actualVersion} was found`);
            }
            ret[name] = resolved.resolvedFile;
        }
        return ret;
    }
    /**
     * From a set of resolved paths, recursively return all assemblies
     */
    assemblyClosure(resolved) {
        const closure = new Map();
        const queue = Array.from(Object.values(resolved));
        while (queue.length > 0) {
            const next = queue.shift();
            const resolved = this.cache.get(next);
            if (!resolved) {
                throw new Error(`Path ${next} not seen before`);
            }
            if (closure.has(next)) {
                continue;
            }
            closure.set(next, resolved.assembly);
            queue.push(...Object.values(resolved.resolvedDependencies));
        }
        return Array.from(closure.values());
    }
    async resolveDependency(root, name, declaration) {
        const { version: versionString, localPackage } = _resolveVersion(declaration, root);
        const version = new semver.Range(versionString);
        if (!version) {
            throw new Error(`Invalid semver expression for ${name}: ${versionString}`);
        }
        const jsiiFile = await _tryResolveAssembly(name, localPackage, root);
        LOG.debug(`Resolved dependency ${name} to ${jsiiFile}`);
        return {
            resolvedVersion: versionString,
            resolvedFile: jsiiFile,
            dependencyInfo: await this.loadAssemblyAndRecurse(jsiiFile),
        };
    }
    async loadAssemblyAndRecurse(jsiiFile) {
        // Only recurse if we haven't seen this assembly yet
        if (this.cache.has(jsiiFile)) {
            return this.cache.get(jsiiFile);
        }
        // eslint-disable-next-line no-await-in-loop
        const assembly = await this.loadAssembly(jsiiFile);
        // Continue loading any dependencies declared in the asm
        const resolvedDependencies = assembly.dependencies
            ? await this.discoverDependencyTree(path.dirname(jsiiFile), assembly.dependencies)
            : {};
        const depInfo = {
            assembly,
            resolvedDependencies,
        };
        this.cache.set(jsiiFile, depInfo);
        return depInfo;
    }
    /**
     * Load a JSII filename and validate it; cached to avoid redundant loads of the same JSII assembly
     */
    async loadAssembly(jsiiFileName) {
        try {
            return await fs.readJson(jsiiFileName);
        }
        catch (e) {
            throw new Error(`Error loading ${jsiiFileName}: ${e}`);
        }
    }
}
function _required(value, message) {
    if (value == null) {
        throw new Error(message);
    }
    return value;
}
function _toPerson(value, field, defaultRole = field) {
    if (typeof value === 'string') {
        value = utils_1.parsePerson(value);
    }
    return {
        name: _required(value.name, `The "package.json" file must specify the "${field}.name" attribute`),
        roles: value.roles ? [...new Set(value.roles)] : [defaultRole],
        email: value.email,
        url: value.url,
        organization: value.organization ? value.organization : undefined,
    };
}
function _toRepository(value) {
    if (typeof value === 'string') {
        value = utils_1.parseRepository(value);
    }
    return {
        url: _required(value.url, 'The "package.json" file must specify the "repository.url" attribute'),
        type: value.type || _guessRepositoryType(value.url),
        directory: value.directory,
    };
}
async function _tryResolveAssembly(mod, localPackage, searchPath) {
    if (localPackage) {
        const result = path.join(localPackage, '.jsii');
        if (!fs.existsSync(result)) {
            throw new Error(`Assembly does not exist: ${result}`);
        }
        return result;
    }
    try {
        const dependencyDir = await utils_1.findDependencyDirectory(mod, searchPath);
        return path.join(dependencyDir, '.jsii');
    }
    catch (e) {
        throw new Error(`Unable to locate jsii assembly for "${mod}". If this module is not jsii-enabled, it must also be declared under bundledDependencies: ${e}`);
    }
}
function _validateLicense(id) {
    if (id === 'UNLICENSED') {
        return id;
    }
    if (!spdx.has(id)) {
        throw new Error(`Invalid license identifier "${id}", see valid license identifiers at https://spdx.org/licenses/`);
    }
    return id;
}
function _validateVersionFormat(format) {
    if (format !== 'short' && format !== 'full') {
        throw new Error(`Invalid jsii.versionFormat "${format}", it must be either "short" or "full" (the default)`);
    }
    return format;
}
function _validateStability(stability, deprecated) {
    if (!stability && deprecated) {
        stability = spec.Stability.Deprecated;
    }
    else if (deprecated && stability !== spec.Stability.Deprecated) {
        throw new Error(`Package is deprecated (${deprecated}), but it's stability is ${stability} and not ${spec.Stability.Deprecated}`);
    }
    if (!stability) {
        return undefined;
    }
    if (!Object.values(spec.Stability).includes(stability)) {
        throw new Error(`Invalid stability "${stability}", it must be one of ${Object.values(spec.Stability).join(', ')}`);
    }
    return stability;
}
/**
 * Resolves an NPM package specifier to a version range
 *
 * If it was already a version range, return it. If it the
 * package references a local file, return the version that
 * package is at.
 */
function _resolveVersion(dep, searchPath) {
    const matches = /^file:(.+)$/.exec(dep);
    if (!matches) {
        return { version: dep };
    }
    const localPackage = path.resolve(searchPath, matches[1]);
    return {
        // Rendering as a caret version to maintain uniformity against the "standard".
        // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires
        version: `^${fs.readJsonSync(path.join(localPackage, 'package.json')).version}`,
        localPackage,
    };
}
/**
 * Merges two metadata blocks together.
 *
 * @param base the base values
 * @param user the user-supplied values, which can override the `base` values
 *
 * @returns the merged metadata block
 */
function mergeMetadata(base, user) {
    if (user == null) {
        return base;
    }
    return mergeObjects(base, user);
    function mergeObjects(base, override) {
        const result = {};
        const allKeys = Array.from(new Set([...Object.keys(base), ...Object.keys(override)])).sort();
        for (const key of allKeys) {
            const baseValue = base[key];
            const overrideValue = override[key];
            if (typeof baseValue === 'object' && typeof overrideValue === 'object') {
                if (overrideValue != null) {
                    result[key] = mergeObjects(baseValue, overrideValue);
                }
            }
            else {
                result[key] = overrideValue !== null && overrideValue !== void 0 ? overrideValue : baseValue;
            }
        }
        return result;
    }
}
function _loadDiagnostics(entries) {
    if (entries === undefined || Object.keys(entries).length === 0) {
        return undefined;
    }
    const result = {};
    for (const code of Object.keys(entries)) {
        let category;
        switch (entries[code].trim().toLowerCase()) {
            case 'error':
                category = ts.DiagnosticCategory.Error;
                break;
            case 'warning':
                category = ts.DiagnosticCategory.Warning;
                break;
            case 'suggestion':
                category = ts.DiagnosticCategory.Suggestion;
                break;
            case 'message':
                category = ts.DiagnosticCategory.Message;
                break;
            default:
                throw new Error(`Invalid category '${entries[code]}' for code '${code}'`);
        }
        result[code] = category;
    }
    return result;
}
function filterDictByKey(xs, predicate) {
    const ret = {};
    for (const [key, value] of Object.entries(xs)) {
        if (predicate(key)) {
            ret[key] = value;
        }
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvamVjdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicHJvamVjdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBRWpDLHVEQUFtRDtBQUNuRCxtQ0FBZ0Y7QUFFaEYscUdBQXFHO0FBQ3JHLE1BQU0sSUFBSSxHQUFnQixPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUU5RCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFxRDNDLEtBQUssVUFBVSxlQUFlLENBQ25DLFdBQW1COztJQUVuQixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUMvRCxvR0FBb0c7SUFDcEcsTUFBTSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBRS9DLE1BQU0sV0FBVyxHQUFvQixFQUFFLENBQUM7SUFFeEMsSUFBSSxrQkFBMEQsQ0FBQztJQUMvRCxLQUFLLE1BQU0sSUFBSSxnQkFBSSxHQUFHLENBQUMsa0JBQWtCLG1DQUFJLEdBQUcsQ0FBQyxtQkFBbUIsbUNBQUksRUFBRSxFQUFFO1FBQzFFLE1BQU0sT0FBTyxTQUFHLEdBQUcsQ0FBQyxZQUFZLDBDQUFHLElBQUksQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDWixNQUFNLElBQUksS0FBSyxDQUNiLGdDQUFnQyxJQUFJLHFFQUFxRSxDQUMxRyxDQUFDO1NBQ0g7UUFFRCxJQUFJLEdBQUcsQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLElBQUksR0FBRyxDQUFDLGdCQUFnQixFQUFFO1lBQ3hELE1BQU0sSUFBSSxLQUFLLENBQ2IsZ0NBQWdDLElBQUksMkRBQTJELENB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cGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgbG9nNGpzIGZyb20gJ2xvZzRqcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHsgSnNpaURpYWdub3N0aWMgfSBmcm9tICcuL2pzaWktZGlhZ25vc3RpYyc7XG5pbXBvcnQgeyBwYXJzZVBlcnNvbiwgcGFyc2VSZXBvc2l0b3J5LCBmaW5kRGVwZW5kZW5jeURpcmVjdG9yeSB9IGZyb20gJy4vdXRpbHMnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3Qgc3BkeDogU2V0PHN0cmluZz4gPSByZXF1aXJlKCdzcGR4LWxpY2Vuc2UtbGlzdC9zaW1wbGUnKTtcblxuY29uc3QgTE9HID0gbG9nNGpzLmdldExvZ2dlcignanNpaS9wYWNrYWdlLWluZm8nKTtcblxuZXhwb3J0IGludGVyZmFjZSBUU0NvbXBpbGVyT3B0aW9ucyB7XG4gIHJlYWRvbmx5IG91dERpcj86IHN0cmluZztcbiAgcmVhZG9ubHkgcm9vdERpcj86IHN0cmluZztcbiAgcmVhZG9ubHkgZm9yY2VDb25zaXN0ZW50Q2FzaW5nSW5GaWxlTmFtZXM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3RJbmZvIHtcbiAgcmVhZG9ubHkgcHJvamVjdFJvb3Q6IHN0cmluZztcbiAgcmVhZG9ubHkgcGFja2FnZUpzb246IGFueTtcblxuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgcmVhZG9ubHkgYXV0aG9yOiBzcGVjLlBlcnNvbjtcbiAgcmVhZG9ubHkgZGVwcmVjYXRlZD86IHN0cmluZztcbiAgcmVhZG9ubHkgc3RhYmlsaXR5Pzogc3BlYy5TdGFiaWxpdHk7XG4gIHJlYWRvbmx5IGxpY2Vuc2U6IHN0cmluZztcbiAgcmVhZG9ubHkgcmVwb3NpdG9yeToge1xuICAgIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcbiAgICByZWFkb25seSB1cmw6IHN0cmluZztcbiAgICByZWFkb25seSBkaXJlY3Rvcnk/OiBzdHJpbmc7XG4gIH07XG4gIHJlYWRvbmx5IGtleXdvcmRzPzogc3RyaW5nW107XG5cbiAgcmVhZG9ubHkgbWFpbjogc3RyaW5nO1xuICByZWFkb25seSB0eXBlczogc3RyaW5nO1xuXG4gIHJlYWRvbmx5IGRlcGVuZGVuY2llczogeyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH07XG4gIHJlYWRvbmx5IHBlZXJEZXBlbmRlbmNpZXM6IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IHN0cmluZyB9O1xuICByZWFkb25seSBkZXBlbmRlbmN5Q2xvc3VyZTogcmVhZG9ubHkgc3BlYy5Bc3NlbWJseVtdO1xuICByZWFkb25seSBidW5kbGVEZXBlbmRlbmNpZXM/OiB7IHJlYWRvbmx5IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgcmVhZG9ubHkgdGFyZ2V0czogc3BlYy5Bc3NlbWJseVRhcmdldHM7XG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgcmVhZG9ubHkganNpaVZlcnNpb25Gb3JtYXQ6ICdzaG9ydCcgfCAnZnVsbCc7XG4gIHJlYWRvbmx5IGRpYWdub3N0aWNzPzogeyByZWFkb25seSBbY29kZTogc3RyaW5nXTogdHMuRGlhZ25vc3RpY0NhdGVnb3J5IH07XG4gIHJlYWRvbmx5IGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICByZWFkb25seSBob21lcGFnZT86IHN0cmluZztcbiAgcmVhZG9ubHkgY29udHJpYnV0b3JzPzogcmVhZG9ubHkgc3BlYy5QZXJzb25bXTtcbiAgcmVhZG9ubHkgZXhjbHVkZVR5cGVzY3JpcHQ6IHN0cmluZ1tdO1xuICByZWFkb25seSBwcm9qZWN0UmVmZXJlbmNlcz86IGJvb2xlYW47XG4gIHJlYWRvbmx5IHRzYz86IFRTQ29tcGlsZXJPcHRpb25zO1xuICByZWFkb25seSBiaW4/OiB7IHJlYWRvbmx5IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgcmVhZG9ubHkgZXhwb3J0cz86IHtcbiAgICByZWFkb25seSBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgeyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH07XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdEluZm9SZXN1bHQge1xuICByZWFkb25seSBwcm9qZWN0SW5mbzogUHJvamVjdEluZm87XG4gIHJlYWRvbmx5IGRpYWdub3N0aWNzOiByZWFkb25seSB0cy5EaWFnbm9zdGljW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUHJvamVjdEluZm8oXG4gIHByb2plY3RSb290OiBzdHJpbmcsXG4pOiBQcm9taXNlPFByb2plY3RJbmZvUmVzdWx0PiB7XG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHBhdGguam9pbihwcm9qZWN0Um9vdCwgJ3BhY2thZ2UuanNvbicpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gIGNvbnN0IHBrZyA9IGF3YWl0IGZzLnJlYWRKc29uKHBhY2thZ2VKc29uUGF0aCk7XG5cbiAgY29uc3QgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSA9IFtdO1xuXG4gIGxldCBidW5kbGVEZXBlbmRlbmNpZXM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9IHwgdW5kZWZpbmVkO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgcGtnLmJ1bmRsZURlcGVuZGVuY2llcyA/PyBwa2cuYnVuZGxlZERlcGVuZGVuY2llcyA/PyBbXSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSBwa2cuZGVwZW5kZW5jaWVzPy5bbmFtZV07XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgXCJwYWNrYWdlLmpzb25cIiBmaWxlIGhhcyBcIiR7bmFtZX1cIiBpbiBcImJ1bmRsZURlcGVuZGVuY2llc1wiLCBidXQgaXQgaXMgbm90IGRlY2xhcmVkIGluIFwiZGVwZW5kZW5jaWVzXCJgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAocGtnLnBlZXJEZXBlbmRlbmNpZXMgJiYgbmFtZSBpbiBwa2cucGVlckRlcGVuZGVuY2llcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIFwicGFja2FnZS5qc29uXCIgZmlsZSBoYXMgXCIke25hbWV9XCIgaW4gXCJidW5kbGVEZXBlbmRlbmNpZXNcIiwgYW5kIGFsc28gaW4gXCJwZWVyRGVwZW5kZW5jaWVzXCJgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBidW5kbGVEZXBlbmRlbmNpZXMgPSBidW5kbGVEZXBlbmRlbmNpZXMgPz8ge307XG4gICAgYnVuZGxlRGVwZW5kZW5jaWVzW25hbWVdID0gX3Jlc29sdmVWZXJzaW9uKHZlcnNpb24sIHByb2plY3RSb290KS52ZXJzaW9uO1xuICB9XG5cbiAgLy8gQ2hlY2sgcGVlckRlcGVuZGVuY2llcyBhcmUgYWxzbyBpbiBkZXZEZXBlbmRlbmNpZXNcbiAgLy8gWW91IG5lZWQgdGhpcyB0byB3cml0ZSB0ZXN0cyBwcm9wZXJseS4gVGhlcmUgYXJlIHByb2JhYmx5IGNhc2VzIHdoZXJlXG4gIC8vIGl0IG1ha2VzIHNlbnNlIHRvIGhhdmUgdGhpcyBkaWZmZXJlbnQsIHNvIG1vc3Qgb2Ygd2hhdCB0aGlzIGNoZWNraW5nXG4gIC8vIHByb2R1Y2VzIGlzIHdhcm5pbmdzLCBub3QgZXJyb3JzLlxuICBjb25zdCBkZXZEZXBlbmRlbmNpZXMgPSBwa2cuZGV2RGVwZW5kZW5jaWVzID8/IHt9O1xuICBmb3IgKGNvbnN0IFtuYW1lLCBybmddIG9mIE9iamVjdC5lbnRyaWVzKHBrZy5wZWVyRGVwZW5kZW5jaWVzID8/IHt9KSkge1xuICAgIGNvbnN0IHJhbmdlID0gbmV3IHNlbXZlci5SYW5nZShcbiAgICAgIF9yZXNvbHZlVmVyc2lvbihybmcgYXMgc3RyaW5nLCBwcm9qZWN0Um9vdCkudmVyc2lvbixcbiAgICApO1xuICAgIGNvbnN0IG1pblZlcnNpb24gPSBzZW12ZXIubWluVmVyc2lvbihyYW5nZSk/LnJhdztcblxuICAgIGlmIChcbiAgICAgICEobmFtZSBpbiBkZXZEZXBlbmRlbmNpZXMpIHx8XG4gICAgICBkZXZEZXBlbmRlbmNpZXNbbmFtZV0gIT09IGAke21pblZlcnNpb259YFxuICAgICkge1xuICAgICAgZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8wMDA2X01JU1NJTkdfREVWX0RFUEVOREVOQ1kuY3JlYXRlRGV0YWNoZWQoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBgJHtybmcgYXMgYW55fWAsXG4gICAgICAgICAgYCR7bWluVmVyc2lvbn1gLFxuICAgICAgICAgIGAke2RldkRlcGVuZGVuY2llc1tuYW1lXX1gLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1bmRsZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGJ1bmRsZURlcGVuZGVuY2llcyA/PyB7fSkpO1xuICBjb25zdCBkZXBlbmRlbmNpZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBmaWx0ZXJEaWN0QnlLZXkoXG4gICAgcGtnLmRlcGVuZGVuY2llcyA/PyB7fSxcbiAgICAoZGVwTmFtZSkgPT4gIWJ1bmRsZWQuaGFzKGRlcE5hbWUpLFxuICApO1xuICBjb25zdCBwZWVyRGVwZW5kZW5jaWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0gcGtnLnBlZXJEZXBlbmRlbmNpZXMgPz8ge307XG5cbiAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgRGVwZW5kZW5jeVJlc29sdmVyKCk7XG4gIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgcmVzb2x2ZXIuZGlzY292ZXJEZXBlbmRlbmN5VHJlZShwcm9qZWN0Um9vdCwge1xuICAgIC4uLmRlcGVuZGVuY2llcyxcbiAgICAuLi5wZWVyRGVwZW5kZW5jaWVzLFxuICB9KTtcbiAgY29uc3QgdHJhbnNpdGl2ZURlcGVuZGVuY2llcyA9IHJlc29sdmVyLmFzc2VtYmx5Q2xvc3VyZShyZXNvbHZlZCk7XG5cbiAgY29uc3QgbWV0YWRhdGEgPSBtZXJnZU1ldGFkYXRhKFxuICAgIHtcbiAgICAgIGpzaWk6IHtcbiAgICAgICAgcGFjbWFrOiB7XG4gICAgICAgICAgLy8gV2hlbiBgdHJ1ZWAsIGBqc2lpLXBhY21ha2Agd2lsbCB1c2UgdGhlIGBKc2lpJERlZmF1bHRgIGltcGxlbWVudGF0aW9uIGluIGNvZGUgZ2VuZXJhdGlvbiBldmVuIGZvciBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgaGFzRGVmYXVsdEludGVyZmFjZXM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgcGtnLmpzaWk/Lm1ldGFkYXRhLFxuICApO1xuXG4gIGNvbnN0IHByb2plY3RJbmZvID0ge1xuICAgIHByb2plY3RSb290LFxuICAgIHBhY2thZ2VKc29uOiBwa2csXG5cbiAgICBuYW1lOiBfcmVxdWlyZWQoXG4gICAgICBwa2cubmFtZSxcbiAgICAgICdUaGUgXCJwYWNrYWdlLmpzb25cIiBmaWxlIG11c3Qgc3BlY2lmeSB0aGUgXCJuYW1lXCIgYXR0cmlidXRlJyxcbiAgICApLFxuICAgIHZlcnNpb246IF9yZXF1aXJlZChcbiAgICAgIHBrZy52ZXJzaW9uLFxuICAgICAgJ1RoZSBcInBhY2thZ2UuanNvblwiIGZpbGUgbXVzdCBzcGVjaWZ5IHRoZSBcInZlcnNpb25cIiBhdHRyaWJ1dGUnLFxuICAgICksXG4gICAgZGVwcmVjYXRlZDogcGtnLmRlcHJlY2F0ZWQsXG4gICAgc3RhYmlsaXR5OiBfdmFsaWRhdGVTdGFiaWxpdHkocGtnLnN0YWJpbGl0eSwgcGtnLmRlcHJlY2F0ZWQpLFxuICAgIGF1dGhvcjogX3RvUGVyc29uKFxuICAgICAgX3JlcXVpcmVkKFxuICAgICAgICBwa2cuYXV0aG9yLFxuICAgICAgICAnVGhlIFwicGFja2FnZS5qc29uXCIgZmlsZSBtdXN0IHNwZWNpZnkgdGhlIFwiYXV0aG9yXCIgYXR0cmlidXRlJyxcbiAgICAgICksXG4gICAgICAnYXV0aG9yJyxcbiAgICApLFxuICAgIHJlcG9zaXRvcnk6IF90b1JlcG9zaXRvcnkoXG4gICAgICBfcmVxdWlyZWQoXG4gICAgICAgIHBrZy5yZXBvc2l0b3J5LFxuICAgICAgICAnVGhlIFwicGFja2FnZS5qc29uXCIgZmlsZSBtdXN0IHNwZWNpZnkgdGhlIFwicmVwb3NpdG9yeVwiIGF0dHJpYnV0ZScsXG4gICAgICApLFxuICAgICksXG4gICAgbGljZW5zZTogX3ZhbGlkYXRlTGljZW5zZShwa2cubGljZW5zZSksXG4gICAga2V5d29yZHM6IHBrZy5rZXl3b3JkcyxcblxuICAgIG1haW46IF9yZXF1aXJlZChcbiAgICAgIHBrZy5tYWluLFxuICAgICAgJ1RoZSBcInBhY2thZ2UuanNvblwiIGZpbGUgbXVzdCBzcGVjaWZ5IHRoZSBcIm1haW5cIiBhdHRyaWJ1dGUnLFxuICAgICksXG4gICAgdHlwZXM6IF9yZXF1aXJlZChcbiAgICAgIHBrZy50eXBlcyxcbiAgICAgICdUaGUgXCJwYWNrYWdlLmpzb25cIiBmaWxlIG11c3Qgc3BlY2lmeSB0aGUgXCJ0eXBlc1wiIGF0dHJpYnV0ZScsXG4gICAgKSxcblxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBwZWVyRGVwZW5kZW5jaWVzLFxuICAgIGRlcGVuZGVuY3lDbG9zdXJlOiB0cmFuc2l0aXZlRGVwZW5kZW5jaWVzLFxuICAgIGJ1bmRsZURlcGVuZGVuY2llcyxcbiAgICB0YXJnZXRzOiB7XG4gICAgICAuLi5fcmVxdWlyZWQoXG4gICAgICAgIHBrZy5qc2lpLFxuICAgICAgICAnVGhlIFwicGFja2FnZS5qc29uXCIgZmlsZSBtdXN0IHNwZWNpZnkgdGhlIFwianNpaVwiIGF0dHJpYnV0ZScsXG4gICAgICApLnRhcmdldHMsXG4gICAgICBqczogeyBucG06IHBrZy5uYW1lIH0sXG4gICAgfSxcbiAgICBtZXRhZGF0YSxcbiAgICBqc2lpVmVyc2lvbkZvcm1hdDogX3ZhbGlkYXRlVmVyc2lvbkZvcm1hdChwa2cuanNpaS52ZXJzaW9uRm9ybWF0ID8/ICdmdWxsJyksXG5cbiAgICBkZXNjcmlwdGlvbjogcGtnLmRlc2NyaXB0aW9uLFxuICAgIGhvbWVwYWdlOiBwa2cuaG9tZXBhZ2UsXG4gICAgY29udHJpYnV0b3JzOiAocGtnLmNvbnRyaWJ1dG9ycyBhcyBhbnlbXSk/Lm1hcCgoY29udHJpYiwgaW5kZXgpID0+XG4gICAgICBfdG9QZXJzb24oY29udHJpYiwgYGNvbnRyaWJ1dG9yc1ske2luZGV4fV1gLCAnY29udHJpYnV0b3InKSxcbiAgICApLFxuXG4gICAgZXhjbHVkZVR5cGVzY3JpcHQ6IHBrZy5qc2lpPy5leGNsdWRlVHlwZXNjcmlwdCA/PyBbXSxcbiAgICBwcm9qZWN0UmVmZXJlbmNlczogcGtnLmpzaWk/LnByb2plY3RSZWZlcmVuY2VzLFxuICAgIHRzYzoge1xuICAgICAgb3V0RGlyOiBwa2cuanNpaT8udHNjPy5vdXREaXIsXG4gICAgICByb290RGlyOiBwa2cuanNpaT8udHNjPy5yb290RGlyLFxuICAgIH0sXG4gICAgYmluOiBwa2cuYmluLFxuICAgIGV4cG9ydHM6IHBrZy5leHBvcnRzLFxuICAgIGRpYWdub3N0aWNzOiBfbG9hZERpYWdub3N0aWNzKHBrZy5qc2lpPy5kaWFnbm9zdGljcyksXG4gIH07XG4gIHJldHVybiB7IHByb2plY3RJbmZvLCBkaWFnbm9zdGljcyB9O1xufVxuXG5mdW5jdGlvbiBfZ3Vlc3NSZXBvc2l0b3J5VHlwZSh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh1cmwuZW5kc1dpdGgoJy5naXQnKSkge1xuICAgIHJldHVybiAnZ2l0JztcbiAgfVxuICBjb25zdCBwYXJ0cyA9IC9eKFteOl0rKTpcXC9cXC8vLmV4ZWModXJsKTtcbiAgaWYgKHBhcnRzPy5bMV0gIT09ICdodHRwJyAmJiBwYXJ0cz8uWzFdICE9PSAnaHR0cHMnKSB7XG4gICAgcmV0dXJuIHBhcnRzIVsxXTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFRoZSBcInBhY2thZ2UuanNvblwiIGZpbGUgbXVzdCBzcGVjaWZ5IHRoZSBcInJlcG9zaXRvcnkudHlwZVwiIGF0dHJpYnV0ZSAoY291bGQgbm90IGd1ZXNzIGZyb20gJHt1cmx9KWAsXG4gICk7XG59XG5cbmludGVyZmFjZSBEZXBlbmRlbmN5SW5mbyB7XG4gIHJlYWRvbmx5IGFzc2VtYmx5OiBzcGVjLkFzc2VtYmx5O1xuICByZWFkb25seSByZXNvbHZlZERlcGVuZGVuY2llczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn1cblxuY2xhc3MgRGVwZW5kZW5jeVJlc29sdmVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBEZXBlbmRlbmN5SW5mbz4oKTtcblxuICAvKipcbiAgICogRGlzY292ZXIgdGhlIGRlcGVuZGVuY3kgdHJlZSBzdGFydGluZyBhdCAncm9vdCcsIHZhbGlkYXRpbmcgdmVyc2lvbnMgYXMgd2UgZ28gYWxvbmdcbiAgICpcbiAgICogVGhpcyBwcmltZXMgdGhlIGRhdGEgc3RydWN0dXJlcyBpbiB0aGlzIGNsYXNzIGFuZCBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LlxuICAgKlxuICAgKiBSZXR1cm4gdGhlIHJlc29sdmVkIGpzaWkgZGVwZW5kZW5jeSBwYXRoc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpc2NvdmVyRGVwZW5kZW5jeVRyZWUoXG4gICAgcm9vdDogc3RyaW5nLFxuICAgIGRlcGVuZGVuY2llczogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gICAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgZm9yIChjb25zdCBbbmFtZSwgZGVjbGFyYXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKGRlcGVuZGVuY2llcykpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHRoaXMucmVzb2x2ZURlcGVuZGVuY3kocm9vdCwgbmFtZSwgZGVjbGFyYXRpb24pO1xuXG4gICAgICBjb25zdCBhY3R1YWxWZXJzaW9uID0gcmVzb2x2ZWQuZGVwZW5kZW5jeUluZm8uYXNzZW1ibHkudmVyc2lvbjtcbiAgICAgIGlmICghc2VtdmVyLnNhdGlzZmllcyhhY3R1YWxWZXJzaW9uLCBkZWNsYXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBEZWNsYXJlZCBkZXBlbmRlbmN5IG9uIHZlcnNpb24gJHtkZWNsYXJhdGlvbn0gb2YgJHtuYW1lfSwgYnV0IHZlcnNpb24gJHthY3R1YWxWZXJzaW9ufSB3YXMgZm91bmRgLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXRbbmFtZV0gPSByZXNvbHZlZC5yZXNvbHZlZEZpbGU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogRnJvbSBhIHNldCBvZiByZXNvbHZlZCBwYXRocywgcmVjdXJzaXZlbHkgcmV0dXJuIGFsbCBhc3NlbWJsaWVzXG4gICAqL1xuICBwdWJsaWMgYXNzZW1ibHlDbG9zdXJlKHJlc29sdmVkOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogc3BlYy5Bc3NlbWJseVtdIHtcbiAgICBjb25zdCBjbG9zdXJlID0gbmV3IE1hcDxzdHJpbmcsIHNwZWMuQXNzZW1ibHk+KCk7XG4gICAgY29uc3QgcXVldWUgPSBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMocmVzb2x2ZWQpKTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmV4dCA9IHF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB0aGlzLmNhY2hlLmdldChuZXh0KTtcbiAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXRoICR7bmV4dH0gbm90IHNlZW4gYmVmb3JlYCk7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc3VyZS5oYXMobmV4dCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNsb3N1cmUuc2V0KG5leHQsIHJlc29sdmVkLmFzc2VtYmx5KTtcbiAgICAgIHF1ZXVlLnB1c2goLi4uT2JqZWN0LnZhbHVlcyhyZXNvbHZlZC5yZXNvbHZlZERlcGVuZGVuY2llcykpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjbG9zdXJlLnZhbHVlcygpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVzb2x2ZURlcGVuZGVuY3koXG4gICAgcm9vdDogc3RyaW5nLFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBkZWNsYXJhdGlvbjogc3RyaW5nLFxuICApIHtcbiAgICBjb25zdCB7IHZlcnNpb246IHZlcnNpb25TdHJpbmcsIGxvY2FsUGFja2FnZSB9ID0gX3Jlc29sdmVWZXJzaW9uKFxuICAgICAgZGVjbGFyYXRpb24sXG4gICAgICByb290LFxuICAgICk7XG4gICAgY29uc3QgdmVyc2lvbiA9IG5ldyBzZW12ZXIuUmFuZ2UodmVyc2lvblN0cmluZyk7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHNlbXZlciBleHByZXNzaW9uIGZvciAke25hbWV9OiAke3ZlcnNpb25TdHJpbmd9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGpzaWlGaWxlID0gYXdhaXQgX3RyeVJlc29sdmVBc3NlbWJseShuYW1lLCBsb2NhbFBhY2thZ2UsIHJvb3QpO1xuICAgIExPRy5kZWJ1ZyhgUmVzb2x2ZWQgZGVwZW5kZW5jeSAke25hbWV9IHRvICR7anNpaUZpbGV9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc29sdmVkVmVyc2lvbjogdmVyc2lvblN0cmluZyxcbiAgICAgIHJlc29sdmVkRmlsZToganNpaUZpbGUsXG4gICAgICBkZXBlbmRlbmN5SW5mbzogYXdhaXQgdGhpcy5sb2FkQXNzZW1ibHlBbmRSZWN1cnNlKGpzaWlGaWxlKSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkQXNzZW1ibHlBbmRSZWN1cnNlKGpzaWlGaWxlOiBzdHJpbmcpIHtcbiAgICAvLyBPbmx5IHJlY3Vyc2UgaWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgYXNzZW1ibHkgeWV0XG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKGpzaWlGaWxlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGpzaWlGaWxlKSE7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMubG9hZEFzc2VtYmx5KGpzaWlGaWxlKTtcbiAgICAvLyBDb250aW51ZSBsb2FkaW5nIGFueSBkZXBlbmRlbmNpZXMgZGVjbGFyZWQgaW4gdGhlIGFzbVxuXG4gICAgY29uc3QgcmVzb2x2ZWREZXBlbmRlbmNpZXMgPSBhc3NlbWJseS5kZXBlbmRlbmNpZXNcbiAgICAgID8gYXdhaXQgdGhpcy5kaXNjb3ZlckRlcGVuZGVuY3lUcmVlKFxuICAgICAgICAgIHBhdGguZGlybmFtZShqc2lpRmlsZSksXG4gICAgICAgICAgYXNzZW1ibHkuZGVwZW5kZW5jaWVzLFxuICAgICAgICApXG4gICAgICA6IHt9O1xuXG4gICAgY29uc3QgZGVwSW5mbzogRGVwZW5kZW5jeUluZm8gPSB7XG4gICAgICBhc3NlbWJseSxcbiAgICAgIHJlc29sdmVkRGVwZW5kZW5jaWVzLFxuICAgIH07XG4gICAgdGhpcy5jYWNoZS5zZXQoanNpaUZpbGUsIGRlcEluZm8pO1xuICAgIHJldHVybiBkZXBJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYSBKU0lJIGZpbGVuYW1lIGFuZCB2YWxpZGF0ZSBpdDsgY2FjaGVkIHRvIGF2b2lkIHJlZHVuZGFudCBsb2FkcyBvZiB0aGUgc2FtZSBKU0lJIGFzc2VtYmx5XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGxvYWRBc3NlbWJseShqc2lpRmlsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8c3BlYy5Bc3NlbWJseT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZnMucmVhZEpzb24oanNpaUZpbGVOYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGxvYWRpbmcgJHtqc2lpRmlsZU5hbWV9OiAke2V9YCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9yZXF1aXJlZDxUPih2YWx1ZTogVCwgbWVzc2FnZTogc3RyaW5nKTogVCB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3RvUGVyc29uKFxuICB2YWx1ZTogYW55LFxuICBmaWVsZDogc3RyaW5nLFxuICBkZWZhdWx0Um9sZTogc3RyaW5nID0gZmllbGQsXG4pOiBzcGVjLlBlcnNvbiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBwYXJzZVBlcnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBfcmVxdWlyZWQoXG4gICAgICB2YWx1ZS5uYW1lLFxuICAgICAgYFRoZSBcInBhY2thZ2UuanNvblwiIGZpbGUgbXVzdCBzcGVjaWZ5IHRoZSBcIiR7ZmllbGR9Lm5hbWVcIiBhdHRyaWJ1dGVgLFxuICAgICksXG4gICAgcm9sZXM6IHZhbHVlLnJvbGVzID8gWy4uLm5ldyBTZXQodmFsdWUucm9sZXMgYXMgc3RyaW5nW10pXSA6IFtkZWZhdWx0Um9sZV0sXG4gICAgZW1haWw6IHZhbHVlLmVtYWlsLFxuICAgIHVybDogdmFsdWUudXJsLFxuICAgIG9yZ2FuaXphdGlvbjogdmFsdWUub3JnYW5pemF0aW9uID8gdmFsdWUub3JnYW5pemF0aW9uIDogdW5kZWZpbmVkLFxuICB9O1xufVxuXG5mdW5jdGlvbiBfdG9SZXBvc2l0b3J5KHZhbHVlOiBhbnkpOiB7XG4gIHR5cGU6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIGRpcmVjdG9yeT86IHN0cmluZztcbn0ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gcGFyc2VSZXBvc2l0b3J5KHZhbHVlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVybDogX3JlcXVpcmVkKFxuICAgICAgdmFsdWUudXJsLFxuICAgICAgJ1RoZSBcInBhY2thZ2UuanNvblwiIGZpbGUgbXVzdCBzcGVjaWZ5IHRoZSBcInJlcG9zaXRvcnkudXJsXCIgYXR0cmlidXRlJyxcbiAgICApLFxuICAgIHR5cGU6IHZhbHVlLnR5cGUgfHwgX2d1ZXNzUmVwb3NpdG9yeVR5cGUodmFsdWUudXJsKSxcbiAgICBkaXJlY3Rvcnk6IHZhbHVlLmRpcmVjdG9yeSxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX3RyeVJlc29sdmVBc3NlbWJseShcbiAgbW9kOiBzdHJpbmcsXG4gIGxvY2FsUGFja2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBzZWFyY2hQYXRoOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAobG9jYWxQYWNrYWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGF0aC5qb2luKGxvY2FsUGFja2FnZSwgJy5qc2lpJyk7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZW1ibHkgZG9lcyBub3QgZXhpc3Q6ICR7cmVzdWx0fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZGVwZW5kZW5jeURpciA9IGF3YWl0IGZpbmREZXBlbmRlbmN5RGlyZWN0b3J5KG1vZCwgc2VhcmNoUGF0aCk7XG4gICAgcmV0dXJuIHBhdGguam9pbihkZXBlbmRlbmN5RGlyLCAnLmpzaWknKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmFibGUgdG8gbG9jYXRlIGpzaWkgYXNzZW1ibHkgZm9yIFwiJHttb2R9XCIuIElmIHRoaXMgbW9kdWxlIGlzIG5vdCBqc2lpLWVuYWJsZWQsIGl0IG11c3QgYWxzbyBiZSBkZWNsYXJlZCB1bmRlciBidW5kbGVkRGVwZW5kZW5jaWVzOiAke2V9YCxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIF92YWxpZGF0ZUxpY2Vuc2UoaWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChpZCA9PT0gJ1VOTElDRU5TRUQnKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGlmICghc3BkeC5oYXMoaWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgbGljZW5zZSBpZGVudGlmaWVyIFwiJHtpZH1cIiwgc2VlIHZhbGlkIGxpY2Vuc2UgaWRlbnRpZmllcnMgYXQgaHR0cHM6Ly9zcGR4Lm9yZy9saWNlbnNlcy9gLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBfdmFsaWRhdGVWZXJzaW9uRm9ybWF0KGZvcm1hdDogc3RyaW5nKTogJ3Nob3J0JyB8ICdmdWxsJyB7XG4gIGlmIChmb3JtYXQgIT09ICdzaG9ydCcgJiYgZm9ybWF0ICE9PSAnZnVsbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBqc2lpLnZlcnNpb25Gb3JtYXQgXCIke2Zvcm1hdH1cIiwgaXQgbXVzdCBiZSBlaXRoZXIgXCJzaG9ydFwiIG9yIFwiZnVsbFwiICh0aGUgZGVmYXVsdClgLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdDtcbn1cblxuZnVuY3Rpb24gX3ZhbGlkYXRlU3RhYmlsaXR5KFxuICBzdGFiaWxpdHk6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZGVwcmVjYXRlZDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuKTogc3BlYy5TdGFiaWxpdHkgfCB1bmRlZmluZWQge1xuICBpZiAoIXN0YWJpbGl0eSAmJiBkZXByZWNhdGVkKSB7XG4gICAgc3RhYmlsaXR5ID0gc3BlYy5TdGFiaWxpdHkuRGVwcmVjYXRlZDtcbiAgfSBlbHNlIGlmIChkZXByZWNhdGVkICYmIHN0YWJpbGl0eSAhPT0gc3BlYy5TdGFiaWxpdHkuRGVwcmVjYXRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBQYWNrYWdlIGlzIGRlcHJlY2F0ZWQgKCR7ZGVwcmVjYXRlZH0pLCBidXQgaXQncyBzdGFiaWxpdHkgaXMgJHtzdGFiaWxpdHl9IGFuZCBub3QgJHtzcGVjLlN0YWJpbGl0eS5EZXByZWNhdGVkfWAsXG4gICAgKTtcbiAgfVxuICBpZiAoIXN0YWJpbGl0eSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFPYmplY3QudmFsdWVzKHNwZWMuU3RhYmlsaXR5KS5pbmNsdWRlcyhzdGFiaWxpdHkgYXMgYW55KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHN0YWJpbGl0eSBcIiR7c3RhYmlsaXR5fVwiLCBpdCBtdXN0IGJlIG9uZSBvZiAke09iamVjdC52YWx1ZXMoXG4gICAgICAgIHNwZWMuU3RhYmlsaXR5LFxuICAgICAgKS5qb2luKCcsICcpfWAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3RhYmlsaXR5IGFzIHNwZWMuU3RhYmlsaXR5O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGFuIE5QTSBwYWNrYWdlIHNwZWNpZmllciB0byBhIHZlcnNpb24gcmFuZ2VcbiAqXG4gKiBJZiBpdCB3YXMgYWxyZWFkeSBhIHZlcnNpb24gcmFuZ2UsIHJldHVybiBpdC4gSWYgaXQgdGhlXG4gKiBwYWNrYWdlIHJlZmVyZW5jZXMgYSBsb2NhbCBmaWxlLCByZXR1cm4gdGhlIHZlcnNpb24gdGhhdFxuICogcGFja2FnZSBpcyBhdC5cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVWZXJzaW9uKFxuICBkZXA6IHN0cmluZyxcbiAgc2VhcmNoUGF0aDogc3RyaW5nLFxuKTogeyB2ZXJzaW9uOiBzdHJpbmc7IGxvY2FsUGFja2FnZT86IHN0cmluZyB9IHtcbiAgY29uc3QgbWF0Y2hlcyA9IC9eZmlsZTooLispJC8uZXhlYyhkZXApO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4geyB2ZXJzaW9uOiBkZXAgfTtcbiAgfVxuICBjb25zdCBsb2NhbFBhY2thZ2UgPSBwYXRoLnJlc29sdmUoc2VhcmNoUGF0aCwgbWF0Y2hlc1sxXSk7XG4gIHJldHVybiB7XG4gICAgLy8gUmVuZGVyaW5nIGFzIGEgY2FyZXQgdmVyc2lvbiB0byBtYWludGFpbiB1bmlmb3JtaXR5IGFnYWluc3QgdGhlIFwic3RhbmRhcmRcIi5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgdmVyc2lvbjogYF4ke1xuICAgICAgZnMucmVhZEpzb25TeW5jKHBhdGguam9pbihsb2NhbFBhY2thZ2UsICdwYWNrYWdlLmpzb24nKSkudmVyc2lvblxuICAgIH1gLFxuICAgIGxvY2FsUGFja2FnZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgdHdvIG1ldGFkYXRhIGJsb2NrcyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0gYmFzZSB0aGUgYmFzZSB2YWx1ZXNcbiAqIEBwYXJhbSB1c2VyIHRoZSB1c2VyLXN1cHBsaWVkIHZhbHVlcywgd2hpY2ggY2FuIG92ZXJyaWRlIHRoZSBgYmFzZWAgdmFsdWVzXG4gKlxuICogQHJldHVybnMgdGhlIG1lcmdlZCBtZXRhZGF0YSBibG9ja1xuICovXG5mdW5jdGlvbiBtZXJnZU1ldGFkYXRhKFxuICBiYXNlOiBOb25OdWxsYWJsZTxQcm9qZWN0SW5mb1snbWV0YWRhdGEnXT4sXG4gIHVzZXI6IFByb2plY3RJbmZvWydtZXRhZGF0YSddLFxuKTogUHJvamVjdEluZm9bJ21ldGFkYXRhJ10ge1xuICBpZiAodXNlciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgcmV0dXJuIG1lcmdlT2JqZWN0cyhiYXNlLCB1c2VyKTtcblxuICBmdW5jdGlvbiBtZXJnZU9iamVjdHMoXG4gICAgYmFzZTogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICBvdmVycmlkZTogUmVjb3JkPHN0cmluZywgYW55PixcbiAgKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gICAgY29uc3QgYWxsS2V5cyA9IEFycmF5LmZyb20oXG4gICAgICBuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyhiYXNlKSwgLi4uT2JqZWN0LmtleXMob3ZlcnJpZGUpXSksXG4gICAgKS5zb3J0KCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgICAgY29uc3QgYmFzZVZhbHVlID0gYmFzZVtrZXldO1xuICAgICAgY29uc3Qgb3ZlcnJpZGVWYWx1ZSA9IG92ZXJyaWRlW2tleV07XG5cbiAgICAgIGlmICh0eXBlb2YgYmFzZVZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3ZlcnJpZGVWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VPYmplY3RzKGJhc2VWYWx1ZSwgb3ZlcnJpZGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb3ZlcnJpZGVWYWx1ZSA/PyBiYXNlVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2xvYWREaWFnbm9zdGljcyhlbnRyaWVzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSk6XG4gIHwge1xuICAgICAgW2tleTogc3RyaW5nXTogdHMuRGlhZ25vc3RpY0NhdGVnb3J5O1xuICAgIH1cbiAgfCB1bmRlZmluZWQge1xuICBpZiAoZW50cmllcyA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKGVudHJpZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgcmVzdWx0OiB7IFtrZXk6IHN0cmluZ106IHRzLkRpYWdub3N0aWNDYXRlZ29yeSB9ID0ge307XG4gIGZvciAoY29uc3QgY29kZSBvZiBPYmplY3Qua2V5cyhlbnRyaWVzKSkge1xuICAgIGxldCBjYXRlZ29yeTogdHMuRGlhZ25vc3RpY0NhdGVnb3J5O1xuICAgIHN3aXRjaCAoZW50cmllc1tjb2RlXS50cmltKCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjYXRlZ29yeSA9IHRzLkRpYWdub3N0aWNDYXRlZ29yeS5FcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgY2F0ZWdvcnkgPSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuV2FybmluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdWdnZXN0aW9uJzpcbiAgICAgICAgY2F0ZWdvcnkgPSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuU3VnZ2VzdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgY2F0ZWdvcnkgPSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuTWVzc2FnZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgY2F0ZWdvcnkgJyR7ZW50cmllc1tjb2RlXX0nIGZvciBjb2RlICcke2NvZGV9J2AsXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJlc3VsdFtjb2RlXSA9IGNhdGVnb3J5O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckRpY3RCeUtleTxBPihcbiAgeHM6IFJlY29yZDxzdHJpbmcsIEE+LFxuICBwcmVkaWNhdGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhbixcbik6IFJlY29yZDxzdHJpbmcsIEE+IHtcbiAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCBBPiA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh4cykpIHtcbiAgICBpZiAocHJlZGljYXRlKGtleSkpIHtcbiAgICAgIHJldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXX0=