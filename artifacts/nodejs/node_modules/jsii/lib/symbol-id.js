"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizePath = exports.symbolIdentifier = void 0;
const fs = require("fs-extra");
const path = require("path");
const ts = require("typescript");
const utils_1 = require("./utils");
/**
 * Return a symbol identifier for the given symbol
 *
 * The symbol identifier identifies a TypeScript symbol in a source file inside
 * a package. We can use this to map between jsii entries in the manifest, and
 * entities in the TypeScript source code.
 *
 * Going via symbol id is the only way to identify symbols in submodules. Otherwise,
 * all the TypeScript compiler sees is:
 *
 * ```
 * /my/package/lib/source/directory/dist.js <containing> MyClass
 * ```
 *
 * And there's no way to figure out what submodule name
 * `lib/source/directory/dist` is exported as.
 *
 * The format of a symbol id is:
 *
 * ```
 * relative/source/file:Name.space.Class[#member]
 * ```
 *
 * We used to build this identifier ourselves. Turns out there was a built-in
 * way to get pretty much the same, by calling `typeChecker.getFullyQualifiedName()`.
 * Whoops ^_^ (this historical accident is why the format is similar to but
 * different from what the TS checker returns).
 */
function symbolIdentifier(typeChecker, sym, options = {}) {
    // If this symbol happens to be an alias, resolve it first
    while ((sym.flags & ts.SymbolFlags.Alias) !== 0) {
        sym = typeChecker.getAliasedSymbol(sym);
    }
    const isMember = (sym.flags &
        (ts.SymbolFlags.Method |
            ts.SymbolFlags.Property |
            ts.SymbolFlags.EnumMember)) !==
        0;
    const tsName = typeChecker.getFullyQualifiedName(sym);
    // TypeScript fqn looks like "/path/to/file"[.name.in.file]
    const groups = /^"([^"]+)"(?:\.(.*))?$/.exec(tsName);
    if (!groups) {
        return undefined;
    }
    const [, fileName, inFileName] = groups; // inFileName may be absent
    const relFile = assemblyRelativeSourceFile(fileName, options === null || options === void 0 ? void 0 : options.assembly);
    if (!relFile) {
        return undefined;
    }
    // If this is a member symbol, replace the final '.' with a '#'
    const typeSymbol = isMember
        ? (inFileName !== null && inFileName !== void 0 ? inFileName : '').replace(/\.([^.]+)$/, '#$1')
        : inFileName !== null && inFileName !== void 0 ? inFileName : '';
    return `${relFile}:${typeSymbol}`;
}
exports.symbolIdentifier = symbolIdentifier;
function assemblyRelativeSourceFile(sourceFileName, asm) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const packageJsonDir = utils_1.findUp(path.dirname(sourceFileName), (dir) => fs.pathExistsSync(path.join(dir, 'package.json')));
    if (!packageJsonDir) {
        return undefined;
    }
    const packageJson = fs.readJsonSync(path.join(packageJsonDir, 'package.json'));
    let sourcePath = removePrefix((_b = (_a = packageJson.jsii) === null || _a === void 0 ? void 0 : _a.outdir) !== null && _b !== void 0 ? _b : '', path.relative(packageJsonDir, sourceFileName));
    // Modify the namespace if we send in the assembly.
    if (asm) {
        const tscRootDir = (_e = (_d = (_c = packageJson.jsii) === null || _c === void 0 ? void 0 : _c.tsc) === null || _d === void 0 ? void 0 : _d.rootDir) !== null && _e !== void 0 ? _e : (_f = asm.metadata) === null || _f === void 0 ? void 0 : _f.tscRootDir;
        const tscOutDir = (_h = (_g = packageJson.jsii) === null || _g === void 0 ? void 0 : _g.tsc) === null || _h === void 0 ? void 0 : _h.outDir;
        sourcePath = normalizePath(sourcePath, tscRootDir, tscOutDir);
    }
    return sourcePath.replace(/(\.d)?\.ts$/, '');
    function removePrefix(prefix, filePath) {
        const prefixParts = prefix.split(/[/\\]/g);
        const pathParts = filePath.split(/[/\\]/g);
        let i = 0;
        while (prefixParts[i] === pathParts[i]) {
            i++;
        }
        return pathParts.slice(i).join('/');
    }
}
/**
 * Ensures that the sourcePath is pointing to the source code
 * and not compiled code. This can happen if the root directory
 * and/or out directory is set for the project. We check to see
 * if the out directory is present in the sourcePath, and if so,
 * we replace it with the root directory.
 */
function normalizePath(sourcePath, rootDir, outDir) {
    if (rootDir === undefined || outDir === undefined) {
        return sourcePath;
    }
    outDir = removeEndSlash(path.normalize(outDir));
    const outDirLength = outDir.split(path.sep).length;
    rootDir = removeEndSlash(path.normalize(rootDir));
    let paths = path.normalize(sourcePath).split(path.sep);
    const pathDir = paths.slice(0, outDirLength).join(path.sep);
    if (outDir === pathDir || outDir === '.') {
        // outDir === '.' is a special case where we do not want
        // to remove any paths from the list.
        if (outDir !== '.') {
            paths = paths.slice(outDirLength);
        }
        sourcePath =
            rootDir === '.' ? paths.join('/') : `${rootDir}/${paths.join('/')}`;
    }
    return unixize(sourcePath);
    function removeEndSlash(filePath) {
        return filePath.endsWith(path.sep)
            ? filePath.slice(0, filePath.length - 1)
            : filePath;
    }
}
exports.normalizePath = normalizePath;
/**
 * Turn backslashes in a path into forward slashes
 */
function unixize(p) {
    return p.replace(/\\/g, '/');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ltYm9sLWlkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3ltYm9sLWlkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBRWpDLG1DQUFpQztBQWdCakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJCRztBQUNILFNBQWdCLGdCQUFnQixDQUM5QixXQUEyQixFQUMzQixHQUFjLEVBQ2QsVUFBMkIsRUFBRTtJQUU3QiwwREFBMEQ7SUFDMUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDL0MsR0FBRyxHQUFHLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUN6QztJQUVELE1BQU0sUUFBUSxHQUNaLENBQUMsR0FBRyxDQUFDLEtBQUs7UUFDUixDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsTUFBTTtZQUNwQixFQUFFLENBQUMsV0FBVyxDQUFDLFFBQVE7WUFDdkIsRUFBRSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMvQixDQUFDLENBQUM7SUFFSixNQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFdEQsMkRBQTJEO0lBQzNELE1BQU0sTUFBTSxHQUFHLHdCQUF3QixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNyRCxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1gsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFFRCxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsMkJBQTJCO0lBRXBFLE1BQU0sT0FBTyxHQUFHLDBCQUEwQixDQUFDLFFBQVEsRUFBRSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsUUFBUSxDQUFDLENB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bHkgfSBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHsgZmluZFVwIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogQWRkaXRpb25hbCBvcHRpb25zIHRoYXQgbWF5IGJlIHByb3ZpZGVkIHRvIHRoZSBzeW1ib2xJZGVudGlmaWVyLlxuICovXG5pbnRlcmZhY2UgU3ltYm9sSWRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBhc3NlbWJseSB0aGF0IHRoZSBzeW1ib2wgaXMgZm91bmQgaW4uXG4gICAqIFRoaXMgaXMgdXNlZCB0byBwcm92aWRlIHRoZSBjb3JyZWN0IHJvb3QgZGlyZWN0b3J5XG4gICAqIGFzIHNwZWNpZmllZCBpbiB0aGUgYXNzZW1ibHkgbWV0YWRhdGEuIEluIHR1cm4sXG4gICAqIHRoZSByb290IGRpcmVjdG9yeSBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgKiBzeW1ib2xJZCBjb21lcyBmcm9tIHNvdXJjZSBjb2RlIGFuZCBub3QgY29tcGlsZWQgY29kZS5cbiAgICovXG4gIHJlYWRvbmx5IGFzc2VtYmx5PzogQXNzZW1ibHk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgc3ltYm9sIGlkZW50aWZpZXIgZm9yIHRoZSBnaXZlbiBzeW1ib2xcbiAqXG4gKiBUaGUgc3ltYm9sIGlkZW50aWZpZXIgaWRlbnRpZmllcyBhIFR5cGVTY3JpcHQgc3ltYm9sIGluIGEgc291cmNlIGZpbGUgaW5zaWRlXG4gKiBhIHBhY2thZ2UuIFdlIGNhbiB1c2UgdGhpcyB0byBtYXAgYmV0d2VlbiBqc2lpIGVudHJpZXMgaW4gdGhlIG1hbmlmZXN0LCBhbmRcbiAqIGVudGl0aWVzIGluIHRoZSBUeXBlU2NyaXB0IHNvdXJjZSBjb2RlLlxuICpcbiAqIEdvaW5nIHZpYSBzeW1ib2wgaWQgaXMgdGhlIG9ubHkgd2F5IHRvIGlkZW50aWZ5IHN5bWJvbHMgaW4gc3VibW9kdWxlcy4gT3RoZXJ3aXNlLFxuICogYWxsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIHNlZXMgaXM6XG4gKlxuICogYGBgXG4gKiAvbXkvcGFja2FnZS9saWIvc291cmNlL2RpcmVjdG9yeS9kaXN0LmpzIDxjb250YWluaW5nPiBNeUNsYXNzXG4gKiBgYGBcbiAqXG4gKiBBbmQgdGhlcmUncyBubyB3YXkgdG8gZmlndXJlIG91dCB3aGF0IHN1Ym1vZHVsZSBuYW1lXG4gKiBgbGliL3NvdXJjZS9kaXJlY3RvcnkvZGlzdGAgaXMgZXhwb3J0ZWQgYXMuXG4gKlxuICogVGhlIGZvcm1hdCBvZiBhIHN5bWJvbCBpZCBpczpcbiAqXG4gKiBgYGBcbiAqIHJlbGF0aXZlL3NvdXJjZS9maWxlOk5hbWUuc3BhY2UuQ2xhc3NbI21lbWJlcl1cbiAqIGBgYFxuICpcbiAqIFdlIHVzZWQgdG8gYnVpbGQgdGhpcyBpZGVudGlmaWVyIG91cnNlbHZlcy4gVHVybnMgb3V0IHRoZXJlIHdhcyBhIGJ1aWx0LWluXG4gKiB3YXkgdG8gZ2V0IHByZXR0eSBtdWNoIHRoZSBzYW1lLCBieSBjYWxsaW5nIGB0eXBlQ2hlY2tlci5nZXRGdWxseVF1YWxpZmllZE5hbWUoKWAuXG4gKiBXaG9vcHMgXl9eICh0aGlzIGhpc3RvcmljYWwgYWNjaWRlbnQgaXMgd2h5IHRoZSBmb3JtYXQgaXMgc2ltaWxhciB0byBidXRcbiAqIGRpZmZlcmVudCBmcm9tIHdoYXQgdGhlIFRTIGNoZWNrZXIgcmV0dXJucykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzeW1ib2xJZGVudGlmaWVyKFxuICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gIHN5bTogdHMuU3ltYm9sLFxuICBvcHRpb25zOiBTeW1ib2xJZE9wdGlvbnMgPSB7fSxcbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIC8vIElmIHRoaXMgc3ltYm9sIGhhcHBlbnMgdG8gYmUgYW4gYWxpYXMsIHJlc29sdmUgaXQgZmlyc3RcbiAgd2hpbGUgKChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykgIT09IDApIHtcbiAgICBzeW0gPSB0eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bSk7XG4gIH1cblxuICBjb25zdCBpc01lbWJlciA9XG4gICAgKHN5bS5mbGFncyAmXG4gICAgICAodHMuU3ltYm9sRmxhZ3MuTWV0aG9kIHxcbiAgICAgICAgdHMuU3ltYm9sRmxhZ3MuUHJvcGVydHkgfFxuICAgICAgICB0cy5TeW1ib2xGbGFncy5FbnVtTWVtYmVyKSkgIT09XG4gICAgMDtcblxuICBjb25zdCB0c05hbWUgPSB0eXBlQ2hlY2tlci5nZXRGdWxseVF1YWxpZmllZE5hbWUoc3ltKTtcblxuICAvLyBUeXBlU2NyaXB0IGZxbiBsb29rcyBsaWtlIFwiL3BhdGgvdG8vZmlsZVwiWy5uYW1lLmluLmZpbGVdXG4gIGNvbnN0IGdyb3VwcyA9IC9eXCIoW15cIl0rKVwiKD86XFwuKC4qKSk/JC8uZXhlYyh0c05hbWUpO1xuICBpZiAoIWdyb3Vwcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBbLCBmaWxlTmFtZSwgaW5GaWxlTmFtZV0gPSBncm91cHM7IC8vIGluRmlsZU5hbWUgbWF5IGJlIGFic2VudFxuXG4gIGNvbnN0IHJlbEZpbGUgPSBhc3NlbWJseVJlbGF0aXZlU291cmNlRmlsZShmaWxlTmFtZSwgb3B0aW9ucz8uYXNzZW1ibHkpO1xuICBpZiAoIXJlbEZpbGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gSWYgdGhpcyBpcyBhIG1lbWJlciBzeW1ib2wsIHJlcGxhY2UgdGhlIGZpbmFsICcuJyB3aXRoIGEgJyMnXG4gIGNvbnN0IHR5cGVTeW1ib2wgPSBpc01lbWJlclxuICAgID8gKGluRmlsZU5hbWUgPz8gJycpLnJlcGxhY2UoL1xcLihbXi5dKykkLywgJyMkMScpXG4gICAgOiBpbkZpbGVOYW1lID8/ICcnO1xuXG4gIHJldHVybiBgJHtyZWxGaWxlfToke3R5cGVTeW1ib2x9YDtcbn1cblxuZnVuY3Rpb24gYXNzZW1ibHlSZWxhdGl2ZVNvdXJjZUZpbGUoc291cmNlRmlsZU5hbWU6IHN0cmluZywgYXNtPzogQXNzZW1ibHkpIHtcbiAgY29uc3QgcGFja2FnZUpzb25EaXIgPSBmaW5kVXAocGF0aC5kaXJuYW1lKHNvdXJjZUZpbGVOYW1lKSwgKGRpcikgPT5cbiAgICBmcy5wYXRoRXhpc3RzU3luYyhwYXRoLmpvaW4oZGlyLCAncGFja2FnZS5qc29uJykpLFxuICApO1xuXG4gIGlmICghcGFja2FnZUpzb25EaXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgcGFja2FnZUpzb24gPSBmcy5yZWFkSnNvblN5bmMoXG4gICAgcGF0aC5qb2luKHBhY2thZ2VKc29uRGlyLCAncGFja2FnZS5qc29uJyksXG4gICk7XG5cbiAgbGV0IHNvdXJjZVBhdGggPSByZW1vdmVQcmVmaXgoXG4gICAgcGFja2FnZUpzb24uanNpaT8ub3V0ZGlyID8/ICcnLFxuICAgIHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25EaXIsIHNvdXJjZUZpbGVOYW1lKSxcbiAgKTtcblxuICAvLyBNb2RpZnkgdGhlIG5hbWVzcGFjZSBpZiB3ZSBzZW5kIGluIHRoZSBhc3NlbWJseS5cbiAgaWYgKGFzbSkge1xuICAgIGNvbnN0IHRzY1Jvb3REaXIgPVxuICAgICAgcGFja2FnZUpzb24uanNpaT8udHNjPy5yb290RGlyID8/IGFzbS5tZXRhZGF0YT8udHNjUm9vdERpcjtcbiAgICBjb25zdCB0c2NPdXREaXIgPSBwYWNrYWdlSnNvbi5qc2lpPy50c2M/Lm91dERpcjtcbiAgICBzb3VyY2VQYXRoID0gbm9ybWFsaXplUGF0aChzb3VyY2VQYXRoLCB0c2NSb290RGlyLCB0c2NPdXREaXIpO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVBhdGgucmVwbGFjZSgvKFxcLmQpP1xcLnRzJC8sICcnKTtcblxuICBmdW5jdGlvbiByZW1vdmVQcmVmaXgocHJlZml4OiBzdHJpbmcsIGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwcmVmaXhQYXJ0cyA9IHByZWZpeC5zcGxpdCgvWy9cXFxcXS9nKTtcbiAgICBjb25zdCBwYXRoUGFydHMgPSBmaWxlUGF0aC5zcGxpdCgvWy9cXFxcXS9nKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKHByZWZpeFBhcnRzW2ldID09PSBwYXRoUGFydHNbaV0pIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhQYXJ0cy5zbGljZShpKS5qb2luKCcvJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgdGhlIHNvdXJjZVBhdGggaXMgcG9pbnRpbmcgdG8gdGhlIHNvdXJjZSBjb2RlXG4gKiBhbmQgbm90IGNvbXBpbGVkIGNvZGUuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgcm9vdCBkaXJlY3RvcnlcbiAqIGFuZC9vciBvdXQgZGlyZWN0b3J5IGlzIHNldCBmb3IgdGhlIHByb2plY3QuIFdlIGNoZWNrIHRvIHNlZVxuICogaWYgdGhlIG91dCBkaXJlY3RvcnkgaXMgcHJlc2VudCBpbiB0aGUgc291cmNlUGF0aCwgYW5kIGlmIHNvLFxuICogd2UgcmVwbGFjZSBpdCB3aXRoIHRoZSByb290IGRpcmVjdG9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgoXG4gIHNvdXJjZVBhdGg6IHN0cmluZyxcbiAgcm9vdERpcj86IHN0cmluZyxcbiAgb3V0RGlyPzogc3RyaW5nLFxuKTogc3RyaW5nIHtcbiAgaWYgKHJvb3REaXIgPT09IHVuZGVmaW5lZCB8fCBvdXREaXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzb3VyY2VQYXRoO1xuICB9XG5cbiAgb3V0RGlyID0gcmVtb3ZlRW5kU2xhc2gocGF0aC5ub3JtYWxpemUob3V0RGlyKSk7XG4gIGNvbnN0IG91dERpckxlbmd0aCA9IG91dERpci5zcGxpdChwYXRoLnNlcCkubGVuZ3RoO1xuICByb290RGlyID0gcmVtb3ZlRW5kU2xhc2gocGF0aC5ub3JtYWxpemUocm9vdERpcikpO1xuXG4gIGxldCBwYXRocyA9IHBhdGgubm9ybWFsaXplKHNvdXJjZVBhdGgpLnNwbGl0KHBhdGguc2VwKTtcbiAgY29uc3QgcGF0aERpciA9IHBhdGhzLnNsaWNlKDAsIG91dERpckxlbmd0aCkuam9pbihwYXRoLnNlcCk7XG5cbiAgaWYgKG91dERpciA9PT0gcGF0aERpciB8fCBvdXREaXIgPT09ICcuJykge1xuICAgIC8vIG91dERpciA9PT0gJy4nIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGRvIG5vdCB3YW50XG4gICAgLy8gdG8gcmVtb3ZlIGFueSBwYXRocyBmcm9tIHRoZSBsaXN0LlxuICAgIGlmIChvdXREaXIgIT09ICcuJykge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZShvdXREaXJMZW5ndGgpO1xuICAgIH1cbiAgICBzb3VyY2VQYXRoID1cbiAgICAgIHJvb3REaXIgPT09ICcuJyA/IHBhdGhzLmpvaW4oJy8nKSA6IGAke3Jvb3REaXJ9LyR7cGF0aHMuam9pbignLycpfWA7XG4gIH1cbiAgcmV0dXJuIHVuaXhpemUoc291cmNlUGF0aCk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRW5kU2xhc2goZmlsZVBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBmaWxlUGF0aC5lbmRzV2l0aChwYXRoLnNlcClcbiAgICAgID8gZmlsZVBhdGguc2xpY2UoMCwgZmlsZVBhdGgubGVuZ3RoIC0gMSlcbiAgICAgIDogZmlsZVBhdGg7XG4gIH1cbn1cblxuLyoqXG4gKiBUdXJuIGJhY2tzbGFzaGVzIGluIGEgcGF0aCBpbnRvIGZvcndhcmQgc2xhc2hlc1xuICovXG5mdW5jdGlvbiB1bml4aXplKHA6IHN0cmluZykge1xuICByZXR1cm4gcC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG59XG4iXX0=