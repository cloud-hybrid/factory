"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const spec = require("@jsii/spec");
const clone = require("clone");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const ts = require("typescript");
const project_info_1 = require("../lib/project-info");
const version_1 = require("../lib/version");
const BASE_PROJECT = {
    name: 'jsii-test',
    version: '1.0.0',
    description: 'A test project for jsii ProjectInfo loading',
    license: 'Apache-2.0',
    author: {
        name: 'Amazon Web Services',
        url: 'https://aws.amazon.com',
        organization: true,
    },
    repository: { url: 'git://github.com/aws/jsii.git' },
    main: 'index.js',
    types: 'index.d.ts',
    jsii: {
        targets: { foo: { bar: 'baz' } },
    },
    dependencies: { 'jsii-test-dep': '^1.2.3' },
    peerDependencies: { 'jsii-test-dep': '^1.2.3' },
};
describe('loadProjectInfo', () => {
    test('loads valid project', () => _withTestProject(async (projectRoot) => {
        var _a, _b;
        const { projectInfo: info } = await project_info_1.loadProjectInfo(projectRoot);
        expect(info.name).toBe(BASE_PROJECT.name);
        expect(info.version).toBe(BASE_PROJECT.version);
        expect(info.description).toBe(BASE_PROJECT.description);
        expect(info.license).toBe(BASE_PROJECT.license);
        expect(_stripUndefined(info.author)).toEqual({
            ...BASE_PROJECT.author,
            roles: ['author'],
        });
        expect(info.main).toBe(BASE_PROJECT.main);
        expect(info.types).toBe(BASE_PROJECT.types);
        expect(info.homepage).toBe(undefined);
        expect((_a = info.repository) === null || _a === void 0 ? void 0 : _a.type).toBe('git');
        expect((_b = info.repository) === null || _b === void 0 ? void 0 : _b.url).toBe(BASE_PROJECT.repository.url);
        expect(info.targets).toEqual({
            ...BASE_PROJECT.jsii.targets,
            js: { npm: BASE_PROJECT.name },
        });
        expect(info.dependencies).toEqual({
            [TEST_DEP_ASSEMBLY.name]: BASE_PROJECT.dependencies[TEST_DEP_ASSEMBLY.name],
        });
        expect(info.dependencyClosure).toEqual([
            TEST_DEP_ASSEMBLY,
            TEST_DEP_DEP_ASSEMBLY,
        ]);
    }));
    test('loads valid project (UNLICENSED)', () => _withTestProject(async (projectRoot) => {
        const { projectInfo: info } = await project_info_1.loadProjectInfo(projectRoot);
        expect(info === null || info === void 0 ? void 0 : info.license).toBe('UNLICENSED');
    }, (info) => {
        info.license = 'UNLICENSED';
    }));
    test('loads valid project (using bundleDependencies)', () => _withTestProject(async (projectRoot) => {
        const { projectInfo: info } = await project_info_1.loadProjectInfo(projectRoot);
        expect(info.bundleDependencies).toEqual({ bundled: '^1.2.3' });
    }, (info) => {
        info.dependencies.bundled = '^1.2.3';
        info.bundleDependencies = ['bundled'];
    }));
    test('loads valid project (using bundledDependencies)', () => _withTestProject(async (projectRoot) => {
        const { projectInfo: info } = await project_info_1.loadProjectInfo(projectRoot);
        expect(info.bundleDependencies).toEqual({ bundled: '^1.2.3' });
    }, (info) => {
        info.dependencies.bundled = '^1.2.3';
        info.bundledDependencies = ['bundled'];
    }));
    test('loads valid project (with contributors)', () => {
        const contributors = [{ name: 'foo', email: 'nobody@amazon.com' }];
        return _withTestProject(async (projectRoot) => {
            var _a;
            const { projectInfo: info } = await project_info_1.loadProjectInfo(projectRoot);
            expect((_a = info === null || info === void 0 ? void 0 : info.contributors) === null || _a === void 0 ? void 0 : _a.map(_stripUndefined)).toEqual(contributors.map((c) => ({ ...c, roles: ['contributor'] })));
        }, (info) => (info.contributors = contributors));
    });
    test('rejects un-declared dependency in bundleDependencies', () => _withTestProject((projectRoot) => expect(project_info_1.loadProjectInfo(projectRoot)).rejects.toThrow(/not declared in "dependencies"/i), (info) => {
        info.bundledDependencies = ['bundled'];
    }));
    test('rejects invalid license', () => _withTestProject((projectRoot) => expect(project_info_1.loadProjectInfo(projectRoot)).rejects.toThrow(/invalid license identifier/i), (info) => {
        info.license = 'Not an SPDX licence ID';
    }));
    test('rejects incompatible dependency version', () => _withTestProject((projectRoot) => expect(project_info_1.loadProjectInfo(projectRoot)).rejects.toThrow(/declared dependency on version .+ but version .+ was found/i), (info) => {
        info.dependencies[TEST_DEP_ASSEMBLY.name] = '^1.2.5';
        info.peerDependencies[TEST_DEP_ASSEMBLY.name] = '^1.2.5';
    }));
    test('missing peerDependencies are allowed', () => _withTestProject((projectRoot) => expect(project_info_1.loadProjectInfo(projectRoot)).resolves.toEqual(expect.objectContaining({
        diagnostics: [],
    })), (info) => {
        delete info.peerDependencies[TEST_DEP_ASSEMBLY.name];
    }));
    test('warns if peerDependency misses a matching devDependency', () => _withTestProject((projectRoot) => expect(project_info_1.loadProjectInfo(projectRoot)).resolves.toEqual(expect.objectContaining({
        diagnostics: [expect.objectContaining({ jsiiCode: 6 })],
    })), () => {
        // By default there is no devDependency in BASE_PROJECT
    }));
    test('warns if peerDependency has a devDependency on the wrong version', () => _withTestProject((projectRoot) => expect(project_info_1.loadProjectInfo(projectRoot)).resolves.toEqual(expect.objectContaining({
        diagnostics: [expect.objectContaining({ jsiiCode: 6 })],
    })), (info) => {
        // By default there is no devDependency in BASE_PROJECT
        info.devDependencies = { 'jsii-test-dep': '4.5.6' };
    }));
    test('no warnings if devDependency point version matches peerDependency range', () => _withTestProject((projectRoot) => expect(project_info_1.loadProjectInfo(projectRoot)).resolves.toEqual(expect.objectContaining({
        diagnostics: [],
    })), (info) => {
        // By default there is no devDependency in BASE_PROJECT
        info.devDependencies = { 'jsii-test-dep': '1.2.3' };
    }));
    describe('_loadDiagnostics', () => {
        test('diagnostic categories are correctly detected', () => {
            return _withTestProject(async (projectRoot) => {
                const { projectInfo: info } = await project_info_1.loadProjectInfo(projectRoot);
                expect(info.diagnostics).toBeDefined();
                const diagnostics = info.diagnostics;
                expect(Object.keys(diagnostics).sort()).toEqual([
                    'diagCode1',
                    'diagCode2',
                    'diagCode3',
                    'diagCode4',
                ]);
                expect(diagnostics.diagCode1).toEqual(ts.DiagnosticCategory.Error);
                expect(diagnostics.diagCode2).toEqual(ts.DiagnosticCategory.Warning);
                expect(diagnostics.diagCode3).toEqual(ts.DiagnosticCategory.Suggestion);
                expect(diagnostics.diagCode4).toEqual(ts.DiagnosticCategory.Message);
            }, (info) => {
                const diagnostics = {
                    diagCode1: 'error',
                    diagCode2: 'warning',
                    diagCode3: 'suggestion',
                    diagCode4: 'message',
                };
                info.jsii.diagnostics = diagnostics;
            });
        });
        test('invalid category is rejected', () => {
            return _withTestProject((projectRoot) => expect(project_info_1.loadProjectInfo(projectRoot)).rejects.toThrow(/Invalid category/), (info) => {
                const diagnostics = {
                    diagCode1: 'invalid-category',
                };
                info.jsii.diagnostics = diagnostics;
            });
        });
    });
});
const TEST_DEP_ASSEMBLY = {
    schema: spec.SchemaVersion.LATEST,
    name: 'jsii-test-dep',
    version: '1.2.4',
    license: 'Apache-2.0',
    description: 'A jsii dependency of jsii-test',
    homepage: 'https://github.com/aws/jsii',
    repository: { type: 'git', url: 'git://github.com/aws/jsii.git' },
    author: {
        name: 'Amazon Web Services',
        url: 'https://aws.amazon.com',
        organization: true,
        roles: ['author'],
    },
    fingerprint: 'F1NG3RPR1N7',
    dependencies: {
        'jsii-test-dep-dep': '3.2.1',
    },
    jsiiVersion: version_1.VERSION,
};
const TEST_DEP_DEP_ASSEMBLY = {
    schema: spec.SchemaVersion.LATEST,
    name: 'jsii-test-dep-dep',
    version: '3.2.1',
    license: 'Apache-2.0',
    description: 'A jsii dependency of jsii-test-dep',
    homepage: 'https://github.com/aws/jsii',
    repository: { type: 'git', url: 'git://github.com/aws/jsii.git' },
    author: {
        name: 'Amazon Web Services',
        url: 'https://aws.amazon.com',
        organization: true,
        roles: ['author'],
    },
    jsiiVersion: version_1.VERSION,
    fingerprint: 'F1NG3RPR1N7',
};
/**
 * Creates a throw-away directory with a ``package.json`` file. Cleans up after itself.
 *
 * @param cb      a callback that will be invoked with the temporary directory's path
 * @param gremlin a function that can modify the content of ``package.json`` before it is written
 *
 * @return the result of executing ``cb``.
 */
async function _withTestProject(cb, gremlin) {
    const tmpdir = await fs.mkdtemp(path.join(os.tmpdir(), path.basename(__filename)));
    try {
        const packageInfo = clone(BASE_PROJECT);
        if (gremlin) {
            gremlin(packageInfo);
        }
        await fs.writeJson(path.join(tmpdir, 'package.json'), packageInfo, {
            spaces: 2,
        });
        await fs.writeFile(path.join(tmpdir, 'index.js'), '// There ought to be some javascript');
        await fs.writeFile(path.join(tmpdir, 'index.ts'), '// There ought to be some typescript');
        await fs.writeFile(path.join(tmpdir, 'index.d.ts'), '// There ought to be some typescript definitions');
        const jsiiTestDep = path.join(tmpdir, 'node_modules', 'jsii-test-dep');
        await writeNpmPackageSkeleton(jsiiTestDep);
        await fs.writeJson(path.join(jsiiTestDep, '.jsii'), TEST_DEP_ASSEMBLY);
        const jsiiTestDepDep = path.join(jsiiTestDep, 'node_modules', 'jsii-test-dep-dep');
        await writeNpmPackageSkeleton(jsiiTestDepDep);
        await fs.writeJson(path.join(jsiiTestDepDep, '.jsii'), TEST_DEP_DEP_ASSEMBLY);
        return await cb(tmpdir);
    }
    finally {
        await fs.remove(tmpdir);
    }
}
/**
 * Write a package.json and an index.js so the package is mostly well-formed
 */
async function writeNpmPackageSkeleton(directory) {
    await fs.mkdirs(directory);
    await fs.writeJson(path.join(directory, 'package.json'), {
        name: path.basename(directory),
    });
    await fs.writeFile(path.join(directory, 'index.js'), '// There should be some JS');
}
/**
 * Removes keys from an object if the associated value is ``undefined``.
 *
 * @param obj the object to be stripped.
 *
 * @return ``obj`` after it has been stripped.
 */
function _stripUndefined(obj) {
    if (!obj) {
        return obj;
    }
    for (const key of Object.keys(obj)) {
        if (obj[key] === undefined) {
            delete obj[key];
        }
    }
    return obj;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvamVjdC1pbmZvLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwcm9qZWN0LWluZm8udGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBRWpDLHNEQUFzRDtBQUN0RCw0Q0FBeUM7QUFFekMsTUFBTSxZQUFZLEdBQUc7SUFDbkIsSUFBSSxFQUFFLFdBQVc7SUFDakIsT0FBTyxFQUFFLE9BQU87SUFDaEIsV0FBVyxFQUFFLDZDQUE2QztJQUMxRCxPQUFPLEVBQUUsWUFBWTtJQUNyQixNQUFNLEVBQUU7UUFDTixJQUFJLEVBQUUscUJBQXFCO1FBQzNCLEdBQUcsRUFBRSx3QkFBd0I7UUFDN0IsWUFBWSxFQUFFLElBQUk7S0FDbkI7SUFDRCxVQUFVLEVBQUUsRUFBRSxHQUFHLEVBQUUsK0JBQStCLEVBQUU7SUFDcEQsSUFBSSxFQUFFLFVBQVU7SUFDaEIsS0FBSyxFQUFFLFlBQVk7SUFDbkIsSUFBSSxFQUFFO1FBQ0osT0FBTyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFO0tBQ2pDO0lBQ0QsWUFBWSxFQUFFLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBZ0M7SUFDekUsZ0JBQWdCLEVBQUUsRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFnQztDQUM5RSxDQUFDO0FBRUYsUUFBUSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtJQUMvQixJQUFJLENBQUMscUJBQXFCLEVBQUUsR0FBRyxFQUFFLENBQy9CLGdCQUFnQixDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUUsRUFBRTs7UUFDckMsTUFBTSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsR0FBRyxNQUFNLDhCQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDakUsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNoRCxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDeEQsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2hELE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO1lBQzNDLEdBQUcsWUFBWSxDQUFDLE1BQU07WUFDdEIsS0FBSyxFQUFFLENBQUMsUUFBUSxDQUFDO1NBQ2xCLENBQUMsQ0FBQztRQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMxQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdEMsTUFBTSxPQUFDLElBQUksQ0FBQyxVQUFVLDBDQUFFLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQyxNQUFNLE9BQUMsSUFBSSxDQUFDLFVBQVUsMENBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDL0QsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUM7WUFDM0IsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU87WUFDNUIsRUFB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O0tBQ1o7SUFDRCxLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDbEMsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxFQUFFO1lBQzFCLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2pCO0tBQ0Y7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzcGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgY2xvbmUgZnJvbSAnY2xvbmUnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQgeyBsb2FkUHJvamVjdEluZm8gfSBmcm9tICcuLi9saWIvcHJvamVjdC1pbmZvJztcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tICcuLi9saWIvdmVyc2lvbic7XG5cbmNvbnN0IEJBU0VfUFJPSkVDVCA9IHtcbiAgbmFtZTogJ2pzaWktdGVzdCcsXG4gIHZlcnNpb246ICcxLjAuMCcsXG4gIGRlc2NyaXB0aW9uOiAnQSB0ZXN0IHByb2plY3QgZm9yIGpzaWkgUHJvamVjdEluZm8gbG9hZGluZycsXG4gIGxpY2Vuc2U6ICdBcGFjaGUtMi4wJyxcbiAgYXV0aG9yOiB7XG4gICAgbmFtZTogJ0FtYXpvbiBXZWIgU2VydmljZXMnLFxuICAgIHVybDogJ2h0dHBzOi8vYXdzLmFtYXpvbi5jb20nLFxuICAgIG9yZ2FuaXphdGlvbjogdHJ1ZSxcbiAgfSxcbiAgcmVwb3NpdG9yeTogeyB1cmw6ICdnaXQ6Ly9naXRodWIuY29tL2F3cy9qc2lpLmdpdCcgfSxcbiAgbWFpbjogJ2luZGV4LmpzJyxcbiAgdHlwZXM6ICdpbmRleC5kLnRzJyxcbiAganNpaToge1xuICAgIHRhcmdldHM6IHsgZm9vOiB7IGJhcjogJ2JheicgfSB9LFxuICB9LFxuICBkZXBlbmRlbmNpZXM6IHsgJ2pzaWktdGVzdC1kZXAnOiAnXjEuMi4zJyB9IGFzIHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9LFxuICBwZWVyRGVwZW5kZW5jaWVzOiB7ICdqc2lpLXRlc3QtZGVwJzogJ14xLjIuMycgfSBhcyB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSxcbn07XG5cbmRlc2NyaWJlKCdsb2FkUHJvamVjdEluZm8nLCAoKSA9PiB7XG4gIHRlc3QoJ2xvYWRzIHZhbGlkIHByb2plY3QnLCAoKSA9PlxuICAgIF93aXRoVGVzdFByb2plY3QoYXN5bmMgKHByb2plY3RSb290KSA9PiB7XG4gICAgICBjb25zdCB7IHByb2plY3RJbmZvOiBpbmZvIH0gPSBhd2FpdCBsb2FkUHJvamVjdEluZm8ocHJvamVjdFJvb3QpO1xuICAgICAgZXhwZWN0KGluZm8ubmFtZSkudG9CZShCQVNFX1BST0pFQ1QubmFtZSk7XG4gICAgICBleHBlY3QoaW5mby52ZXJzaW9uKS50b0JlKEJBU0VfUFJPSkVDVC52ZXJzaW9uKTtcbiAgICAgIGV4cGVjdChpbmZvLmRlc2NyaXB0aW9uKS50b0JlKEJBU0VfUFJPSkVDVC5kZXNjcmlwdGlvbik7XG4gICAgICBleHBlY3QoaW5mby5saWNlbnNlKS50b0JlKEJBU0VfUFJPSkVDVC5saWNlbnNlKTtcbiAgICAgIGV4cGVjdChfc3RyaXBVbmRlZmluZWQoaW5mby5hdXRob3IpKS50b0VxdWFsKHtcbiAgICAgICAgLi4uQkFTRV9QUk9KRUNULmF1dGhvcixcbiAgICAgICAgcm9sZXM6IFsnYXV0aG9yJ10sXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChpbmZvLm1haW4pLnRvQmUoQkFTRV9QUk9KRUNULm1haW4pO1xuICAgICAgZXhwZWN0KGluZm8udHlwZXMpLnRvQmUoQkFTRV9QUk9KRUNULnR5cGVzKTtcbiAgICAgIGV4cGVjdChpbmZvLmhvbWVwYWdlKS50b0JlKHVuZGVmaW5lZCk7XG4gICAgICBleHBlY3QoaW5mby5yZXBvc2l0b3J5Py50eXBlKS50b0JlKCdnaXQnKTtcbiAgICAgIGV4cGVjdChpbmZvLnJlcG9zaXRvcnk/LnVybCkudG9CZShCQVNFX1BST0pFQ1QucmVwb3NpdG9yeS51cmwpO1xuICAgICAgZXhwZWN0KGluZm8udGFyZ2V0cykudG9FcXVhbCh7XG4gICAgICAgIC4uLkJBU0VfUFJPSkVDVC5qc2lpLnRhcmdldHMsXG4gICAgICAgIGpzOiB7IG5wbTogQkFTRV9QUk9KRUNULm5hbWUgfSxcbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KGluZm8uZGVwZW5kZW5jaWVzKS50b0VxdWFsKHtcbiAgICAgICAgW1RFU1RfREVQX0FTU0VNQkxZLm5hbWVdOlxuICAgICAgICAgIEJBU0VfUFJPSkVDVC5kZXBlbmRlbmNpZXNbVEVTVF9ERVBfQVNTRU1CTFkubmFtZV0sXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChpbmZvLmRlcGVuZGVuY3lDbG9zdXJlKS50b0VxdWFsKFtcbiAgICAgICAgVEVTVF9ERVBfQVNTRU1CTFksXG4gICAgICAgIFRFU1RfREVQX0RFUF9BU1NFTUJMWSxcbiAgICAgIF0pO1xuICAgIH0pKTtcblxuICB0ZXN0KCdsb2FkcyB2YWxpZCBwcm9qZWN0IChVTkxJQ0VOU0VEKScsICgpID0+XG4gICAgX3dpdGhUZXN0UHJvamVjdChcbiAgICAgIGFzeW5jIChwcm9qZWN0Um9vdCkgPT4ge1xuICAgICAgICBjb25zdCB7IHByb2plY3RJbmZvOiBpbmZvIH0gPSBhd2FpdCBsb2FkUHJvamVjdEluZm8ocHJvamVjdFJvb3QpO1xuICAgICAgICBleHBlY3QoaW5mbz8ubGljZW5zZSkudG9CZSgnVU5MSUNFTlNFRCcpO1xuICAgICAgfSxcbiAgICAgIChpbmZvKSA9PiB7XG4gICAgICAgIGluZm8ubGljZW5zZSA9ICdVTkxJQ0VOU0VEJztcbiAgICAgIH0sXG4gICAgKSk7XG5cbiAgdGVzdCgnbG9hZHMgdmFsaWQgcHJvamVjdCAodXNpbmcgYnVuZGxlRGVwZW5kZW5jaWVzKScsICgpID0+XG4gICAgX3dpdGhUZXN0UHJvamVjdChcbiAgICAgIGFzeW5jIChwcm9qZWN0Um9vdCkgPT4ge1xuICAgICAgICBjb25zdCB7IHByb2plY3RJbmZvOiBpbmZvIH0gPSBhd2FpdCBsb2FkUHJvamVjdEluZm8ocHJvamVjdFJvb3QpO1xuICAgICAgICBleHBlY3QoaW5mby5idW5kbGVEZXBlbmRlbmNpZXMpLnRvRXF1YWwoeyBidW5kbGVkOiAnXjEuMi4zJyB9KTtcbiAgICAgIH0sXG4gICAgICAoaW5mbykgPT4ge1xuICAgICAgICBpbmZvLmRlcGVuZGVuY2llcy5idW5kbGVkID0gJ14xLjIuMyc7XG4gICAgICAgIGluZm8uYnVuZGxlRGVwZW5kZW5jaWVzID0gWydidW5kbGVkJ107XG4gICAgICB9LFxuICAgICkpO1xuXG4gIHRlc3QoJ2xvYWRzIHZhbGlkIHByb2plY3QgKHVzaW5nIGJ1bmRsZWREZXBlbmRlbmNpZXMpJywgKCkgPT5cbiAgICBfd2l0aFRlc3RQcm9qZWN0KFxuICAgICAgYXN5bmMgKHByb2plY3RSb290KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdEluZm86IGluZm8gfSA9IGF3YWl0IGxvYWRQcm9qZWN0SW5mbyhwcm9qZWN0Um9vdCk7XG4gICAgICAgIGV4cGVjdChpbmZvLmJ1bmRsZURlcGVuZGVuY2llcykudG9FcXVhbCh7IGJ1bmRsZWQ6ICdeMS4yLjMnIH0pO1xuICAgICAgfSxcbiAgICAgIChpbmZvKSA9PiB7XG4gICAgICAgIGluZm8uZGVwZW5kZW5jaWVzLmJ1bmRsZWQgPSAnXjEuMi4zJztcbiAgICAgICAgaW5mby5idW5kbGVkRGVwZW5kZW5jaWVzID0gWydidW5kbGVkJ107XG4gICAgICB9LFxuICAgICkpO1xuXG4gIHRlc3QoJ2xvYWRzIHZhbGlkIHByb2plY3QgKHdpdGggY29udHJpYnV0b3JzKScsICgpID0+IHtcbiAgICBjb25zdCBjb250cmlidXRvcnMgPSBbeyBuYW1lOiAnZm9vJywgZW1haWw6ICdub2JvZHlAYW1hem9uLmNvbScgfV07XG4gICAgcmV0dXJuIF93aXRoVGVzdFByb2plY3QoXG4gICAgICBhc3luYyAocHJvamVjdFJvb3QpID0+IHtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0SW5mbzogaW5mbyB9ID0gYXdhaXQgbG9hZFByb2plY3RJbmZvKHByb2plY3RSb290KTtcbiAgICAgICAgZXhwZWN0KGluZm8/LmNvbnRyaWJ1dG9ycz8ubWFwKF9zdHJpcFVuZGVmaW5lZCkpLnRvRXF1YWwoXG4gICAgICAgICAgY29udHJpYnV0b3JzLm1hcCgoYykgPT4gKHsgLi4uYywgcm9sZXM6IFsnY29udHJpYnV0b3InXSB9KSksXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgKGluZm8pID0+IChpbmZvLmNvbnRyaWJ1dG9ycyA9IGNvbnRyaWJ1dG9ycyksXG4gICAgKTtcbiAgfSk7XG5cbiAgdGVzdCgncmVqZWN0cyB1bi1kZWNsYXJlZCBkZXBlbmRlbmN5IGluIGJ1bmRsZURlcGVuZGVuY2llcycsICgpID0+XG4gICAgX3dpdGhUZXN0UHJvamVjdChcbiAgICAgIChwcm9qZWN0Um9vdCkgPT5cbiAgICAgICAgZXhwZWN0KGxvYWRQcm9qZWN0SW5mbyhwcm9qZWN0Um9vdCkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgICAvbm90IGRlY2xhcmVkIGluIFwiZGVwZW5kZW5jaWVzXCIvaSxcbiAgICAgICAgKSxcbiAgICAgIChpbmZvKSA9PiB7XG4gICAgICAgIGluZm8uYnVuZGxlZERlcGVuZGVuY2llcyA9IFsnYnVuZGxlZCddO1xuICAgICAgfSxcbiAgICApKTtcblxuICB0ZXN0KCdyZWplY3RzIGludmFsaWQgbGljZW5zZScsICgpID0+XG4gICAgX3dpdGhUZXN0UHJvamVjdChcbiAgICAgIChwcm9qZWN0Um9vdCkgPT5cbiAgICAgICAgZXhwZWN0KGxvYWRQcm9qZWN0SW5mbyhwcm9qZWN0Um9vdCkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgICAvaW52YWxpZCBsaWNlbnNlIGlkZW50aWZpZXIvaSxcbiAgICAgICAgKSxcbiAgICAgIChpbmZvKSA9PiB7XG4gICAgICAgIGluZm8ubGljZW5zZSA9ICdOb3QgYW4gU1BEWCBsaWNlbmNlIElEJztcbiAgICAgIH0sXG4gICAgKSk7XG5cbiAgdGVzdCgncmVqZWN0cyBpbmNvbXBhdGlibGUgZGVwZW5kZW5jeSB2ZXJzaW9uJywgKCkgPT5cbiAgICBfd2l0aFRlc3RQcm9qZWN0KFxuICAgICAgKHByb2plY3RSb290KSA9PlxuICAgICAgICBleHBlY3QobG9hZFByb2plY3RJbmZvKHByb2plY3RSb290KSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAgIC9kZWNsYXJlZCBkZXBlbmRlbmN5IG9uIHZlcnNpb24gLisgYnV0IHZlcnNpb24gLisgd2FzIGZvdW5kL2ksXG4gICAgICAgICksXG4gICAgICAoaW5mbykgPT4ge1xuICAgICAgICBpbmZvLmRlcGVuZGVuY2llc1tURVNUX0RFUF9BU1NFTUJMWS5uYW1lXSA9ICdeMS4yLjUnO1xuICAgICAgICBpbmZvLnBlZXJEZXBlbmRlbmNpZXNbVEVTVF9ERVBfQVNTRU1CTFkubmFtZV0gPSAnXjEuMi41JztcbiAgICAgIH0sXG4gICAgKSk7XG5cbiAgdGVzdCgnbWlzc2luZyBwZWVyRGVwZW5kZW5jaWVzIGFyZSBhbGxvd2VkJywgKCkgPT5cbiAgICBfd2l0aFRlc3RQcm9qZWN0KFxuICAgICAgKHByb2plY3RSb290KSA9PlxuICAgICAgICBleHBlY3QobG9hZFByb2plY3RJbmZvKHByb2plY3RSb290KSkucmVzb2x2ZXMudG9FcXVhbChcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBkaWFnbm9zdGljczogW10sXG4gICAgICAgICAgfSksXG4gICAgICAgICksXG4gICAgICAoaW5mbykgPT4ge1xuICAgICAgICBkZWxldGUgaW5mby5wZWVyRGVwZW5kZW5jaWVzW1RFU1RfREVQX0FTU0VNQkxZLm5hbWVdO1xuICAgICAgfSxcbiAgICApKTtcblxuICB0ZXN0KCd3YXJucyBpZiBwZWVyRGVwZW5kZW5jeSBtaXNzZXMgYSBtYXRjaGluZyBkZXZEZXBlbmRlbmN5JywgKCkgPT5cbiAgICBfd2l0aFRlc3RQcm9qZWN0KFxuICAgICAgKHByb2plY3RSb290KSA9PlxuICAgICAgICBleHBlY3QobG9hZFByb2plY3RJbmZvKHByb2plY3RSb290KSkucmVzb2x2ZXMudG9FcXVhbChcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBkaWFnbm9zdGljczogW2V4cGVjdC5vYmplY3RDb250YWluaW5nKHsganNpaUNvZGU6IDYgfSldLFxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBCeSBkZWZhdWx0IHRoZXJlIGlzIG5vIGRldkRlcGVuZGVuY3kgaW4gQkFTRV9QUk9KRUNUXG4gICAgICB9LFxuICAgICkpO1xuXG4gIHRlc3QoJ3dhcm5zIGlmIHBlZXJEZXBlbmRlbmN5IGhhcyBhIGRldkRlcGVuZGVuY3kgb24gdGhlIHdyb25nIHZlcnNpb24nLCAoKSA9PlxuICAgIF93aXRoVGVzdFByb2plY3QoXG4gICAgICAocHJvamVjdFJvb3QpID0+XG4gICAgICAgIGV4cGVjdChsb2FkUHJvamVjdEluZm8ocHJvamVjdFJvb3QpKS5yZXNvbHZlcy50b0VxdWFsKFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGRpYWdub3N0aWNzOiBbZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoeyBqc2lpQ29kZTogNiB9KV0sXG4gICAgICAgICAgfSksXG4gICAgICAgICksXG4gICAgICAoaW5mbykgPT4ge1xuICAgICAgICAvLyBCeSBkZWZhdWx0IHRoZXJlIGlzIG5vIGRldkRlcGVuZGVuY3kgaW4gQkFTRV9QUk9KRUNUXG4gICAgICAgIGluZm8uZGV2RGVwZW5kZW5jaWVzID0geyAnanNpaS10ZXN0LWRlcCc6ICc0LjUuNicgfTtcbiAgICAgIH0sXG4gICAgKSk7XG5cbiAgdGVzdCgnbm8gd2FybmluZ3MgaWYgZGV2RGVwZW5kZW5jeSBwb2ludCB2ZXJzaW9uIG1hdGNoZXMgcGVlckRlcGVuZGVuY3kgcmFuZ2UnLCAoKSA9PlxuICAgIF93aXRoVGVzdFByb2plY3QoXG4gICAgICAocHJvamVjdFJvb3QpID0+XG4gICAgICAgIGV4cGVjdChsb2FkUHJvamVjdEluZm8ocHJvamVjdFJvb3QpKS5yZXNvbHZlcy50b0VxdWFsKFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGRpYWdub3N0aWNzOiBbXSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKSxcbiAgICAgIChpbmZvKSA9PiB7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhlcmUgaXMgbm8gZGV2RGVwZW5kZW5jeSBpbiBCQVNFX1BST0pFQ1RcbiAgICAgICAgaW5mby5kZXZEZXBlbmRlbmNpZXMgPSB7ICdqc2lpLXRlc3QtZGVwJzogJzEuMi4zJyB9O1xuICAgICAgfSxcbiAgICApKTtcblxuICBkZXNjcmliZSgnX2xvYWREaWFnbm9zdGljcycsICgpID0+IHtcbiAgICB0ZXN0KCdkaWFnbm9zdGljIGNhdGVnb3JpZXMgYXJlIGNvcnJlY3RseSBkZXRlY3RlZCcsICgpID0+IHtcbiAgICAgIHJldHVybiBfd2l0aFRlc3RQcm9qZWN0KFxuICAgICAgICBhc3luYyAocHJvamVjdFJvb3QpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb2plY3RJbmZvOiBpbmZvIH0gPSBhd2FpdCBsb2FkUHJvamVjdEluZm8ocHJvamVjdFJvb3QpO1xuICAgICAgICAgIGV4cGVjdChpbmZvLmRpYWdub3N0aWNzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgIGNvbnN0IGRpYWdub3N0aWNzID0gaW5mby5kaWFnbm9zdGljcyE7XG4gICAgICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGRpYWdub3N0aWNzKS5zb3J0KCkpLnRvRXF1YWwoW1xuICAgICAgICAgICAgJ2RpYWdDb2RlMScsXG4gICAgICAgICAgICAnZGlhZ0NvZGUyJyxcbiAgICAgICAgICAgICdkaWFnQ29kZTMnLFxuICAgICAgICAgICAgJ2RpYWdDb2RlNCcsXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgZXhwZWN0KGRpYWdub3N0aWNzLmRpYWdDb2RlMSkudG9FcXVhbCh0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IpO1xuICAgICAgICAgIGV4cGVjdChkaWFnbm9zdGljcy5kaWFnQ29kZTIpLnRvRXF1YWwodHMuRGlhZ25vc3RpY0NhdGVnb3J5Lldhcm5pbmcpO1xuICAgICAgICAgIGV4cGVjdChkaWFnbm9zdGljcy5kaWFnQ29kZTMpLnRvRXF1YWwoXG4gICAgICAgICAgICB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuU3VnZ2VzdGlvbixcbiAgICAgICAgICApO1xuICAgICAgICAgIGV4cGVjdChkaWFnbm9zdGljcy5kaWFnQ29kZTQpLnRvRXF1YWwodHMuRGlhZ25vc3RpY0NhdGVnb3J5Lk1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICAoaW5mbykgPT4ge1xuICAgICAgICAgIGNvbnN0IGRpYWdub3N0aWNzID0ge1xuICAgICAgICAgICAgZGlhZ0NvZGUxOiAnZXJyb3InLFxuICAgICAgICAgICAgZGlhZ0NvZGUyOiAnd2FybmluZycsXG4gICAgICAgICAgICBkaWFnQ29kZTM6ICdzdWdnZXN0aW9uJyxcbiAgICAgICAgICAgIGRpYWdDb2RlNDogJ21lc3NhZ2UnLFxuICAgICAgICAgIH07XG4gICAgICAgICAgaW5mby5qc2lpLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaW52YWxpZCBjYXRlZ29yeSBpcyByZWplY3RlZCcsICgpID0+IHtcbiAgICAgIHJldHVybiBfd2l0aFRlc3RQcm9qZWN0KFxuICAgICAgICAocHJvamVjdFJvb3QpID0+XG4gICAgICAgICAgZXhwZWN0KGxvYWRQcm9qZWN0SW5mbyhwcm9qZWN0Um9vdCkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgICAgIC9JbnZhbGlkIGNhdGVnb3J5LyxcbiAgICAgICAgICApLFxuICAgICAgICAoaW5mbykgPT4ge1xuICAgICAgICAgIGNvbnN0IGRpYWdub3N0aWNzID0ge1xuICAgICAgICAgICAgZGlhZ0NvZGUxOiAnaW52YWxpZC1jYXRlZ29yeScsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpbmZvLmpzaWkuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmNvbnN0IFRFU1RfREVQX0FTU0VNQkxZOiBzcGVjLkFzc2VtYmx5ID0ge1xuICBzY2hlbWE6IHNwZWMuU2NoZW1hVmVyc2lvbi5MQVRFU1QsXG4gIG5hbWU6ICdqc2lpLXRlc3QtZGVwJyxcbiAgdmVyc2lvbjogJzEuMi40JyxcbiAgbGljZW5zZTogJ0FwYWNoZS0yLjAnLFxuICBkZXNjcmlwdGlvbjogJ0EganNpaSBkZXBlbmRlbmN5IG9mIGpzaWktdGVzdCcsXG4gIGhvbWVwYWdlOiAnaHR0cHM6Ly9naXRodWIuY29tL2F3cy9qc2lpJyxcbiAgcmVwb3NpdG9yeTogeyB0eXBlOiAnZ2l0JywgdXJsOiAnZ2l0Oi8vZ2l0aHViLmNvbS9hd3MvanNpaS5naXQnIH0sXG4gIGF1dGhvcjoge1xuICAgIG5hbWU6ICdBbWF6b24gV2ViIFNlcnZpY2VzJyxcbiAgICB1cmw6ICdodHRwczovL2F3cy5hbWF6b24uY29tJyxcbiAgICBvcmdhbml6YXRpb246IHRydWUsXG4gICAgcm9sZXM6IFsnYXV0aG9yJ10sXG4gIH0sXG4gIGZpbmdlcnByaW50OiAnRjFORzNSUFIxTjcnLFxuICBkZXBlbmRlbmNpZXM6IHtcbiAgICAnanNpaS10ZXN0LWRlcC1kZXAnOiAnMy4yLjEnLFxuICB9LFxuICBqc2lpVmVyc2lvbjogVkVSU0lPTixcbn07XG5cbmNvbnN0IFRFU1RfREVQX0RFUF9BU1NFTUJMWTogc3BlYy5Bc3NlbWJseSA9IHtcbiAgc2NoZW1hOiBzcGVjLlNjaGVtYVZlcnNpb24uTEFURVNULFxuICBuYW1lOiAnanNpaS10ZXN0LWRlcC1kZXAnLFxuICB2ZXJzaW9uOiAnMy4yLjEnLFxuICBsaWNlbnNlOiAnQXBhY2hlLTIuMCcsXG4gIGRlc2NyaXB0aW9uOiAnQSBqc2lpIGRlcGVuZGVuY3kgb2YganNpaS10ZXN0LWRlcCcsXG4gIGhvbWVwYWdlOiAnaHR0cHM6Ly9naXRodWIuY29tL2F3cy9qc2lpJyxcbiAgcmVwb3NpdG9yeTogeyB0eXBlOiAnZ2l0JywgdXJsOiAnZ2l0Oi8vZ2l0aHViLmNvbS9hd3MvanNpaS5naXQnIH0sXG4gIGF1dGhvcjoge1xuICAgIG5hbWU6ICdBbWF6b24gV2ViIFNlcnZpY2VzJyxcbiAgICB1cmw6ICdodHRwczovL2F3cy5hbWF6b24uY29tJyxcbiAgICBvcmdhbml6YXRpb246IHRydWUsXG4gICAgcm9sZXM6IFsnYXV0aG9yJ10sXG4gIH0sXG4gIGpzaWlWZXJzaW9uOiBWRVJTSU9OLFxuICBmaW5nZXJwcmludDogJ0YxTkczUlBSMU43Jyxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm93LWF3YXkgZGlyZWN0b3J5IHdpdGggYSBgYHBhY2thZ2UuanNvbmBgIGZpbGUuIENsZWFucyB1cCBhZnRlciBpdHNlbGYuXG4gKlxuICogQHBhcmFtIGNiICAgICAgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5J3MgcGF0aFxuICogQHBhcmFtIGdyZW1saW4gYSBmdW5jdGlvbiB0aGF0IGNhbiBtb2RpZnkgdGhlIGNvbnRlbnQgb2YgYGBwYWNrYWdlLmpzb25gYCBiZWZvcmUgaXQgaXMgd3JpdHRlblxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgYGBjYmBgLlxuICovXG5hc3luYyBmdW5jdGlvbiBfd2l0aFRlc3RQcm9qZWN0PFQ+KFxuICBjYjogKHByb2plY3RSb290OiBzdHJpbmcpID0+IFQgfCBQcm9taXNlPFQ+LFxuICBncmVtbGluPzogKHBhY2thZ2VJbmZvOiBhbnkpID0+IHZvaWQsXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgdG1wZGlyID0gYXdhaXQgZnMubWtkdGVtcChcbiAgICBwYXRoLmpvaW4ob3MudG1wZGlyKCksIHBhdGguYmFzZW5hbWUoX19maWxlbmFtZSkpLFxuICApO1xuICB0cnkge1xuICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gY2xvbmUoQkFTRV9QUk9KRUNUKTtcbiAgICBpZiAoZ3JlbWxpbikge1xuICAgICAgZ3JlbWxpbihwYWNrYWdlSW5mbyk7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlSnNvbihwYXRoLmpvaW4odG1wZGlyLCAncGFja2FnZS5qc29uJyksIHBhY2thZ2VJbmZvLCB7XG4gICAgICBzcGFjZXM6IDIsXG4gICAgfSk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgcGF0aC5qb2luKHRtcGRpciwgJ2luZGV4LmpzJyksXG4gICAgICAnLy8gVGhlcmUgb3VnaHQgdG8gYmUgc29tZSBqYXZhc2NyaXB0JyxcbiAgICApO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShcbiAgICAgIHBhdGguam9pbih0bXBkaXIsICdpbmRleC50cycpLFxuICAgICAgJy8vIFRoZXJlIG91Z2h0IHRvIGJlIHNvbWUgdHlwZXNjcmlwdCcsXG4gICAgKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoXG4gICAgICBwYXRoLmpvaW4odG1wZGlyLCAnaW5kZXguZC50cycpLFxuICAgICAgJy8vIFRoZXJlIG91Z2h0IHRvIGJlIHNvbWUgdHlwZXNjcmlwdCBkZWZpbml0aW9ucycsXG4gICAgKTtcblxuICAgIGNvbnN0IGpzaWlUZXN0RGVwID0gcGF0aC5qb2luKHRtcGRpciwgJ25vZGVfbW9kdWxlcycsICdqc2lpLXRlc3QtZGVwJyk7XG4gICAgYXdhaXQgd3JpdGVOcG1QYWNrYWdlU2tlbGV0b24oanNpaVRlc3REZXApO1xuXG4gICAgYXdhaXQgZnMud3JpdGVKc29uKHBhdGguam9pbihqc2lpVGVzdERlcCwgJy5qc2lpJyksIFRFU1RfREVQX0FTU0VNQkxZKTtcbiAgICBjb25zdCBqc2lpVGVzdERlcERlcCA9IHBhdGguam9pbihcbiAgICAgIGpzaWlUZXN0RGVwLFxuICAgICAgJ25vZGVfbW9kdWxlcycsXG4gICAgICAnanNpaS10ZXN0LWRlcC1kZXAnLFxuICAgICk7XG5cbiAgICBhd2FpdCB3cml0ZU5wbVBhY2thZ2VTa2VsZXRvbihqc2lpVGVzdERlcERlcCk7XG4gICAgYXdhaXQgZnMud3JpdGVKc29uKFxuICAgICAgcGF0aC5qb2luKGpzaWlUZXN0RGVwRGVwLCAnLmpzaWknKSxcbiAgICAgIFRFU1RfREVQX0RFUF9BU1NFTUJMWSxcbiAgICApO1xuXG4gICAgcmV0dXJuIGF3YWl0IGNiKHRtcGRpcik7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmVtb3ZlKHRtcGRpcik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIHBhY2thZ2UuanNvbiBhbmQgYW4gaW5kZXguanMgc28gdGhlIHBhY2thZ2UgaXMgbW9zdGx5IHdlbGwtZm9ybWVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlTnBtUGFja2FnZVNrZWxldG9uKGRpcmVjdG9yeTogc3RyaW5nKSB7XG4gIGF3YWl0IGZzLm1rZGlycyhkaXJlY3RvcnkpO1xuICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5qb2luKGRpcmVjdG9yeSwgJ3BhY2thZ2UuanNvbicpLCB7XG4gICAgbmFtZTogcGF0aC5iYXNlbmFtZShkaXJlY3RvcnkpLFxuICB9KTtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgIHBhdGguam9pbihkaXJlY3RvcnksICdpbmRleC5qcycpLFxuICAgICcvLyBUaGVyZSBzaG91bGQgYmUgc29tZSBKUycsXG4gICk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBrZXlzIGZyb20gYW4gb2JqZWN0IGlmIHRoZSBhc3NvY2lhdGVkIHZhbHVlIGlzIGBgdW5kZWZpbmVkYGAuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHRvIGJlIHN0cmlwcGVkLlxuICpcbiAqIEByZXR1cm4gYGBvYmpgYCBhZnRlciBpdCBoYXMgYmVlbiBzdHJpcHBlZC5cbiAqL1xuZnVuY3Rpb24gX3N0cmlwVW5kZWZpbmVkKFxuICBvYmo6IHsgW2tleTogc3RyaW5nXTogYW55IH0gfCB1bmRlZmluZWQsXG4pOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuIl19