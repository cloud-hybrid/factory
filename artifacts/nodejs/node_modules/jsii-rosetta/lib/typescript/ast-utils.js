"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEnclosingClassDeclaration = exports.privatePropertyNames = exports.findSuperCall = exports.isReadOnly = exports.visibility = exports.quoteStringLiteral = exports.extractVoidExpression = exports.voidExpressionString = exports.extractShowingVoidExpression = exports.extractMaskingVoidExpression = exports.scanText = exports.commentRangeFromTextRange = exports.extractComments = exports.repeatNewlines = exports.countNakedNewlines = exports.matchAst = exports.DONE = exports.allOfType = exports.anyNode = exports.nodeOfType = exports.nodeChildren = exports.stringFromLiteral = exports.stripCommentMarkers = void 0;
const ts = require("typescript");
function stripCommentMarkers(comment, multiline) {
    if (multiline) {
        // The text *must* start with '/*' and end with '*/'.
        // Strip leading '*' from every remaining line (first line because of '**',
        // other lines because of continuations.
        return comment
            .substring(2, comment.length - 2)
            .replace(/^[ \t]+/g, '') // Strip all leading whitepace
            .replace(/[ \t]+$/g, '') // Strip all trailing whitepace
            .replace(/^[ \t]*\*[ \t]?/gm, ''); // Strip "* " from start of line
    }
    // The text *must* start with '//'
    return comment.replace(/^[/]{2}[ \t]?/gm, '');
}
exports.stripCommentMarkers = stripCommentMarkers;
function stringFromLiteral(expr) {
    if (ts.isStringLiteral(expr)) {
        return expr.text;
    }
    return '???';
}
exports.stringFromLiteral = stringFromLiteral;
/**
 * Return AST children of the given node
 *
 * Difference with node.getChildren():
 *
 * - node.getChildren() must take a SourceFile (will fail if it doesn't get it)
 *   and returns a mix of abstract and concrete syntax nodes.
 * - This function function will ONLY return abstract syntax nodes.
 */
function nodeChildren(node) {
    const ret = new Array();
    node.forEachChild((n) => {
        ret.push(n);
    });
    return ret;
}
exports.nodeChildren = nodeChildren;
// eslint-disable-next-line max-len
function nodeOfType(syntaxKindOrCaptureName, nodeTypeOrChildren, children) {
    var _a;
    const capturing = typeof syntaxKindOrCaptureName === 'string'; // Determine which overload we're in (SyntaxKind is a number)
    const realNext = (_a = (capturing ? children : nodeTypeOrChildren)) !== null && _a !== void 0 ? _a : exports.DONE;
    const realCapture = capturing ? syntaxKindOrCaptureName : undefined;
    const realSyntaxKind = capturing ? nodeTypeOrChildren : syntaxKindOrCaptureName;
    return (nodes) => {
        for (const node of nodes !== null && nodes !== void 0 ? nodes : []) {
            if (node.kind === realSyntaxKind) {
                const ret = realNext(nodeChildren(node));
                if (!ret) {
                    continue;
                }
                if (realCapture) {
                    return Object.assign(ret, {
                        [realCapture]: node,
                    });
                }
                return ret;
            }
        }
        return undefined;
    };
}
exports.nodeOfType = nodeOfType;
function anyNode(children) {
    const realNext = children !== null && children !== void 0 ? children : exports.DONE;
    return (nodes) => {
        for (const node of nodes !== null && nodes !== void 0 ? nodes : []) {
            const m = realNext(nodeChildren(node));
            if (m) {
                return m;
            }
        }
        return undefined;
    };
}
exports.anyNode = anyNode;
// Does not capture deeper because how would we even represent that?
function allOfType(s, name, children) {
    const realNext = children !== null && children !== void 0 ? children : exports.DONE;
    return (nodes) => {
        let ret;
        for (const node of nodes !== null && nodes !== void 0 ? nodes : []) {
            if (node.kind === s) {
                if (realNext(nodeChildren(node))) {
                    if (!ret) {
                        ret = { [name]: new Array() };
                    }
                    ret[name].push(node);
                }
            }
        }
        return ret;
    };
}
exports.allOfType = allOfType;
exports.DONE = () => ({});
function matchAst(node, matcher, cb) {
    const matched = matcher([node]);
    if (cb) {
        if (matched) {
            cb(matched);
        }
        return !!matched;
    }
    return matched;
}
exports.matchAst = matchAst;
/**
 * Count the newlines in a given piece of string that aren't in comment blocks
 */
function countNakedNewlines(str) {
    let ret = 0;
    scanText(str, 0, str.length)
        .filter((s) => s.type === 'other' || s.type === 'blockcomment')
        .forEach((s) => {
        if (s.type === 'other') {
            // Count newlines in non-comments
            for (let i = s.pos; i < s.end; i++) {
                if (str[i] === '\n') {
                    ret++;
                }
            }
        }
        else {
            // Discount newlines at the end of block comments
            if (s.hasTrailingNewLine) {
                ret--;
            }
        }
    });
    return ret;
}
exports.countNakedNewlines = countNakedNewlines;
function repeatNewlines(str) {
    return '\n'.repeat(Math.min(2, countNakedNewlines(str)));
}
exports.repeatNewlines = repeatNewlines;
const WHITESPACE = [' ', '\t', '\r', '\n'];
/**
 * Extract single-line and multi-line comments from the given string
 *
 * Rewritten because I can't get ts.getLeadingComments and ts.getTrailingComments to do what I want.
 */
function extractComments(text, start) {
    return scanText(text, start)
        .filter((s) => s.type === 'blockcomment' || s.type === 'linecomment')
        .map(commentRangeFromTextRange);
}
exports.extractComments = extractComments;
function commentRangeFromTextRange(rng) {
    return {
        kind: rng.type === 'blockcomment' ? ts.SyntaxKind.MultiLineCommentTrivia : ts.SyntaxKind.SingleLineCommentTrivia,
        pos: rng.pos,
        end: rng.end,
        hasTrailingNewLine: rng.type !== 'blockcomment' && rng.hasTrailingNewLine,
    };
}
exports.commentRangeFromTextRange = commentRangeFromTextRange;
/**
 * Extract spans of comments and non-comments out of the string
 *
 * Stop at 'end' when given, or the first non-whitespace character in a
 * non-comment if not given.
 */
function scanText(text, start, end) {
    const ret = [];
    let pos = start;
    const stopAtCode = end === undefined;
    if (end === undefined) {
        end = text.length;
    }
    while (pos < end) {
        const ch = text[pos];
        if (WHITESPACE.includes(ch)) {
            pos++;
            continue;
        }
        if (ch === '/' && text[pos + 1] === '/') {
            accumulateTextBlock();
            scanSinglelineComment();
            continue;
        }
        if (ch === '/' && text[pos + 1] === '*') {
            accumulateTextBlock();
            scanMultilineComment();
            continue;
        }
        // Non-whitespace, non-comment, must be regular token. End if we're not scanning
        // to a particular location, otherwise continue.
        if (stopAtCode) {
            break;
        }
        pos++;
    }
    accumulateTextBlock();
    return ret;
    function scanMultilineComment() {
        const endOfComment = findNext('*/', pos + 2);
        ret.push({
            type: 'blockcomment',
            hasTrailingNewLine: ['\n', '\r'].includes(text[endOfComment + 2]),
            pos,
            end: endOfComment + 2,
        });
        pos = endOfComment + 2;
        start = pos;
    }
    function scanSinglelineComment() {
        const nl = Math.min(findNext('\r', pos + 2), findNext('\n', pos + 2));
        if (text[pos + 2] === '/') {
            // Special /// comment
            ret.push({
                type: 'directive',
                hasTrailingNewLine: true,
                pos: pos + 1,
                end: nl,
            });
        }
        else {
            // Regular // comment
            ret.push({
                type: 'linecomment',
                hasTrailingNewLine: true,
                pos,
                end: nl,
            });
        }
        pos = nl + 1;
        start = pos;
    }
    function accumulateTextBlock() {
        if (pos - start > 0) {
            ret.push({
                type: 'other',
                hasTrailingNewLine: false,
                pos: start,
                end: pos,
            });
            start = pos;
        }
    }
    function findNext(sub, startPos) {
        const f = text.indexOf(sub, startPos);
        if (f === -1) {
            return text.length;
        }
        return f;
    }
}
exports.scanText = scanText;
const VOID_SHOW_KEYWORD = 'show';
function extractMaskingVoidExpression(node) {
    const expr = extractVoidExpression(node);
    if (!expr) {
        return undefined;
    }
    if (ts.isStringLiteral(expr.expression) && expr.expression.text === VOID_SHOW_KEYWORD) {
        return undefined;
    }
    return expr;
}
exports.extractMaskingVoidExpression = extractMaskingVoidExpression;
function extractShowingVoidExpression(node) {
    const expr = extractVoidExpression(node);
    if (!expr) {
        return undefined;
    }
    if (ts.isStringLiteral(expr.expression) && expr.expression.text === VOID_SHOW_KEYWORD) {
        return expr;
    }
    return undefined;
}
exports.extractShowingVoidExpression = extractShowingVoidExpression;
/**
 * Return the string argument to a void expression if it exists
 */
function voidExpressionString(node) {
    if (ts.isStringLiteral(node.expression)) {
        return node.expression.text;
    }
    return undefined;
}
exports.voidExpressionString = voidExpressionString;
/**
 * We use void directives as pragmas. Extract the void directives here
 */
function extractVoidExpression(node) {
    if (ts.isVoidExpression(node)) {
        return node;
    }
    if (ts.isExpressionStatement(node)) {
        return extractVoidExpression(node.expression);
    }
    if (ts.isParenthesizedExpression(node)) {
        return extractVoidExpression(node.expression);
    }
    if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.CommaToken) {
        return extractVoidExpression(node.left);
    }
    return undefined;
}
exports.extractVoidExpression = extractVoidExpression;
function quoteStringLiteral(x) {
    return x.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
}
exports.quoteStringLiteral = quoteStringLiteral;
function visibility(x) {
    const flags = ts.getCombinedModifierFlags(x);
    if (flags & ts.ModifierFlags.Private) {
        return 'private';
    }
    if (flags & ts.ModifierFlags.Protected) {
        return 'protected';
    }
    return 'public';
}
exports.visibility = visibility;
function isReadOnly(x) {
    const flags = ts.getCombinedModifierFlags(x);
    return (flags & ts.ModifierFlags.Readonly) !== 0;
}
exports.isReadOnly = isReadOnly;
/**
 * Return the super() call from a method body if found
 */
function findSuperCall(node, renderer) {
    if (node === undefined) {
        return undefined;
    }
    if (ts.isCallExpression(node)) {
        if (renderer.textOf(node.expression) === 'super') {
            return node;
        }
    }
    if (ts.isExpressionStatement(node)) {
        return findSuperCall(node.expression, renderer);
    }
    if (ts.isBlock(node)) {
        for (const statement of node.statements) {
            if (ts.isExpressionStatement(statement)) {
                const s = findSuperCall(statement.expression, renderer);
                if (s) {
                    return s;
                }
            }
        }
    }
    return undefined;
}
exports.findSuperCall = findSuperCall;
/**
 * Return the names of all private property declarations
 */
function privatePropertyNames(members, renderer) {
    const props = members.filter((m) => ts.isPropertyDeclaration(m));
    return props.filter((m) => visibility(m) === 'private').map((m) => renderer.textOf(m.name));
}
exports.privatePropertyNames = privatePropertyNames;
function findEnclosingClassDeclaration(node) {
    while (node && !ts.isClassDeclaration(node)) {
        node = node.parent;
    }
    return node;
}
exports.findEnclosingClassDeclaration = findEnclosingClassDeclaration;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN0LXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXN0LXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUFpQztBQUlqQyxTQUFnQixtQkFBbUIsQ0FBQyxPQUFlLEVBQUUsU0FBa0I7SUFDckUsSUFBSSxTQUFTLEVBQUU7UUFDYixxREFBcUQ7UUFDckQsMkVBQTJFO1FBQzNFLHdDQUF3QztRQUN4QyxPQUFPLE9BQU87YUFDWCxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQ2hDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUMsOEJBQThCO2FBQ3RELE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUMsK0JBQStCO2FBQ3ZELE9BQU8sQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLGdDQUFnQztLQUN0RTtJQUNELGtDQUFrQztJQUNsQyxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsaUJBQWlCLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDaEQsQ0FBQztBQWJELGtEQWFDO0FBRUQsU0FBZ0IsaUJBQWlCLENBQUMsSUFBbUI7SUFDbkQsSUFBSSxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzVCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztLQUNsQjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUxELDhDQUtDO0FBaUJEOzs7Ozs7OztHQVFHO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLElBQWE7SUFDeEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQVcsQ0FBQztJQUNqQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7UUFDdEIsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNkLENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxHQUFHLENBQUM7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QUU7Z0JBQ3ZDLE1BQU0sQ0FBQyxHQUFHLGFBQWEsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUN4RCxJQUFJLENBQUMsRUFBRTtvQkFDTCxPQUFPLENBQUMsQ0FBQztpQkFDVjthQUNGO1NBQ0Y7S0FDRjtJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUExQkQsc0NBMEJDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixvQkFBb0IsQ0FBQyxPQUFtQyxFQUFFLFFBQTBCO0lBQ2xHLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBNkIsQ0FBQztJQUM3RixPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDOUYsQ0FBQztBQUhELG9EQUdDO0FBRUQsU0FBZ0IsNkJBQTZCLENBQUMsSUFBYTtJQUN6RCxPQUFPLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUMzQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUxELHNFQUtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IEFzdFJlbmRlcmVyIH0gZnJvbSAnLi4vcmVuZGVyZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBDb21tZW50TWFya2Vycyhjb21tZW50OiBzdHJpbmcsIG11bHRpbGluZTogYm9vbGVhbikge1xuICBpZiAobXVsdGlsaW5lKSB7XG4gICAgLy8gVGhlIHRleHQgKm11c3QqIHN0YXJ0IHdpdGggJy8qJyBhbmQgZW5kIHdpdGggJyovJy5cbiAgICAvLyBTdHJpcCBsZWFkaW5nICcqJyBmcm9tIGV2ZXJ5IHJlbWFpbmluZyBsaW5lIChmaXJzdCBsaW5lIGJlY2F1c2Ugb2YgJyoqJyxcbiAgICAvLyBvdGhlciBsaW5lcyBiZWNhdXNlIG9mIGNvbnRpbnVhdGlvbnMuXG4gICAgcmV0dXJuIGNvbW1lbnRcbiAgICAgIC5zdWJzdHJpbmcoMiwgY29tbWVudC5sZW5ndGggLSAyKVxuICAgICAgLnJlcGxhY2UoL15bIFxcdF0rL2csICcnKSAvLyBTdHJpcCBhbGwgbGVhZGluZyB3aGl0ZXBhY2VcbiAgICAgIC5yZXBsYWNlKC9bIFxcdF0rJC9nLCAnJykgLy8gU3RyaXAgYWxsIHRyYWlsaW5nIHdoaXRlcGFjZVxuICAgICAgLnJlcGxhY2UoL15bIFxcdF0qXFwqWyBcXHRdPy9nbSwgJycpOyAvLyBTdHJpcCBcIiogXCIgZnJvbSBzdGFydCBvZiBsaW5lXG4gIH1cbiAgLy8gVGhlIHRleHQgKm11c3QqIHN0YXJ0IHdpdGggJy8vJ1xuICByZXR1cm4gY29tbWVudC5yZXBsYWNlKC9eWy9dezJ9WyBcXHRdPy9nbSwgJycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbUxpdGVyYWwoZXhwcjogdHMuRXhwcmVzc2lvbikge1xuICBpZiAodHMuaXNTdHJpbmdMaXRlcmFsKGV4cHIpKSB7XG4gICAgcmV0dXJuIGV4cHIudGV4dDtcbiAgfVxuICByZXR1cm4gJz8/Pyc7XG59XG5cbi8qKlxuICogQWxsIHR5cGVzIG9mIG5vZGVzIHRoYXQgY2FuIGJlIGNhcHR1cmVkIHVzaW5nIGBub2RlT2ZUeXBlYCwgYW5kIHRoZSB0eXBlIG9mIE5vZGUgdGhleSBtYXAgdG9cbiAqL1xuZXhwb3J0IHR5cGUgQ2FwdHVyYWJsZU5vZGVzID0ge1xuICBbdHMuU3ludGF4S2luZC5JbXBvcnREZWNsYXJhdGlvbl06IHRzLkltcG9ydERlY2xhcmF0aW9uO1xuICBbdHMuU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uXTogdHMuVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgW3RzLlN5bnRheEtpbmQuRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VdOiB0cy5FeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbiAgW3RzLlN5bnRheEtpbmQuTmFtZXNwYWNlSW1wb3J0XTogdHMuTmFtZXNwYWNlSW1wb3J0O1xuICBbdHMuU3ludGF4S2luZC5OYW1lZEltcG9ydHNdOiB0cy5OYW1lZEltcG9ydHM7XG4gIFt0cy5TeW50YXhLaW5kLkltcG9ydFNwZWNpZmllcl06IHRzLkltcG9ydFNwZWNpZmllcjtcbiAgW3RzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbF06IHRzLlN0cmluZ0xpdGVyYWw7XG59O1xuXG5leHBvcnQgdHlwZSBBc3RNYXRjaGVyPEE+ID0gKG5vZGVzPzogdHMuTm9kZVtdKSA9PiBBIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJldHVybiBBU1QgY2hpbGRyZW4gb2YgdGhlIGdpdmVuIG5vZGVcbiAqXG4gKiBEaWZmZXJlbmNlIHdpdGggbm9kZS5nZXRDaGlsZHJlbigpOlxuICpcbiAqIC0gbm9kZS5nZXRDaGlsZHJlbigpIG11c3QgdGFrZSBhIFNvdXJjZUZpbGUgKHdpbGwgZmFpbCBpZiBpdCBkb2Vzbid0IGdldCBpdClcbiAqICAgYW5kIHJldHVybnMgYSBtaXggb2YgYWJzdHJhY3QgYW5kIGNvbmNyZXRlIHN5bnRheCBub2Rlcy5cbiAqIC0gVGhpcyBmdW5jdGlvbiBmdW5jdGlvbiB3aWxsIE9OTFkgcmV0dXJuIGFic3RyYWN0IHN5bnRheCBub2Rlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVDaGlsZHJlbihub2RlOiB0cy5Ob2RlKTogdHMuTm9kZVtdIHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PHRzLk5vZGU+KCk7XG4gIG5vZGUuZm9yRWFjaENoaWxkKChuKSA9PiB7XG4gICAgcmV0LnB1c2gobik7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1hdGNoIGEgc2luZ2xlIG5vZGUgb2YgYSBnaXZlbiB0eXBlXG4gKlxuICogQ2FwdHVyZSBuYW1lIGlzIGZpcnN0IHNvIHRoYXQgdGhlIElERSBjYW4gZGV0ZWN0IGVhZ2VybHkgdGhhdCB3ZSdyZSBmYWxsaW5nIGludG9cbiAqIHRoYXQgb3ZlcmxvYWQgYW5kIHByb3Blcmx5IGF1dG9jb21wbGV0ZSB0aGUgcmVjb2duaXplZCBub2RlIHR5cGVzIGZyb20gQ2FwdHVyYWJsZU5vZGVzLlxuICpcbiAqIExvb2tzIGxpa2UgU3ludGF4TGlzdCBub2RlcyBhcHBlYXIgaW4gdGhlIHByaW50ZWQgQVNULCBidXQgdGhleSBkb24ndCBhY3R1YWxseSBhcHBlYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVPZlR5cGU8QT4oc3ludGF4S2luZDogdHMuU3ludGF4S2luZCwgY2hpbGRyZW4/OiBBc3RNYXRjaGVyPEE+KTogQXN0TWF0Y2hlcjxBPjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5leHBvcnQgZnVuY3Rpb24gbm9kZU9mVHlwZTxTIGV4dGVuZHMga2V5b2YgQ2FwdHVyYWJsZU5vZGVzLCBOIGV4dGVuZHMgc3RyaW5nLCBBPihcbiAgY2FwdHVyZTogTixcbiAgY2FwdHVyYWJsZU5vZGVUeXBlOiBTLFxuICBjaGlsZHJlbj86IEFzdE1hdGNoZXI8QT4sXG4pOiBBc3RNYXRjaGVyPE9taXQ8QSwgTj4gJiB7IFtrZXkgaW4gTl06IENhcHR1cmFibGVOb2Rlc1tTXSB9Pjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5leHBvcnQgZnVuY3Rpb24gbm9kZU9mVHlwZTxTIGV4dGVuZHMga2V5b2YgQ2FwdHVyYWJsZU5vZGVzLCBOIGV4dGVuZHMgc3RyaW5nLCBBPihcbiAgc3ludGF4S2luZE9yQ2FwdHVyZU5hbWU6IHRzLlN5bnRheEtpbmQgfCBOLFxuICBub2RlVHlwZU9yQ2hpbGRyZW4/OiBTIHwgQXN0TWF0Y2hlcjxBPixcbiAgY2hpbGRyZW4/OiBBc3RNYXRjaGVyPEE+LFxuKTogQXN0TWF0Y2hlcjxBPiB8IEFzdE1hdGNoZXI8QSAmIHsgW2tleSBpbiBOXTogQ2FwdHVyYWJsZU5vZGVzW1NdIH0+IHtcbiAgY29uc3QgY2FwdHVyaW5nID0gdHlwZW9mIHN5bnRheEtpbmRPckNhcHR1cmVOYW1lID09PSAnc3RyaW5nJzsgLy8gRGV0ZXJtaW5lIHdoaWNoIG92ZXJsb2FkIHdlJ3JlIGluIChTeW50YXhLaW5kIGlzIGEgbnVtYmVyKVxuXG4gIGNvbnN0IHJlYWxOZXh0ID0gKGNhcHR1cmluZyA/IGNoaWxkcmVuIDogKG5vZGVUeXBlT3JDaGlsZHJlbiBhcyBBc3RNYXRjaGVyPEE+KSkgPz8gRE9ORTtcbiAgY29uc3QgcmVhbENhcHR1cmUgPSBjYXB0dXJpbmcgPyAoc3ludGF4S2luZE9yQ2FwdHVyZU5hbWUgYXMgTikgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHJlYWxTeW50YXhLaW5kID0gY2FwdHVyaW5nID8gbm9kZVR5cGVPckNoaWxkcmVuIDogc3ludGF4S2luZE9yQ2FwdHVyZU5hbWU7XG5cbiAgcmV0dXJuIChub2RlcykgPT4ge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlcyA/PyBbXSkge1xuICAgICAgaWYgKG5vZGUua2luZCA9PT0gcmVhbFN5bnRheEtpbmQpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gcmVhbE5leHQobm9kZUNoaWxkcmVuKG5vZGUpKTtcbiAgICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFsQ2FwdHVyZSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJldCwge1xuICAgICAgICAgICAgW3JlYWxDYXB0dXJlXTogbm9kZSBhcyBDYXB0dXJhYmxlTm9kZXNbU10sXG4gICAgICAgICAgfSkgYXMgYW55O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbnlOb2RlKCk6IEFzdE1hdGNoZXI8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+O1xuZXhwb3J0IGZ1bmN0aW9uIGFueU5vZGU8QT4oY2hpbGRyZW46IEFzdE1hdGNoZXI8QT4pOiBBc3RNYXRjaGVyPEE+O1xuZXhwb3J0IGZ1bmN0aW9uIGFueU5vZGU8QT4oY2hpbGRyZW4/OiBBc3RNYXRjaGVyPEE+KTogQXN0TWF0Y2hlcjxBPiB8IEFzdE1hdGNoZXI8YW55PiB7XG4gIGNvbnN0IHJlYWxOZXh0ID0gY2hpbGRyZW4gPz8gRE9ORTtcbiAgcmV0dXJuIChub2RlcykgPT4ge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlcyA/PyBbXSkge1xuICAgICAgY29uc3QgbSA9IHJlYWxOZXh0KG5vZGVDaGlsZHJlbihub2RlKSk7XG4gICAgICBpZiAobSkge1xuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLy8gRG9lcyBub3QgY2FwdHVyZSBkZWVwZXIgYmVjYXVzZSBob3cgd291bGQgd2UgZXZlbiByZXByZXNlbnQgdGhhdD9cbmV4cG9ydCBmdW5jdGlvbiBhbGxPZlR5cGU8UyBleHRlbmRzIGtleW9mIENhcHR1cmFibGVOb2RlcywgTiBleHRlbmRzIHN0cmluZywgQT4oXG4gIHM6IFMsXG4gIG5hbWU6IE4sXG4gIGNoaWxkcmVuPzogQXN0TWF0Y2hlcjxBPixcbik6IEFzdE1hdGNoZXI8eyBba2V5IGluIE5dOiBBcnJheTxDYXB0dXJhYmxlTm9kZXNbU10+IH0+IHtcbiAgdHlwZSBBcnJheVR5cGUgPSBBcnJheTxDYXB0dXJhYmxlTm9kZXNbU10+O1xuICB0eXBlIFJldHVyblR5cGUgPSB7IFtrZXkgaW4gTl06IEFycmF5VHlwZSB9O1xuICBjb25zdCByZWFsTmV4dCA9IGNoaWxkcmVuID8/IERPTkU7XG5cbiAgcmV0dXJuIChub2RlcykgPT4ge1xuICAgIGxldCByZXQ6IFJldHVyblR5cGUgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzID8/IFtdKSB7XG4gICAgICBpZiAobm9kZS5raW5kID09PSBzKSB7XG4gICAgICAgIGlmIChyZWFsTmV4dChub2RlQ2hpbGRyZW4obm9kZSkpKSB7XG4gICAgICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgICAgIHJldCA9IHsgW25hbWVdOiBuZXcgQXJyYXk8Q2FwdHVyYWJsZU5vZGVzW1NdPigpIH0gYXMgUmV0dXJuVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0W25hbWVdLnB1c2gobm9kZSBhcyBhbnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBET05FOiBBc3RNYXRjaGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9ICgpID0+ICh7fSk7XG5cbi8qKlxuICogUnVuIGEgbWF0Y2hlciBhZ2FpbnN0IGEgbm9kZSBhbmQgcmV0dXJuIChvciBpbnZva2UgYSBjYWxsYmFjayB3aXRoKSB0aGUgYWNjdW11bGF0ZWQgYmluZGluZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoQXN0PEE+KG5vZGU6IHRzLk5vZGUsIG1hdGNoZXI6IEFzdE1hdGNoZXI8QT4pOiBBIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoQXN0PEE+KG5vZGU6IHRzLk5vZGUsIG1hdGNoZXI6IEFzdE1hdGNoZXI8QT4sIGNiOiAoYmluZGluZ3M6IEEpID0+IHZvaWQpOiBib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoQXN0PEE+KFxuICBub2RlOiB0cy5Ob2RlLFxuICBtYXRjaGVyOiBBc3RNYXRjaGVyPEE+LFxuICBjYj86IChiaW5kaW5nczogQSkgPT4gdm9pZCxcbik6IGJvb2xlYW4gfCBBIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgbWF0Y2hlZCA9IG1hdGNoZXIoW25vZGVdKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIGNiKG1hdGNoZWQpO1xuICAgIH1cbiAgICByZXR1cm4gISFtYXRjaGVkO1xuICB9XG4gIHJldHVybiBtYXRjaGVkO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBuZXdsaW5lcyBpbiBhIGdpdmVuIHBpZWNlIG9mIHN0cmluZyB0aGF0IGFyZW4ndCBpbiBjb21tZW50IGJsb2Nrc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY291bnROYWtlZE5ld2xpbmVzKHN0cjogc3RyaW5nKSB7XG4gIGxldCByZXQgPSAwO1xuICBzY2FuVGV4dChzdHIsIDAsIHN0ci5sZW5ndGgpXG4gICAgLmZpbHRlcigocykgPT4gcy50eXBlID09PSAnb3RoZXInIHx8IHMudHlwZSA9PT0gJ2Jsb2NrY29tbWVudCcpXG4gICAgLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvdGhlcicpIHtcbiAgICAgICAgLy8gQ291bnQgbmV3bGluZXMgaW4gbm9uLWNvbW1lbnRzXG4gICAgICAgIGZvciAobGV0IGkgPSBzLnBvczsgaSA8IHMuZW5kOyBpKyspIHtcbiAgICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEaXNjb3VudCBuZXdsaW5lcyBhdCB0aGUgZW5kIG9mIGJsb2NrIGNvbW1lbnRzXG4gICAgICAgIGlmIChzLmhhc1RyYWlsaW5nTmV3TGluZSkge1xuICAgICAgICAgIHJldC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBlYXROZXdsaW5lcyhzdHI6IHN0cmluZykge1xuICByZXR1cm4gJ1xcbicucmVwZWF0KE1hdGgubWluKDIsIGNvdW50TmFrZWROZXdsaW5lcyhzdHIpKSk7XG59XG5cbmNvbnN0IFdISVRFU1BBQ0UgPSBbJyAnLCAnXFx0JywgJ1xccicsICdcXG4nXTtcblxuLyoqXG4gKiBFeHRyYWN0IHNpbmdsZS1saW5lIGFuZCBtdWx0aS1saW5lIGNvbW1lbnRzIGZyb20gdGhlIGdpdmVuIHN0cmluZ1xuICpcbiAqIFJld3JpdHRlbiBiZWNhdXNlIEkgY2FuJ3QgZ2V0IHRzLmdldExlYWRpbmdDb21tZW50cyBhbmQgdHMuZ2V0VHJhaWxpbmdDb21tZW50cyB0byBkbyB3aGF0IEkgd2FudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RDb21tZW50cyh0ZXh0OiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIpOiB0cy5Db21tZW50UmFuZ2VbXSB7XG4gIHJldHVybiBzY2FuVGV4dCh0ZXh0LCBzdGFydClcbiAgICAuZmlsdGVyKChzKSA9PiBzLnR5cGUgPT09ICdibG9ja2NvbW1lbnQnIHx8IHMudHlwZSA9PT0gJ2xpbmVjb21tZW50JylcbiAgICAubWFwKGNvbW1lbnRSYW5nZUZyb21UZXh0UmFuZ2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tbWVudFJhbmdlRnJvbVRleHRSYW5nZShybmc6IFRleHRSYW5nZSk6IHRzLkNvbW1lbnRSYW5nZSB7XG4gIHJldHVybiB7XG4gICAga2luZDogcm5nLnR5cGUgPT09ICdibG9ja2NvbW1lbnQnID8gdHMuU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhIDogdHMuU3ludGF4S2luZC5TaW5nbGVMaW5lQ29tbWVudFRyaXZpYSxcbiAgICBwb3M6IHJuZy5wb3MsXG4gICAgZW5kOiBybmcuZW5kLFxuICAgIGhhc1RyYWlsaW5nTmV3TGluZTogcm5nLnR5cGUgIT09ICdibG9ja2NvbW1lbnQnICYmIHJuZy5oYXNUcmFpbGluZ05ld0xpbmUsXG4gIH07XG59XG5cbmludGVyZmFjZSBUZXh0UmFuZ2Uge1xuICBwb3M6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG4gIHR5cGU6ICdsaW5lY29tbWVudCcgfCAnYmxvY2tjb21tZW50JyB8ICdvdGhlcicgfCAnZGlyZWN0aXZlJztcbiAgaGFzVHJhaWxpbmdOZXdMaW5lOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEV4dHJhY3Qgc3BhbnMgb2YgY29tbWVudHMgYW5kIG5vbi1jb21tZW50cyBvdXQgb2YgdGhlIHN0cmluZ1xuICpcbiAqIFN0b3AgYXQgJ2VuZCcgd2hlbiBnaXZlbiwgb3IgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBpbiBhXG4gKiBub24tY29tbWVudCBpZiBub3QgZ2l2ZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FuVGV4dCh0ZXh0OiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIsIGVuZD86IG51bWJlcik6IFRleHRSYW5nZVtdIHtcbiAgY29uc3QgcmV0OiBUZXh0UmFuZ2VbXSA9IFtdO1xuXG4gIGxldCBwb3MgPSBzdGFydDtcbiAgY29uc3Qgc3RvcEF0Q29kZSA9IGVuZCA9PT0gdW5kZWZpbmVkO1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0ZXh0Lmxlbmd0aDtcbiAgfVxuICB3aGlsZSAocG9zIDwgZW5kKSB7XG4gICAgY29uc3QgY2ggPSB0ZXh0W3Bvc107XG5cbiAgICBpZiAoV0hJVEVTUEFDRS5pbmNsdWRlcyhjaCkpIHtcbiAgICAgIHBvcysrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnLycgJiYgdGV4dFtwb3MgKyAxXSA9PT0gJy8nKSB7XG4gICAgICBhY2N1bXVsYXRlVGV4dEJsb2NrKCk7XG4gICAgICBzY2FuU2luZ2xlbGluZUNvbW1lbnQoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJy8nICYmIHRleHRbcG9zICsgMV0gPT09ICcqJykge1xuICAgICAgYWNjdW11bGF0ZVRleHRCbG9jaygpO1xuICAgICAgc2Nhbk11bHRpbGluZUNvbW1lbnQoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIE5vbi13aGl0ZXNwYWNlLCBub24tY29tbWVudCwgbXVzdCBiZSByZWd1bGFyIHRva2VuLiBFbmQgaWYgd2UncmUgbm90IHNjYW5uaW5nXG4gICAgLy8gdG8gYSBwYXJ0aWN1bGFyIGxvY2F0aW9uLCBvdGhlcndpc2UgY29udGludWUuXG4gICAgaWYgKHN0b3BBdENvZGUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgYWNjdW11bGF0ZVRleHRCbG9jaygpO1xuXG4gIHJldHVybiByZXQ7XG5cbiAgZnVuY3Rpb24gc2Nhbk11bHRpbGluZUNvbW1lbnQoKSB7XG4gICAgY29uc3QgZW5kT2ZDb21tZW50ID0gZmluZE5leHQoJyovJywgcG9zICsgMik7XG4gICAgcmV0LnB1c2goe1xuICAgICAgdHlwZTogJ2Jsb2NrY29tbWVudCcsXG4gICAgICBoYXNUcmFpbGluZ05ld0xpbmU6IFsnXFxuJywgJ1xcciddLmluY2x1ZGVzKHRleHRbZW5kT2ZDb21tZW50ICsgMl0pLFxuICAgICAgcG9zLFxuICAgICAgZW5kOiBlbmRPZkNvbW1lbnQgKyAyLFxuICAgIH0pO1xuICAgIHBvcyA9IGVuZE9mQ29tbWVudCArIDI7XG4gICAgc3RhcnQgPSBwb3M7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuU2luZ2xlbGluZUNvbW1lbnQoKSB7XG4gICAgY29uc3QgbmwgPSBNYXRoLm1pbihmaW5kTmV4dCgnXFxyJywgcG9zICsgMiksIGZpbmROZXh0KCdcXG4nLCBwb3MgKyAyKSk7XG5cbiAgICBpZiAodGV4dFtwb3MgKyAyXSA9PT0gJy8nKSB7XG4gICAgICAvLyBTcGVjaWFsIC8vLyBjb21tZW50XG4gICAgICByZXQucHVzaCh7XG4gICAgICAgIHR5cGU6ICdkaXJlY3RpdmUnLFxuICAgICAgICBoYXNUcmFpbGluZ05ld0xpbmU6IHRydWUsXG4gICAgICAgIHBvczogcG9zICsgMSxcbiAgICAgICAgZW5kOiBubCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWd1bGFyIC8vIGNvbW1lbnRcbiAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpbmVjb21tZW50JyxcbiAgICAgICAgaGFzVHJhaWxpbmdOZXdMaW5lOiB0cnVlLFxuICAgICAgICBwb3MsXG4gICAgICAgIGVuZDogbmwsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcG9zID0gbmwgKyAxO1xuICAgIHN0YXJ0ID0gcG9zO1xuICB9XG5cbiAgZnVuY3Rpb24gYWNjdW11bGF0ZVRleHRCbG9jaygpIHtcbiAgICBpZiAocG9zIC0gc3RhcnQgPiAwKSB7XG4gICAgICByZXQucHVzaCh7XG4gICAgICAgIHR5cGU6ICdvdGhlcicsXG4gICAgICAgIGhhc1RyYWlsaW5nTmV3TGluZTogZmFsc2UsXG4gICAgICAgIHBvczogc3RhcnQsXG4gICAgICAgIGVuZDogcG9zLFxuICAgICAgfSk7XG4gICAgICBzdGFydCA9IHBvcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTmV4dChzdWI6IHN0cmluZywgc3RhcnRQb3M6IG51bWJlcikge1xuICAgIGNvbnN0IGYgPSB0ZXh0LmluZGV4T2Yoc3ViLCBzdGFydFBvcyk7XG4gICAgaWYgKGYgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBmO1xuICB9XG59XG5cbmNvbnN0IFZPSURfU0hPV19LRVlXT1JEID0gJ3Nob3cnO1xuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdE1hc2tpbmdWb2lkRXhwcmVzc2lvbihub2RlOiB0cy5Ob2RlKTogdHMuVm9pZEV4cHJlc3Npb24gfCB1bmRlZmluZWQge1xuICBjb25zdCBleHByID0gZXh0cmFjdFZvaWRFeHByZXNzaW9uKG5vZGUpO1xuICBpZiAoIWV4cHIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0cy5pc1N0cmluZ0xpdGVyYWwoZXhwci5leHByZXNzaW9uKSAmJiBleHByLmV4cHJlc3Npb24udGV4dCA9PT0gVk9JRF9TSE9XX0tFWVdPUkQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBleHByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFNob3dpbmdWb2lkRXhwcmVzc2lvbihub2RlOiB0cy5Ob2RlKTogdHMuVm9pZEV4cHJlc3Npb24gfCB1bmRlZmluZWQge1xuICBjb25zdCBleHByID0gZXh0cmFjdFZvaWRFeHByZXNzaW9uKG5vZGUpO1xuICBpZiAoIWV4cHIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0cy5pc1N0cmluZ0xpdGVyYWwoZXhwci5leHByZXNzaW9uKSAmJiBleHByLmV4cHJlc3Npb24udGV4dCA9PT0gVk9JRF9TSE9XX0tFWVdPUkQpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIGFyZ3VtZW50IHRvIGEgdm9pZCBleHByZXNzaW9uIGlmIGl0IGV4aXN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gdm9pZEV4cHJlc3Npb25TdHJpbmcobm9kZTogdHMuVm9pZEV4cHJlc3Npb24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAodHMuaXNTdHJpbmdMaXRlcmFsKG5vZGUuZXhwcmVzc2lvbikpIHtcbiAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uLnRleHQ7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBXZSB1c2Ugdm9pZCBkaXJlY3RpdmVzIGFzIHByYWdtYXMuIEV4dHJhY3QgdGhlIHZvaWQgZGlyZWN0aXZlcyBoZXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Vm9pZEV4cHJlc3Npb24obm9kZTogdHMuTm9kZSk6IHRzLlZvaWRFeHByZXNzaW9uIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHRzLmlzVm9pZEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpZiAodHMuaXNFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RWb2lkRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24pO1xuICB9XG4gIGlmICh0cy5pc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RWb2lkRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24pO1xuICB9XG4gIGlmICh0cy5pc0JpbmFyeUV4cHJlc3Npb24obm9kZSkgJiYgbm9kZS5vcGVyYXRvclRva2VuLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29tbWFUb2tlbikge1xuICAgIHJldHVybiBleHRyYWN0Vm9pZEV4cHJlc3Npb24obm9kZS5sZWZ0KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVvdGVTdHJpbmdMaXRlcmFsKHg6IHN0cmluZykge1xuICByZXR1cm4geC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZpc2liaWxpdHkoeDogdHMuUHJvcGVydHlMaWtlRGVjbGFyYXRpb24gfCB0cy5GdW5jdGlvbkxpa2VEZWNsYXJhdGlvbkJhc2UpIHtcbiAgY29uc3QgZmxhZ3MgPSB0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoeCk7XG4gIGlmIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuUHJpdmF0ZSkge1xuICAgIHJldHVybiAncHJpdmF0ZSc7XG4gIH1cbiAgaWYgKGZsYWdzICYgdHMuTW9kaWZpZXJGbGFncy5Qcm90ZWN0ZWQpIHtcbiAgICByZXR1cm4gJ3Byb3RlY3RlZCc7XG4gIH1cbiAgcmV0dXJuICdwdWJsaWMnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFkT25seSh4OiB0cy5Qcm9wZXJ0eUxpa2VEZWNsYXJhdGlvbiB8IHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uQmFzZSkge1xuICBjb25zdCBmbGFncyA9IHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyh4KTtcbiAgcmV0dXJuIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuUmVhZG9ubHkpICE9PSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc3VwZXIoKSBjYWxsIGZyb20gYSBtZXRob2QgYm9keSBpZiBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFN1cGVyQ2FsbChcbiAgbm9kZTogdHMuQmxvY2sgfCB0cy5FeHByZXNzaW9uIHwgdW5kZWZpbmVkLFxuICByZW5kZXJlcjogQXN0UmVuZGVyZXI8YW55Pixcbik6IHRzLlN1cGVyQ2FsbCB8IHVuZGVmaW5lZCB7XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0cy5pc0NhbGxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgaWYgKHJlbmRlcmVyLnRleHRPZihub2RlLmV4cHJlc3Npb24pID09PSAnc3VwZXInKSB7XG4gICAgICByZXR1cm4gbm9kZSBhcyB1bmtub3duIGFzIHRzLlN1cGVyQ2FsbDtcbiAgICB9XG4gIH1cbiAgaWYgKHRzLmlzRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSkge1xuICAgIHJldHVybiBmaW5kU3VwZXJDYWxsKG5vZGUuZXhwcmVzc2lvbiwgcmVuZGVyZXIpO1xuICB9XG4gIGlmICh0cy5pc0Jsb2NrKG5vZGUpKSB7XG4gICAgZm9yIChjb25zdCBzdGF0ZW1lbnQgb2Ygbm9kZS5zdGF0ZW1lbnRzKSB7XG4gICAgICBpZiAodHMuaXNFeHByZXNzaW9uU3RhdGVtZW50KHN0YXRlbWVudCkpIHtcbiAgICAgICAgY29uc3QgcyA9IGZpbmRTdXBlckNhbGwoc3RhdGVtZW50LmV4cHJlc3Npb24sIHJlbmRlcmVyKTtcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZXMgb2YgYWxsIHByaXZhdGUgcHJvcGVydHkgZGVjbGFyYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcml2YXRlUHJvcGVydHlOYW1lcyhtZW1iZXJzOiByZWFkb25seSB0cy5DbGFzc0VsZW1lbnRbXSwgcmVuZGVyZXI6IEFzdFJlbmRlcmVyPGFueT4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHByb3BzID0gbWVtYmVycy5maWx0ZXIoKG0pID0+IHRzLmlzUHJvcGVydHlEZWNsYXJhdGlvbihtKSkgYXMgdHMuUHJvcGVydHlEZWNsYXJhdGlvbltdO1xuICByZXR1cm4gcHJvcHMuZmlsdGVyKChtKSA9PiB2aXNpYmlsaXR5KG0pID09PSAncHJpdmF0ZScpLm1hcCgobSkgPT4gcmVuZGVyZXIudGV4dE9mKG0ubmFtZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEVuY2xvc2luZ0NsYXNzRGVjbGFyYXRpb24obm9kZTogdHMuTm9kZSk6IHRzLkNsYXNzRGVjbGFyYXRpb24gfCB1bmRlZmluZWQge1xuICB3aGlsZSAobm9kZSAmJiAhdHMuaXNDbGFzc0RlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuIl19