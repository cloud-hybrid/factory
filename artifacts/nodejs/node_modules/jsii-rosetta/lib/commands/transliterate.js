"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transliterateAssembly = void 0;
const spec_1 = require("@jsii/spec");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const fixtures_1 = require("../fixtures");
const assemblies_1 = require("../jsii/assemblies");
const logging_1 = require("../logging");
const rosetta_reader_1 = require("../rosetta-reader");
const snippet_1 = require("../snippet");
const util_1 = require("../util");
const extract_1 = require("./extract");
/**
 * Prepares transliterated versions of the designated assemblies into the
 * selected taregt languages.
 *
 * @param assemblyLocations the directories which contain assemblies to
 *                          transliterate.
 * @param targetLanguages   the languages into which to transliterate.
 * @param tabletLocation    an optional Rosetta tablet file to source
 *                          pre-transliterated snippets from.
 *
 * @experimental
 */
async function transliterateAssembly(assemblyLocations, targetLanguages, options = {}) {
    var _a, _b;
    // Start by doing an 'extract' for all these assemblies
    //
    // This will locate all examples that haven't been translated yet and translate
    // them. Importantly: it will translate them in parallel, which is going to improve
    // performance a lot. We ignore diagnostics.
    const { tablet } = await extract_1.extractSnippets(assemblyLocations, {
        includeCompilerDiagnostics: true,
        loose: options.loose,
        cacheFromFile: options.tablet,
        writeToImplicitTablets: false,
    });
    // Now do a regular "tablet reader" cycle, expecting everything to be translated already,
    // and therefore it doesn't matter that we do this all in a single-threaded loop.
    const rosetta = new rosetta_reader_1.RosettaTabletReader({
        unknownSnippets: rosetta_reader_1.UnknownSnippetMode.FAIL,
        targetLanguages,
    });
    // Put in the same caching tablet here
    if (options.tablet) {
        await rosetta.loadTabletFromFile(options.tablet);
    }
    // Any fresh translations we just came up with
    rosetta.addTablet(tablet);
    const assemblies = await loadAssemblies(assemblyLocations, rosetta);
    for (const [location, loadAssembly] of assemblies.entries()) {
        for (const language of targetLanguages) {
            const now = new Date().getTime();
            // eslint-disable-next-line no-await-in-loop
            const result = await loadAssembly();
            if ((_a = result.readme) === null || _a === void 0 ? void 0 : _a.markdown) {
                result.readme.markdown = rosetta.translateSnippetsInMarkdown({ api: 'moduleReadme', moduleFqn: result.name }, result.readme.markdown, language, true /* strict */, (translation) => ({
                    language: translation.language,
                    source: prefixDisclaimer(translation),
                }), location);
            }
            for (const type of Object.values((_b = result.types) !== null && _b !== void 0 ? _b : {})) {
                transliterateType(type, rosetta, language, location, options.loose);
            }
            // eslint-disable-next-line no-await-in-loop
            await fs_extra_1.writeJson(path_1.resolve(location, `${spec_1.SPEC_FILE_NAME}.${language}`), result, { spaces: 2 });
            const then = new Date().getTime();
            logging_1.debug(`Done transliterating ${result.name}@${result.version} to ${language} after ${then - now} milliseconds`);
        }
    }
    rosetta.printDiagnostics(process.stderr);
    if (rosetta.hasErrors && options.strict) {
        throw new Error('Strict mode is enabled and some examples failed compilation!');
    }
}
exports.transliterateAssembly = transliterateAssembly;
/**
 * Given a set of directories containing `.jsii` assemblies, load all the
 * assemblies into the provided `Rosetta` instance and return a map of
 * directories to assembly-loading functions (the function re-loads the original
 * assembly from disk on each invocation).
 *
 * @param directories the assembly-containing directories to traverse.
 * @param rosetta     the `Rosetta` instance in which to load assemblies.
 *
 * @returns a map of directories to a function that loads the `.jsii` assembly
 *          contained therein from disk.
 */
async function loadAssemblies(directories, rosetta) {
    const result = new Map();
    for (const directory of directories) {
        const loader = () => fs_extra_1.readJson(path_1.resolve(directory, spec_1.SPEC_FILE_NAME));
        // eslint-disable-next-line no-await-in-loop
        await rosetta.addAssembly(await loader(), directory);
        result.set(directory, loader);
    }
    return result;
}
function prefixDisclaimer(translation) {
    const comment = commentToken();
    const disclaimer = translation.didCompile
        ? 'This example was automatically transliterated.'
        : 'This example was automatically transliterated with incomplete type information. It may not work as-is.';
    return [
        `${comment} ${disclaimer}`,
        `${comment} See https://github.com/aws/jsii/issues/826 for more information.`,
        '',
        translation.source,
    ].join('\n');
    function commentToken() {
        // This is future-proofed a bit, but don't read too much in this...
        switch (translation.language) {
            case 'python':
            case 'ruby':
                return '#';
            case 'csharp':
            case 'java':
            case 'go':
            default:
                return '//';
        }
    }
}
function transliterateType(type, rosetta, language, workingDirectory, loose = false) {
    var _a, _b, _c;
    transliterateDocs({ api: 'type', fqn: type.fqn }, type.docs, workingDirectory);
    switch (type.kind) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore 7029
        case spec_1.TypeKind.Class:
            if (type.initializer) {
                transliterateDocs({ api: 'initializer', fqn: type.fqn }, type.initializer.docs, workingDirectory);
            }
        // fallthrough
        case spec_1.TypeKind.Interface:
            for (const method of (_a = type.methods) !== null && _a !== void 0 ? _a : []) {
                transliterateDocs({ api: 'member', fqn: type.fqn, memberName: method.name }, method.docs, workingDirectory);
                for (const parameter of (_b = method.parameters) !== null && _b !== void 0 ? _b : []) {
                    transliterateDocs({ api: 'parameter', fqn: type.fqn, methodName: method.name, parameterName: parameter.name }, parameter.docs, workingDirectory);
                }
            }
            for (const property of (_c = type.properties) !== null && _c !== void 0 ? _c : []) {
                transliterateDocs({ api: 'member', fqn: type.fqn, memberName: property.name }, property.docs, workingDirectory);
            }
            break;
        case spec_1.TypeKind.Enum:
            for (const member of type.members) {
                transliterateDocs({ api: 'member', fqn: type.fqn, memberName: member.name }, member.docs, workingDirectory);
            }
            break;
        default:
            throw new Error(`Unsupported type kind: ${type.kind}`);
    }
    function transliterateDocs(api, docs, workingDirectory) {
        var _a, _b;
        if (docs === null || docs === void 0 ? void 0 : docs.remarks) {
            docs.remarks = rosetta.translateSnippetsInMarkdown(api, docs.remarks, language, true /* strict */, (translation) => ({
                language: translation.language,
                source: prefixDisclaimer(translation),
            }), workingDirectory);
        }
        if (docs === null || docs === void 0 ? void 0 : docs.example) {
            const location = { api, field: { field: 'example' } };
            const metadata = (_b = util_1.fmap((_a = docs.custom) === null || _a === void 0 ? void 0 : _a[assemblies_1.EXAMPLE_METADATA_JSDOCTAG], snippet_1.parseMetadataLine)) !== null && _b !== void 0 ? _b : {};
            const snippet = fixtures_1.fixturize(snippet_1.typeScriptSnippetFromVisibleSource(docs.example, location, true /* strict */, {
                [snippet_1.SnippetParameters.$PROJECT_DIRECTORY]: workingDirectory,
                ...metadata,
            }), loose);
            const translation = rosetta.translateSnippet(snippet, language);
            if (translation != null) {
                docs.example = prefixDisclaimer(translation);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsaXRlcmF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRyYW5zbGl0ZXJhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQTRFO0FBQzVFLHVDQUErQztBQUMvQywrQkFBK0I7QUFFL0IsMENBQXdDO0FBQ3hDLG1EQUErRDtBQUUvRCx3Q0FBbUM7QUFDbkMsc0RBQTRFO0FBQzVFLHdDQUFtSDtBQUVuSCxrQ0FBK0I7QUFDL0IsdUNBQTRDO0FBMkI1Qzs7Ozs7Ozs7Ozs7R0FXRztBQUNJLEtBQUssVUFBVSxxQkFBcUIsQ0FDekMsaUJBQW9DLEVBQ3BDLGVBQTBDLEVBQzFDLFVBQXdDLEVBQUU7O0lBRTFDLHVEQUF1RDtJQUN2RCxFQUFFO0lBQ0YsK0VBQStFO0lBQy9FLG1GQUFtRjtJQUNuRiw0Q0FBNEM7SUFDNUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLE1BQU0seUJBQWUsQ0FBQyxpQkFBaUIsRUFBRTtRQUMxRCwwQkFBMEIsRUFBRSxJQUFJO1FBQ2hDLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSztRQUNwQixhQUFhLEVBQUUsT0FBTyxDQUFDLE1BQU07UUFDN0Isc0JBQXNCLEVBQUUsS0FBSztLQUM5QixDQUFDLENBQUM7SUFFSCx5RkFBeUY7SUFDekYsaUZBQWlGO0lBQ2pGLE1BQU0sT0FBTyxHQUFHLElBQUksb0NBQW1CLENBQUM7UUFDdEMsZUFBZSxFQUFFLG1DQUFrQixDQUFDLElBQUk7UUFDeEMsZUFBZTtLQUNoQixDQUFDLENBQUM7SUFDSCxzQ0FBc0M7SUFDdEMsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO1FBQ2xCLE1BQU0sT0FBTyxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNsRDtJQUNELDhDQUE4QztJQUM5QyxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTFCLE1BQU0sVUFBVSxHQUFHLE1BQU0sY0FBYyxDQUFDLGlCQUFpQixF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QUFHLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQzlDO1NBQ0Y7SUFDSCxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzc2VtYmx5LCBEb2NzLCBTUEVDX0ZJTEVfTkFNRSwgVHlwZSwgVHlwZUtpbmQgfSBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCB7IHJlYWRKc29uLCB3cml0ZUpzb24gfSBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IGZpeHR1cml6ZSB9IGZyb20gJy4uL2ZpeHR1cmVzJztcbmltcG9ydCB7IEVYQU1QTEVfTUVUQURBVEFfSlNET0NUQUcgfSBmcm9tICcuLi9qc2lpL2Fzc2VtYmxpZXMnO1xuaW1wb3J0IHsgVGFyZ2V0TGFuZ3VhZ2UgfSBmcm9tICcuLi9sYW5ndWFnZXMnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IFJvc2V0dGFUYWJsZXRSZWFkZXIsIFVua25vd25TbmlwcGV0TW9kZSB9IGZyb20gJy4uL3Jvc2V0dGEtcmVhZGVyJztcbmltcG9ydCB7IFNuaXBwZXRQYXJhbWV0ZXJzLCB0eXBlU2NyaXB0U25pcHBldEZyb21WaXNpYmxlU291cmNlLCBBcGlMb2NhdGlvbiwgcGFyc2VNZXRhZGF0YUxpbmUgfSBmcm9tICcuLi9zbmlwcGV0JztcbmltcG9ydCB7IFRyYW5zbGF0aW9uIH0gZnJvbSAnLi4vdGFibGV0cy90YWJsZXRzJztcbmltcG9ydCB7IGZtYXAgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IGV4dHJhY3RTbmlwcGV0cyB9IGZyb20gJy4vZXh0cmFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsaXRlcmF0ZUFzc2VtYmx5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGlnbm9yZSBhbnkgbWlzc2luZyBmaXh0dXJlIGZpbGVzIG9yIGxpdGVyYXRlIG1hcmtkb3duIGRvY3VtZW50c1xuICAgKiByZWZlcmVuY2VkIGJ5IHRoZSBhc3NlbWJseSwgaW5zdGVhZCBvZiBmYWlsaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgbG9vc2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRyYW5zbGl0ZXJhdGlvbiBzaG91bGQgZmFpbCB1cG9uIGZhaWxpbmcgdG8gY29tcGlsZSBhbiBleGFtcGxlIHRoYXRcbiAgICogcmVxdWlyZWQgbGl2ZSB0cmFuc2xpdGVyYXRpb24uXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBzdHJpY3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIHByZS1idWlsZCB0cmFuc2xhdGlvbiB0YWJsZXQgKGFzIHByb2R1Y2VkIGJ5IGBqc2lpLXJvc2V0dGEgZXh0cmFjdGApLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE9ubHkgdGhlIGRlZmF1bHQgdGFibGV0IChgLmpzaWkudGFibC5qc29uYCkgZmlsZXMgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcmVhZG9ubHkgdGFibGV0Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFByZXBhcmVzIHRyYW5zbGl0ZXJhdGVkIHZlcnNpb25zIG9mIHRoZSBkZXNpZ25hdGVkIGFzc2VtYmxpZXMgaW50byB0aGVcbiAqIHNlbGVjdGVkIHRhcmVndCBsYW5ndWFnZXMuXG4gKlxuICogQHBhcmFtIGFzc2VtYmx5TG9jYXRpb25zIHRoZSBkaXJlY3RvcmllcyB3aGljaCBjb250YWluIGFzc2VtYmxpZXMgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xpdGVyYXRlLlxuICogQHBhcmFtIHRhcmdldExhbmd1YWdlcyAgIHRoZSBsYW5ndWFnZXMgaW50byB3aGljaCB0byB0cmFuc2xpdGVyYXRlLlxuICogQHBhcmFtIHRhYmxldExvY2F0aW9uICAgIGFuIG9wdGlvbmFsIFJvc2V0dGEgdGFibGV0IGZpbGUgdG8gc291cmNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlLXRyYW5zbGl0ZXJhdGVkIHNuaXBwZXRzIGZyb20uXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhbnNsaXRlcmF0ZUFzc2VtYmx5KFxuICBhc3NlbWJseUxvY2F0aW9uczogcmVhZG9ubHkgc3RyaW5nW10sXG4gIHRhcmdldExhbmd1YWdlczogcmVhZG9ubHkgVGFyZ2V0TGFuZ3VhZ2VbXSxcbiAgb3B0aW9uczogVHJhbnNsaXRlcmF0ZUFzc2VtYmx5T3B0aW9ucyA9IHt9LFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFN0YXJ0IGJ5IGRvaW5nIGFuICdleHRyYWN0JyBmb3IgYWxsIHRoZXNlIGFzc2VtYmxpZXNcbiAgLy9cbiAgLy8gVGhpcyB3aWxsIGxvY2F0ZSBhbGwgZXhhbXBsZXMgdGhhdCBoYXZlbid0IGJlZW4gdHJhbnNsYXRlZCB5ZXQgYW5kIHRyYW5zbGF0ZVxuICAvLyB0aGVtLiBJbXBvcnRhbnRseTogaXQgd2lsbCB0cmFuc2xhdGUgdGhlbSBpbiBwYXJhbGxlbCwgd2hpY2ggaXMgZ29pbmcgdG8gaW1wcm92ZVxuICAvLyBwZXJmb3JtYW5jZSBhIGxvdC4gV2UgaWdub3JlIGRpYWdub3N0aWNzLlxuICBjb25zdCB7IHRhYmxldCB9ID0gYXdhaXQgZXh0cmFjdFNuaXBwZXRzKGFzc2VtYmx5TG9jYXRpb25zLCB7XG4gICAgaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3M6IHRydWUsXG4gICAgbG9vc2U6IG9wdGlvbnMubG9vc2UsXG4gICAgY2FjaGVGcm9tRmlsZTogb3B0aW9ucy50YWJsZXQsXG4gICAgd3JpdGVUb0ltcGxpY2l0VGFibGV0czogZmFsc2UsXG4gIH0pO1xuXG4gIC8vIE5vdyBkbyBhIHJlZ3VsYXIgXCJ0YWJsZXQgcmVhZGVyXCIgY3ljbGUsIGV4cGVjdGluZyBldmVyeXRoaW5nIHRvIGJlIHRyYW5zbGF0ZWQgYWxyZWFkeSxcbiAgLy8gYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG1hdHRlciB0aGF0IHdlIGRvIHRoaXMgYWxsIGluIGEgc2luZ2xlLXRocmVhZGVkIGxvb3AuXG4gIGNvbnN0IHJvc2V0dGEgPSBuZXcgUm9zZXR0YVRhYmxldFJlYWRlcih7XG4gICAgdW5rbm93blNuaXBwZXRzOiBVbmtub3duU25pcHBldE1vZGUuRkFJTCxcbiAgICB0YXJnZXRMYW5ndWFnZXMsXG4gIH0pO1xuICAvLyBQdXQgaW4gdGhlIHNhbWUgY2FjaGluZyB0YWJsZXQgaGVyZVxuICBpZiAob3B0aW9ucy50YWJsZXQpIHtcbiAgICBhd2FpdCByb3NldHRhLmxvYWRUYWJsZXRGcm9tRmlsZShvcHRpb25zLnRhYmxldCk7XG4gIH1cbiAgLy8gQW55IGZyZXNoIHRyYW5zbGF0aW9ucyB3ZSBqdXN0IGNhbWUgdXAgd2l0aFxuICByb3NldHRhLmFkZFRhYmxldCh0YWJsZXQpO1xuXG4gIGNvbnN0IGFzc2VtYmxpZXMgPSBhd2FpdCBsb2FkQXNzZW1ibGllcyhhc3NlbWJseUxvY2F0aW9ucywgcm9zZXR0YSk7XG5cbiAgZm9yIChjb25zdCBbbG9jYXRpb24sIGxvYWRBc3NlbWJseV0gb2YgYXNzZW1ibGllcy5lbnRyaWVzKCkpIHtcbiAgICBmb3IgKGNvbnN0IGxhbmd1YWdlIG9mIHRhcmdldExhbmd1YWdlcykge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZEFzc2VtYmx5KCk7XG4gICAgICBpZiAocmVzdWx0LnJlYWRtZT8ubWFya2Rvd24pIHtcbiAgICAgICAgcmVzdWx0LnJlYWRtZS5tYXJrZG93biA9IHJvc2V0dGEudHJhbnNsYXRlU25pcHBldHNJbk1hcmtkb3duKFxuICAgICAgICAgIHsgYXBpOiAnbW9kdWxlUmVhZG1lJywgbW9kdWxlRnFuOiByZXN1bHQubmFtZSB9LFxuICAgICAgICAgIHJlc3VsdC5yZWFkbWUubWFya2Rvd24sXG4gICAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgICAgdHJ1ZSAvKiBzdHJpY3QgKi8sXG4gICAgICAgICAgKHRyYW5zbGF0aW9uKSA9PiAoe1xuICAgICAgICAgICAgbGFuZ3VhZ2U6IHRyYW5zbGF0aW9uLmxhbmd1YWdlLFxuICAgICAgICAgICAgc291cmNlOiBwcmVmaXhEaXNjbGFpbWVyKHRyYW5zbGF0aW9uKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3QudmFsdWVzKHJlc3VsdC50eXBlcyA/PyB7fSkpIHtcbiAgICAgICAgdHJhbnNsaXRlcmF0ZVR5cGUodHlwZSwgcm9zZXR0YSwgbGFuZ3VhZ2UsIGxvY2F0aW9uLCBvcHRpb25zLmxvb3NlKTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICBhd2FpdCB3cml0ZUpzb24ocmVzb2x2ZShsb2NhdGlvbiwgYCR7U1BFQ19GSUxFX05BTUV9LiR7bGFuZ3VhZ2V9YCksIHJlc3VsdCwgeyBzcGFjZXM6IDIgfSk7XG4gICAgICBjb25zdCB0aGVuID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBkZWJ1ZyhgRG9uZSB0cmFuc2xpdGVyYXRpbmcgJHtyZXN1bHQubmFtZX1AJHtyZXN1bHQudmVyc2lvbn0gdG8gJHtsYW5ndWFnZX0gYWZ0ZXIgJHt0aGVuIC0gbm93fSBtaWxsaXNlY29uZHNgKTtcbiAgICB9XG4gIH1cblxuICByb3NldHRhLnByaW50RGlhZ25vc3RpY3MocHJvY2Vzcy5zdGRlcnIpO1xuICBpZiAocm9zZXR0YS5oYXNFcnJvcnMgJiYgb3B0aW9ucy5zdHJpY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmljdCBtb2RlIGlzIGVuYWJsZWQgYW5kIHNvbWUgZXhhbXBsZXMgZmFpbGVkIGNvbXBpbGF0aW9uIScpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBzZXQgb2YgZGlyZWN0b3JpZXMgY29udGFpbmluZyBgLmpzaWlgIGFzc2VtYmxpZXMsIGxvYWQgYWxsIHRoZVxuICogYXNzZW1ibGllcyBpbnRvIHRoZSBwcm92aWRlZCBgUm9zZXR0YWAgaW5zdGFuY2UgYW5kIHJldHVybiBhIG1hcCBvZlxuICogZGlyZWN0b3JpZXMgdG8gYXNzZW1ibHktbG9hZGluZyBmdW5jdGlvbnMgKHRoZSBmdW5jdGlvbiByZS1sb2FkcyB0aGUgb3JpZ2luYWxcbiAqIGFzc2VtYmx5IGZyb20gZGlzayBvbiBlYWNoIGludm9jYXRpb24pLlxuICpcbiAqIEBwYXJhbSBkaXJlY3RvcmllcyB0aGUgYXNzZW1ibHktY29udGFpbmluZyBkaXJlY3RvcmllcyB0byB0cmF2ZXJzZS5cbiAqIEBwYXJhbSByb3NldHRhICAgICB0aGUgYFJvc2V0dGFgIGluc3RhbmNlIGluIHdoaWNoIHRvIGxvYWQgYXNzZW1ibGllcy5cbiAqXG4gKiBAcmV0dXJucyBhIG1hcCBvZiBkaXJlY3RvcmllcyB0byBhIGZ1bmN0aW9uIHRoYXQgbG9hZHMgdGhlIGAuanNpaWAgYXNzZW1ibHlcbiAqICAgICAgICAgIGNvbnRhaW5lZCB0aGVyZWluIGZyb20gZGlzay5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZEFzc2VtYmxpZXMoXG4gIGRpcmVjdG9yaWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgcm9zZXR0YTogUm9zZXR0YVRhYmxldFJlYWRlcixcbik6IFByb21pc2U8UmVhZG9ubHlNYXA8c3RyaW5nLCBBc3NlbWJseUxvYWRlcj4+IHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcDxzdHJpbmcsIEFzc2VtYmx5TG9hZGVyPigpO1xuXG4gIGZvciAoY29uc3QgZGlyZWN0b3J5IG9mIGRpcmVjdG9yaWVzKSB7XG4gICAgY29uc3QgbG9hZGVyID0gKCkgPT4gcmVhZEpzb24ocmVzb2x2ZShkaXJlY3RvcnksIFNQRUNfRklMRV9OQU1FKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICBhd2FpdCByb3NldHRhLmFkZEFzc2VtYmx5KGF3YWl0IGxvYWRlcigpLCBkaXJlY3RvcnkpO1xuICAgIHJlc3VsdC5zZXQoZGlyZWN0b3J5LCBsb2FkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudHlwZSBNdXRhYmxlPFQ+ID0geyAtcmVhZG9ubHkgW0sgaW4ga2V5b2YgVF06IE11dGFibGU8VFtLXT4gfTtcbnR5cGUgQXNzZW1ibHlMb2FkZXIgPSAoKSA9PiBQcm9taXNlPE11dGFibGU8QXNzZW1ibHk+PjtcblxuZnVuY3Rpb24gcHJlZml4RGlzY2xhaW1lcih0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24pOiBzdHJpbmcge1xuICBjb25zdCBjb21tZW50ID0gY29tbWVudFRva2VuKCk7XG4gIGNvbnN0IGRpc2NsYWltZXIgPSB0cmFuc2xhdGlvbi5kaWRDb21waWxlXG4gICAgPyAnVGhpcyBleGFtcGxlIHdhcyBhdXRvbWF0aWNhbGx5IHRyYW5zbGl0ZXJhdGVkLidcbiAgICA6ICdUaGlzIGV4YW1wbGUgd2FzIGF1dG9tYXRpY2FsbHkgdHJhbnNsaXRlcmF0ZWQgd2l0aCBpbmNvbXBsZXRlIHR5cGUgaW5mb3JtYXRpb24uIEl0IG1heSBub3Qgd29yayBhcy1pcy4nO1xuXG4gIHJldHVybiBbXG4gICAgYCR7Y29tbWVudH0gJHtkaXNjbGFpbWVyfWAsXG4gICAgYCR7Y29tbWVudH0gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9pc3N1ZXMvODI2IGZvciBtb3JlIGluZm9ybWF0aW9uLmAsXG4gICAgJycsXG4gICAgdHJhbnNsYXRpb24uc291cmNlLFxuICBdLmpvaW4oJ1xcbicpO1xuXG4gIGZ1bmN0aW9uIGNvbW1lbnRUb2tlbigpIHtcbiAgICAvLyBUaGlzIGlzIGZ1dHVyZS1wcm9vZmVkIGEgYml0LCBidXQgZG9uJ3QgcmVhZCB0b28gbXVjaCBpbiB0aGlzLi4uXG4gICAgc3dpdGNoICh0cmFuc2xhdGlvbi5sYW5ndWFnZSkge1xuICAgICAgY2FzZSAncHl0aG9uJzpcbiAgICAgIGNhc2UgJ3J1YnknOlxuICAgICAgICByZXR1cm4gJyMnO1xuICAgICAgY2FzZSAnY3NoYXJwJzpcbiAgICAgIGNhc2UgJ2phdmEnOlxuICAgICAgY2FzZSAnZ28nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICcvLyc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGl0ZXJhdGVUeXBlKFxuICB0eXBlOiBUeXBlLFxuICByb3NldHRhOiBSb3NldHRhVGFibGV0UmVhZGVyLFxuICBsYW5ndWFnZTogVGFyZ2V0TGFuZ3VhZ2UsXG4gIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZyxcbiAgbG9vc2UgPSBmYWxzZSxcbik6IHZvaWQge1xuICB0cmFuc2xpdGVyYXRlRG9jcyh7IGFwaTogJ3R5cGUnLCBmcW46IHR5cGUuZnFuIH0sIHR5cGUuZG9jcywgd29ya2luZ0RpcmVjdG9yeSk7XG4gIHN3aXRjaCAodHlwZS5raW5kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmUgNzAyOVxuICAgIGNhc2UgVHlwZUtpbmQuQ2xhc3M6XG4gICAgICBpZiAodHlwZS5pbml0aWFsaXplcikge1xuICAgICAgICB0cmFuc2xpdGVyYXRlRG9jcyh7IGFwaTogJ2luaXRpYWxpemVyJywgZnFuOiB0eXBlLmZxbiB9LCB0eXBlLmluaXRpYWxpemVyLmRvY3MsIHdvcmtpbmdEaXJlY3RvcnkpO1xuICAgICAgfVxuXG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIFR5cGVLaW5kLkludGVyZmFjZTpcbiAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHR5cGUubWV0aG9kcyA/PyBbXSkge1xuICAgICAgICB0cmFuc2xpdGVyYXRlRG9jcyh7IGFwaTogJ21lbWJlcicsIGZxbjogdHlwZS5mcW4sIG1lbWJlck5hbWU6IG1ldGhvZC5uYW1lIH0sIG1ldGhvZC5kb2NzLCB3b3JraW5nRGlyZWN0b3J5KTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2YgbWV0aG9kLnBhcmFtZXRlcnMgPz8gW10pIHtcbiAgICAgICAgICB0cmFuc2xpdGVyYXRlRG9jcyhcbiAgICAgICAgICAgIHsgYXBpOiAncGFyYW1ldGVyJywgZnFuOiB0eXBlLmZxbiwgbWV0aG9kTmFtZTogbWV0aG9kLm5hbWUsIHBhcmFtZXRlck5hbWU6IHBhcmFtZXRlci5uYW1lIH0sXG4gICAgICAgICAgICBwYXJhbWV0ZXIuZG9jcyxcbiAgICAgICAgICAgIHdvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0eXBlLnByb3BlcnRpZXMgPz8gW10pIHtcbiAgICAgICAgdHJhbnNsaXRlcmF0ZURvY3MoeyBhcGk6ICdtZW1iZXInLCBmcW46IHR5cGUuZnFuLCBtZW1iZXJOYW1lOiBwcm9wZXJ0eS5uYW1lIH0sIHByb3BlcnR5LmRvY3MsIHdvcmtpbmdEaXJlY3RvcnkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFR5cGVLaW5kLkVudW06XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLm1lbWJlcnMpIHtcbiAgICAgICAgdHJhbnNsaXRlcmF0ZURvY3MoeyBhcGk6ICdtZW1iZXInLCBmcW46IHR5cGUuZnFuLCBtZW1iZXJOYW1lOiBtZW1iZXIubmFtZSB9LCBtZW1iZXIuZG9jcywgd29ya2luZ0RpcmVjdG9yeSk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUga2luZDogJHsodHlwZSBhcyBhbnkpLmtpbmR9YCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xpdGVyYXRlRG9jcyhhcGk6IEFwaUxvY2F0aW9uLCBkb2NzOiBEb2NzIHwgdW5kZWZpbmVkLCB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmcpIHtcbiAgICBpZiAoZG9jcz8ucmVtYXJrcykge1xuICAgICAgZG9jcy5yZW1hcmtzID0gcm9zZXR0YS50cmFuc2xhdGVTbmlwcGV0c0luTWFya2Rvd24oXG4gICAgICAgIGFwaSxcbiAgICAgICAgZG9jcy5yZW1hcmtzLFxuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgdHJ1ZSAvKiBzdHJpY3QgKi8sXG4gICAgICAgICh0cmFuc2xhdGlvbikgPT4gKHtcbiAgICAgICAgICBsYW5ndWFnZTogdHJhbnNsYXRpb24ubGFuZ3VhZ2UsXG4gICAgICAgICAgc291cmNlOiBwcmVmaXhEaXNjbGFpbWVyKHRyYW5zbGF0aW9uKSxcbiAgICAgICAgfSksXG4gICAgICAgIHdvcmtpbmdEaXJlY3RvcnksXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChkb2NzPy5leGFtcGxlKSB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHsgYXBpLCBmaWVsZDogeyBmaWVsZDogJ2V4YW1wbGUnIH0gfSBhcyBjb25zdDtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gZm1hcChkb2NzLmN1c3RvbT8uW0VYQU1QTEVfTUVUQURBVEFfSlNET0NUQUddLCBwYXJzZU1ldGFkYXRhTGluZSkgPz8ge307XG4gICAgICBjb25zdCBzbmlwcGV0ID0gZml4dHVyaXplKFxuICAgICAgICB0eXBlU2NyaXB0U25pcHBldEZyb21WaXNpYmxlU291cmNlKGRvY3MuZXhhbXBsZSwgbG9jYXRpb24sIHRydWUgLyogc3RyaWN0ICovLCB7XG4gICAgICAgICAgW1NuaXBwZXRQYXJhbWV0ZXJzLiRQUk9KRUNUX0RJUkVDVE9SWV06IHdvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIH0pLFxuICAgICAgICBsb29zZSxcbiAgICAgICk7XG4gICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHJvc2V0dGEudHJhbnNsYXRlU25pcHBldChzbmlwcGV0LCBsYW5ndWFnZSk7XG4gICAgICBpZiAodHJhbnNsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBkb2NzLmV4YW1wbGUgPSBwcmVmaXhEaXNjbGFpbWVyKHRyYW5zbGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==