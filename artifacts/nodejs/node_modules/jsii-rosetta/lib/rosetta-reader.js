"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rosetta = exports.RosettaTabletReader = exports.UnknownSnippetMode = void 0;
const fs = require("fs-extra");
const path = require("path");
const assemblies_1 = require("./jsii/assemblies");
const logging = require("./logging");
const markdown_1 = require("./markdown/markdown");
const markdown_renderer_1 = require("./markdown/markdown-renderer");
const replace_typescript_transform_1 = require("./markdown/replace-typescript-transform");
const snippet_1 = require("./snippet");
const key_1 = require("./tablets/key");
const tablets_1 = require("./tablets/tablets");
const translate_1 = require("./translate");
const util_1 = require("./util");
var UnknownSnippetMode;
(function (UnknownSnippetMode) {
    /**
     * Return the snippet as given (untranslated)
     */
    UnknownSnippetMode["VERBATIM"] = "verbatim";
    /**
     * Live-translate the snippet as best as we can
     */
    UnknownSnippetMode["TRANSLATE"] = "translate";
    /**
     * Throw an error if this occurs
     */
    UnknownSnippetMode["FAIL"] = "fail";
})(UnknownSnippetMode = exports.UnknownSnippetMode || (exports.UnknownSnippetMode = {}));
/**
 * Entry point class for consumers of Rosetta tablets (primarily: pacmak)
 *
 * Rosetta can work in one of two modes:
 *
 * 1. Live translation of snippets.
 * 2. Read translations from a pre-translated tablet (prepared using `jsii-rosetta extract` command).
 *
 * The second method affords more control over the precise circumstances of
 * sample compilation and is recommended, but the first method will do
 * when the second one is not necessary.
 */
class RosettaTabletReader {
    constructor(options = {}) {
        var _a, _b;
        this.options = options;
        /**
         * Newly translated samples
         *
         * In case live translation has been enabled, all samples that have been translated on-the-fly
         * are added to this tablet.
         */
        this.liveTablet = new tablets_1.LanguageTablet();
        this.loadedTablets = [];
        this.extractedSnippets = new Map();
        this.loose = !!options.loose;
        this.unknownSnippets = (_a = options.unknownSnippets) !== null && _a !== void 0 ? _a : UnknownSnippetMode.VERBATIM;
        this.translator = new translate_1.Translator((_b = options.includeCompilerDiagnostics) !== null && _b !== void 0 ? _b : false);
    }
    /**
     * Diagnostics encountered while doing live translation
     */
    get diagnostics() {
        return this.translator.diagnostics;
    }
    /**
     * Load a tablet as a source for translateable snippets
     *
     * Note: the snippets loaded from this tablet will NOT be validated for
     * their fingerprints or translator versions! If a matching snippet is found
     * in the tablet, it will always be returned, whether or not it is stale.
     */
    async loadTabletFromFile(tabletFile) {
        const tablet = new tablets_1.LanguageTablet();
        await tablet.load(tabletFile);
        this.addTablet(tablet);
    }
    /**
     * Directly add a tablet to the list of tablets to load translations from
     */
    addTablet(tablet) {
        this.loadedTablets.push(tablet);
    }
    /**
     * Add an assembly
     *
     * If a default tablet file is found in the assembly's directory, it will be
     * loaded (and assumed to contain a complete list of translated snippets for
     * this assembly already).
     *
     * Otherwise, if live conversion is enabled, the snippets in the assembly
     * become available for live translation later. This is necessary because we probably
     * need to fixturize snippets for successful compilation, and the information
     * pacmak sends our way later on is not going to be enough to do that.
     */
    async addAssembly(assembly, assemblyDir) {
        const defaultTablet = path.join(assemblyDir, tablets_1.DEFAULT_TABLET_NAME);
        if (await fs.pathExists(defaultTablet)) {
            try {
                await this.loadTabletFromFile(defaultTablet);
                return;
            }
            catch (e) {
                logging.warn(`Error loading ${defaultTablet}: ${e.message}. Skipped.`);
            }
        }
        // Inventarize the snippets from this assembly, but only if there's a chance
        // we're going to need them.
        if (this.unknownSnippets === UnknownSnippetMode.TRANSLATE) {
            for (const tsnip of assemblies_1.allTypeScriptSnippets([{ assembly, directory: assemblyDir }], this.loose)) {
                this.extractedSnippets.set(key_1.snippetKey(tsnip), tsnip);
            }
        }
    }
    /**
     * Translate the given snippet for the given target language
     *
     * This will either:
     *
     * - Find an existing translation in a tablet and return that, if available.
     * - Otherwise, find a fixturized version of this snippet in an assembly that
     *   was loaded beforehand, and translate it on-the-fly. Finding the fixture
     *   will be based on the snippet key, which consists of a hash of the
     *   visible source and the API location.
     * - Otherwise, translate the snippet as-is (without fixture information).
     *
     * This will do and store a full conversion of the given snippet, even if it only
     * returns one language. Subsequent retrievals for the same snippet in other
     * languages will reuse the translation from cache.
     *
     * If you are calling this for the side effect of adding translations to the live
     * tablet, you only need to do that for one language.
     */
    translateSnippet(source, targetLang) {
        // Look for it in loaded tablets (or previous conversions)
        for (const tab of this.allTablets) {
            const ret = tab.lookup(source, targetLang);
            if (ret !== undefined) {
                return ret;
            }
        }
        if (this.unknownSnippets === UnknownSnippetMode.VERBATIM) {
            return {
                language: targetLang,
                source: source.visibleSource,
            };
        }
        if (this.unknownSnippets === UnknownSnippetMode.FAIL) {
            const message = [
                'The following snippet was not found in any of the loaded tablets:',
                source.visibleSource,
                `Location: ${JSON.stringify(source.location)}`,
                `Language: ${targetLang}`,
            ].join('\n');
            throw new Error(message);
        }
        if (this.options.targetLanguages && !this.options.targetLanguages.includes(targetLang)) {
            throw new Error(`Rosetta configured for live conversion to ${this.options.targetLanguages.join(', ')}, but requested ${targetLang}`);
        }
        // See if we can find a fixturized version of this snippet. If so, use that do the live
        // conversion.
        const extracted = this.extractedSnippets.get(key_1.snippetKey(source));
        if (extracted !== undefined) {
            const snippet = this.translator.translate(extracted, this.options.targetLanguages);
            this.liveTablet.addSnippet(snippet);
            return snippet.get(targetLang);
        }
        // Try to live-convert it as-is.
        const snippet = this.translator.translate(source, this.options.targetLanguages);
        this.liveTablet.addSnippet(snippet);
        return snippet.get(targetLang);
    }
    /**
     * Translate a snippet found in the "@ example" section of a jsii assembly
     *
     * Behaves exactly like `translateSnippet`, so see that method for documentation.
     */
    translateExample(apiLocation, example, targetLang, strict, compileDirectory = process.cwd()) {
        const location = { api: apiLocation, field: { field: 'example' } };
        const snippet = snippet_1.typeScriptSnippetFromSource(example, location, strict, {
            [snippet_1.SnippetParameters.$COMPILATION_DIRECTORY]: compileDirectory,
        });
        const translated = this.translateSnippet(snippet, targetLang);
        return translated !== null && translated !== void 0 ? translated : { language: 'typescript', source: example };
    }
    /**
     * Translate all TypeScript snippets found in a block of Markdown text
     *
     * For each snippet, behaves exactly like `translateSnippet`, so see that
     * method for documentation.
     */
    translateSnippetsInMarkdown(apiLocation, markdown, targetLang, strict, translationToCodeBlock = id, compileDirectory = process.cwd()) {
        return markdown_1.transformMarkdown(markdown, new markdown_renderer_1.MarkdownRenderer(), new replace_typescript_transform_1.ReplaceTypeScriptTransform(apiLocation, strict, (tsSnip) => {
            const translated = this.translateSnippet(snippet_1.updateParameters(tsSnip, {
                [snippet_1.SnippetParameters.$COMPILATION_DIRECTORY]: compileDirectory,
            }), targetLang);
            if (!translated) {
                return undefined;
            }
            return translationToCodeBlock(translated);
        }));
    }
    printDiagnostics(stream) {
        util_1.printDiagnostics(this.diagnostics, stream);
    }
    get hasErrors() {
        return this.diagnostics.some((d) => d.isError);
    }
    get allTablets() {
        return [...this.loadedTablets, this.liveTablet];
    }
}
exports.RosettaTabletReader = RosettaTabletReader;
function id(x) {
    return x;
}
/**
 * Backwards compatibility
 *
 * @deprecated use RosettaTabletReader instead
 */
class Rosetta extends RosettaTabletReader {
}
exports.Rosetta = Rosetta;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9zZXR0YS1yZWFkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyb3NldHRhLXJlYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBRTdCLGtEQUEwRDtBQUUxRCxxQ0FBcUM7QUFDckMsa0RBQXdEO0FBQ3hELG9FQUFnRTtBQUNoRSwwRkFBcUY7QUFFckYsdUNBTW1CO0FBQ25CLHVDQUEyQztBQUMzQywrQ0FBcUY7QUFDckYsMkNBQXlDO0FBQ3pDLGlDQUEwQztBQUUxQyxJQUFZLGtCQWVYO0FBZkQsV0FBWSxrQkFBa0I7SUFDNUI7O09BRUc7SUFDSCwyQ0FBcUIsQ0FBQTtJQUVyQjs7T0FFRztJQUNILDZDQUF1QixDQUFBO0lBRXZCOztPQUVHO0lBQ0gsbUNBQWEsQ0FBQTtBQUNmLENBQUMsRUFmVyxrQkFBa0IsR0FBbEIsMEJBQWtCLEtBQWxCLDBCQUFrQixRQWU3QjtBQStCRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQWEsbUJBQW1CO0lBZTlCLFlBQW9DLFVBQTBCLEVBQUU7O1FBQTVCLFlBQU8sR0FBUCxPQUFPLENBQXFCO1FBZGhFOzs7OztXQUtHO1FBQ2EsZUFBVSxHQUFHLElBQUksd0JBQWMsRUFBRSxDQUFDO1FBRWpDLGtCQUFhLEdBQXFCLEVBQUUsQ0FBQztRQUNyQyxzQkFBaUIsR0FBRyxJQUFJLEdBQUcsRUFBNkIsQ0FBQztRQU14RSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBQzdCLElBQUksQ0FBQyxlQUFlLFNBQUcsT0FBTyxDQUFDLGVBQWUsbUNBQUksa0JBQWtCLENBQUMsUUFBUSxDQUFDO1FBQzlFLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxzQkFBVSxPQUFDLE9BQU8sQ0FBQywwQkFBMEIsbUNBQUksS0FBSyxDQUFDLENBQUM7SUFDaEYsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxXQUFXO1FBQ3BCLE9B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akQsQ0FBQztJQUVELElBQVksVUFBVTtRQUNwQixPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNsRCxDQUFDO0NBQ0Y7QUF2TkQsa0RBdU5DO0FBRUQsU0FBUyxFQUFFLENBQUMsQ0FBYztJQUN4QixPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBYSxPQUFRLFNBQVEsbUJBQW1CO0NBQUc7QUFBbkQsMEJBQW1EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3BlYyBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IGFsbFR5cGVTY3JpcHRTbmlwcGV0cyB9IGZyb20gJy4vanNpaS9hc3NlbWJsaWVzJztcbmltcG9ydCB7IFRhcmdldExhbmd1YWdlIH0gZnJvbSAnLi9sYW5ndWFnZXMnO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICcuL2xvZ2dpbmcnO1xuaW1wb3J0IHsgdHJhbnNmb3JtTWFya2Rvd24gfSBmcm9tICcuL21hcmtkb3duL21hcmtkb3duJztcbmltcG9ydCB7IE1hcmtkb3duUmVuZGVyZXIgfSBmcm9tICcuL21hcmtkb3duL21hcmtkb3duLXJlbmRlcmVyJztcbmltcG9ydCB7IFJlcGxhY2VUeXBlU2NyaXB0VHJhbnNmb3JtIH0gZnJvbSAnLi9tYXJrZG93bi9yZXBsYWNlLXR5cGVzY3JpcHQtdHJhbnNmb3JtJztcbmltcG9ydCB7IENvZGVCbG9jayB9IGZyb20gJy4vbWFya2Rvd24vdHlwZXMnO1xuaW1wb3J0IHtcbiAgU25pcHBldFBhcmFtZXRlcnMsXG4gIFR5cGVTY3JpcHRTbmlwcGV0LFxuICB1cGRhdGVQYXJhbWV0ZXJzLFxuICBBcGlMb2NhdGlvbixcbiAgdHlwZVNjcmlwdFNuaXBwZXRGcm9tU291cmNlLFxufSBmcm9tICcuL3NuaXBwZXQnO1xuaW1wb3J0IHsgc25pcHBldEtleSB9IGZyb20gJy4vdGFibGV0cy9rZXknO1xuaW1wb3J0IHsgREVGQVVMVF9UQUJMRVRfTkFNRSwgTGFuZ3VhZ2VUYWJsZXQsIFRyYW5zbGF0aW9uIH0gZnJvbSAnLi90YWJsZXRzL3RhYmxldHMnO1xuaW1wb3J0IHsgVHJhbnNsYXRvciB9IGZyb20gJy4vdHJhbnNsYXRlJztcbmltcG9ydCB7IHByaW50RGlhZ25vc3RpY3MgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZW51bSBVbmtub3duU25pcHBldE1vZGUge1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBzbmlwcGV0IGFzIGdpdmVuICh1bnRyYW5zbGF0ZWQpXG4gICAqL1xuICBWRVJCQVRJTSA9ICd2ZXJiYXRpbScsXG5cbiAgLyoqXG4gICAqIExpdmUtdHJhbnNsYXRlIHRoZSBzbmlwcGV0IGFzIGJlc3QgYXMgd2UgY2FuXG4gICAqL1xuICBUUkFOU0xBVEUgPSAndHJhbnNsYXRlJyxcblxuICAvKipcbiAgICogVGhyb3cgYW4gZXJyb3IgaWYgdGhpcyBvY2N1cnNcbiAgICovXG4gIEZBSUwgPSAnZmFpbCcsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm9zZXR0YU9wdGlvbnMge1xuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gbGl2ZS1jb252ZXJ0IHNhbXBsZXNcbiAgICpcbiAgICogQGRlZmF1bHQgVW5rbm93blNuaXBwZXRNb2RlLlZFUkJBVElNXG4gICAqL1xuICByZWFkb25seSB1bmtub3duU25pcHBldHM/OiBVbmtub3duU25pcHBldE1vZGU7XG5cbiAgLyoqXG4gICAqIFRhcmdldCBsYW5ndWFnZXMgdG8gdXNlIGZvciBsaXZlIGNvbnZlcnNpb25cbiAgICpcbiAgICogQGRlZmF1bHQgQWxsIGxhbmd1YWdlc1xuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0TGFuZ3VhZ2VzPzogcmVhZG9ubHkgVGFyZ2V0TGFuZ3VhZ2VbXTtcblxuICAvKipcbiAgICogV2hldGhlciB0byBpbmNsdWRlIGNvbXBpbGVyIGRpYWdub3N0aWNzIGluIHRoZSBjb21waWxhdGlvbiByZXN1bHRzLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3M/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgUm9zZXR0YSBzaG91bGQgb3BlcmF0ZSBpbiBcImxvb3NlXCIgbW9kZSwgd2hlcmUgbWlzc2luZyBsaXRlcmF0ZVxuICAgKiBzb3VyY2UgZmlsZXMgYW5kIG1pc3NpbmcgZml4dHVyZXMgYXJlIGlnbm9yZWQgaW5zdGVhZCBvZiBmYWlsaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgbG9vc2U/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEVudHJ5IHBvaW50IGNsYXNzIGZvciBjb25zdW1lcnMgb2YgUm9zZXR0YSB0YWJsZXRzIChwcmltYXJpbHk6IHBhY21haylcbiAqXG4gKiBSb3NldHRhIGNhbiB3b3JrIGluIG9uZSBvZiB0d28gbW9kZXM6XG4gKlxuICogMS4gTGl2ZSB0cmFuc2xhdGlvbiBvZiBzbmlwcGV0cy5cbiAqIDIuIFJlYWQgdHJhbnNsYXRpb25zIGZyb20gYSBwcmUtdHJhbnNsYXRlZCB0YWJsZXQgKHByZXBhcmVkIHVzaW5nIGBqc2lpLXJvc2V0dGEgZXh0cmFjdGAgY29tbWFuZCkuXG4gKlxuICogVGhlIHNlY29uZCBtZXRob2QgYWZmb3JkcyBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgcHJlY2lzZSBjaXJjdW1zdGFuY2VzIG9mXG4gKiBzYW1wbGUgY29tcGlsYXRpb24gYW5kIGlzIHJlY29tbWVuZGVkLCBidXQgdGhlIGZpcnN0IG1ldGhvZCB3aWxsIGRvXG4gKiB3aGVuIHRoZSBzZWNvbmQgb25lIGlzIG5vdCBuZWNlc3NhcnkuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb3NldHRhVGFibGV0UmVhZGVyIHtcbiAgLyoqXG4gICAqIE5ld2x5IHRyYW5zbGF0ZWQgc2FtcGxlc1xuICAgKlxuICAgKiBJbiBjYXNlIGxpdmUgdHJhbnNsYXRpb24gaGFzIGJlZW4gZW5hYmxlZCwgYWxsIHNhbXBsZXMgdGhhdCBoYXZlIGJlZW4gdHJhbnNsYXRlZCBvbi10aGUtZmx5XG4gICAqIGFyZSBhZGRlZCB0byB0aGlzIHRhYmxldC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBsaXZlVGFibGV0ID0gbmV3IExhbmd1YWdlVGFibGV0KCk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBsb2FkZWRUYWJsZXRzOiBMYW5ndWFnZVRhYmxldFtdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgZXh0cmFjdGVkU25pcHBldHMgPSBuZXcgTWFwPHN0cmluZywgVHlwZVNjcmlwdFNuaXBwZXQ+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgdHJhbnNsYXRvcjogVHJhbnNsYXRvcjtcbiAgcHJpdmF0ZSByZWFkb25seSBsb29zZTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSB1bmtub3duU25pcHBldHM6IFVua25vd25TbmlwcGV0TW9kZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBSb3NldHRhT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZTtcbiAgICB0aGlzLnVua25vd25TbmlwcGV0cyA9IG9wdGlvbnMudW5rbm93blNuaXBwZXRzID8/IFVua25vd25TbmlwcGV0TW9kZS5WRVJCQVRJTTtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihvcHRpb25zLmluY2x1ZGVDb21waWxlckRpYWdub3N0aWNzID8/IGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWFnbm9zdGljcyBlbmNvdW50ZXJlZCB3aGlsZSBkb2luZyBsaXZlIHRyYW5zbGF0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRpYWdub3N0aWNzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0b3IuZGlhZ25vc3RpY3M7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIHRhYmxldCBhcyBhIHNvdXJjZSBmb3IgdHJhbnNsYXRlYWJsZSBzbmlwcGV0c1xuICAgKlxuICAgKiBOb3RlOiB0aGUgc25pcHBldHMgbG9hZGVkIGZyb20gdGhpcyB0YWJsZXQgd2lsbCBOT1QgYmUgdmFsaWRhdGVkIGZvclxuICAgKiB0aGVpciBmaW5nZXJwcmludHMgb3IgdHJhbnNsYXRvciB2ZXJzaW9ucyEgSWYgYSBtYXRjaGluZyBzbmlwcGV0IGlzIGZvdW5kXG4gICAqIGluIHRoZSB0YWJsZXQsIGl0IHdpbGwgYWx3YXlzIGJlIHJldHVybmVkLCB3aGV0aGVyIG9yIG5vdCBpdCBpcyBzdGFsZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsb2FkVGFibGV0RnJvbUZpbGUodGFibGV0RmlsZTogc3RyaW5nKSB7XG4gICAgY29uc3QgdGFibGV0ID0gbmV3IExhbmd1YWdlVGFibGV0KCk7XG4gICAgYXdhaXQgdGFibGV0LmxvYWQodGFibGV0RmlsZSk7XG4gICAgdGhpcy5hZGRUYWJsZXQodGFibGV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXJlY3RseSBhZGQgYSB0YWJsZXQgdG8gdGhlIGxpc3Qgb2YgdGFibGV0cyB0byBsb2FkIHRyYW5zbGF0aW9ucyBmcm9tXG4gICAqL1xuICBwdWJsaWMgYWRkVGFibGV0KHRhYmxldDogTGFuZ3VhZ2VUYWJsZXQpIHtcbiAgICB0aGlzLmxvYWRlZFRhYmxldHMucHVzaCh0YWJsZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBhc3NlbWJseVxuICAgKlxuICAgKiBJZiBhIGRlZmF1bHQgdGFibGV0IGZpbGUgaXMgZm91bmQgaW4gdGhlIGFzc2VtYmx5J3MgZGlyZWN0b3J5LCBpdCB3aWxsIGJlXG4gICAqIGxvYWRlZCAoYW5kIGFzc3VtZWQgdG8gY29udGFpbiBhIGNvbXBsZXRlIGxpc3Qgb2YgdHJhbnNsYXRlZCBzbmlwcGV0cyBmb3JcbiAgICogdGhpcyBhc3NlbWJseSBhbHJlYWR5KS5cbiAgICpcbiAgICogT3RoZXJ3aXNlLCBpZiBsaXZlIGNvbnZlcnNpb24gaXMgZW5hYmxlZCwgdGhlIHNuaXBwZXRzIGluIHRoZSBhc3NlbWJseVxuICAgKiBiZWNvbWUgYXZhaWxhYmxlIGZvciBsaXZlIHRyYW5zbGF0aW9uIGxhdGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIHByb2JhYmx5XG4gICAqIG5lZWQgdG8gZml4dHVyaXplIHNuaXBwZXRzIGZvciBzdWNjZXNzZnVsIGNvbXBpbGF0aW9uLCBhbmQgdGhlIGluZm9ybWF0aW9uXG4gICAqIHBhY21hayBzZW5kcyBvdXIgd2F5IGxhdGVyIG9uIGlzIG5vdCBnb2luZyB0byBiZSBlbm91Z2ggdG8gZG8gdGhhdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBhZGRBc3NlbWJseShhc3NlbWJseTogc3BlYy5Bc3NlbWJseSwgYXNzZW1ibHlEaXI6IHN0cmluZykge1xuICAgIGNvbnN0IGRlZmF1bHRUYWJsZXQgPSBwYXRoLmpvaW4oYXNzZW1ibHlEaXIsIERFRkFVTFRfVEFCTEVUX05BTUUpO1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGRlZmF1bHRUYWJsZXQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRUYWJsZXRGcm9tRmlsZShkZWZhdWx0VGFibGV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnaW5nLndhcm4oYEVycm9yIGxvYWRpbmcgJHtkZWZhdWx0VGFibGV0fTogJHtlLm1lc3NhZ2V9LiBTa2lwcGVkLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEludmVudGFyaXplIHRoZSBzbmlwcGV0cyBmcm9tIHRoaXMgYXNzZW1ibHksIGJ1dCBvbmx5IGlmIHRoZXJlJ3MgYSBjaGFuY2VcbiAgICAvLyB3ZSdyZSBnb2luZyB0byBuZWVkIHRoZW0uXG4gICAgaWYgKHRoaXMudW5rbm93blNuaXBwZXRzID09PSBVbmtub3duU25pcHBldE1vZGUuVFJBTlNMQVRFKSB7XG4gICAgICBmb3IgKGNvbnN0IHRzbmlwIG9mIGFsbFR5cGVTY3JpcHRTbmlwcGV0cyhbeyBhc3NlbWJseSwgZGlyZWN0b3J5OiBhc3NlbWJseURpciB9XSwgdGhpcy5sb29zZSkpIHtcbiAgICAgICAgdGhpcy5leHRyYWN0ZWRTbmlwcGV0cy5zZXQoc25pcHBldEtleSh0c25pcCksIHRzbmlwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIHRoZSBnaXZlbiBzbmlwcGV0IGZvciB0aGUgZ2l2ZW4gdGFyZ2V0IGxhbmd1YWdlXG4gICAqXG4gICAqIFRoaXMgd2lsbCBlaXRoZXI6XG4gICAqXG4gICAqIC0gRmluZCBhbiBleGlzdGluZyB0cmFuc2xhdGlvbiBpbiBhIHRhYmxldCBhbmQgcmV0dXJuIHRoYXQsIGlmIGF2YWlsYWJsZS5cbiAgICogLSBPdGhlcndpc2UsIGZpbmQgYSBmaXh0dXJpemVkIHZlcnNpb24gb2YgdGhpcyBzbmlwcGV0IGluIGFuIGFzc2VtYmx5IHRoYXRcbiAgICogICB3YXMgbG9hZGVkIGJlZm9yZWhhbmQsIGFuZCB0cmFuc2xhdGUgaXQgb24tdGhlLWZseS4gRmluZGluZyB0aGUgZml4dHVyZVxuICAgKiAgIHdpbGwgYmUgYmFzZWQgb24gdGhlIHNuaXBwZXQga2V5LCB3aGljaCBjb25zaXN0cyBvZiBhIGhhc2ggb2YgdGhlXG4gICAqICAgdmlzaWJsZSBzb3VyY2UgYW5kIHRoZSBBUEkgbG9jYXRpb24uXG4gICAqIC0gT3RoZXJ3aXNlLCB0cmFuc2xhdGUgdGhlIHNuaXBwZXQgYXMtaXMgKHdpdGhvdXQgZml4dHVyZSBpbmZvcm1hdGlvbikuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBkbyBhbmQgc3RvcmUgYSBmdWxsIGNvbnZlcnNpb24gb2YgdGhlIGdpdmVuIHNuaXBwZXQsIGV2ZW4gaWYgaXQgb25seVxuICAgKiByZXR1cm5zIG9uZSBsYW5ndWFnZS4gU3Vic2VxdWVudCByZXRyaWV2YWxzIGZvciB0aGUgc2FtZSBzbmlwcGV0IGluIG90aGVyXG4gICAqIGxhbmd1YWdlcyB3aWxsIHJldXNlIHRoZSB0cmFuc2xhdGlvbiBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBJZiB5b3UgYXJlIGNhbGxpbmcgdGhpcyBmb3IgdGhlIHNpZGUgZWZmZWN0IG9mIGFkZGluZyB0cmFuc2xhdGlvbnMgdG8gdGhlIGxpdmVcbiAgICogdGFibGV0LCB5b3Ugb25seSBuZWVkIHRvIGRvIHRoYXQgZm9yIG9uZSBsYW5ndWFnZS5cbiAgICovXG4gIHB1YmxpYyB0cmFuc2xhdGVTbmlwcGV0KHNvdXJjZTogVHlwZVNjcmlwdFNuaXBwZXQsIHRhcmdldExhbmc6IFRhcmdldExhbmd1YWdlKTogVHJhbnNsYXRpb24gfCB1bmRlZmluZWQge1xuICAgIC8vIExvb2sgZm9yIGl0IGluIGxvYWRlZCB0YWJsZXRzIChvciBwcmV2aW91cyBjb252ZXJzaW9ucylcbiAgICBmb3IgKGNvbnN0IHRhYiBvZiB0aGlzLmFsbFRhYmxldHMpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRhYi5sb29rdXAoc291cmNlLCB0YXJnZXRMYW5nKTtcbiAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnVua25vd25TbmlwcGV0cyA9PT0gVW5rbm93blNuaXBwZXRNb2RlLlZFUkJBVElNKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYW5ndWFnZTogdGFyZ2V0TGFuZyxcbiAgICAgICAgc291cmNlOiBzb3VyY2UudmlzaWJsZVNvdXJjZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudW5rbm93blNuaXBwZXRzID09PSBVbmtub3duU25pcHBldE1vZGUuRkFJTCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgJ1RoZSBmb2xsb3dpbmcgc25pcHBldCB3YXMgbm90IGZvdW5kIGluIGFueSBvZiB0aGUgbG9hZGVkIHRhYmxldHM6JyxcbiAgICAgICAgc291cmNlLnZpc2libGVTb3VyY2UsXG4gICAgICAgIGBMb2NhdGlvbjogJHtKU09OLnN0cmluZ2lmeShzb3VyY2UubG9jYXRpb24pfWAsXG4gICAgICAgIGBMYW5ndWFnZTogJHt0YXJnZXRMYW5nfWAsXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2VzICYmICF0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2VzLmluY2x1ZGVzKHRhcmdldExhbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBSb3NldHRhIGNvbmZpZ3VyZWQgZm9yIGxpdmUgY29udmVyc2lvbiB0byAke3RoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZXMuam9pbihcbiAgICAgICAgICAnLCAnLFxuICAgICAgICApfSwgYnV0IHJlcXVlc3RlZCAke3RhcmdldExhbmd9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gU2VlIGlmIHdlIGNhbiBmaW5kIGEgZml4dHVyaXplZCB2ZXJzaW9uIG9mIHRoaXMgc25pcHBldC4gSWYgc28sIHVzZSB0aGF0IGRvIHRoZSBsaXZlXG4gICAgLy8gY29udmVyc2lvbi5cbiAgICBjb25zdCBleHRyYWN0ZWQgPSB0aGlzLmV4dHJhY3RlZFNuaXBwZXRzLmdldChzbmlwcGV0S2V5KHNvdXJjZSkpO1xuICAgIGlmIChleHRyYWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgc25pcHBldCA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUoZXh0cmFjdGVkLCB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2VzKTtcbiAgICAgIHRoaXMubGl2ZVRhYmxldC5hZGRTbmlwcGV0KHNuaXBwZXQpO1xuICAgICAgcmV0dXJuIHNuaXBwZXQuZ2V0KHRhcmdldExhbmcpO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBsaXZlLWNvbnZlcnQgaXQgYXMtaXMuXG4gICAgY29uc3Qgc25pcHBldCA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUoc291cmNlLCB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2VzKTtcbiAgICB0aGlzLmxpdmVUYWJsZXQuYWRkU25pcHBldChzbmlwcGV0KTtcbiAgICByZXR1cm4gc25pcHBldC5nZXQodGFyZ2V0TGFuZyk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIGEgc25pcHBldCBmb3VuZCBpbiB0aGUgXCJAIGV4YW1wbGVcIiBzZWN0aW9uIG9mIGEganNpaSBhc3NlbWJseVxuICAgKlxuICAgKiBCZWhhdmVzIGV4YWN0bHkgbGlrZSBgdHJhbnNsYXRlU25pcHBldGAsIHNvIHNlZSB0aGF0IG1ldGhvZCBmb3IgZG9jdW1lbnRhdGlvbi5cbiAgICovXG4gIHB1YmxpYyB0cmFuc2xhdGVFeGFtcGxlKFxuICAgIGFwaUxvY2F0aW9uOiBBcGlMb2NhdGlvbixcbiAgICBleGFtcGxlOiBzdHJpbmcsXG4gICAgdGFyZ2V0TGFuZzogVGFyZ2V0TGFuZ3VhZ2UsXG4gICAgc3RyaWN0OiBib29sZWFuLFxuICAgIGNvbXBpbGVEaXJlY3RvcnkgPSBwcm9jZXNzLmN3ZCgpLFxuICApOiBUcmFuc2xhdGlvbiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSB7IGFwaTogYXBpTG9jYXRpb24sIGZpZWxkOiB7IGZpZWxkOiAnZXhhbXBsZScgfSB9IGFzIGNvbnN0O1xuXG4gICAgY29uc3Qgc25pcHBldCA9IHR5cGVTY3JpcHRTbmlwcGV0RnJvbVNvdXJjZShleGFtcGxlLCBsb2NhdGlvbiwgc3RyaWN0LCB7XG4gICAgICBbU25pcHBldFBhcmFtZXRlcnMuJENPTVBJTEFUSU9OX0RJUkVDVE9SWV06IGNvbXBpbGVEaXJlY3RvcnksXG4gICAgfSk7XG5cbiAgICBjb25zdCB0cmFuc2xhdGVkID0gdGhpcy50cmFuc2xhdGVTbmlwcGV0KHNuaXBwZXQsIHRhcmdldExhbmcpO1xuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZWQgPz8geyBsYW5ndWFnZTogJ3R5cGVzY3JpcHQnLCBzb3VyY2U6IGV4YW1wbGUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYWxsIFR5cGVTY3JpcHQgc25pcHBldHMgZm91bmQgaW4gYSBibG9jayBvZiBNYXJrZG93biB0ZXh0XG4gICAqXG4gICAqIEZvciBlYWNoIHNuaXBwZXQsIGJlaGF2ZXMgZXhhY3RseSBsaWtlIGB0cmFuc2xhdGVTbmlwcGV0YCwgc28gc2VlIHRoYXRcbiAgICogbWV0aG9kIGZvciBkb2N1bWVudGF0aW9uLlxuICAgKi9cbiAgcHVibGljIHRyYW5zbGF0ZVNuaXBwZXRzSW5NYXJrZG93bihcbiAgICBhcGlMb2NhdGlvbjogQXBpTG9jYXRpb24sXG4gICAgbWFya2Rvd246IHN0cmluZyxcbiAgICB0YXJnZXRMYW5nOiBUYXJnZXRMYW5ndWFnZSxcbiAgICBzdHJpY3Q6IGJvb2xlYW4sXG4gICAgdHJhbnNsYXRpb25Ub0NvZGVCbG9jazogKHg6IFRyYW5zbGF0aW9uKSA9PiBDb2RlQmxvY2sgPSBpZCxcbiAgICBjb21waWxlRGlyZWN0b3J5ID0gcHJvY2Vzcy5jd2QoKSxcbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtTWFya2Rvd24oXG4gICAgICBtYXJrZG93bixcbiAgICAgIG5ldyBNYXJrZG93blJlbmRlcmVyKCksXG4gICAgICBuZXcgUmVwbGFjZVR5cGVTY3JpcHRUcmFuc2Zvcm0oYXBpTG9jYXRpb24sIHN0cmljdCwgKHRzU25pcCkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2xhdGVkID0gdGhpcy50cmFuc2xhdGVTbmlwcGV0KFxuICAgICAgICAgIHVwZGF0ZVBhcmFtZXRlcnModHNTbmlwLCB7XG4gICAgICAgICAgICBbU25pcHBldFBhcmFtZXRlcnMuJENPTVBJTEFUSU9OX0RJUkVDVE9SWV06IGNvbXBpbGVEaXJlY3RvcnksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGFyZ2V0TGFuZyxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0cmFuc2xhdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvblRvQ29kZUJsb2NrKHRyYW5zbGF0ZWQpO1xuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBwcmludERpYWdub3N0aWNzKHN0cmVhbTogTm9kZUpTLldyaXRhYmxlU3RyZWFtKSB7XG4gICAgcHJpbnREaWFnbm9zdGljcyh0aGlzLmRpYWdub3N0aWNzLCBzdHJlYW0pO1xuICB9XG5cbiAgcHVibGljIGdldCBoYXNFcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlhZ25vc3RpY3Muc29tZSgoZCkgPT4gZC5pc0Vycm9yKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGFsbFRhYmxldHMoKTogTGFuZ3VhZ2VUYWJsZXRbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmxvYWRlZFRhYmxldHMsIHRoaXMubGl2ZVRhYmxldF07XG4gIH1cbn1cblxuZnVuY3Rpb24gaWQoeDogVHJhbnNsYXRpb24pIHtcbiAgcmV0dXJuIHg7XG59XG5cbi8qKlxuICogQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgUm9zZXR0YVRhYmxldFJlYWRlciBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBjbGFzcyBSb3NldHRhIGV4dGVuZHMgUm9zZXR0YVRhYmxldFJlYWRlciB7fVxuIl19