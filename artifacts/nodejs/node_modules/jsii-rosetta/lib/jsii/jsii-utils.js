"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.namespaceName = exports.simpleName = exports.parentSymbol = exports.resolvedSymbolAtLocation = exports.resolveEnumLiteral = exports.lookupJsiiSymbol = exports.lookupJsiiSymbolFromNode = exports.structPropertyAcceptsUndefined = exports.propertiesOfStruct = exports.hasAnyFlag = exports.hasAllFlags = exports.analyzeStructType = exports.isNamedLikeStruct = void 0;
const jsii_1 = require("jsii");
const ts = require("typescript");
const types_1 = require("../typescript/types");
const util_1 = require("../util");
const assemblies_1 = require("./assemblies");
function isNamedLikeStruct(name) {
    // Start with an I and another uppercase character
    return !/^I[A-Z]/.test(name);
}
exports.isNamedLikeStruct = isNamedLikeStruct;
function analyzeStructType(typeChecker, type) {
    if (!type.isClassOrInterface() ||
        !hasAllFlags(type.objectFlags, ts.ObjectFlags.Interface) ||
        !isNamedLikeStruct(type.symbol.name)) {
        return false;
    }
    const jsiiSym = lookupJsiiSymbol(typeChecker, type.symbol);
    if (jsiiSym) {
        return { kind: 'struct', type, jsiiSym };
    }
    return { kind: 'local-struct', type };
}
exports.analyzeStructType = analyzeStructType;
function hasAllFlags(flags, test) {
    // tslint:disable-next-line:no-bitwise
    return test !== 0 && (flags & test) === test;
}
exports.hasAllFlags = hasAllFlags;
function hasAnyFlag(flags, test) {
    // tslint:disable-next-line:no-bitwise
    return test !== 0 && (flags & test) !== 0;
}
exports.hasAnyFlag = hasAnyFlag;
function propertiesOfStruct(type, context) {
    return type.isClassOrInterface()
        ? type.getProperties().map((s) => {
            let propType;
            let questionMark = false;
            const propSymbol = type.getProperty(s.name);
            const symbolDecl = propSymbol.valueDeclaration;
            if (ts.isPropertyDeclaration(symbolDecl) || ts.isPropertySignature(symbolDecl)) {
                questionMark = symbolDecl.questionToken !== undefined;
                propType = symbolDecl.type && context.typeOfType(symbolDecl.type);
            }
            return {
                name: s.name,
                type: propType,
                questionMark,
            };
        })
        : [];
}
exports.propertiesOfStruct = propertiesOfStruct;
function structPropertyAcceptsUndefined(prop) {
    return prop.questionMark || (!!prop.type && types_1.typeContainsUndefined(prop.type));
}
exports.structPropertyAcceptsUndefined = structPropertyAcceptsUndefined;
function lookupJsiiSymbolFromNode(typeChecker, node) {
    return util_1.fmap(typeChecker.getSymbolAtLocation(node), (s) => lookupJsiiSymbol(typeChecker, s));
}
exports.lookupJsiiSymbolFromNode = lookupJsiiSymbolFromNode;
/**
 * Returns the jsii FQN for a TypeScript (class or type) symbol
 *
 * TypeScript only knows the symbol NAME plus the FILE the symbol is defined
 * in. We need to extract two things:
 *
 * 1. The package name (extracted from the nearest `package.json`)
 * 2. The submodule name (...?? don't know how to get this yet)
 * 3. Any containing type names or namespace names.
 *
 * For tests, we also treat symbols in a file that has the string '/// fake-from-jsii'
 * as coming from jsii.
 */
function lookupJsiiSymbol(typeChecker, sym) {
    var _a;
    // Resolve alias, if it is one. This comes into play if the symbol refers to a module,
    // we need to resolve the alias to find the ACTUAL module.
    if (hasAnyFlag(sym.flags, ts.SymbolFlags.Alias)) {
        sym = typeChecker.getAliasedSymbol(sym);
    }
    const decl = (_a = sym.declarations) === null || _a === void 0 ? void 0 : _a[0];
    if (!decl) {
        return undefined;
    }
    if (ts.isSourceFile(decl)) {
        // This is a module.
        const sourceAssembly = assemblies_1.findTypeLookupAssembly(decl.fileName);
        return util_1.fmap(sourceAssembly, (asm) => {
            var _a;
            return ({
                fqn: (_a = util_1.fmap(jsii_1.symbolIdentifier(typeChecker, sym, util_1.fmap(sourceAssembly, (sa) => ({ assembly: sa.assembly }))), (symbolId) => sourceAssembly === null || sourceAssembly === void 0 ? void 0 : sourceAssembly.symbolIdMap[symbolId])) !== null && _a !== void 0 ? _a : sourceAssembly === null || sourceAssembly === void 0 ? void 0 : sourceAssembly.assembly.name,
                sourceAssembly: asm,
                symbolType: 'module',
            });
        });
    }
    if (!isDeclaration(decl)) {
        return undefined;
    }
    const declaringFile = decl.getSourceFile();
    if (/^\/\/\/ fake-from-jsii/m.test(declaringFile.getFullText())) {
        return { fqn: `fake_jsii.${sym.name}`, symbolType: 'type' };
    }
    const declSym = getSymbolFromDeclaration(decl, typeChecker);
    if (!declSym) {
        return undefined;
    }
    const fileName = decl.getSourceFile().fileName;
    const sourceAssembly = assemblies_1.findTypeLookupAssembly(fileName);
    const symbolId = jsii_1.symbolIdentifier(typeChecker, declSym, { assembly: sourceAssembly === null || sourceAssembly === void 0 ? void 0 : sourceAssembly.assembly });
    if (!symbolId) {
        return undefined;
    }
    return util_1.fmap(/([^#]*)(#.*)?/.exec(symbolId), ([, typeSymbolId, memberFragment]) => {
        if (memberFragment) {
            return util_1.fmap(sourceAssembly === null || sourceAssembly === void 0 ? void 0 : sourceAssembly.symbolIdMap[typeSymbolId], (fqn) => ({
                fqn: `${fqn}${memberFragment}`,
                sourceAssembly,
                symbolType: 'member',
            }));
        }
        return util_1.fmap(sourceAssembly === null || sourceAssembly === void 0 ? void 0 : sourceAssembly.symbolIdMap[typeSymbolId], (fqn) => ({ fqn, sourceAssembly, symbolType: 'type' }));
    });
}
exports.lookupJsiiSymbol = lookupJsiiSymbol;
function isDeclaration(x) {
    return (ts.isClassDeclaration(x) ||
        ts.isNamespaceExportDeclaration(x) ||
        ts.isNamespaceExport(x) ||
        ts.isModuleDeclaration(x) ||
        ts.isEnumDeclaration(x) ||
        ts.isEnumMember(x) ||
        ts.isInterfaceDeclaration(x) ||
        ts.isMethodDeclaration(x) ||
        ts.isMethodSignature(x) ||
        ts.isPropertyDeclaration(x) ||
        ts.isPropertySignature(x));
}
/**
 * If the given type is an enum literal, resolve to the enum type
 */
function resolveEnumLiteral(typeChecker, type) {
    if (!hasAnyFlag(type.flags, ts.TypeFlags.EnumLiteral)) {
        return type;
    }
    return typeChecker.getBaseTypeOfLiteralType(type);
}
exports.resolveEnumLiteral = resolveEnumLiteral;
function resolvedSymbolAtLocation(typeChecker, node) {
    let symbol = typeChecker.getSymbolAtLocation(node);
    while (symbol && hasAnyFlag(symbol.flags, ts.SymbolFlags.Alias)) {
        symbol = typeChecker.getAliasedSymbol(symbol);
    }
    return symbol;
}
exports.resolvedSymbolAtLocation = resolvedSymbolAtLocation;
function getSymbolFromDeclaration(decl, typeChecker) {
    if (!isDeclaration(decl)) {
        return undefined;
    }
    const name = ts.getNameOfDeclaration(decl);
    return name ? typeChecker.getSymbolAtLocation(name) : undefined;
}
function parentSymbol(sym) {
    const parts = sym.fqn.split('.');
    if (parts.length === 1) {
        return undefined;
    }
    return {
        fqn: parts.slice(0, -1).join('.'),
        symbolType: 'module',
        sourceAssembly: sym.sourceAssembly,
    };
}
exports.parentSymbol = parentSymbol;
/**
 * Get the last part of a dot-separated string
 */
function simpleName(x) {
    return x.split('.').slice(-1)[0];
}
exports.simpleName = simpleName;
/**
 * Get all parts except the last of a dot-separated string
 */
function namespaceName(x) {
    return x.split('.').slice(0, -1).join('.');
}
exports.namespaceName = namespaceName;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNpaS11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImpzaWktdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0JBQXdDO0FBQ3hDLGlDQUFpQztBQUdqQywrQ0FBNEQ7QUFDNUQsa0NBQStCO0FBQy9CLDZDQUEwRTtBQUcxRSxTQUFnQixpQkFBaUIsQ0FBQyxJQUFZO0lBQzVDLGtEQUFrRDtJQUNsRCxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMvQixDQUFDO0FBSEQsOENBR0M7QUFFRCxTQUFnQixpQkFBaUIsQ0FBQyxXQUEyQixFQUFFLElBQWE7SUFDMUUsSUFDRSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtRQUMxQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDO1FBQ3hELENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFDcEM7UUFDQSxPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsTUFBTSxPQUFPLEdBQUcsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRCxJQUFJLE9BQU8sRUFBRTtRQUNYLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztLQUMxQztJQUVELE9BQU8sRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ3hDLENBQUM7QUFmRCw4Q0FlQztBQUVELFNBQWdCLFdBQVcsQ0FBbUIsS0FBUSxFQUFFLElBQU87SUFDN0Qsc0NBQXNDO0lBQ3RDLE9BQU8sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUM7QUFDL0MsQ0FBQztBQUhELGtDQUdDO0FBRUQsU0FBZ0IsVUFB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LEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFFRCxPQUFPO1FBQ0wsR0FBRyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNqQyxVQUFVLEVBQUUsUUFBUTtRQUNwQixjQUFjLEVBQUUsR0FBRyxDQUFDLGNBQWM7S0FDbkMsQ0FBQztBQUNKLENBQUM7QUFYRCxvQ0FXQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsVUFBVSxDQUFDLENBQVM7SUFDbEMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFGRCxnQ0FFQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLENBQVM7SUFDckMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDN0MsQ0FBQztBQUZELHNDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3ltYm9sSWRlbnRpZmllciB9IGZyb20gJ2pzaWknO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IEFzdFJlbmRlcmVyIH0gZnJvbSAnLi4vcmVuZGVyZXInO1xuaW1wb3J0IHsgdHlwZUNvbnRhaW5zVW5kZWZpbmVkIH0gZnJvbSAnLi4vdHlwZXNjcmlwdC90eXBlcyc7XG5pbXBvcnQgeyBmbWFwIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBmaW5kVHlwZUxvb2t1cEFzc2VtYmx5LCBUeXBlTG9va3VwQXNzZW1ibHkgfSBmcm9tICcuL2Fzc2VtYmxpZXMnO1xuaW1wb3J0IHsgT2JqZWN0TGl0ZXJhbFN0cnVjdCB9IGZyb20gJy4vanNpaS10eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05hbWVkTGlrZVN0cnVjdChuYW1lOiBzdHJpbmcpIHtcbiAgLy8gU3RhcnQgd2l0aCBhbiBJIGFuZCBhbm90aGVyIHVwcGVyY2FzZSBjaGFyYWN0ZXJcbiAgcmV0dXJuICEvXklbQS1aXS8udGVzdChuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFuYWx5emVTdHJ1Y3RUeXBlKHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgdHlwZTogdHMuVHlwZSk6IE9iamVjdExpdGVyYWxTdHJ1Y3QgfCBmYWxzZSB7XG4gIGlmIChcbiAgICAhdHlwZS5pc0NsYXNzT3JJbnRlcmZhY2UoKSB8fFxuICAgICFoYXNBbGxGbGFncyh0eXBlLm9iamVjdEZsYWdzLCB0cy5PYmplY3RGbGFncy5JbnRlcmZhY2UpIHx8XG4gICAgIWlzTmFtZWRMaWtlU3RydWN0KHR5cGUuc3ltYm9sLm5hbWUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGpzaWlTeW0gPSBsb29rdXBKc2lpU3ltYm9sKHR5cGVDaGVja2VyLCB0eXBlLnN5bWJvbCk7XG4gIGlmIChqc2lpU3ltKSB7XG4gICAgcmV0dXJuIHsga2luZDogJ3N0cnVjdCcsIHR5cGUsIGpzaWlTeW0gfTtcbiAgfVxuXG4gIHJldHVybiB7IGtpbmQ6ICdsb2NhbC1zdHJ1Y3QnLCB0eXBlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNBbGxGbGFnczxBIGV4dGVuZHMgbnVtYmVyPihmbGFnczogQSwgdGVzdDogQSkge1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICByZXR1cm4gdGVzdCAhPT0gMCAmJiAoZmxhZ3MgJiB0ZXN0KSA9PT0gdGVzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0FueUZsYWc8QSBleHRlbmRzIG51bWJlcj4oZmxhZ3M6IEEsIHRlc3Q6IEEpIHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgcmV0dXJuIHRlc3QgIT09IDAgJiYgKGZsYWdzICYgdGVzdCkgIT09IDA7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RydWN0UHJvcGVydHkge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IHRzLlR5cGUgfCB1bmRlZmluZWQ7XG4gIHF1ZXN0aW9uTWFyazogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnRpZXNPZlN0cnVjdCh0eXBlOiB0cy5UeXBlLCBjb250ZXh0OiBBc3RSZW5kZXJlcjxhbnk+KTogU3RydWN0UHJvcGVydHlbXSB7XG4gIHJldHVybiB0eXBlLmlzQ2xhc3NPckludGVyZmFjZSgpXG4gICAgPyB0eXBlLmdldFByb3BlcnRpZXMoKS5tYXAoKHMpID0+IHtcbiAgICAgICAgbGV0IHByb3BUeXBlO1xuICAgICAgICBsZXQgcXVlc3Rpb25NYXJrID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgcHJvcFN5bWJvbCA9IHR5cGUuZ2V0UHJvcGVydHkocy5uYW1lKSE7XG4gICAgICAgIGNvbnN0IHN5bWJvbERlY2wgPSBwcm9wU3ltYm9sLnZhbHVlRGVjbGFyYXRpb247XG4gICAgICAgIGlmICh0cy5pc1Byb3BlcnR5RGVjbGFyYXRpb24oc3ltYm9sRGVjbCkgfHwgdHMuaXNQcm9wZXJ0eVNpZ25hdHVyZShzeW1ib2xEZWNsKSkge1xuICAgICAgICAgIHF1ZXN0aW9uTWFyayA9IHN5bWJvbERlY2wucXVlc3Rpb25Ub2tlbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgIHByb3BUeXBlID0gc3ltYm9sRGVjbC50eXBlICYmIGNvbnRleHQudHlwZU9mVHlwZShzeW1ib2xEZWNsLnR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBzLm5hbWUsXG4gICAgICAgICAgdHlwZTogcHJvcFR5cGUsXG4gICAgICAgICAgcXVlc3Rpb25NYXJrLFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICA6IFtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RydWN0UHJvcGVydHlBY2NlcHRzVW5kZWZpbmVkKHByb3A6IFN0cnVjdFByb3BlcnR5KTogYm9vbGVhbiB7XG4gIHJldHVybiBwcm9wLnF1ZXN0aW9uTWFyayB8fCAoISFwcm9wLnR5cGUgJiYgdHlwZUNvbnRhaW5zVW5kZWZpbmVkKHByb3AudHlwZSkpO1xufVxuXG4vKipcbiAqIEEgVHlwZVNjcmlwdCBzeW1ib2wgcmVzb2x2ZWQgdG8gaXRzIGpzaWkgdHlwZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEpzaWlTeW1ib2wge1xuICAvKipcbiAgICogRlFOIG9mIHRoZSBzeW1ib2xcbiAgICpcbiAgICogSXMgZWl0aGVyIHRoZSBGUU4gb2YgYSB0eXBlIChmb3IgYSB0eXBlKS4gRm9yIGEgbWVtYnIsIHRoZSBGUU4gbG9va3MgbGlrZTpcbiAgICogJ3R5cGUuZnFuI21lbWJlck5hbWUnLlxuICAgKi9cbiAgcmVhZG9ubHkgZnFuOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoYXQga2luZCBvZiBzeW1ib2wgdGhpcyBpc1xuICAgKi9cbiAgcmVhZG9ubHkgc3ltYm9sVHlwZTogJ21vZHVsZScgfCAndHlwZScgfCAnbWVtYmVyJztcblxuICAvKipcbiAgICogQXNzZW1ibHkgd2hlcmUgdGhlIHR5cGUgd2FzIGZvdW5kXG4gICAqXG4gICAqIE1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB0aGUgdHlwZSB3YXMgRkFLRSBmcm9tIGpzaWkgKGZvciB0ZXN0cylcbiAgICovXG4gIHJlYWRvbmx5IHNvdXJjZUFzc2VtYmx5PzogVHlwZUxvb2t1cEFzc2VtYmx5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9va3VwSnNpaVN5bWJvbEZyb21Ob2RlKHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgbm9kZTogdHMuTm9kZSk6IEpzaWlTeW1ib2wgfCB1bmRlZmluZWQge1xuICByZXR1cm4gZm1hcCh0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUpLCAocykgPT4gbG9va3VwSnNpaVN5bWJvbCh0eXBlQ2hlY2tlciwgcykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGpzaWkgRlFOIGZvciBhIFR5cGVTY3JpcHQgKGNsYXNzIG9yIHR5cGUpIHN5bWJvbFxuICpcbiAqIFR5cGVTY3JpcHQgb25seSBrbm93cyB0aGUgc3ltYm9sIE5BTUUgcGx1cyB0aGUgRklMRSB0aGUgc3ltYm9sIGlzIGRlZmluZWRcbiAqIGluLiBXZSBuZWVkIHRvIGV4dHJhY3QgdHdvIHRoaW5nczpcbiAqXG4gKiAxLiBUaGUgcGFja2FnZSBuYW1lIChleHRyYWN0ZWQgZnJvbSB0aGUgbmVhcmVzdCBgcGFja2FnZS5qc29uYClcbiAqIDIuIFRoZSBzdWJtb2R1bGUgbmFtZSAoLi4uPz8gZG9uJ3Qga25vdyBob3cgdG8gZ2V0IHRoaXMgeWV0KVxuICogMy4gQW55IGNvbnRhaW5pbmcgdHlwZSBuYW1lcyBvciBuYW1lc3BhY2UgbmFtZXMuXG4gKlxuICogRm9yIHRlc3RzLCB3ZSBhbHNvIHRyZWF0IHN5bWJvbHMgaW4gYSBmaWxlIHRoYXQgaGFzIHRoZSBzdHJpbmcgJy8vLyBmYWtlLWZyb20tanNpaSdcbiAqIGFzIGNvbWluZyBmcm9tIGpzaWkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29rdXBKc2lpU3ltYm9sKHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgc3ltOiB0cy5TeW1ib2wpOiBKc2lpU3ltYm9sIHwgdW5kZWZpbmVkIHtcbiAgLy8gUmVzb2x2ZSBhbGlhcywgaWYgaXQgaXMgb25lLiBUaGlzIGNvbWVzIGludG8gcGxheSBpZiB0aGUgc3ltYm9sIHJlZmVycyB0byBhIG1vZHVsZSxcbiAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhbGlhcyB0byBmaW5kIHRoZSBBQ1RVQUwgbW9kdWxlLlxuICBpZiAoaGFzQW55RmxhZyhzeW0uZmxhZ3MsIHRzLlN5bWJvbEZsYWdzLkFsaWFzKSkge1xuICAgIHN5bSA9IHR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltKTtcbiAgfVxuXG4gIGNvbnN0IGRlY2w6IHRzLk5vZGUgfCB1bmRlZmluZWQgPSBzeW0uZGVjbGFyYXRpb25zPy5bMF07XG4gIGlmICghZGVjbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHMuaXNTb3VyY2VGaWxlKGRlY2wpKSB7XG4gICAgLy8gVGhpcyBpcyBhIG1vZHVsZS5cbiAgICBjb25zdCBzb3VyY2VBc3NlbWJseSA9IGZpbmRUeXBlTG9va3VwQXNzZW1ibHkoZGVjbC5maWxlTmFtZSk7XG4gICAgcmV0dXJuIGZtYXAoXG4gICAgICBzb3VyY2VBc3NlbWJseSxcbiAgICAgIChhc20pID0+XG4gICAgICAgICh7XG4gICAgICAgICAgZnFuOlxuICAgICAgICAgICAgZm1hcChcbiAgICAgICAgICAgICAgc3ltYm9sSWRlbnRpZmllcihcbiAgICAgICAgICAgICAgICB0eXBlQ2hlY2tlcixcbiAgICAgICAgICAgICAgICBzeW0sXG4gICAgICAgICAgICAgICAgZm1hcChzb3VyY2VBc3NlbWJseSwgKHNhKSA9PiAoeyBhc3NlbWJseTogc2EuYXNzZW1ibHkgfSkpLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoc3ltYm9sSWQpID0+IHNvdXJjZUFzc2VtYmx5Py5zeW1ib2xJZE1hcFtzeW1ib2xJZF0sXG4gICAgICAgICAgICApID8/IHNvdXJjZUFzc2VtYmx5Py5hc3NlbWJseS5uYW1lLFxuICAgICAgICAgIHNvdXJjZUFzc2VtYmx5OiBhc20sXG4gICAgICAgICAgc3ltYm9sVHlwZTogJ21vZHVsZScsXG4gICAgICAgIH0gYXMgSnNpaVN5bWJvbCksXG4gICAgKTtcbiAgfVxuXG4gIGlmICghaXNEZWNsYXJhdGlvbihkZWNsKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBkZWNsYXJpbmdGaWxlID0gZGVjbC5nZXRTb3VyY2VGaWxlKCk7XG4gIGlmICgvXlxcL1xcL1xcLyBmYWtlLWZyb20tanNpaS9tLnRlc3QoZGVjbGFyaW5nRmlsZS5nZXRGdWxsVGV4dCgpKSkge1xuICAgIHJldHVybiB7IGZxbjogYGZha2VfanNpaS4ke3N5bS5uYW1lfWAsIHN5bWJvbFR5cGU6ICd0eXBlJyB9O1xuICB9XG5cbiAgY29uc3QgZGVjbFN5bSA9IGdldFN5bWJvbEZyb21EZWNsYXJhdGlvbihkZWNsLCB0eXBlQ2hlY2tlcik7XG4gIGlmICghZGVjbFN5bSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBmaWxlTmFtZSA9IGRlY2wuZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lO1xuICBjb25zdCBzb3VyY2VBc3NlbWJseSA9IGZpbmRUeXBlTG9va3VwQXNzZW1ibHkoZmlsZU5hbWUpO1xuICBjb25zdCBzeW1ib2xJZCA9IHN5bWJvbElkZW50aWZpZXIodHlwZUNoZWNrZXIsIGRlY2xTeW0sIHsgYXNzZW1ibHk6IHNvdXJjZUFzc2VtYmx5Py5hc3NlbWJseSB9KTtcbiAgaWYgKCFzeW1ib2xJZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gZm1hcCgvKFteI10qKSgjLiopPy8uZXhlYyhzeW1ib2xJZCksIChbLCB0eXBlU3ltYm9sSWQsIG1lbWJlckZyYWdtZW50XSkgPT4ge1xuICAgIGlmIChtZW1iZXJGcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGZtYXAoc291cmNlQXNzZW1ibHk/LnN5bWJvbElkTWFwW3R5cGVTeW1ib2xJZF0sIChmcW4pID0+ICh7XG4gICAgICAgIGZxbjogYCR7ZnFufSR7bWVtYmVyRnJhZ21lbnR9YCxcbiAgICAgICAgc291cmNlQXNzZW1ibHksXG4gICAgICAgIHN5bWJvbFR5cGU6ICdtZW1iZXInLFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmbWFwKHNvdXJjZUFzc2VtYmx5Py5zeW1ib2xJZE1hcFt0eXBlU3ltYm9sSWRdLCAoZnFuKSA9PiAoeyBmcW4sIHNvdXJjZUFzc2VtYmx5LCBzeW1ib2xUeXBlOiAndHlwZScgfSkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJhdGlvbih4OiB0cy5Ob2RlKTogeCBpcyB0cy5EZWNsYXJhdGlvbiB7XG4gIHJldHVybiAoXG4gICAgdHMuaXNDbGFzc0RlY2xhcmF0aW9uKHgpIHx8XG4gICAgdHMuaXNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbih4KSB8fFxuICAgIHRzLmlzTmFtZXNwYWNlRXhwb3J0KHgpIHx8XG4gICAgdHMuaXNNb2R1bGVEZWNsYXJhdGlvbih4KSB8fFxuICAgIHRzLmlzRW51bURlY2xhcmF0aW9uKHgpIHx8XG4gICAgdHMuaXNFbnVtTWVtYmVyKHgpIHx8XG4gICAgdHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbih4KSB8fFxuICAgIHRzLmlzTWV0aG9kRGVjbGFyYXRpb24oeCkgfHxcbiAgICB0cy5pc01ldGhvZFNpZ25hdHVyZSh4KSB8fFxuICAgIHRzLmlzUHJvcGVydHlEZWNsYXJhdGlvbih4KSB8fFxuICAgIHRzLmlzUHJvcGVydHlTaWduYXR1cmUoeClcbiAgKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gdHlwZSBpcyBhbiBlbnVtIGxpdGVyYWwsIHJlc29sdmUgdG8gdGhlIGVudW0gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUVudW1MaXRlcmFsKHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgdHlwZTogdHMuVHlwZSkge1xuICBpZiAoIWhhc0FueUZsYWcodHlwZS5mbGFncywgdHMuVHlwZUZsYWdzLkVudW1MaXRlcmFsKSkge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVDaGVja2VyLmdldEJhc2VUeXBlT2ZMaXRlcmFsVHlwZSh0eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVkU3ltYm9sQXRMb2NhdGlvbih0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIG5vZGU6IHRzLk5vZGUpIHtcbiAgbGV0IHN5bWJvbCA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZSk7XG4gIHdoaWxlIChzeW1ib2wgJiYgaGFzQW55RmxhZyhzeW1ib2wuZmxhZ3MsIHRzLlN5bWJvbEZsYWdzLkFsaWFzKSkge1xuICAgIHN5bWJvbCA9IHR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltYm9sKTtcbiAgfVxuICByZXR1cm4gc3ltYm9sO1xufVxuXG5mdW5jdGlvbiBnZXRTeW1ib2xGcm9tRGVjbGFyYXRpb24oZGVjbDogdHMuTm9kZSwgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyKTogdHMuU3ltYm9sIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFpc0RlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSB0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbihkZWNsKTtcbiAgcmV0dXJuIG5hbWUgPyB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5hbWUpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50U3ltYm9sKHN5bTogSnNpaVN5bWJvbCk6IEpzaWlTeW1ib2wgfCB1bmRlZmluZWQge1xuICBjb25zdCBwYXJ0cyA9IHN5bS5mcW4uc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZxbjogcGFydHMuc2xpY2UoMCwgLTEpLmpvaW4oJy4nKSxcbiAgICBzeW1ib2xUeXBlOiAnbW9kdWxlJywgLy8gTWlnaHQgbm90IGJlIHRydWUsIGJ1dCBwcm9iYWJseSBnb29kIGVub3VnaFxuICAgIHNvdXJjZUFzc2VtYmx5OiBzeW0uc291cmNlQXNzZW1ibHksXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBsYXN0IHBhcnQgb2YgYSBkb3Qtc2VwYXJhdGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxlTmFtZSh4OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHguc3BsaXQoJy4nKS5zbGljZSgtMSlbMF07XG59XG5cbi8qKlxuICogR2V0IGFsbCBwYXJ0cyBleGNlcHQgdGhlIGxhc3Qgb2YgYSBkb3Qtc2VwYXJhdGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmFtZXNwYWNlTmFtZSh4OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHguc3BsaXQoJy4nKS5zbGljZSgwLCAtMSkuam9pbignLicpO1xufVxuIl19