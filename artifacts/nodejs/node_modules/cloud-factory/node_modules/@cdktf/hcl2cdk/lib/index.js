"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegistryModule = exports.convertProject = exports.getTerraformConfigFromDir = exports.convert = exports.convertToTypescript = exports.parseProviderRequirements = exports.getParsedHcl = void 0;
const hcl2json_1 = require("@cdktf/hcl2json");
const provider_generator_1 = require("@cdktf/provider-generator");
Object.defineProperty(exports, "isRegistryModule", { enumerable: true, get: function () { return provider_generator_1.isRegistryModule; } });
const t = __importStar(require("@babel/types"));
const prettier_1 = __importDefault(require("prettier"));
const path = __importStar(require("path"));
const glob = __importStar(require("glob"));
const fs = __importStar(require("fs"));
const graphology_1 = require("graphology");
const rosetta = __importStar(require("jsii-rosetta"));
const schema_1 = require("./schema");
const expressions_1 = require("./expressions");
const generation_1 = require("./generation");
const iteration_1 = require("./iteration");
const provider_1 = require("./provider");
async function getParsedHcl(hcl) {
    // Get the JSON representation of the HCL
    let json;
    try {
        json = await hcl2json_1.parse("terraform.tf", hcl);
    }
    catch (err) {
        throw new Error(`Error: Could not parse HCL, this means either that the HCL passed is invalid or that you found a bug. If the HCL seems valid, please file a bug under https://cdk.tf/bugs/new/convert`);
    }
    // Ensure the JSON representation matches the expected structure
    let plan;
    try {
        plan = schema_1.schema.parse(json);
    }
    catch (err) {
        throw new Error(`Error: HCL-JSON does not conform to schema. This is not expected, please file a bug under https://cdk.tf/bugs/new/convert
Please include this information:
${JSON.stringify(err.errors)}`);
    }
    return plan;
}
exports.getParsedHcl = getParsedHcl;
async function parseProviderRequirements(hcl) {
    const plan = await getParsedHcl(hcl);
    return provider_1.getProviderRequirements(plan);
}
exports.parseProviderRequirements = parseProviderRequirements;
async function convertToTypescript(hcl, providerSchema) {
    var _a, _b;
    const plan = await getParsedHcl(hcl);
    // Each key in the scope needs to be unique, therefore we save them in a set
    // Each variable needs to be unique as well, we save them in a record so we can identify if two variables are the same
    const scope = {
        providerSchema,
        constructs: new Set(),
        variables: {},
    };
    // Get all items in the JSON as a map of id to function that generates the AST
    // We will use this to construct the nodes for a dependency graph
    // We need to use a function here because the same node has different representation based on if it's referenced by another one
    const nodeMap = {
        ...iteration_1.forEachProvider(scope, plan.provider, generation_1.provider),
        ...iteration_1.forEachGlobal(scope, "var", plan.variable, generation_1.variable),
        // locals are a special case
        ...iteration_1.forEachGlobal(scope, "local", Array.isArray(plan.locals)
            ? plan.locals.reduce((carry, locals) => ({ ...carry, ...locals }), {})
            : {}, generation_1.local),
        ...iteration_1.forEachGlobal(scope, "out", plan.output, generation_1.output),
        ...iteration_1.forEachGlobal(scope, "module", plan.module, generation_1.modules),
        ...iteration_1.forEachNamespaced(scope, plan.resource, generation_1.resource),
        ...iteration_1.forEachNamespaced(scope, plan.data, generation_1.resource, "data"),
    };
    const graph = new graphology_1.DirectedGraph();
    // Add all nodes to the dependency graph so we can detect if an edge is added for an unknown link
    Object.entries(nodeMap).forEach(([key, value]) => graph.addNode(key, { code: value }));
    // Finding references becomes easier of the to be referenced ids are already known
    const nodeIds = Object.keys(nodeMap);
    function addEdges(id, value) {
        expressions_1.findUsedReferences(nodeIds, value).forEach((ref) => {
            if (!graph.hasDirectedEdge(ref.referencee.id, id) &&
                graph.hasNode(ref.referencee.id) // in case the referencee is a dynamic variable
            ) {
                if (!graph.hasNode(id)) {
                    throw new Error(`The dependency graph is expected to link from ${ref.referencee.id} to ${id} but ${id} does not exist. 
            These nodes exist: ${graph.nodes().join("\n")}`);
                }
                graph.addDirectedEdge(ref.referencee.id, id, { ref });
            }
        });
    }
    // We recursively inspect each resource value to find references to other values
    // We add these to a dependency graph so that the programming code has the right order
    function addGlobalEdges(_scope, _key, id, value) {
        addEdges(id, value);
    }
    function addProviderEdges(_scope, _key, id, value) {
        addEdges(id, value);
    }
    function addNamespacedEdges(_scope, _type, _key, id, value) {
        addEdges(id, value);
    }
    Object.values({
        ...iteration_1.forEachProvider(scope, plan.provider, addProviderEdges),
        ...iteration_1.forEachGlobal(scope, "var", plan.variable, addGlobalEdges),
        // locals are a special case
        ...iteration_1.forEachGlobal(scope, "local", Array.isArray(plan.locals)
            ? plan.locals.reduce((carry, locals) => ({ ...carry, ...locals }), {})
            : {}, addGlobalEdges),
        ...iteration_1.forEachGlobal(scope, "out", plan.output, addGlobalEdges),
        ...iteration_1.forEachGlobal(scope, "module", plan.module, addGlobalEdges),
        ...iteration_1.forEachNamespaced(scope, plan.resource, addNamespacedEdges),
        ...iteration_1.forEachNamespaced(scope, plan.data, addNamespacedEdges, "data"),
    }).forEach((addEdgesToGraph) => addEdgesToGraph(graph));
    // We traverse the dependency graph to get the unordered JSON nodes into an ordered array
    // where no node is referenced before it's defined
    // As we check that the nodes on both ends of an edge exist we can be sure
    // that no infinite loop exists, there can be no stray dependency on a node
    const expressions = [];
    let nodesToVisit = [...nodeIds];
    // This ensures we detect cycles and don't end up in an endless loop
    let nodesVisitedThisIteration = 0;
    do {
        nodesVisitedThisIteration = 0;
        graph.forEachNode((nodeId) => {
            if (!nodesToVisit.includes(nodeId)) {
                return;
            }
            const unresolvedDependencies = graph
                .inNeighbors(nodeId)
                .filter((item) => nodesToVisit.includes(item));
            if (unresolvedDependencies.length === 0) {
                nodesToVisit = nodesToVisit.filter((id) => nodeId !== id);
                nodesVisitedThisIteration = nodesVisitedThisIteration + 1;
                const list = graph.getNodeAttribute(nodeId, "code")(graph);
                (Array.isArray(list) ? list : [list]).forEach((item) => expressions.push(item));
            }
        });
    } while (nodesToVisit.length > 0 && nodesVisitedThisIteration != 0);
    const backendExpressions = (_a = plan.terraform) === null || _a === void 0 ? void 0 : _a.reduce((carry, terraform) => [
        ...carry,
        ...generation_1.backendToExpression(scope, terraform.backend, nodeIds),
    ], []);
    // We collect all module sources
    const moduleRequirements = [
        ...new Set(Object.values(plan.module || {}).reduce((carry, moduleBlock) => [
            ...carry,
            ...moduleBlock.reduce((arr, { source, version }) => [
                ...arr,
                version ? `${source}@${version}` : source,
            ], []),
        ], []) || []),
    ];
    // Variables, Outputs, and Backends are defined in the CDKTF project so we need to import from it
    // If none are used we don't want to leave a stray import
    const cdktfImports = ((_b = plan.terraform) === null || _b === void 0 ? void 0 : _b.some((tf) => Object.keys(tf.backend || {}).length > 0)) ||
        Object.keys({ ...plan.variable, ...plan.output }).length > 0
        ? [generation_1.cdktfImport]
        : [];
    if (Object.keys(plan.variable || {}).length > 0 && expressions.length > 0) {
        expressions[0] = t.addComment(expressions[0], "leading", `Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables`);
    }
    const providerRequirements = provider_1.getProviderRequirements(plan);
    const providers = generation_1.providerImports(Object.keys(providerRequirements));
    if (providers.length > 0) {
        providers[0] = t.addComment(providers[0], "leading", `Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.`);
    }
    // We add a comment if there are providers with missing schema information
    const providersLackingSchema = Object.keys(providerRequirements).filter((providerName) => !Object.keys(providerSchema.provider_schemas || {}).some((schemaName) => schemaName.endsWith(providerName)));
    if (providersLackingSchema.length > 0) {
        expressions[0] = t.addComment(expressions[0], "leading", `The following providers are missing schema information and might need manual adjustments to synthesize correctly: ${providersLackingSchema.join(", ")}.
For a more precise conversion please use the --provider flag in convert.`);
    }
    // We split up the generated code so that users can have more control over what to insert where
    return {
        all: generation_1.gen([
            ...cdktfImports,
            ...providers,
            ...generation_1.moduleImports(plan.module),
            ...(backendExpressions || []),
            ...expressions,
        ]),
        imports: generation_1.gen([
            ...cdktfImports,
            ...providers,
            ...generation_1.moduleImports(plan.module),
        ]),
        code: generation_1.gen([...(backendExpressions || []), ...expressions]),
        providers: Object.entries(providerRequirements).map(([source, version]) => version === "*" ? source : `${source}@${version}`),
        modules: moduleRequirements,
        // We track some usage data to make it easier to understand what is used
        stats: {
            numberOfModules: moduleRequirements.length,
            numberOfProviders: Object.keys(providerRequirements).length,
            resources: iteration_1.resourceStats(plan.resource || {}),
            data: iteration_1.resourceStats(plan.data || {}),
            convertedLines: hcl.split("\n").length,
        },
    };
}
exports.convertToTypescript = convertToTypescript;
const translations = {
    typescript: (file) => file.contents,
    python: (file) => rosetta.translateTypeScript(file, new rosetta.PythonVisitor()).translation,
    java: (file) => rosetta.translateTypeScript(file, new rosetta.JavaVisitor()).translation,
    csharp: (file) => rosetta.translateTypeScript(file, new rosetta.CSharpVisitor()).translation,
};
async function convert(hcl, { language, providerSchema }) {
    const fileName = "terraform.tf";
    const translater = translations[language];
    if (!translater) {
        throw new Error("Unsupported language used: " + language);
    }
    const tsCode = await convertToTypescript(hcl, providerSchema);
    return {
        ...tsCode,
        all: translater({ fileName, contents: tsCode.all }),
        imports: translater({ fileName, contents: tsCode.imports }),
        code: translater({ fileName, contents: tsCode.code }),
        stats: { ...tsCode.stats, language },
    };
}
exports.convert = convert;
function getTerraformConfigFromDir(importPath) {
    const absPath = path.resolve(importPath);
    const fileContents = glob
        .sync("./*.tf", { cwd: absPath })
        .map((p) => fs.readFileSync(path.resolve(absPath, p), "utf8"));
    return fileContents.join("\n");
}
exports.getTerraformConfigFromDir = getTerraformConfigFromDir;
async function convertProject(combinedHcl, inputMainFile, inputCdktfJson, { language, providerSchema }) {
    if (language !== "typescript") {
        throw new Error("Unsupported language used: " + language);
    }
    const { imports, code, providers, modules: tfModules, stats, } = await convert(combinedHcl, {
        language,
        providerSchema,
    });
    const importMainFile = [imports, inputMainFile].join("\n");
    const outputMainFile = importMainFile.replace("// define resources here", code);
    const cdktfJson = { ...inputCdktfJson };
    cdktfJson.terraformProviders = providers;
    cdktfJson.terraformModules = tfModules;
    return {
        code: prettier_1.default.format(outputMainFile, { parser: "babel" }),
        cdktfJson,
        stats,
    };
}
exports.convertProject = convertProject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOENBQXdDO0FBQ3hDLGtFQUE2RTtBQXdZcEUsaUdBeFlBLHFDQUFnQixPQXdZQTtBQXZZekIsZ0RBQWtDO0FBQ2xDLHdEQUFnQztBQUNoQywyQ0FBNkI7QUFDN0IsMkNBQTZCO0FBQzdCLHVDQUF5QjtBQUN6QiwyQ0FBMkM7QUFDM0Msc0RBQXdDO0FBR3hDLHFDQUFrQztBQUNsQywrQ0FBbUQ7QUFDbkQsNkNBWXNCO0FBRXRCLDJDQUtxQjtBQUNyQix5Q0FBcUQ7QUFFOUMsS0FBSyxVQUFVLFlBQVksQ0FBQyxHQUFXO0lBQzVDLHlDQUF5QztJQUN6QyxJQUFJLElBQTZCLENBQUM7SUFDbEMsSUFBSTtRQUNGLElBQUksR0FBRyxNQUFNLGdCQUFLLENBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQ3pDO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDWixNQUFNLElBQUksS0FBSyxDQUNiLHVMQUF1TCxDQUN4TCxDQUFDO0tBQ0g7SUFFRCxnRUFBZ0U7SUFDaEUsSUFBSSxJQUE0QixDQUFDO0lBQ2pDLElBQUk7UUFDRixJQUFJLEdBQUcsZUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMzQjtJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQzs7RUFFbEIsSUFBSSxDQUFDLFNBQVMsQ0FBRSxHQUFrQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUM3QztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQXRCRCxvQ0FzQkM7QUFFTSxLQUFLLFVBQVUseUJBQXlCLENBQUMsR0FBVztJQUN6RCxNQUFNLElBQUksR0FBRyxNQUFNLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxPQUFPLGtDQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZDLENBQUM7QUFIRCw4REFHQztBQUVNLEtBQUssVUFBVSxtQkFBbUIsQ0FDdkMsR0FBVyxFQUNYLGNBQThCOztJQUU5QixNQUFNLElBQUksR0FBRyxNQUFNLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVyQyw0RUFBNEU7SUFDNUUsc0hBQXNIO0lBQ3RILE1BQU0sS0FBSyxHQUFVO1FBQ25CLGNBQWM7UUFDZCxVQUFVLEVBQUUsSUFBSSxHQUFHLEVBQVU7UUFDN0IsU0FBUyxFQUFFLEVBQUU7S0FDZCxDQUFDO0lBRUYsOEVBQThFO0lBQzlFLGlFQUFpRTtJQUNqRSwrSEFBK0g7SUFDL0gsTUFBTSxPQUFPLEdBQUc7UUFDZCxHQUFHLDJCQUFlLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUscUJBQVEsQ0FBQztRQUNsRCxHQUFHLHlCQUFhLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLHFCQUFRLENBQUM7UUFDdkQsNEJBQTRCO1FBQzVCLEdBQUcseUJBQWEsQ0FDZCxLQUFLLEVBQ0wsT0FBTyxFQUNQLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUN4QixDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxLQUFLLEVBQUUsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUN0RSxDQUFDLENBQUMsRUFBRSxFQUNOLGtCQUFLLENBQ047UUFDRCxHQUFHLHlCQUFhLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLG1CQUFNLENBQUM7UUFDbkQsR0FBRyx5QkFBYSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxvQkFBTyxDQUFDO1FBQ3ZELEdBQUcsNkJBQWlCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUscUJBQVEsQ0FBQztRQUNwRCxHQUFHLDZCQUFpQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLHFCQUFRLEVBQUUsTUFBTSxDQUFDO0tBQ3pELENBQUM7SUFFRixNQUFNLEtBQUssR0FBRyxJQUFJLDBCQUFhLEVBQUUsQ0FBQztJQUNsQyxpR0FBaUc7SUFDakcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQy9DLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQ3BDLENBQUM7SUFFRixrRkFBa0Y7SUFDbEYsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNyQyxTQUFTLFFBQVEsQ0FBQyxFQUFVLEVBQUUsS0FBNkI7UUFDekQsZ0NBQWtCLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ2pELElBQ0UsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztnQkFDN0MsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLCtDQUErQztjQUNoRjtnQkFDQSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRTtvQkFDdEIsTUFBTSxJQUFJLEtBQUssQ0FDYixpREFDRSxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQ2pCLE9BQU8sRUFBRSxRQUFRLEVBQUU7aUNBQ0UsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNoRCxDQUFDO2lCQUNIO2dCQUNELEtBQUssQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQzthQUN2RDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELGdGQUFnRjtJQUNoRixzRkFBc0Y7SUFDdEYsU0FBUyxjQUFjLENBQ3JCLE1BQWEsRUFDYixJQUFZLEVBQ1osRUFBVSxFQUNWLEtBQTZCO1FBRTdCLFFBQVEsQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUNELFNBQVMsZ0JBQWdCLENBQ3ZCLE1BQWEsRUFDYixJQUFZLEVBQ1osRUFBVSxFQUNWLEtBQTZCO1FBRTdCLFFBQVEsQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUNELFNBQVMsa0JBQWtCLENBQ3pCLE1BQWEsRUFDYixLQUFhLEVBQ2IsSUFBWSxFQUNaLEVBQVUsRUFDVixLQUE2QjtRQUU3QixRQUFRLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFFRCxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ1osR0FBRywyQkFBZSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLGdCQUFnQixDQUFDO1FBQzFELEdBQUcseUJBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsY0FBYyxDQUFDO1FBQzdELDRCQUE0QjtRQUM1QixHQUFHLHlCQUFhLENBQ2QsS0FBSyxFQUNMLE9BQU8sRUFDUCxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDeEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsS0FBSyxFQUFFLEdBQUcsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDdEUsQ0FBQyxDQUFDLEVBQUUsRUFDTixjQUFjLENBQ2Y7UUFDRCxHQUFHLHlCQUFhLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQztRQUMzRCxHQUFHLHlCQUFhLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQztRQUM5RCxHQUFHLDZCQUFpQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLGtCQUFrQixDQUFDO1FBQzlELEdBQUcsNkJBQWlCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxDQUFDO0tBQ25FLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRXhELHlGQUF5RjtJQUN6RixrREFBa0Q7SUFDbEQsMEVBQTBFO0lBQzFFLDJFQUEyRTtJQUMzRSxNQUFNLFdBQVcsR0FBa0IsRUFBRSxDQUFDO0lBQ3RDLElBQUksWUFBWSxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQztJQUNoQyxvRUFBb0U7SUFDcEUsSUFBSSx5QkFBeUIsR0FBRyxDQUFDLENBQUM7SUFDbEMsR0FBRztRQUNELHlCQUF5QixHQUFHLENBQUMsQ0FBQztRQUM5QixLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ2xDLE9BQU87YUFDUjtZQUVELE1BQU0sc0JBQXNCLEdBQUcsS0FBSztpQkFDakMsV0FBVyxDQUFDLE1BQU0sQ0FBQztpQkFDbkIsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFFakQsSUFBSSxzQkFBc0IsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUN2QyxZQUFZLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsTUFBTSxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRCx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxDQUFDLENBQUM7Z0JBRTFELE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzNELENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FDckQsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDdkIsQ0FBQzthQUNIO1FBQ0gsQ0FBQyxDQUFDLENBQUM7S0FDSixRQUFRLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLHlCQUF5QixJQUFJLENBQUMsRUFBRTtJQUVwRSxNQUFNLGtCQUFrQixTQUFHLElBQUksQ0FBQyxTQUFTLDBDQUFFLE1BQU0sQ0FDL0MsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQztRQUNwQixHQUFHLEtBQUs7UUFDUixHQUFHLGdDQUFtQixDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQztLQUMxRCxFQUNELEVBQW1CLENBQ3BCLENBQUM7SUFFRixnQ0FBZ0M7SUFDaEMsTUFBTSxrQkFBa0IsR0FBRztRQUN6QixHQUFHLElBQUksR0FBRyxDQUNSLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQ3JDLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUM7WUFDdEIsR0FBRyxLQUFLO1lBQ1IsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUNuQixDQUFDLEdBQUcsRUFBRSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUM7Z0JBQzVCLEdBQUcsR0FBRztnQkFDTixPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxJQUFJLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNO2FBQzFDLEVBQ0QsRUFBYyxDQUNmO1NBQ0YsRUFDRCxFQUFjLENBQ2YsSUFBSSxFQUFFLENBQ1I7S0FDRixDQUFDO0lBRUYsaUdBQWlHO0lBQ2pHLHlEQUF5RDtJQUN6RCxNQUFNLFlBQVksR0FDaEIsT0FBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQztRQUNyRSxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUM7UUFDMUQsQ0FBQyxDQUFDLENBQUMsd0JBQVcsQ0FBQztRQUNmLENBQUMsQ0FBRSxFQUFvQixDQUFDO0lBRTVCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDekUsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQzNCLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFDZCxTQUFTLEVBQ1Q7eURBQ21ELENBQ3BELENBQUM7S0FDSDtJQUVELE1BQU0sb0JBQW9CLEdBQUcsa0NBQXVCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFM0QsTUFBTSxTQUFTLEdBQUcsNEJBQWUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztJQUNyRSxJQUFJLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3hCLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUN6QixTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQ1osU0FBUyxFQUNUO3lEQUNtRCxDQUNwRCxDQUFDO0tBQ0g7SUFFRCwwRUFBMEU7SUFDMUUsTUFBTSxzQkFBc0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsTUFBTSxDQUNyRSxDQUFDLFlBQVksRUFBRSxFQUFFLENBQ2YsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUN0RSxVQUFVLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUNsQyxDQUNKLENBQUM7SUFDRixJQUFJLHNCQUFzQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDckMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQzNCLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFDZCxTQUFTLEVBQ1QscUhBQXFILHNCQUFzQixDQUFDLElBQUksQ0FDOUksSUFBSSxDQUNMO3lFQUNrRSxDQUNwRSxDQUFDO0tBQ0g7SUFFRCwrRkFBK0Y7SUFDL0YsT0FBTztRQUNMLEdBQUcsRUFBRSxnQkFBRyxDQUFDO1lBQ1AsR0FBRyxZQUFZO1lBQ2YsR0FBRyxTQUFTO1lBQ1osR0FBRywwQkFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDN0IsR0FBSSxDQUFDLGtCQUFrQixJQUFJLEVBQUUsQ0FBUztZQUN0QyxHQUFHLFdBQVc7U0FDZixDQUFDO1FBQ0YsT0FBTyxFQUFFLGdCQUFHLENBQUM7WUFDWCxHQUFHLFlBQVk7WUFDZixHQUFHLFNBQVM7WUFDWixHQUFHLDBCQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUM5QixDQUFDO1FBQ0YsSUFBSSxFQUFFLGdCQUFHLENBQUMsQ0FBQyxHQUFJLENBQUMsa0JBQWtCLElBQUksRUFBRSxDQUFTLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQztRQUNuRSxTQUFTLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsQ0FDeEUsT0FBTyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sSUFBSSxPQUFPLEVBQUUsQ0FDbEQ7UUFDRCxPQUFPLEVBQUUsa0JBQWtCO1FBQzNCLHdFQUF3RTtRQUN4RSxLQUFLLEVBQUU7WUFDTCxlQUFlLEVBQUUsa0JBQWtCLENBQUMsTUFBTTtZQUMxQyxpQkFBaUIsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsTUFBTTtZQUMzRCxTQUFTLEVBQUUseUJBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQztZQUM3QyxJQUFJLEVBQUUseUJBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUNwQyxjQUFjLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNO1NBQ3ZDO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFqUEQsa0RBaVBDO0FBR0QsTUFBTSxZQUFZLEdBQUc7SUFDbkIsVUFBVSxFQUFFLENBQUMsSUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUTtJQUN6QyxNQUFNLEVBQUUsQ0FBQyxJQUFVLEVBQUUsRUFBRSxDQUNyQixPQUFPLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsV0FBVztJQUM1RSxJQUFJLEVBQUUsQ0FBQyxJQUFVLEVBQUUsRUFBRSxDQUNuQixPQUFPLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLElBQUksT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsV0FBVztJQUMxRSxNQUFNLEVBQUUsQ0FBQyxJQUFVLEVBQUUsRUFBRSxDQUNyQixPQUFPLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsV0FBVztDQUM3RSxDQUFDO0FBT0ssS0FBSyxVQUFVLE9BQU8sQ0FDM0IsR0FBVyxFQUNYLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBa0I7SUFFNUMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDO0lBQ2hDLE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUUxQyxJQUFJLENBQUMsVUFBVSxFQUFFO1FBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsR0FBRyxRQUFRLENBQUMsQ0FBQztLQUMzRDtJQUNELE1BQU0sTUFBTSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsR0FBRyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQzlELE9BQU87UUFDTCxHQUFHLE1BQU07UUFDVCxHQUFHLEVBQUUsVUFBVSxDQUFDLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDbkQsT0FBTyxFQUFFLFVBQVUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzNELElBQUksRUFBRSxVQUFVLENBQUMsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyRCxLQUFLLEVBQUUsRUFBRSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFO0tBQ3JDLENBQUM7QUFDSixDQUFDO0FBbEJELDBCQWtCQztBQUVELFNBQWdCLHlCQUF5QixDQUFDLFVBQWtCO0lBQzFELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDekMsTUFBTSxZQUFZLEdBQUcsSUFBSTtTQUN0QixJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDO1NBQ2hDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBRWpFLE9BQU8sWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBUEQsOERBT0M7QUFNTSxLQUFLLFVBQVUsY0FBYyxDQUNsQyxXQUFtQixFQUNuQixhQUFxQixFQUNyQixjQUF5QixFQUN6QixFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQWtCO0lBRTVDLElBQUksUUFBUSxLQUFLLFlBQVksRUFBRTtRQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixHQUFHLFFBQVEsQ0FBQyxDQUFDO0tBQzNEO0lBRUQsTUFBTSxFQUNKLE9BQU8sRUFDUCxJQUFJLEVBQ0osU0FBUyxFQUNULE9BQU8sRUFBRSxTQUFTLEVBQ2xCLEtBQUssR0FDTixHQUFHLE1BQU0sT0FBTyxDQUFDLFdBQVcsRUFBRTtRQUM3QixRQUFRO1FBQ1IsY0FBYztLQUNmLENBQUMsQ0FBQztJQUNILE1BQU0sY0FBYyxHQUFHLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzRCxNQUFNLGNBQWMsR0FBRyxjQUFjLENBQUMsT0FBTyxDQUMzQywwQkFBMEIsRUFDMUIsSUFBSSxDQUNMLENBQUM7SUFFRixNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsY0FBYyxFQUFFLENBQUM7SUFDeEMsU0FBUyxDQUFDLGtCQUFrQixHQUFHLFNBQVMsQ0FBQztJQUN6QyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxDQUFDO0lBRXZDLE9BQU87UUFDTCxJQUFJLEVBQUUsa0JBQVEsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDO1FBQzFELFNBQVM7UUFDVCxLQUFLO0tBQ04sQ0FBQztBQUNKLENBQUM7QUFuQ0Qsd0NBbUNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiQGNka3RmL2hjbDJqc29uXCI7XG5pbXBvcnQgeyBpc1JlZ2lzdHJ5TW9kdWxlLCBQcm92aWRlclNjaGVtYSB9IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5pbXBvcnQgKiBhcyB0IGZyb20gXCJAYmFiZWwvdHlwZXNcIjtcbmltcG9ydCBwcmV0dGllciBmcm9tIFwicHJldHRpZXJcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGdsb2IgZnJvbSBcImdsb2JcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgRGlyZWN0ZWRHcmFwaCB9IGZyb20gXCJncmFwaG9sb2d5XCI7XG5pbXBvcnQgKiBhcyByb3NldHRhIGZyb20gXCJqc2lpLXJvc2V0dGFcIjtcbmltcG9ydCAqIGFzIHogZnJvbSBcInpvZFwiO1xuXG5pbXBvcnQgeyBzY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWFcIjtcbmltcG9ydCB7IGZpbmRVc2VkUmVmZXJlbmNlcyB9IGZyb20gXCIuL2V4cHJlc3Npb25zXCI7XG5pbXBvcnQge1xuICBiYWNrZW5kVG9FeHByZXNzaW9uLFxuICBjZGt0ZkltcG9ydCxcbiAgZ2VuLFxuICBsb2NhbCxcbiAgbW9kdWxlSW1wb3J0cyxcbiAgbW9kdWxlcyxcbiAgb3V0cHV0LFxuICBwcm92aWRlcixcbiAgcHJvdmlkZXJJbXBvcnRzLFxuICByZXNvdXJjZSxcbiAgdmFyaWFibGUsXG59IGZyb20gXCIuL2dlbmVyYXRpb25cIjtcbmltcG9ydCB7IFRlcnJhZm9ybVJlc291cmNlQmxvY2ssIFNjb3BlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7XG4gIGZvckVhY2hQcm92aWRlcixcbiAgZm9yRWFjaEdsb2JhbCxcbiAgZm9yRWFjaE5hbWVzcGFjZWQsXG4gIHJlc291cmNlU3RhdHMsXG59IGZyb20gXCIuL2l0ZXJhdGlvblwiO1xuaW1wb3J0IHsgZ2V0UHJvdmlkZXJSZXF1aXJlbWVudHMgfSBmcm9tIFwiLi9wcm92aWRlclwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFyc2VkSGNsKGhjbDogc3RyaW5nKSB7XG4gIC8vIEdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgSENMXG4gIGxldCBqc29uOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgdHJ5IHtcbiAgICBqc29uID0gYXdhaXQgcGFyc2UoXCJ0ZXJyYWZvcm0udGZcIiwgaGNsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEVycm9yOiBDb3VsZCBub3QgcGFyc2UgSENMLCB0aGlzIG1lYW5zIGVpdGhlciB0aGF0IHRoZSBIQ0wgcGFzc2VkIGlzIGludmFsaWQgb3IgdGhhdCB5b3UgZm91bmQgYSBidWcuIElmIHRoZSBIQ0wgc2VlbXMgdmFsaWQsIHBsZWFzZSBmaWxlIGEgYnVnIHVuZGVyIGh0dHBzOi8vY2RrLnRmL2J1Z3MvbmV3L2NvbnZlcnRgXG4gICAgKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBtYXRjaGVzIHRoZSBleHBlY3RlZCBzdHJ1Y3R1cmVcbiAgbGV0IHBsYW46IHouaW5mZXI8dHlwZW9mIHNjaGVtYT47XG4gIHRyeSB7XG4gICAgcGxhbiA9IHNjaGVtYS5wYXJzZShqc29uKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvcjogSENMLUpTT04gZG9lcyBub3QgY29uZm9ybSB0byBzY2hlbWEuIFRoaXMgaXMgbm90IGV4cGVjdGVkLCBwbGVhc2UgZmlsZSBhIGJ1ZyB1bmRlciBodHRwczovL2Nkay50Zi9idWdzL25ldy9jb252ZXJ0XG5QbGVhc2UgaW5jbHVkZSB0aGlzIGluZm9ybWF0aW9uOlxuJHtKU09OLnN0cmluZ2lmeSgoZXJyIGFzIHouWm9kRXJyb3IpLmVycm9ycyl9YCk7XG4gIH1cblxuICByZXR1cm4gcGxhbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlUHJvdmlkZXJSZXF1aXJlbWVudHMoaGNsOiBzdHJpbmcpIHtcbiAgY29uc3QgcGxhbiA9IGF3YWl0IGdldFBhcnNlZEhjbChoY2wpO1xuICByZXR1cm4gZ2V0UHJvdmlkZXJSZXF1aXJlbWVudHMocGxhbik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9UeXBlc2NyaXB0KFxuICBoY2w6IHN0cmluZyxcbiAgcHJvdmlkZXJTY2hlbWE6IFByb3ZpZGVyU2NoZW1hXG4pIHtcbiAgY29uc3QgcGxhbiA9IGF3YWl0IGdldFBhcnNlZEhjbChoY2wpO1xuXG4gIC8vIEVhY2gga2V5IGluIHRoZSBzY29wZSBuZWVkcyB0byBiZSB1bmlxdWUsIHRoZXJlZm9yZSB3ZSBzYXZlIHRoZW0gaW4gYSBzZXRcbiAgLy8gRWFjaCB2YXJpYWJsZSBuZWVkcyB0byBiZSB1bmlxdWUgYXMgd2VsbCwgd2Ugc2F2ZSB0aGVtIGluIGEgcmVjb3JkIHNvIHdlIGNhbiBpZGVudGlmeSBpZiB0d28gdmFyaWFibGVzIGFyZSB0aGUgc2FtZVxuICBjb25zdCBzY29wZTogU2NvcGUgPSB7XG4gICAgcHJvdmlkZXJTY2hlbWEsXG4gICAgY29uc3RydWN0czogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgdmFyaWFibGVzOiB7fSxcbiAgfTtcblxuICAvLyBHZXQgYWxsIGl0ZW1zIGluIHRoZSBKU09OIGFzIGEgbWFwIG9mIGlkIHRvIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIHRoZSBBU1RcbiAgLy8gV2Ugd2lsbCB1c2UgdGhpcyB0byBjb25zdHJ1Y3QgdGhlIG5vZGVzIGZvciBhIGRlcGVuZGVuY3kgZ3JhcGhcbiAgLy8gV2UgbmVlZCB0byB1c2UgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2UgdGhlIHNhbWUgbm9kZSBoYXMgZGlmZmVyZW50IHJlcHJlc2VudGF0aW9uIGJhc2VkIG9uIGlmIGl0J3MgcmVmZXJlbmNlZCBieSBhbm90aGVyIG9uZVxuICBjb25zdCBub2RlTWFwID0ge1xuICAgIC4uLmZvckVhY2hQcm92aWRlcihzY29wZSwgcGxhbi5wcm92aWRlciwgcHJvdmlkZXIpLFxuICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwidmFyXCIsIHBsYW4udmFyaWFibGUsIHZhcmlhYmxlKSxcbiAgICAvLyBsb2NhbHMgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgLi4uZm9yRWFjaEdsb2JhbChcbiAgICAgIHNjb3BlLFxuICAgICAgXCJsb2NhbFwiLFxuICAgICAgQXJyYXkuaXNBcnJheShwbGFuLmxvY2FscylcbiAgICAgICAgPyBwbGFuLmxvY2Fscy5yZWR1Y2UoKGNhcnJ5LCBsb2NhbHMpID0+ICh7IC4uLmNhcnJ5LCAuLi5sb2NhbHMgfSksIHt9KVxuICAgICAgICA6IHt9LFxuICAgICAgbG9jYWxcbiAgICApLFxuICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwib3V0XCIsIHBsYW4ub3V0cHV0LCBvdXRwdXQpLFxuICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwibW9kdWxlXCIsIHBsYW4ubW9kdWxlLCBtb2R1bGVzKSxcbiAgICAuLi5mb3JFYWNoTmFtZXNwYWNlZChzY29wZSwgcGxhbi5yZXNvdXJjZSwgcmVzb3VyY2UpLFxuICAgIC4uLmZvckVhY2hOYW1lc3BhY2VkKHNjb3BlLCBwbGFuLmRhdGEsIHJlc291cmNlLCBcImRhdGFcIiksXG4gIH07XG5cbiAgY29uc3QgZ3JhcGggPSBuZXcgRGlyZWN0ZWRHcmFwaCgpO1xuICAvLyBBZGQgYWxsIG5vZGVzIHRvIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHNvIHdlIGNhbiBkZXRlY3QgaWYgYW4gZWRnZSBpcyBhZGRlZCBmb3IgYW4gdW5rbm93biBsaW5rXG4gIE9iamVjdC5lbnRyaWVzKG5vZGVNYXApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT5cbiAgICBncmFwaC5hZGROb2RlKGtleSwgeyBjb2RlOiB2YWx1ZSB9KVxuICApO1xuXG4gIC8vIEZpbmRpbmcgcmVmZXJlbmNlcyBiZWNvbWVzIGVhc2llciBvZiB0aGUgdG8gYmUgcmVmZXJlbmNlZCBpZHMgYXJlIGFscmVhZHkga25vd25cbiAgY29uc3Qgbm9kZUlkcyA9IE9iamVjdC5rZXlzKG5vZGVNYXApO1xuICBmdW5jdGlvbiBhZGRFZGdlcyhpZDogc3RyaW5nLCB2YWx1ZTogVGVycmFmb3JtUmVzb3VyY2VCbG9jaykge1xuICAgIGZpbmRVc2VkUmVmZXJlbmNlcyhub2RlSWRzLCB2YWx1ZSkuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFncmFwaC5oYXNEaXJlY3RlZEVkZ2UocmVmLnJlZmVyZW5jZWUuaWQsIGlkKSAmJlxuICAgICAgICBncmFwaC5oYXNOb2RlKHJlZi5yZWZlcmVuY2VlLmlkKSAvLyBpbiBjYXNlIHRoZSByZWZlcmVuY2VlIGlzIGEgZHluYW1pYyB2YXJpYWJsZVxuICAgICAgKSB7XG4gICAgICAgIGlmICghZ3JhcGguaGFzTm9kZShpZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIGRlcGVuZGVuY3kgZ3JhcGggaXMgZXhwZWN0ZWQgdG8gbGluayBmcm9tICR7XG4gICAgICAgICAgICAgIHJlZi5yZWZlcmVuY2VlLmlkXG4gICAgICAgICAgICB9IHRvICR7aWR9IGJ1dCAke2lkfSBkb2VzIG5vdCBleGlzdC4gXG4gICAgICAgICAgICBUaGVzZSBub2RlcyBleGlzdDogJHtncmFwaC5ub2RlcygpLmpvaW4oXCJcXG5cIil9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhcGguYWRkRGlyZWN0ZWRFZGdlKHJlZi5yZWZlcmVuY2VlLmlkLCBpZCwgeyByZWYgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBXZSByZWN1cnNpdmVseSBpbnNwZWN0IGVhY2ggcmVzb3VyY2UgdmFsdWUgdG8gZmluZCByZWZlcmVuY2VzIHRvIG90aGVyIHZhbHVlc1xuICAvLyBXZSBhZGQgdGhlc2UgdG8gYSBkZXBlbmRlbmN5IGdyYXBoIHNvIHRoYXQgdGhlIHByb2dyYW1taW5nIGNvZGUgaGFzIHRoZSByaWdodCBvcmRlclxuICBmdW5jdGlvbiBhZGRHbG9iYWxFZGdlcyhcbiAgICBfc2NvcGU6IFNjb3BlLFxuICAgIF9rZXk6IHN0cmluZyxcbiAgICBpZDogc3RyaW5nLFxuICAgIHZhbHVlOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrXG4gICkge1xuICAgIGFkZEVkZ2VzKGlkLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkUHJvdmlkZXJFZGdlcyhcbiAgICBfc2NvcGU6IFNjb3BlLFxuICAgIF9rZXk6IHN0cmluZyxcbiAgICBpZDogc3RyaW5nLFxuICAgIHZhbHVlOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrXG4gICkge1xuICAgIGFkZEVkZ2VzKGlkLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTmFtZXNwYWNlZEVkZ2VzKFxuICAgIF9zY29wZTogU2NvcGUsXG4gICAgX3R5cGU6IHN0cmluZyxcbiAgICBfa2V5OiBzdHJpbmcsXG4gICAgaWQ6IHN0cmluZyxcbiAgICB2YWx1ZTogVGVycmFmb3JtUmVzb3VyY2VCbG9ja1xuICApIHtcbiAgICBhZGRFZGdlcyhpZCwgdmFsdWUpO1xuICB9XG5cbiAgT2JqZWN0LnZhbHVlcyh7XG4gICAgLi4uZm9yRWFjaFByb3ZpZGVyKHNjb3BlLCBwbGFuLnByb3ZpZGVyLCBhZGRQcm92aWRlckVkZ2VzKSxcbiAgICAuLi5mb3JFYWNoR2xvYmFsKHNjb3BlLCBcInZhclwiLCBwbGFuLnZhcmlhYmxlLCBhZGRHbG9iYWxFZGdlcyksXG4gICAgLy8gbG9jYWxzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgIC4uLmZvckVhY2hHbG9iYWwoXG4gICAgICBzY29wZSxcbiAgICAgIFwibG9jYWxcIixcbiAgICAgIEFycmF5LmlzQXJyYXkocGxhbi5sb2NhbHMpXG4gICAgICAgID8gcGxhbi5sb2NhbHMucmVkdWNlKChjYXJyeSwgbG9jYWxzKSA9PiAoeyAuLi5jYXJyeSwgLi4ubG9jYWxzIH0pLCB7fSlcbiAgICAgICAgOiB7fSxcbiAgICAgIGFkZEdsb2JhbEVkZ2VzXG4gICAgKSxcbiAgICAuLi5mb3JFYWNoR2xvYmFsKHNjb3BlLCBcIm91dFwiLCBwbGFuLm91dHB1dCwgYWRkR2xvYmFsRWRnZXMpLFxuICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwibW9kdWxlXCIsIHBsYW4ubW9kdWxlLCBhZGRHbG9iYWxFZGdlcyksXG4gICAgLi4uZm9yRWFjaE5hbWVzcGFjZWQoc2NvcGUsIHBsYW4ucmVzb3VyY2UsIGFkZE5hbWVzcGFjZWRFZGdlcyksXG4gICAgLi4uZm9yRWFjaE5hbWVzcGFjZWQoc2NvcGUsIHBsYW4uZGF0YSwgYWRkTmFtZXNwYWNlZEVkZ2VzLCBcImRhdGFcIiksXG4gIH0pLmZvckVhY2goKGFkZEVkZ2VzVG9HcmFwaCkgPT4gYWRkRWRnZXNUb0dyYXBoKGdyYXBoKSk7XG5cbiAgLy8gV2UgdHJhdmVyc2UgdGhlIGRlcGVuZGVuY3kgZ3JhcGggdG8gZ2V0IHRoZSB1bm9yZGVyZWQgSlNPTiBub2RlcyBpbnRvIGFuIG9yZGVyZWQgYXJyYXlcbiAgLy8gd2hlcmUgbm8gbm9kZSBpcyByZWZlcmVuY2VkIGJlZm9yZSBpdCdzIGRlZmluZWRcbiAgLy8gQXMgd2UgY2hlY2sgdGhhdCB0aGUgbm9kZXMgb24gYm90aCBlbmRzIG9mIGFuIGVkZ2UgZXhpc3Qgd2UgY2FuIGJlIHN1cmVcbiAgLy8gdGhhdCBubyBpbmZpbml0ZSBsb29wIGV4aXN0cywgdGhlcmUgY2FuIGJlIG5vIHN0cmF5IGRlcGVuZGVuY3kgb24gYSBub2RlXG4gIGNvbnN0IGV4cHJlc3Npb25zOiB0LlN0YXRlbWVudFtdID0gW107XG4gIGxldCBub2Rlc1RvVmlzaXQgPSBbLi4ubm9kZUlkc107XG4gIC8vIFRoaXMgZW5zdXJlcyB3ZSBkZXRlY3QgY3ljbGVzIGFuZCBkb24ndCBlbmQgdXAgaW4gYW4gZW5kbGVzcyBsb29wXG4gIGxldCBub2Rlc1Zpc2l0ZWRUaGlzSXRlcmF0aW9uID0gMDtcbiAgZG8ge1xuICAgIG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gPSAwO1xuICAgIGdyYXBoLmZvckVhY2hOb2RlKChub2RlSWQpID0+IHtcbiAgICAgIGlmICghbm9kZXNUb1Zpc2l0LmluY2x1ZGVzKG5vZGVJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bnJlc29sdmVkRGVwZW5kZW5jaWVzID0gZ3JhcGhcbiAgICAgICAgLmluTmVpZ2hib3JzKG5vZGVJZClcbiAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gbm9kZXNUb1Zpc2l0LmluY2x1ZGVzKGl0ZW0pKTtcblxuICAgICAgaWYgKHVucmVzb2x2ZWREZXBlbmRlbmNpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5vZGVzVG9WaXNpdCA9IG5vZGVzVG9WaXNpdC5maWx0ZXIoKGlkKSA9PiBub2RlSWQgIT09IGlkKTtcbiAgICAgICAgbm9kZXNWaXNpdGVkVGhpc0l0ZXJhdGlvbiA9IG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gKyAxO1xuXG4gICAgICAgIGNvbnN0IGxpc3QgPSBncmFwaC5nZXROb2RlQXR0cmlidXRlKG5vZGVJZCwgXCJjb2RlXCIpKGdyYXBoKTtcbiAgICAgICAgKEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogW2xpc3RdKS5mb3JFYWNoKChpdGVtKSA9PlxuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goaXRlbSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSB3aGlsZSAobm9kZXNUb1Zpc2l0Lmxlbmd0aCA+IDAgJiYgbm9kZXNWaXNpdGVkVGhpc0l0ZXJhdGlvbiAhPSAwKTtcblxuICBjb25zdCBiYWNrZW5kRXhwcmVzc2lvbnMgPSBwbGFuLnRlcnJhZm9ybT8ucmVkdWNlKFxuICAgIChjYXJyeSwgdGVycmFmb3JtKSA9PiBbXG4gICAgICAuLi5jYXJyeSxcbiAgICAgIC4uLmJhY2tlbmRUb0V4cHJlc3Npb24oc2NvcGUsIHRlcnJhZm9ybS5iYWNrZW5kLCBub2RlSWRzKSxcbiAgICBdLFxuICAgIFtdIGFzIHQuU3RhdGVtZW50W11cbiAgKTtcblxuICAvLyBXZSBjb2xsZWN0IGFsbCBtb2R1bGUgc291cmNlc1xuICBjb25zdCBtb2R1bGVSZXF1aXJlbWVudHMgPSBbXG4gICAgLi4ubmV3IFNldChcbiAgICAgIE9iamVjdC52YWx1ZXMocGxhbi5tb2R1bGUgfHwge30pLnJlZHVjZShcbiAgICAgICAgKGNhcnJ5LCBtb2R1bGVCbG9jaykgPT4gW1xuICAgICAgICAgIC4uLmNhcnJ5LFxuICAgICAgICAgIC4uLm1vZHVsZUJsb2NrLnJlZHVjZShcbiAgICAgICAgICAgIChhcnIsIHsgc291cmNlLCB2ZXJzaW9uIH0pID0+IFtcbiAgICAgICAgICAgICAgLi4uYXJyLFxuICAgICAgICAgICAgICB2ZXJzaW9uID8gYCR7c291cmNlfUAke3ZlcnNpb259YCA6IHNvdXJjZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXSBhcyBzdHJpbmdbXVxuICAgICAgICAgICksXG4gICAgICAgIF0sXG4gICAgICAgIFtdIGFzIHN0cmluZ1tdXG4gICAgICApIHx8IFtdXG4gICAgKSxcbiAgXTtcblxuICAvLyBWYXJpYWJsZXMsIE91dHB1dHMsIGFuZCBCYWNrZW5kcyBhcmUgZGVmaW5lZCBpbiB0aGUgQ0RLVEYgcHJvamVjdCBzbyB3ZSBuZWVkIHRvIGltcG9ydCBmcm9tIGl0XG4gIC8vIElmIG5vbmUgYXJlIHVzZWQgd2UgZG9uJ3Qgd2FudCB0byBsZWF2ZSBhIHN0cmF5IGltcG9ydFxuICBjb25zdCBjZGt0ZkltcG9ydHMgPVxuICAgIHBsYW4udGVycmFmb3JtPy5zb21lKCh0ZikgPT4gT2JqZWN0LmtleXModGYuYmFja2VuZCB8fCB7fSkubGVuZ3RoID4gMCkgfHxcbiAgICBPYmplY3Qua2V5cyh7IC4uLnBsYW4udmFyaWFibGUsIC4uLnBsYW4ub3V0cHV0IH0pLmxlbmd0aCA+IDBcbiAgICAgID8gW2Nka3RmSW1wb3J0XVxuICAgICAgOiAoW10gYXMgdC5TdGF0ZW1lbnRbXSk7XG5cbiAgaWYgKE9iamVjdC5rZXlzKHBsYW4udmFyaWFibGUgfHwge30pLmxlbmd0aCA+IDAgJiYgZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIGV4cHJlc3Npb25zWzBdID0gdC5hZGRDb21tZW50KFxuICAgICAgZXhwcmVzc2lvbnNbMF0sXG4gICAgICBcImxlYWRpbmdcIixcbiAgICAgIGBUZXJyYWZvcm0gVmFyaWFibGVzIGFyZSBub3QgYWx3YXlzIHRoZSBiZXN0IGZpdCBmb3IgZ2V0dGluZyBpbnB1dHMgaW4gdGhlIGNvbnRleHQgb2YgVGVycmFmb3JtIENESy5cbllvdSBjYW4gcmVhZCBtb3JlIGFib3V0IHRoaXMgYXQgaHR0cHM6Ly9jZGsudGYvdmFyaWFibGVzYFxuICAgICk7XG4gIH1cblxuICBjb25zdCBwcm92aWRlclJlcXVpcmVtZW50cyA9IGdldFByb3ZpZGVyUmVxdWlyZW1lbnRzKHBsYW4pO1xuXG4gIGNvbnN0IHByb3ZpZGVycyA9IHByb3ZpZGVySW1wb3J0cyhPYmplY3Qua2V5cyhwcm92aWRlclJlcXVpcmVtZW50cykpO1xuICBpZiAocHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICBwcm92aWRlcnNbMF0gPSB0LmFkZENvbW1lbnQoXG4gICAgICBwcm92aWRlcnNbMF0sXG4gICAgICBcImxlYWRpbmdcIixcbiAgICAgIGBQcm92aWRlciBiaW5kaW5ncyBhcmUgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgY2RrdGYgZ2V0LlxuU2VlIGh0dHBzOi8vY2RrLnRmL3Byb3ZpZGVyLWdlbmVyYXRpb24gZm9yIG1vcmUgZGV0YWlscy5gXG4gICAgKTtcbiAgfVxuXG4gIC8vIFdlIGFkZCBhIGNvbW1lbnQgaWYgdGhlcmUgYXJlIHByb3ZpZGVycyB3aXRoIG1pc3Npbmcgc2NoZW1hIGluZm9ybWF0aW9uXG4gIGNvbnN0IHByb3ZpZGVyc0xhY2tpbmdTY2hlbWEgPSBPYmplY3Qua2V5cyhwcm92aWRlclJlcXVpcmVtZW50cykuZmlsdGVyKFxuICAgIChwcm92aWRlck5hbWUpID0+XG4gICAgICAhT2JqZWN0LmtleXMocHJvdmlkZXJTY2hlbWEucHJvdmlkZXJfc2NoZW1hcyB8fCB7fSkuc29tZSgoc2NoZW1hTmFtZSkgPT5cbiAgICAgICAgc2NoZW1hTmFtZS5lbmRzV2l0aChwcm92aWRlck5hbWUpXG4gICAgICApXG4gICk7XG4gIGlmIChwcm92aWRlcnNMYWNraW5nU2NoZW1hLmxlbmd0aCA+IDApIHtcbiAgICBleHByZXNzaW9uc1swXSA9IHQuYWRkQ29tbWVudChcbiAgICAgIGV4cHJlc3Npb25zWzBdLFxuICAgICAgXCJsZWFkaW5nXCIsXG4gICAgICBgVGhlIGZvbGxvd2luZyBwcm92aWRlcnMgYXJlIG1pc3Npbmcgc2NoZW1hIGluZm9ybWF0aW9uIGFuZCBtaWdodCBuZWVkIG1hbnVhbCBhZGp1c3RtZW50cyB0byBzeW50aGVzaXplIGNvcnJlY3RseTogJHtwcm92aWRlcnNMYWNraW5nU2NoZW1hLmpvaW4oXG4gICAgICAgIFwiLCBcIlxuICAgICAgKX0uXG5Gb3IgYSBtb3JlIHByZWNpc2UgY29udmVyc2lvbiBwbGVhc2UgdXNlIHRoZSAtLXByb3ZpZGVyIGZsYWcgaW4gY29udmVydC5gXG4gICAgKTtcbiAgfVxuXG4gIC8vIFdlIHNwbGl0IHVwIHRoZSBnZW5lcmF0ZWQgY29kZSBzbyB0aGF0IHVzZXJzIGNhbiBoYXZlIG1vcmUgY29udHJvbCBvdmVyIHdoYXQgdG8gaW5zZXJ0IHdoZXJlXG4gIHJldHVybiB7XG4gICAgYWxsOiBnZW4oW1xuICAgICAgLi4uY2RrdGZJbXBvcnRzLFxuICAgICAgLi4ucHJvdmlkZXJzLFxuICAgICAgLi4ubW9kdWxlSW1wb3J0cyhwbGFuLm1vZHVsZSksXG4gICAgICAuLi4oKGJhY2tlbmRFeHByZXNzaW9ucyB8fCBbXSkgYXMgYW55KSxcbiAgICAgIC4uLmV4cHJlc3Npb25zLFxuICAgIF0pLFxuICAgIGltcG9ydHM6IGdlbihbXG4gICAgICAuLi5jZGt0ZkltcG9ydHMsXG4gICAgICAuLi5wcm92aWRlcnMsXG4gICAgICAuLi5tb2R1bGVJbXBvcnRzKHBsYW4ubW9kdWxlKSxcbiAgICBdKSxcbiAgICBjb2RlOiBnZW4oWy4uLigoYmFja2VuZEV4cHJlc3Npb25zIHx8IFtdKSBhcyBhbnkpLCAuLi5leHByZXNzaW9uc10pLFxuICAgIHByb3ZpZGVyczogT2JqZWN0LmVudHJpZXMocHJvdmlkZXJSZXF1aXJlbWVudHMpLm1hcCgoW3NvdXJjZSwgdmVyc2lvbl0pID0+XG4gICAgICB2ZXJzaW9uID09PSBcIipcIiA/IHNvdXJjZSA6IGAke3NvdXJjZX1AJHt2ZXJzaW9ufWBcbiAgICApLFxuICAgIG1vZHVsZXM6IG1vZHVsZVJlcXVpcmVtZW50cyxcbiAgICAvLyBXZSB0cmFjayBzb21lIHVzYWdlIGRhdGEgdG8gbWFrZSBpdCBlYXNpZXIgdG8gdW5kZXJzdGFuZCB3aGF0IGlzIHVzZWRcbiAgICBzdGF0czoge1xuICAgICAgbnVtYmVyT2ZNb2R1bGVzOiBtb2R1bGVSZXF1aXJlbWVudHMubGVuZ3RoLFxuICAgICAgbnVtYmVyT2ZQcm92aWRlcnM6IE9iamVjdC5rZXlzKHByb3ZpZGVyUmVxdWlyZW1lbnRzKS5sZW5ndGgsXG4gICAgICByZXNvdXJjZXM6IHJlc291cmNlU3RhdHMocGxhbi5yZXNvdXJjZSB8fCB7fSksXG4gICAgICBkYXRhOiByZXNvdXJjZVN0YXRzKHBsYW4uZGF0YSB8fCB7fSksXG4gICAgICBjb252ZXJ0ZWRMaW5lczogaGNsLnNwbGl0KFwiXFxuXCIpLmxlbmd0aCxcbiAgICB9LFxuICB9O1xufVxuXG50eXBlIEZpbGUgPSB7IGNvbnRlbnRzOiBzdHJpbmc7IGZpbGVOYW1lOiBzdHJpbmcgfTtcbmNvbnN0IHRyYW5zbGF0aW9ucyA9IHtcbiAgdHlwZXNjcmlwdDogKGZpbGU6IEZpbGUpID0+IGZpbGUuY29udGVudHMsXG4gIHB5dGhvbjogKGZpbGU6IEZpbGUpID0+XG4gICAgcm9zZXR0YS50cmFuc2xhdGVUeXBlU2NyaXB0KGZpbGUsIG5ldyByb3NldHRhLlB5dGhvblZpc2l0b3IoKSkudHJhbnNsYXRpb24sXG4gIGphdmE6IChmaWxlOiBGaWxlKSA9PlxuICAgIHJvc2V0dGEudHJhbnNsYXRlVHlwZVNjcmlwdChmaWxlLCBuZXcgcm9zZXR0YS5KYXZhVmlzaXRvcigpKS50cmFuc2xhdGlvbixcbiAgY3NoYXJwOiAoZmlsZTogRmlsZSkgPT5cbiAgICByb3NldHRhLnRyYW5zbGF0ZVR5cGVTY3JpcHQoZmlsZSwgbmV3IHJvc2V0dGEuQ1NoYXJwVmlzaXRvcigpKS50cmFuc2xhdGlvbixcbn07XG5cbnR5cGUgQ29udmVydE9wdGlvbnMgPSB7XG4gIGxhbmd1YWdlOiBrZXlvZiB0eXBlb2YgdHJhbnNsYXRpb25zO1xuICBwcm92aWRlclNjaGVtYTogUHJvdmlkZXJTY2hlbWE7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29udmVydChcbiAgaGNsOiBzdHJpbmcsXG4gIHsgbGFuZ3VhZ2UsIHByb3ZpZGVyU2NoZW1hIH06IENvbnZlcnRPcHRpb25zXG4pIHtcbiAgY29uc3QgZmlsZU5hbWUgPSBcInRlcnJhZm9ybS50ZlwiO1xuICBjb25zdCB0cmFuc2xhdGVyID0gdHJhbnNsYXRpb25zW2xhbmd1YWdlXTtcblxuICBpZiAoIXRyYW5zbGF0ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBsYW5ndWFnZSB1c2VkOiBcIiArIGxhbmd1YWdlKTtcbiAgfVxuICBjb25zdCB0c0NvZGUgPSBhd2FpdCBjb252ZXJ0VG9UeXBlc2NyaXB0KGhjbCwgcHJvdmlkZXJTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIC4uLnRzQ29kZSxcbiAgICBhbGw6IHRyYW5zbGF0ZXIoeyBmaWxlTmFtZSwgY29udGVudHM6IHRzQ29kZS5hbGwgfSksXG4gICAgaW1wb3J0czogdHJhbnNsYXRlcih7IGZpbGVOYW1lLCBjb250ZW50czogdHNDb2RlLmltcG9ydHMgfSksXG4gICAgY29kZTogdHJhbnNsYXRlcih7IGZpbGVOYW1lLCBjb250ZW50czogdHNDb2RlLmNvZGUgfSksXG4gICAgc3RhdHM6IHsgLi4udHNDb2RlLnN0YXRzLCBsYW5ndWFnZSB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVycmFmb3JtQ29uZmlnRnJvbURpcihpbXBvcnRQYXRoOiBzdHJpbmcpIHtcbiAgY29uc3QgYWJzUGF0aCA9IHBhdGgucmVzb2x2ZShpbXBvcnRQYXRoKTtcbiAgY29uc3QgZmlsZUNvbnRlbnRzID0gZ2xvYlxuICAgIC5zeW5jKFwiLi8qLnRmXCIsIHsgY3dkOiBhYnNQYXRoIH0pXG4gICAgLm1hcCgocCkgPT4gZnMucmVhZEZpbGVTeW5jKHBhdGgucmVzb2x2ZShhYnNQYXRoLCBwKSwgXCJ1dGY4XCIpKTtcblxuICByZXR1cm4gZmlsZUNvbnRlbnRzLmpvaW4oXCJcXG5cIik7XG59XG5cbnR5cGUgQ2RrdGZKc29uID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4gJiB7XG4gIHRlcnJhZm9ybVByb3ZpZGVyczogYW55W107XG4gIHRlcnJhZm9ybU1vZHVsZXM6IGFueVtdO1xufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0UHJvamVjdChcbiAgY29tYmluZWRIY2w6IHN0cmluZyxcbiAgaW5wdXRNYWluRmlsZTogc3RyaW5nLFxuICBpbnB1dENka3RmSnNvbjogQ2RrdGZKc29uLFxuICB7IGxhbmd1YWdlLCBwcm92aWRlclNjaGVtYSB9OiBDb252ZXJ0T3B0aW9uc1xuKSB7XG4gIGlmIChsYW5ndWFnZSAhPT0gXCJ0eXBlc2NyaXB0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBsYW5ndWFnZSB1c2VkOiBcIiArIGxhbmd1YWdlKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBpbXBvcnRzLFxuICAgIGNvZGUsXG4gICAgcHJvdmlkZXJzLFxuICAgIG1vZHVsZXM6IHRmTW9kdWxlcyxcbiAgICBzdGF0cyxcbiAgfSA9IGF3YWl0IGNvbnZlcnQoY29tYmluZWRIY2wsIHtcbiAgICBsYW5ndWFnZSxcbiAgICBwcm92aWRlclNjaGVtYSxcbiAgfSk7XG4gIGNvbnN0IGltcG9ydE1haW5GaWxlID0gW2ltcG9ydHMsIGlucHV0TWFpbkZpbGVdLmpvaW4oXCJcXG5cIik7XG4gIGNvbnN0IG91dHB1dE1haW5GaWxlID0gaW1wb3J0TWFpbkZpbGUucmVwbGFjZShcbiAgICBcIi8vIGRlZmluZSByZXNvdXJjZXMgaGVyZVwiLFxuICAgIGNvZGVcbiAgKTtcblxuICBjb25zdCBjZGt0Zkpzb24gPSB7IC4uLmlucHV0Q2RrdGZKc29uIH07XG4gIGNka3RmSnNvbi50ZXJyYWZvcm1Qcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gIGNka3RmSnNvbi50ZXJyYWZvcm1Nb2R1bGVzID0gdGZNb2R1bGVzO1xuXG4gIHJldHVybiB7XG4gICAgY29kZTogcHJldHRpZXIuZm9ybWF0KG91dHB1dE1haW5GaWxlLCB7IHBhcnNlcjogXCJiYWJlbFwiIH0pLFxuICAgIGNka3RmSnNvbixcbiAgICBzdGF0cyxcbiAgfTtcbn1cblxuZXhwb3J0IHsgaXNSZWdpc3RyeU1vZHVsZSB9O1xuIl19