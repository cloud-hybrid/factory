"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs-extra"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const constructs_maker_1 = require("../constructs-maker");
describe("constructsMaker", () => {
    describe("determineGoModuleName", () => {
        let tmpDir;
        let emptySubDir, validSubdir, invalidSubdir;
        beforeAll(async () => {
            tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "cdktf.test"));
            /* test directory layout
             * <tmpDir>
             * ├── go.mod
             * └── subdir
             *     ├── empty
             *     ├── valid
             *     │   └── go.mod
             *     └── invalid
             *         └── go.mod
             */
            emptySubDir = path.join(tmpDir, "subdir", "empty");
            validSubdir = path.join(tmpDir, "subdir", "valid");
            invalidSubdir = path.join(tmpDir, "subdir", "invalid");
            await fs.mkdirs(emptySubDir);
            await fs.mkdirs(validSubdir);
            await fs.mkdirs(invalidSubdir);
            const root = `module cdk.tf/test/go`;
            const valid = `module cdk.tf/test/go-valid-subdir`;
            const invalid = `malformed go mod`;
            await fs.writeFile(path.join(tmpDir, "go.mod"), root);
            await fs.writeFile(path.join(validSubdir, "go.mod"), valid);
            await fs.writeFile(path.join(invalidSubdir, "go.mod"), invalid);
        });
        afterAll(async () => {
            // await fs.remove(tmpDir);
        });
        it("works in root directory", async () => {
            const moduleName = await constructs_maker_1.determineGoModuleName(tmpDir);
            expect(moduleName).toBe("cdk.tf/test/go");
        });
        it("can walk upwards from empty directory", async () => {
            const moduleName = await constructs_maker_1.determineGoModuleName(emptySubDir);
            expect(moduleName).toBe("cdk.tf/test/go/subdir/empty");
        });
        it("works in subdirectory with go.mod", async () => {
            const moduleName = await constructs_maker_1.determineGoModuleName(validSubdir);
            expect(moduleName).toBe("cdk.tf/test/go-valid-subdir");
        });
        it("throws if go.mod is invalid", async () => {
            await expect(constructs_maker_1.determineGoModuleName(invalidSubdir)).rejects.toThrow(`Could not determine the root Go module name. Found ${path.join(invalidSubdir, "go.mod")} but failed to regex match the module name directive`);
        });
        it("works from subdirectory that does not exist yet", async () => {
            const moduleName = await constructs_maker_1.determineGoModuleName(path.join(tmpDir, "subdir", "that", "does", "not", "exist", "yet"));
            expect(moduleName).toBe("cdk.tf/test/go/subdir/that/does/not/exist/yet");
        });
        it("throws if nothing could be found", async () => {
            const dir = "/cdktf-test/this/dir/does/not/exist"; //... and has no go.mod in any parent dir
            await expect(constructs_maker_1.determineGoModuleName(dir)).rejects.toThrow(`Could not determine the root Go module name. No go.mod found in ${dir} and any parent directories`);
        });
    });
    describe("ConstructsMakerProviderTarget", () => {
        it("returns valid package name for Go", () => {
            const target = new constructs_maker_1.ConstructsMakerProviderTarget({
                name: "google-beta",
                fqn: "google-beta",
                source: "google-beta",
                version: "~> 4.0",
            }, constructs_maker_1.Language.GO);
            expect(target.srcMakName).toEqual("google_beta");
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0cy1tYWtlci50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29uc3RydWN0cy1tYWtlci50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUErQjtBQUMvQix1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLDBEQUk2QjtBQUU3QixRQUFRLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxFQUFFO0lBQy9CLFFBQVEsQ0FBQyx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7UUFDckMsSUFBSSxNQUFjLENBQUM7UUFDbkIsSUFBSSxXQUFtQixFQUFFLFdBQW1CLEVBQUUsYUFBcUIsQ0FBQztRQUVwRSxTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDbkIsTUFBTSxHQUFHLE1BQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ2hFOzs7Ozs7Ozs7ZUFTRztZQUNILFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDbkQsV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNuRCxhQUFhLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBRXZELE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM3QixNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDN0IsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRS9CLE1BQU0sSUFBSSxHQUFHLHVCQUF1QixDQUFDO1lBQ3JDLE1BQU0sS0FBSyxHQUFHLG9DQUFvQyxDQUFDO1lBQ25ELE1BQU0sT0FBTyxHQUFHLGtCQUFrQixDQUFDO1lBRW5DLE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN0RCxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDNUQsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2xFLENBQUMsQ0FBQyxDQUFDO1FBRUgsUUFBUSxDQUFDLEtBQUssSUFBSSxFQUFFO1lBQ2xCLDJCQUEyQjtRQUM3QixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyx5QkFBeUIsRUFBRSxLQUFLLElBQUksRUFBRTtZQUN2QyxNQUFNLFVBQVUsR0FBRyxNQUFNLHdDQUFxQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZELE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyx1Q0FBdUMsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNyRCxNQUFNLFVBQVUsR0FBRyxNQUFNLHdDQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzVELE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztRQUN6RCxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxtQ0FBbUMsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNqRCxNQUFNLFVBQVUsR0FBRyxNQUFNLHdDQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzVELE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztRQUN6RCxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyw2QkFBNkIsRUFBRSxLQUFLLElBQUksRUFBRTtZQUMzQyxNQUFNLE1BQU0sQ0FBQyx3Q0FBcUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQ2hFLHNEQUFzRCxJQUFJLENBQUMsSUFBSSxDQUM3RCxhQUFhLEVBQ2IsUUFBUSxDQUNULHNEQUFzRCxDQUN4RCxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsaURBQWlELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDL0QsTUFBTSxVQUFVLEdBQUcsTUFBTSx3Q0FBcUIsQ0FDNUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FDbkUsQ0FBQztZQUNGLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsK0NBQStDLENBQUMsQ0FBQztRQUMzRSxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxrQ0FBa0MsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNoRCxNQUFNLEdBQUcsR0FBRyxxQ0FBcUMsQ0FBQyxDQUFDLHlDQUF5QztZQUM1RixNQUFNLE1BQU0sQ0FBQyx3Q0FBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQ3RELG1FQUFtRSxHQUFHLDZCQUE2QixDQUNwRyxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUNILFFBQVEsQ0FBQywrQkFBK0IsRUFBRSxHQUFHLEVBQUU7UUFDN0MsRUFBRSxDQUFDLG1DQUFtQyxFQUFFLEdBQUcsRUFBRTtZQUMzQyxNQUFNLE1BQU0sR0FBRyxJQUFJLGdEQUE2QixDQUM5QztnQkFDRSxJQUFJLEVBQUUsYUFBYTtnQkFDbkIsR0FBRyxFQUFFLGFBQWE7Z0JBQ2xCLE1BQU0sRUFBRSxhQUFhO2dCQUNyQixPQUFPLEVBQUUsUUFBUTthQUNsQixFQUNELDJCQUFRLENBQUMsRUFBRSxDQUNaLENBQUM7WUFDRixNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNuRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCAqIGFzIG9zIGZyb20gXCJvc1wiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHtcbiAgQ29uc3RydWN0c01ha2VyUHJvdmlkZXJUYXJnZXQsXG4gIGRldGVybWluZUdvTW9kdWxlTmFtZSxcbiAgTGFuZ3VhZ2UsXG59IGZyb20gXCIuLi9jb25zdHJ1Y3RzLW1ha2VyXCI7XG5cbmRlc2NyaWJlKFwiY29uc3RydWN0c01ha2VyXCIsICgpID0+IHtcbiAgZGVzY3JpYmUoXCJkZXRlcm1pbmVHb01vZHVsZU5hbWVcIiwgKCkgPT4ge1xuICAgIGxldCB0bXBEaXI6IHN0cmluZztcbiAgICBsZXQgZW1wdHlTdWJEaXI6IHN0cmluZywgdmFsaWRTdWJkaXI6IHN0cmluZywgaW52YWxpZFN1YmRpcjogc3RyaW5nO1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgIHRtcERpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCBcImNka3RmLnRlc3RcIikpO1xuICAgICAgLyogdGVzdCBkaXJlY3RvcnkgbGF5b3V0XG4gICAgICAgKiA8dG1wRGlyPlxuICAgICAgICog4pSc4pSA4pSAIGdvLm1vZFxuICAgICAgICog4pSU4pSA4pSAIHN1YmRpclxuICAgICAgICogICAgIOKUnOKUgOKUgCBlbXB0eVxuICAgICAgICogICAgIOKUnOKUgOKUgCB2YWxpZFxuICAgICAgICogICAgIOKUgiAgIOKUlOKUgOKUgCBnby5tb2RcbiAgICAgICAqICAgICDilJTilIDilIAgaW52YWxpZFxuICAgICAgICogICAgICAgICDilJTilIDilIAgZ28ubW9kXG4gICAgICAgKi9cbiAgICAgIGVtcHR5U3ViRGlyID0gcGF0aC5qb2luKHRtcERpciwgXCJzdWJkaXJcIiwgXCJlbXB0eVwiKTtcbiAgICAgIHZhbGlkU3ViZGlyID0gcGF0aC5qb2luKHRtcERpciwgXCJzdWJkaXJcIiwgXCJ2YWxpZFwiKTtcbiAgICAgIGludmFsaWRTdWJkaXIgPSBwYXRoLmpvaW4odG1wRGlyLCBcInN1YmRpclwiLCBcImludmFsaWRcIik7XG5cbiAgICAgIGF3YWl0IGZzLm1rZGlycyhlbXB0eVN1YkRpcik7XG4gICAgICBhd2FpdCBmcy5ta2RpcnModmFsaWRTdWJkaXIpO1xuICAgICAgYXdhaXQgZnMubWtkaXJzKGludmFsaWRTdWJkaXIpO1xuXG4gICAgICBjb25zdCByb290ID0gYG1vZHVsZSBjZGsudGYvdGVzdC9nb2A7XG4gICAgICBjb25zdCB2YWxpZCA9IGBtb2R1bGUgY2RrLnRmL3Rlc3QvZ28tdmFsaWQtc3ViZGlyYDtcbiAgICAgIGNvbnN0IGludmFsaWQgPSBgbWFsZm9ybWVkIGdvIG1vZGA7XG5cbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShwYXRoLmpvaW4odG1wRGlyLCBcImdvLm1vZFwiKSwgcm9vdCk7XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUocGF0aC5qb2luKHZhbGlkU3ViZGlyLCBcImdvLm1vZFwiKSwgdmFsaWQpO1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHBhdGguam9pbihpbnZhbGlkU3ViZGlyLCBcImdvLm1vZFwiKSwgaW52YWxpZCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgICAvLyBhd2FpdCBmcy5yZW1vdmUodG1wRGlyKTtcbiAgICB9KTtcblxuICAgIGl0KFwid29ya3MgaW4gcm9vdCBkaXJlY3RvcnlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IGF3YWl0IGRldGVybWluZUdvTW9kdWxlTmFtZSh0bXBEaXIpO1xuICAgICAgZXhwZWN0KG1vZHVsZU5hbWUpLnRvQmUoXCJjZGsudGYvdGVzdC9nb1wiKTtcbiAgICB9KTtcblxuICAgIGl0KFwiY2FuIHdhbGsgdXB3YXJkcyBmcm9tIGVtcHR5IGRpcmVjdG9yeVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGVOYW1lID0gYXdhaXQgZGV0ZXJtaW5lR29Nb2R1bGVOYW1lKGVtcHR5U3ViRGlyKTtcbiAgICAgIGV4cGVjdChtb2R1bGVOYW1lKS50b0JlKFwiY2RrLnRmL3Rlc3QvZ28vc3ViZGlyL2VtcHR5XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJ3b3JrcyBpbiBzdWJkaXJlY3Rvcnkgd2l0aCBnby5tb2RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IGF3YWl0IGRldGVybWluZUdvTW9kdWxlTmFtZSh2YWxpZFN1YmRpcik7XG4gICAgICBleHBlY3QobW9kdWxlTmFtZSkudG9CZShcImNkay50Zi90ZXN0L2dvLXZhbGlkLXN1YmRpclwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwidGhyb3dzIGlmIGdvLm1vZCBpcyBpbnZhbGlkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGV4cGVjdChkZXRlcm1pbmVHb01vZHVsZU5hbWUoaW52YWxpZFN1YmRpcikpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgYENvdWxkIG5vdCBkZXRlcm1pbmUgdGhlIHJvb3QgR28gbW9kdWxlIG5hbWUuIEZvdW5kICR7cGF0aC5qb2luKFxuICAgICAgICAgIGludmFsaWRTdWJkaXIsXG4gICAgICAgICAgXCJnby5tb2RcIlxuICAgICAgICApfSBidXQgZmFpbGVkIHRvIHJlZ2V4IG1hdGNoIHRoZSBtb2R1bGUgbmFtZSBkaXJlY3RpdmVgXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoXCJ3b3JrcyBmcm9tIHN1YmRpcmVjdG9yeSB0aGF0IGRvZXMgbm90IGV4aXN0IHlldFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGVOYW1lID0gYXdhaXQgZGV0ZXJtaW5lR29Nb2R1bGVOYW1lKFxuICAgICAgICBwYXRoLmpvaW4odG1wRGlyLCBcInN1YmRpclwiLCBcInRoYXRcIiwgXCJkb2VzXCIsIFwibm90XCIsIFwiZXhpc3RcIiwgXCJ5ZXRcIilcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9kdWxlTmFtZSkudG9CZShcImNkay50Zi90ZXN0L2dvL3N1YmRpci90aGF0L2RvZXMvbm90L2V4aXN0L3lldFwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwidGhyb3dzIGlmIG5vdGhpbmcgY291bGQgYmUgZm91bmRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGlyID0gXCIvY2RrdGYtdGVzdC90aGlzL2Rpci9kb2VzL25vdC9leGlzdFwiOyAvLy4uLiBhbmQgaGFzIG5vIGdvLm1vZCBpbiBhbnkgcGFyZW50IGRpclxuICAgICAgYXdhaXQgZXhwZWN0KGRldGVybWluZUdvTW9kdWxlTmFtZShkaXIpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIHRoZSByb290IEdvIG1vZHVsZSBuYW1lLiBObyBnby5tb2QgZm91bmQgaW4gJHtkaXJ9IGFuZCBhbnkgcGFyZW50IGRpcmVjdG9yaWVzYFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG4gIGRlc2NyaWJlKFwiQ29uc3RydWN0c01ha2VyUHJvdmlkZXJUYXJnZXRcIiwgKCkgPT4ge1xuICAgIGl0KFwicmV0dXJucyB2YWxpZCBwYWNrYWdlIG5hbWUgZm9yIEdvXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG5ldyBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldChcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiZ29vZ2xlLWJldGFcIixcbiAgICAgICAgICBmcW46IFwiZ29vZ2xlLWJldGFcIixcbiAgICAgICAgICBzb3VyY2U6IFwiZ29vZ2xlLWJldGFcIixcbiAgICAgICAgICB2ZXJzaW9uOiBcIn4+IDQuMFwiLFxuICAgICAgICB9LFxuICAgICAgICBMYW5ndWFnZS5HT1xuICAgICAgKTtcbiAgICAgIGV4cGVjdCh0YXJnZXQuc3JjTWFrTmFtZSkudG9FcXVhbChcImdvb2dsZV9iZXRhXCIpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19