"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLServerProvider = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const ws_1 = __importDefault(require("ws"));
const client_1 = require("@apollo/client");
const utilities_1 = require("@apollo/client/utilities");
const ws_2 = require("@apollo/client/link/ws");
const error_1 = require("@apollo/client/link/error");
const logging_1 = require("../logging");
const ink_1 = require("ink");
const server_1 = require("../server");
const react_1 = __importStar(require("react"));
const subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
const useAsyncEffect = (fun, deps) => {
    react_1.useEffect(() => {
        fun();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
};
exports.GraphQLServerProvider = ({ children, }) => {
    const [client, setClient] = react_1.useState();
    useAsyncEffect(async () => {
        const { port } = await server_1.startServer();
        const webSocketUri = `ws://localhost:${port}/graphql`;
        const wsClient = new subscriptions_transport_ws_1.SubscriptionClient(webSocketUri, {
            reconnect: true,
            connectionCallback: (error) => logging_1.logger.debug(error || "CONNECTED to GraphqlEndpoint"),
        }, ws_1.default);
        wsClient.onError((event) => {
            throw new Error(`Watch could not connect to spawned GraphQL server which handles watching of files and deploying changes: ${event.message}
More debug info can be found in cdktf.log. Enable logging by setting the environment variable CDKTF_DISABLE_LOGGING to false`);
        });
        const wsLink = new ws_2.WebSocketLink(wsClient);
        const httpLink = new client_1.HttpLink({
            uri: `http://localhost:${port}/graphql`,
            fetch: cross_fetch_1.default,
        });
        // Log any GraphQL errors or network error that occurred
        const errorLink = error_1.onError(({ graphQLErrors, networkError }) => {
            if (graphQLErrors)
                graphQLErrors.map(({ message, locations, path }) => logging_1.logger.error(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`));
            if (networkError)
                console.log(`[Network error]: ${networkError}`);
        });
        const networkLink = client_1.split(({ query }) => {
            const definition = utilities_1.getMainDefinition(query);
            return (definition.kind === "OperationDefinition" &&
                definition.operation === "subscription");
        }, wsLink, httpLink);
        const apolloClient = new client_1.ApolloClient({
            link: client_1.from([errorLink, networkLink]),
            cache: new client_1.InMemoryCache(),
        });
        setClient(apolloClient);
    }, []);
    if (!client) {
        return react_1.default.createElement(ink_1.Text, null, "Starting server...");
    }
    return react_1.default.createElement(client_1.ApolloProvider, { client: client }, children);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyZWFjdC50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDhEQUFnQztBQUNoQyw0Q0FBMEM7QUFDMUMsMkNBUXdCO0FBQ3hCLHdEQUE2RDtBQUM3RCwrQ0FBdUQ7QUFDdkQscURBQW9EO0FBQ3BELHdDQUFvQztBQUNwQyw2QkFBMkI7QUFDM0Isc0NBQXdDO0FBQ3hDLCtDQUE4RDtBQUM5RCwyRUFBZ0U7QUFFaEUsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUF3QixFQUFFLElBQWdCLEVBQUUsRUFBRTtJQUNwRSxpQkFBUyxDQUFDLEdBQUcsRUFBRTtRQUNiLEdBQUcsRUFBRSxDQUFDO1FBQ04sdURBQXVEO0lBQ3pELENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQztBQUVXLFFBQUEscUJBQXFCLEdBQUcsQ0FBQyxFQUNwQyxRQUFRLEdBR1QsRUFBRSxFQUFFO0lBQ0gsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsR0FBRyxnQkFBUSxFQUVqQyxDQUFDO0lBQ0osY0FBYyxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3hCLE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxNQUFNLG9CQUFXLEVBQUUsQ0FBQztRQUNyQyxNQUFNLFlBQVksR0FBRyxrQkFBa0IsSUFBSSxVQUFVLENBQUM7UUFFdEQsTUFBTSxRQUFRLEdBQUcsSUFBSSwrQ0FBa0IsQ0FDckMsWUFBWSxFQUNaO1lBQ0UsU0FBUyxFQUFFLElBQUk7WUFDZixrQkFBa0IsRUFBRSxDQUFDLEtBQVUsRUFBRSxFQUFFLENBQ2pDLGdCQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSw4QkFBOEIsQ0FBQztTQUN4RCxFQUNELFlBQVMsQ0FDVixDQUFDO1FBQ0YsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQ2IsNEdBQTRHLEtBQUssQ0FBQyxPQUFPOzZIQUNKLENBQ3RILENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sTUFBTSxHQUFHLElBQUksa0JBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMzQyxNQUFNLFFBQVEsR0FBRyxJQUFJLGlCQUFRLENBQUM7WUFDNUIsR0FBRyxFQUFFLG9CQUFvQixJQUFJLFVBQVU7WUFDdkMsS0FBSyxFQUFMLHFCQUFLO1NBQ04sQ0FBQyxDQUFDO1FBRUgsd0RBQXdEO1FBQ3hELE1BQU0sU0FBUyxHQUFHLGVBQU8sQ0FBQyxDQUFDLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxFQUFFLEVBQUU7WUFDNUQsSUFBSSxhQUFhO2dCQUNmLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUNqRCxnQkFBTSxDQUFDLEtBQUssQ0FDViw2QkFBNkIsT0FBTyxlQUFlLFNBQVMsV0FBVyxJQUFJLEVBQUUsQ0FDOUUsQ0FDRixDQUFDO1lBQ0osSUFBSSxZQUFZO2dCQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLFlBQVksRUFBRSxDQUFDLENBQUM7UUFDcEUsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLFdBQVcsR0FBRyxjQUFLLENBQ3ZCLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFO1lBQ1osTUFBTSxVQUFVLEdBQUcsNkJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDNUMsT0FBTyxDQUNMLFVBQVUsQ0FBQyxJQUFJLEtBQUsscUJBQXFCO2dCQUN6QyxVQUFVLENBQUMsU0FBUyxLQUFLLGNBQWMsQ0FDeEMsQ0FBQztRQUNKLENBQUMsRUFDRCxNQUFNLEVBQ04sUUFBUSxDQUNULENBQUM7UUFFRixNQUFNLFlBQVksR0FBRyxJQUFJLHFCQUFZLENBQUM7WUFDcEMsSUFBSSxFQUFFLGFBQUksQ0FBQyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztZQUNwQyxLQUFLLEVBQUUsSUFBSSxzQkFBYSxFQUFFO1NBQzNCLENBQUMsQ0FBQztRQUNILFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUMxQixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFUCxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1gsT0FBTyw4QkFBQyxVQUFJLDZCQUEwQixDQUFDO0tBQ3hDO0lBRUQsT0FBTyw4QkFBQyx1QkFBYyxJQUFDLE1BQU0sRUFBRSxNQUFNLElBQUcsUUFBUSxDQUFrQixDQUFDO0FBQ3JFLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmZXRjaCBmcm9tIFwiY3Jvc3MtZmV0Y2hcIjtcbmltcG9ydCB7IGRlZmF1bHQgYXMgV2ViU29ja2V0IH0gZnJvbSBcIndzXCI7XG5pbXBvcnQge1xuICBBcG9sbG9DbGllbnQsXG4gIEh0dHBMaW5rLFxuICBJbk1lbW9yeUNhY2hlLFxuICBBcG9sbG9Qcm92aWRlcixcbiAgc3BsaXQsXG4gIGZyb20sXG4gIE5vcm1hbGl6ZWRDYWNoZU9iamVjdCxcbn0gZnJvbSBcIkBhcG9sbG8vY2xpZW50XCI7XG5pbXBvcnQgeyBnZXRNYWluRGVmaW5pdGlvbiB9IGZyb20gXCJAYXBvbGxvL2NsaWVudC91dGlsaXRpZXNcIjtcbmltcG9ydCB7IFdlYlNvY2tldExpbmsgfSBmcm9tIFwiQGFwb2xsby9jbGllbnQvbGluay93c1wiO1xuaW1wb3J0IHsgb25FcnJvciB9IGZyb20gXCJAYXBvbGxvL2NsaWVudC9saW5rL2Vycm9yXCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2luZ1wiO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gXCJpbmtcIjtcbmltcG9ydCB7IHN0YXJ0U2VydmVyIH0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uQ2xpZW50IH0gZnJvbSBcInN1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzXCI7XG5cbmNvbnN0IHVzZUFzeW5jRWZmZWN0ID0gKGZ1bjogKCkgPT4gUHJvbWlzZTx2b2lkPiwgZGVwczogQXJyYXk8YW55PikgPT4ge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bigpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgZGVwcyk7XG59O1xuXG5leHBvcnQgY29uc3QgR3JhcGhRTFNlcnZlclByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG59OiB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59KSA9PiB7XG4gIGNvbnN0IFtjbGllbnQsIHNldENsaWVudF0gPSB1c2VTdGF0ZTxcbiAgICBBcG9sbG9DbGllbnQ8Tm9ybWFsaXplZENhY2hlT2JqZWN0PiB8IHVuZGVmaW5lZFxuICA+KCk7XG4gIHVzZUFzeW5jRWZmZWN0KGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHBvcnQgfSA9IGF3YWl0IHN0YXJ0U2VydmVyKCk7XG4gICAgY29uc3Qgd2ViU29ja2V0VXJpID0gYHdzOi8vbG9jYWxob3N0OiR7cG9ydH0vZ3JhcGhxbGA7XG5cbiAgICBjb25zdCB3c0NsaWVudCA9IG5ldyBTdWJzY3JpcHRpb25DbGllbnQoXG4gICAgICB3ZWJTb2NrZXRVcmksXG4gICAgICB7XG4gICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgY29ubmVjdGlvbkNhbGxiYWNrOiAoZXJyb3I6IGFueSkgPT5cbiAgICAgICAgICBsb2dnZXIuZGVidWcoZXJyb3IgfHwgXCJDT05ORUNURUQgdG8gR3JhcGhxbEVuZHBvaW50XCIpLFxuICAgICAgfSxcbiAgICAgIFdlYlNvY2tldFxuICAgICk7XG4gICAgd3NDbGllbnQub25FcnJvcigoZXZlbnQpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFdhdGNoIGNvdWxkIG5vdCBjb25uZWN0IHRvIHNwYXduZWQgR3JhcGhRTCBzZXJ2ZXIgd2hpY2ggaGFuZGxlcyB3YXRjaGluZyBvZiBmaWxlcyBhbmQgZGVwbG95aW5nIGNoYW5nZXM6ICR7ZXZlbnQubWVzc2FnZX1cbk1vcmUgZGVidWcgaW5mbyBjYW4gYmUgZm91bmQgaW4gY2RrdGYubG9nLiBFbmFibGUgbG9nZ2luZyBieSBzZXR0aW5nIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBDREtURl9ESVNBQkxFX0xPR0dJTkcgdG8gZmFsc2VgXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgd3NMaW5rID0gbmV3IFdlYlNvY2tldExpbmsod3NDbGllbnQpO1xuICAgIGNvbnN0IGh0dHBMaW5rID0gbmV3IEh0dHBMaW5rKHtcbiAgICAgIHVyaTogYGh0dHA6Ly9sb2NhbGhvc3Q6JHtwb3J0fS9ncmFwaHFsYCxcbiAgICAgIGZldGNoLFxuICAgIH0pO1xuXG4gICAgLy8gTG9nIGFueSBHcmFwaFFMIGVycm9ycyBvciBuZXR3b3JrIGVycm9yIHRoYXQgb2NjdXJyZWRcbiAgICBjb25zdCBlcnJvckxpbmsgPSBvbkVycm9yKCh7IGdyYXBoUUxFcnJvcnMsIG5ldHdvcmtFcnJvciB9KSA9PiB7XG4gICAgICBpZiAoZ3JhcGhRTEVycm9ycylcbiAgICAgICAgZ3JhcGhRTEVycm9ycy5tYXAoKHsgbWVzc2FnZSwgbG9jYXRpb25zLCBwYXRoIH0pID0+XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgYFtHcmFwaFFMIGVycm9yXTogTWVzc2FnZTogJHttZXNzYWdlfSwgTG9jYXRpb246ICR7bG9jYXRpb25zfSwgUGF0aDogJHtwYXRofWBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICBpZiAobmV0d29ya0Vycm9yKSBjb25zb2xlLmxvZyhgW05ldHdvcmsgZXJyb3JdOiAke25ldHdvcmtFcnJvcn1gKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG5ldHdvcmtMaW5rID0gc3BsaXQoXG4gICAgICAoeyBxdWVyeSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBnZXRNYWluRGVmaW5pdGlvbihxdWVyeSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZGVmaW5pdGlvbi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIiAmJlxuICAgICAgICAgIGRlZmluaXRpb24ub3BlcmF0aW9uID09PSBcInN1YnNjcmlwdGlvblwiXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgd3NMaW5rLFxuICAgICAgaHR0cExpbmtcbiAgICApO1xuXG4gICAgY29uc3QgYXBvbGxvQ2xpZW50ID0gbmV3IEFwb2xsb0NsaWVudCh7XG4gICAgICBsaW5rOiBmcm9tKFtlcnJvckxpbmssIG5ldHdvcmtMaW5rXSksXG4gICAgICBjYWNoZTogbmV3IEluTWVtb3J5Q2FjaGUoKSxcbiAgICB9KTtcbiAgICBzZXRDbGllbnQoYXBvbGxvQ2xpZW50KTtcbiAgfSwgW10pO1xuXG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIDxUZXh0PlN0YXJ0aW5nIHNlcnZlci4uLjwvVGV4dD47XG4gIH1cblxuICByZXR1cm4gPEFwb2xsb1Byb3ZpZGVyIGNsaWVudD17Y2xpZW50fT57Y2hpbGRyZW59PC9BcG9sbG9Qcm92aWRlcj47XG59O1xuIl19