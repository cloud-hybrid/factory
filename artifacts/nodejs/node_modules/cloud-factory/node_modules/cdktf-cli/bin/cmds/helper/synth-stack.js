"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SynthStack = void 0;
const util_1 = require("../../../lib/util");
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const chalk = __importStar(require("chalk"));
const indent_string_1 = __importDefault(require("indent-string"));
const cdktf_1 = require("cdktf");
const checkpoint_1 = require("../../../lib/checkpoint");
const perf_hooks_1 = require("perf_hooks");
const chalkColour = new chalk.Instance();
class SynthStack {
    static async synth(command, outdir, graceful = false, // will not exit the process but rethrow the error instead
    synthOrigin) {
        // start performance timer
        const startTime = perf_hooks_1.performance.now();
        const isDirectory = (source) => fs.lstatSync(source).isDirectory();
        const getDirectories = (source) => {
            if (!fs.existsSync(source))
                return [];
            return fs
                .readdirSync(source)
                .map((name) => path.join(source, name))
                .filter(isDirectory);
        };
        const existingDirectories = getDirectories(path.join(outdir, cdktf_1.Manifest.stacksFolder));
        try {
            await util_1.shell(command, [], {
                shell: true,
                env: {
                    ...process.env,
                    CDKTF_OUTDIR: outdir,
                    CDKTF_CONTINUE_SYNTH_ON_ERROR_ANNOTATIONS: "true",
                },
            });
        }
        catch (e) {
            const errorOutput = chalkColour `{redBright cdktf encountered an error while synthesizing}

Synth command: {blue ${command}}
Error:         {redBright ${e.message}}
${e.stderr
                ? chalkColour `
Command output on stderr:

{dim ${indent_string_1.default(e.stderr, 4)}}
`
                : ""}
${e.stdout
                ? chalkColour `
Command output on stdout:

{dim ${indent_string_1.default(e.stdout, 4)}}
`
                : ""}`;
            await this.synthErrorTelemetry(synthOrigin);
            if (graceful) {
                e.errorOutput = errorOutput;
                throw e;
            }
            console.error(errorOutput);
            process.exit(1);
        }
        if (!(await fs.pathExists(path.join(outdir, cdktf_1.Manifest.fileName)))) {
            const errorMessage = `ERROR: synthesis failed, app expected to create "${outdir}/${cdktf_1.Manifest.fileName}"`;
            if (graceful) {
                throw new Error(errorMessage);
            }
            console.error(errorMessage);
            process.exit(1);
        }
        // end performance timer
        const endTime = perf_hooks_1.performance.now();
        const stacks = [];
        const manifest = JSON.parse(fs.readFileSync(path.join(outdir, cdktf_1.Manifest.fileName)).toString());
        for (const stackName in manifest.stacks) {
            const stack = manifest.stacks[stackName];
            const filePath = path.join(outdir, stack.synthesizedStackPath);
            const jsonContent = JSON.parse(fs.readFileSync(filePath).toString());
            stacks.push({
                ...stack,
                workingDirectory: path.join(outdir, stack.workingDirectory),
                content: JSON.stringify(jsonContent, null, 2),
            });
        }
        await this.synthTelemetry(endTime - startTime, stacks, synthOrigin);
        if (stacks.length === 0) {
            console.error("ERROR: No Terraform code synthesized.");
        }
        const stackNames = stacks.map((s) => s.name);
        const orphanedDirectories = existingDirectories.filter((e) => !stackNames.includes(path.basename(e)));
        for (const orphanedDirectory of orphanedDirectories) {
            fs.rmdirSync(orphanedDirectory, { recursive: true });
        }
        return stacks;
    }
    static async synthTelemetry(totalTime, stacks, synthOrigin) {
        await checkpoint_1.sendTelemetry("synth", {
            totalTime: totalTime,
            synthOrigin,
            stackMetadata: stacks.map((stack) => JSON.parse(stack.content)["//"].metadata),
        });
    }
    static async synthErrorTelemetry(synthOrigin) {
        await checkpoint_1.sendTelemetry("synth", { error: true, synthOrigin });
    }
}
exports.SynthStack = SynthStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ludGgtc3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzeW50aC1zdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNENBQTBDO0FBQzFDLDZDQUErQjtBQUMvQiwyQ0FBNkI7QUFDN0IsNkNBQStCO0FBQy9CLGtFQUF5QztBQUN6QyxpQ0FBd0U7QUFDeEUsd0RBQXdEO0FBQ3hELDJDQUF5QztBQUV6QyxNQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQWlCekMsTUFBYSxVQUFVO0lBQ2QsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQ3ZCLE9BQWUsRUFDZixNQUFjLEVBQ2QsUUFBUSxHQUFHLEtBQUssRUFBRSwwREFBMEQ7SUFDNUUsV0FBeUI7UUFFekIsMEJBQTBCO1FBQzFCLE1BQU0sU0FBUyxHQUFHLHdCQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFcEMsTUFBTSxXQUFXLEdBQUcsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDM0UsTUFBTSxjQUFjLEdBQUcsQ0FBQyxNQUFjLEVBQUUsRUFBRTtZQUN4QyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUM7Z0JBQUUsT0FBTyxFQUFFLENBQUM7WUFDdEMsT0FBTyxFQUFFO2lCQUNOLFdBQVcsQ0FBQyxNQUFNLENBQUM7aUJBQ25CLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ3RDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN6QixDQUFDLENBQUM7UUFFRixNQUFNLG1CQUFtQixHQUFHLGNBQWMsQ0FDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsZ0JBQVEsQ0FBQyxZQUFZLENBQUMsQ0FDekMsQ0FBQztRQUVGLElBQUk7WUFDRixNQUFNLFlBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFO2dCQUN2QixLQUFLLEVBQUUsSUFBSTtnQkFDWCxHQUFHLEVBQUU7b0JBQ0gsR0FBRyxPQUFPLENBQUMsR0FBRztvQkFDZCxZQUFZLEVBQUUsTUFBTTtvQkFDcEIseUNBQXlDLEVBQUUsTUFBTTtpQkFDbEQ7YUFDRixDQUFDLENBQUM7U0FDSjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFBOzt1QkFFZCxPQUFPOzRCQUNGLENBQUMsQ0FBQyxPQUFPO0VBRW5DLENBQUMsQ0FBQyxNQUFNO2dCQUNOLENBQUMsQ0FBQyxXQUFXLENBQUE7OztPQUdWLHVCQUFZLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7Q0FDL0I7Z0JBQ0csQ0FBQyxDQUFDLEVBQ047RUFFRSxDQUFDLENBQUMsTUFBTTtnQkFDTixDQUFDLENBQUMsV0FBVyxDQUFBOzs7T0FHVix1QkFBWSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0NBQy9CO2dCQUNHLENBQUMsQ0FBQyxFQUNOLEVBQUUsQ0FBQztZQUNHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzVDLElBQUksUUFBUSxFQUFFO2dCQUNaLENBQUMsQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO2dCQUM1QixNQUFNLENBQUMsQ0FBQzthQUNUO1lBQ0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUMzQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pCO1FBRUQsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLGdCQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2hFLE1BQU0sWUFBWSxHQUFHLG9EQUFvRCxNQUFNLElBQUksZ0JBQVEsQ0FBQyxRQUFRLEdBQUcsQ0FBQztZQUN4RyxJQUFJLFFBQVEsRUFBRTtnQkFDWixNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQy9CO1lBQ0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUM1QixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pCO1FBRUQsd0JBQXdCO1FBQ3hCLE1BQU0sT0FBTyxHQUFHLHdCQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFbEMsTUFBTSxNQUFNLEdBQXVCLEVBQUUsQ0FBQztRQUN0QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUN6QixFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLGdCQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FDakQsQ0FBQztRQUVsQixLQUFLLE1BQU0sU0FBUyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUU7WUFDdkMsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUN6QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztZQUMvRCxNQUFNLFdBQVcsR0FBNkIsSUFBSSxDQUFDLEtBQUssQ0FDdEQsRUFBRSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FDckMsQ0FBQztZQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ1YsR0FBRyxLQUFLO2dCQUNSLGdCQUFnQixFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQztnQkFDM0QsT0FBTyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7YUFDOUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxHQUFHLFNBQVMsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFFcEUsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixPQUFPLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7U0FDeEQ7UUFFRCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0MsTUFBTSxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLENBQ3BELENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUM5QyxDQUFDO1FBRUYsS0FBSyxNQUFNLGlCQUFpQixJQUFJLG1CQUFtQixFQUFFO1lBQ25ELEVBQUUsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUN0RDtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxNQUFNLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FDaEMsU0FBaUIsRUFDakIsTUFBMEIsRUFDMUIsV0FBeUI7UUFFekIsTUFBTSwwQkFBYSxDQUFDLE9BQU8sRUFBRTtZQUMzQixTQUFTLEVBQUUsU0FBUztZQUNwQixXQUFXO1lBQ1gsYUFBYSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQ3ZCLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQ3BEO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLE1BQU0sQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsV0FBeUI7UUFDL0QsTUFBTSwwQkFBYSxDQUFDLE9BQU8sRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUM3RCxDQUFDO0NBQ0Y7QUFqSUQsZ0NBaUlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hlbGwgfSBmcm9tIFwiLi4vLi4vLi4vbGliL3V0aWxcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgaW5kZW50U3RyaW5nIGZyb20gXCJpbmRlbnQtc3RyaW5nXCI7XG5pbXBvcnQgeyBNYW5pZmVzdCwgU3RhY2tNYW5pZmVzdCwgVGVycmFmb3JtU3RhY2tNZXRhZGF0YSB9IGZyb20gXCJjZGt0ZlwiO1xuaW1wb3J0IHsgc2VuZFRlbGVtZXRyeSB9IGZyb20gXCIuLi8uLi8uLi9saWIvY2hlY2twb2ludFwiO1xuaW1wb3J0IHsgcGVyZm9ybWFuY2UgfSBmcm9tIFwicGVyZl9ob29rc1wiO1xuXG5jb25zdCBjaGFsa0NvbG91ciA9IG5ldyBjaGFsay5JbnN0YW5jZSgpO1xuXG5pbnRlcmZhY2UgU3ludGhlc2l6ZWRTdGFja01ldGFkYXRhIHtcbiAgXCIvL1wiPzogeyBba2V5OiBzdHJpbmddOiBUZXJyYWZvcm1TdGFja01ldGFkYXRhIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3ludGhlc2l6ZWRTdGFjayBleHRlbmRzIFN0YWNrTWFuaWZlc3Qge1xuICBjb250ZW50OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBNYW5pZmVzdEpzb24ge1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIHN0YWNrczogU3RhY2tNYW5pZmVzdFtdO1xufVxuXG50eXBlIFN5bnRoT3JpZ2luID0gXCJ3YXRjaFwiO1xuXG5leHBvcnQgY2xhc3MgU3ludGhTdGFjayB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgc3ludGgoXG4gICAgY29tbWFuZDogc3RyaW5nLFxuICAgIG91dGRpcjogc3RyaW5nLFxuICAgIGdyYWNlZnVsID0gZmFsc2UsIC8vIHdpbGwgbm90IGV4aXQgdGhlIHByb2Nlc3MgYnV0IHJldGhyb3cgdGhlIGVycm9yIGluc3RlYWRcbiAgICBzeW50aE9yaWdpbj86IFN5bnRoT3JpZ2luXG4gICk6IFByb21pc2U8U3ludGhlc2l6ZWRTdGFja1tdPiB7XG4gICAgLy8gc3RhcnQgcGVyZm9ybWFuY2UgdGltZXJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGNvbnN0IGlzRGlyZWN0b3J5ID0gKHNvdXJjZTogc3RyaW5nKSA9PiBmcy5sc3RhdFN5bmMoc291cmNlKS5pc0RpcmVjdG9yeSgpO1xuICAgIGNvbnN0IGdldERpcmVjdG9yaWVzID0gKHNvdXJjZTogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc291cmNlKSkgcmV0dXJuIFtdO1xuICAgICAgcmV0dXJuIGZzXG4gICAgICAgIC5yZWFkZGlyU3luYyhzb3VyY2UpXG4gICAgICAgIC5tYXAoKG5hbWUpID0+IHBhdGguam9pbihzb3VyY2UsIG5hbWUpKVxuICAgICAgICAuZmlsdGVyKGlzRGlyZWN0b3J5KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXhpc3RpbmdEaXJlY3RvcmllcyA9IGdldERpcmVjdG9yaWVzKFxuICAgICAgcGF0aC5qb2luKG91dGRpciwgTWFuaWZlc3Quc3RhY2tzRm9sZGVyKVxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2hlbGwoY29tbWFuZCwgW10sIHtcbiAgICAgICAgc2hlbGw6IHRydWUsXG4gICAgICAgIGVudjoge1xuICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgIENES1RGX09VVERJUjogb3V0ZGlyLFxuICAgICAgICAgIENES1RGX0NPTlRJTlVFX1NZTlRIX09OX0VSUk9SX0FOTk9UQVRJT05TOiBcInRydWVcIiwgLy8gd2Ugd2FudCB0byBkaXNwbGF5IHRoZSBlcnJvcnMgb3Vyc2VsdmVzXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnJvck91dHB1dCA9IGNoYWxrQ29sb3VyYHtyZWRCcmlnaHQgY2RrdGYgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgc3ludGhlc2l6aW5nfVxuXG5TeW50aCBjb21tYW5kOiB7Ymx1ZSAke2NvbW1hbmR9fVxuRXJyb3I6ICAgICAgICAge3JlZEJyaWdodCAke2UubWVzc2FnZX19XG4ke1xuICBlLnN0ZGVyclxuICAgID8gY2hhbGtDb2xvdXJgXG5Db21tYW5kIG91dHB1dCBvbiBzdGRlcnI6XG5cbntkaW0gJHtpbmRlbnRTdHJpbmcoZS5zdGRlcnIsIDQpfX1cbmBcbiAgICA6IFwiXCJcbn1cbiR7XG4gIGUuc3Rkb3V0XG4gICAgPyBjaGFsa0NvbG91cmBcbkNvbW1hbmQgb3V0cHV0IG9uIHN0ZG91dDpcblxue2RpbSAke2luZGVudFN0cmluZyhlLnN0ZG91dCwgNCl9fVxuYFxuICAgIDogXCJcIlxufWA7XG4gICAgICBhd2FpdCB0aGlzLnN5bnRoRXJyb3JUZWxlbWV0cnkoc3ludGhPcmlnaW4pO1xuICAgICAgaWYgKGdyYWNlZnVsKSB7XG4gICAgICAgIGUuZXJyb3JPdXRwdXQgPSBlcnJvck91dHB1dDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JPdXRwdXQpO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5qb2luKG91dGRpciwgTWFuaWZlc3QuZmlsZU5hbWUpKSkpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBFUlJPUjogc3ludGhlc2lzIGZhaWxlZCwgYXBwIGV4cGVjdGVkIHRvIGNyZWF0ZSBcIiR7b3V0ZGlyfS8ke01hbmlmZXN0LmZpbGVOYW1lfVwiYDtcbiAgICAgIGlmIChncmFjZWZ1bCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG5cbiAgICAvLyBlbmQgcGVyZm9ybWFuY2UgdGltZXJcbiAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBjb25zdCBzdGFja3M6IFN5bnRoZXNpemVkU3RhY2tbXSA9IFtdO1xuICAgIGNvbnN0IG1hbmlmZXN0ID0gSlNPTi5wYXJzZShcbiAgICAgIGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4ob3V0ZGlyLCBNYW5pZmVzdC5maWxlTmFtZSkpLnRvU3RyaW5nKClcbiAgICApIGFzIE1hbmlmZXN0SnNvbjtcblxuICAgIGZvciAoY29uc3Qgc3RhY2tOYW1lIGluIG1hbmlmZXN0LnN0YWNrcykge1xuICAgICAgY29uc3Qgc3RhY2sgPSBtYW5pZmVzdC5zdGFja3Nbc3RhY2tOYW1lXTtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKG91dGRpciwgc3RhY2suc3ludGhlc2l6ZWRTdGFja1BhdGgpO1xuICAgICAgY29uc3QganNvbkNvbnRlbnQ6IFN5bnRoZXNpemVkU3RhY2tNZXRhZGF0YSA9IEpTT04ucGFyc2UoXG4gICAgICAgIGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCkudG9TdHJpbmcoKVxuICAgICAgKTtcbiAgICAgIHN0YWNrcy5wdXNoKHtcbiAgICAgICAgLi4uc3RhY2ssXG4gICAgICAgIHdvcmtpbmdEaXJlY3Rvcnk6IHBhdGguam9pbihvdXRkaXIsIHN0YWNrLndvcmtpbmdEaXJlY3RvcnkpLFxuICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShqc29uQ29udGVudCwgbnVsbCwgMiksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnN5bnRoVGVsZW1ldHJ5KGVuZFRpbWUgLSBzdGFydFRpbWUsIHN0YWNrcywgc3ludGhPcmlnaW4pO1xuXG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFUlJPUjogTm8gVGVycmFmb3JtIGNvZGUgc3ludGhlc2l6ZWQuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWNrTmFtZXMgPSBzdGFja3MubWFwKChzKSA9PiBzLm5hbWUpO1xuICAgIGNvbnN0IG9ycGhhbmVkRGlyZWN0b3JpZXMgPSBleGlzdGluZ0RpcmVjdG9yaWVzLmZpbHRlcihcbiAgICAgIChlKSA9PiAhc3RhY2tOYW1lcy5pbmNsdWRlcyhwYXRoLmJhc2VuYW1lKGUpKVxuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IG9ycGhhbmVkRGlyZWN0b3J5IG9mIG9ycGhhbmVkRGlyZWN0b3JpZXMpIHtcbiAgICAgIGZzLnJtZGlyU3luYyhvcnBoYW5lZERpcmVjdG9yeSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgc3ludGhUZWxlbWV0cnkoXG4gICAgdG90YWxUaW1lOiBudW1iZXIsXG4gICAgc3RhY2tzOiBTeW50aGVzaXplZFN0YWNrW10sXG4gICAgc3ludGhPcmlnaW4/OiBTeW50aE9yaWdpblxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBzZW5kVGVsZW1ldHJ5KFwic3ludGhcIiwge1xuICAgICAgdG90YWxUaW1lOiB0b3RhbFRpbWUsXG4gICAgICBzeW50aE9yaWdpbixcbiAgICAgIHN0YWNrTWV0YWRhdGE6IHN0YWNrcy5tYXAoXG4gICAgICAgIChzdGFjaykgPT4gSlNPTi5wYXJzZShzdGFjay5jb250ZW50KVtcIi8vXCJdLm1ldGFkYXRhXG4gICAgICApLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhc3luYyBzeW50aEVycm9yVGVsZW1ldHJ5KHN5bnRoT3JpZ2luPzogU3ludGhPcmlnaW4pIHtcbiAgICBhd2FpdCBzZW5kVGVsZW1ldHJ5KFwic3ludGhcIiwgeyBlcnJvcjogdHJ1ZSwgc3ludGhPcmlnaW4gfSk7XG4gIH1cbn1cbiJdfQ==