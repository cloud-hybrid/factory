"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeSystem = void 0;
const jsii = require("@jsii/spec");
const fs = require("fs-extra");
const path = require("path");
const assembly_1 = require("./assembly");
const class_1 = require("./class");
const enum_1 = require("./enum");
const interface_1 = require("./interface");
const util_1 = require("./util");
class TypeSystem {
    constructor() {
        /**
         * All assemblies in this type system.
         */
        this.assemblies = new Array();
        /**
         * The "root" assemblies (ones that loaded explicitly via a "load" call).
         */
        this.roots = new Array();
        this._assemblyLookup = {};
    }
    /**
     * Load all JSII dependencies of the given NPM package directory.
     *
     * The NPM package itself does *not* have to be a jsii package, and does
     * NOT have to declare a JSII dependency on any of the packages.
     */
    async loadNpmDependencies(packageRoot, options = {}) {
        const pkg = await fs.readJson(path.resolve(packageRoot, 'package.json'));
        for (const dep of dependenciesOf(pkg)) {
            if (util_1.isBuiltinModule(dep)) {
                continue;
            }
            // eslint-disable-next-line no-await-in-loop
            const depDir = await util_1.findDependencyDirectory(dep, packageRoot);
            // eslint-disable-next-line no-await-in-loop
            const depPkgJson = await fs.readJson(path.join(depDir, 'package.json'));
            if (!depPkgJson.jsii) {
                continue;
            }
            // eslint-disable-next-line no-await-in-loop
            await this.loadModule(depDir, options);
        }
    }
    /**
     * Loads a jsii module or a single .jsii file into the type system.
     *
     * If `fileOrDirectory` is a directory, it will be treated as a jsii npm module,
     * and its dependencies (as determined by its 'package.json' file) will be loaded
     * as well.
     *
     * If `fileOrDirectory` is a file, it will be treated as a single .jsii file.
     * No dependencies will be loaded. You almost never want this.
     *
     * Not validating makes the difference between loading assemblies with lots
     * of dependencies (such as app-delivery) in 90ms vs 3500ms.
     *
     * @param fileOrDirectory A .jsii file path or a module directory
     * @param validate Whether or not to validate the assembly while loading it.
     */
    async load(fileOrDirectory, options = {}) {
        if ((await fs.stat(fileOrDirectory)).isDirectory()) {
            return this.loadModule(fileOrDirectory, options);
        }
        return this.loadFile(fileOrDirectory, { ...options, isRoot: true });
    }
    async loadModule(dir, options = {}) {
        const out = await _loadModule.call(this, dir, true);
        if (!out) {
            throw new Error(`Unable to load module from directory: ${dir}`);
        }
        return out;
        async function _loadModule(moduleDirectory, isRoot = false) {
            const filePath = path.join(moduleDirectory, 'package.json');
            const pkg = JSON.parse(await fs.readFile(filePath, { encoding: 'utf-8' }));
            if (!pkg.jsii) {
                throw new Error(`No "jsii" section in ${filePath}`);
            }
            // Load the assembly, but don't recurse if we already have an assembly with the same name.
            // Validation is not an insignificant time sink, and loading IS insignificant, so do a
            // load without validation first. This saves about 2/3rds of processing time.
            const asm = await this.loadAssembly(path.join(moduleDirectory, '.jsii'), false);
            if (this.includesAssembly(asm.name)) {
                const existing = this.findAssembly(asm.name);
                if (existing.version !== asm.version) {
                    throw new Error(`Conflicting versions of ${asm.name} in type system: previously loaded ${existing.version}, trying to load ${asm.version}`);
                }
                // Make sure that we mark this thing as root after all if it wasn't yet.
                if (isRoot) {
                    this.addRoot(asm);
                }
                return existing;
            }
            if (options.validate !== false) {
                asm.validate();
            }
            const root = this.addAssembly(asm, { isRoot });
            // Using || instead of ?? because npmjs.com will alter the package.json file and possibly put `false` in pkg.bundleDependencies.
            // This is actually non compliant to the package.json specification, but that's how it is...
            const bundled = pkg.bundledDependencies || pkg.bundleDependencies || [];
            for (const name of dependenciesOf(pkg)) {
                if (bundled.includes(name)) {
                    continue;
                }
                // eslint-disable-next-line no-await-in-loop
                const depDir = await util_1.findDependencyDirectory(name, moduleDirectory);
                // eslint-disable-next-line no-await-in-loop
                await _loadModule.call(this, depDir);
            }
            return root;
        }
    }
    async loadFile(file, options = {}) {
        const assembly = await this.loadAssembly(file, options.validate !== false);
        return this.addAssembly(assembly, options);
    }
    addAssembly(asm, options = {}) {
        if (asm.system !== this) {
            throw new Error('Assembly has been created for different typesystem');
        }
        if (!this._assemblyLookup[asm.name]) {
            this._assemblyLookup[asm.name] = asm;
            this.assemblies.push(asm);
        }
        if (options.isRoot !== false) {
            this.addRoot(asm);
        }
        return asm;
    }
    /**
     * Determines whether this TypeSystem includes a given assembly.
     *
     * @param name the name of the assembly being looked for.
     */
    includesAssembly(name) {
        return name in this._assemblyLookup;
    }
    isRoot(name) {
        return this.roots.map((r) => r.name).includes(name);
    }
    findAssembly(name) {
        const ret = this.tryFindAssembly(name);
        if (!ret) {
            throw new Error(`Assembly "${name}" not found`);
        }
        return ret;
    }
    tryFindAssembly(name) {
        return this._assemblyLookup[name];
    }
    findFqn(fqn) {
        const [assembly] = fqn.split('.');
        const asm = this.findAssembly(assembly);
        return asm.findType(fqn);
    }
    tryFindFqn(fqn) {
        const [assembly] = fqn.split('.');
        const asm = this.tryFindAssembly(assembly);
        return asm === null || asm === void 0 ? void 0 : asm.tryFindType(fqn);
    }
    findClass(fqn) {
        const type = this.findFqn(fqn);
        if (!(type instanceof class_1.ClassType)) {
            throw new Error(`FQN ${fqn} is not a class`);
        }
        return type;
    }
    findInterface(fqn) {
        const type = this.findFqn(fqn);
        if (!(type instanceof interface_1.InterfaceType)) {
            throw new Error(`FQN ${fqn} is not an interface`);
        }
        return type;
    }
    findEnum(fqn) {
        const type = this.findFqn(fqn);
        if (!(type instanceof enum_1.EnumType)) {
            throw new Error(`FQN ${fqn} is not an enum`);
        }
        return type;
    }
    /**
     * All methods in the type system.
     */
    get methods() {
        const getMethods = (mod) => {
            return [
                ...flatMap(mod.submodules, getMethods),
                ...flatMap(mod.interfaces, (iface) => iface.ownMethods),
                ...flatMap(mod.classes, (clazz) => clazz.ownMethods),
            ];
        };
        return flatMap(this.assemblies, getMethods);
    }
    /**
     * All properties in the type system.
     */
    get properties() {
        const getProperties = (mod) => {
            return [
                ...flatMap(mod.submodules, getProperties),
                ...flatMap(mod.interfaces, (iface) => iface.ownProperties),
                ...flatMap(mod.classes, (clazz) => clazz.ownProperties),
            ];
        };
        return flatMap(this.assemblies, getProperties);
    }
    /**
     * All classes in the type system.
     */
    get classes() {
        const out = new Array();
        this.assemblies.forEach((a) => {
            out.push(...collectTypes(a, (item) => item.classes));
        });
        return out;
    }
    /**
     * All interfaces in the type system.
     */
    get interfaces() {
        const out = new Array();
        this.assemblies.forEach((a) => {
            out.push(...collectTypes(a, (item) => item.interfaces));
        });
        return out;
    }
    /**
     * All enums in the type system.
     */
    get enums() {
        const out = new Array();
        this.assemblies.forEach((a) => {
            out.push(...collectTypes(a, (item) => item.enums));
        });
        return out;
    }
    /**
     * Load an assembly without adding it to the typesystem
     * @param file Assembly file to load
     * @param validate Whether to validate the assembly or just assume it matches the schema
     */
    async loadAssembly(file, validate = true) {
        const spec = JSON.parse(await fs.readFile(file, { encoding: 'utf-8' }));
        const ass = validate
            ? jsii.validateAssembly(spec)
            : spec;
        return new assembly_1.Assembly(this, ass);
    }
    addRoot(asm) {
        if (!this.roots.map((r) => r.name).includes(asm.name)) {
            this.roots.push(asm);
        }
    }
}
exports.TypeSystem = TypeSystem;
function dependenciesOf(packageJson) {
    var _a, _b;
    const deps = new Set();
    Object.keys((_a = packageJson.dependencies) !== null && _a !== void 0 ? _a : {}).forEach(deps.add.bind(deps));
    Object.keys((_b = packageJson.peerDependencies) !== null && _b !== void 0 ? _b : {}).forEach(deps.add.bind(deps));
    return Array.from(deps);
}
function collectTypes(module, getter) {
    const result = new Array();
    for (const submodule of module.submodules) {
        result.push(...collectTypes(submodule, getter));
    }
    result.push(...getter(module));
    return result;
}
function flatMap(collection, mapper) {
    return collection
        .map(mapper)
        .reduce((acc, elt) => acc.concat(elt), new Array());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1zeXN0ZW0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0eXBlLXN5c3RlbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBbUM7QUFDbkMsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUU3Qix5Q0FBc0M7QUFDdEMsbUNBQW9DO0FBQ3BDLGlDQUFrQztBQUNsQywyQ0FBNEM7QUFLNUMsaUNBQWtFO0FBRWxFLE1BQWEsVUFBVTtJQUF2QjtRQUNFOztXQUVHO1FBQ2EsZUFBVSxHQUFHLElBQUksS0FBSyxFQUFZLENBQUM7UUFFbkQ7O1dBRUc7UUFDYSxVQUFLLEdBQUcsSUFBSSxLQUFLLEVBQVksQ0FBQztRQUU3QixvQkFBZSxHQUFpQyxFQUFFLENBQUM7SUEwU3RFLENBQUM7SUF4U0M7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsbUJBQW1CLENBQzlCLFdBQW1CLEVBQ25CLFVBQWtDLEVBQUU7UUFFcEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFFekUsS0FBSyxNQUFNLEdBQUcsSUFBSSxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDckMsSUFBSSxzQkFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUN4QixTQUFTO2FBQ1Y7WUFFRCw0Q0FBNEM7WUFDNUMsTUFBTSxNQUFNLEdBQUcsTUFBTSw4QkFBdUIsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFFL0QsNENBQTRDO1lBQzVDLE1BQU0sVUFBVSxHQUFHLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3hFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFO2dCQUNwQixTQUFTO2FBQ1Y7WUFFRCw0Q0FBNEM7WUFDNUMsTUFBTSxJQUFJLENB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QUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLEtBQUssRUFBSyxDQUFDLENBQUM7QUFDM0QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGpzaWkgZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBBc3NlbWJseSB9IGZyb20gJy4vYXNzZW1ibHknO1xuaW1wb3J0IHsgQ2xhc3NUeXBlIH0gZnJvbSAnLi9jbGFzcyc7XG5pbXBvcnQgeyBFbnVtVHlwZSB9IGZyb20gJy4vZW51bSc7XG5pbXBvcnQgeyBJbnRlcmZhY2VUeXBlIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgTWV0aG9kIH0gZnJvbSAnLi9tZXRob2QnO1xuaW1wb3J0IHsgTW9kdWxlTGlrZSB9IGZyb20gJy4vbW9kdWxlLWxpa2UnO1xuaW1wb3J0IHsgUHJvcGVydHkgfSBmcm9tICcuL3Byb3BlcnR5JztcbmltcG9ydCB7IFR5cGUgfSBmcm9tICcuL3R5cGUnO1xuaW1wb3J0IHsgZmluZERlcGVuZGVuY3lEaXJlY3RvcnksIGlzQnVpbHRpbk1vZHVsZSB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBUeXBlU3lzdGVtIHtcbiAgLyoqXG4gICAqIEFsbCBhc3NlbWJsaWVzIGluIHRoaXMgdHlwZSBzeXN0ZW0uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgYXNzZW1ibGllcyA9IG5ldyBBcnJheTxBc3NlbWJseT4oKTtcblxuICAvKipcbiAgICogVGhlIFwicm9vdFwiIGFzc2VtYmxpZXMgKG9uZXMgdGhhdCBsb2FkZWQgZXhwbGljaXRseSB2aWEgYSBcImxvYWRcIiBjYWxsKS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSByb290cyA9IG5ldyBBcnJheTxBc3NlbWJseT4oKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9hc3NlbWJseUxvb2t1cDogeyBbbmFtZTogc3RyaW5nXTogQXNzZW1ibHkgfSA9IHt9O1xuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBKU0lJIGRlcGVuZGVuY2llcyBvZiB0aGUgZ2l2ZW4gTlBNIHBhY2thZ2UgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBUaGUgTlBNIHBhY2thZ2UgaXRzZWxmIGRvZXMgKm5vdCogaGF2ZSB0byBiZSBhIGpzaWkgcGFja2FnZSwgYW5kIGRvZXNcbiAgICogTk9UIGhhdmUgdG8gZGVjbGFyZSBhIEpTSUkgZGVwZW5kZW5jeSBvbiBhbnkgb2YgdGhlIHBhY2thZ2VzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxvYWROcG1EZXBlbmRlbmNpZXMoXG4gICAgcGFja2FnZVJvb3Q6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7IHZhbGlkYXRlPzogYm9vbGVhbiB9ID0ge30sXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHBrZyA9IGF3YWl0IGZzLnJlYWRKc29uKHBhdGgucmVzb2x2ZShwYWNrYWdlUm9vdCwgJ3BhY2thZ2UuanNvbicpKTtcblxuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcGVuZGVuY2llc09mKHBrZykpIHtcbiAgICAgIGlmIChpc0J1aWx0aW5Nb2R1bGUoZGVwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgIGNvbnN0IGRlcERpciA9IGF3YWl0IGZpbmREZXBlbmRlbmN5RGlyZWN0b3J5KGRlcCwgcGFja2FnZVJvb3QpO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgY29uc3QgZGVwUGtnSnNvbiA9IGF3YWl0IGZzLnJlYWRKc29uKHBhdGguam9pbihkZXBEaXIsICdwYWNrYWdlLmpzb24nKSk7XG4gICAgICBpZiAoIWRlcFBrZ0pzb24uanNpaSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgIGF3YWl0IHRoaXMubG9hZE1vZHVsZShkZXBEaXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIGpzaWkgbW9kdWxlIG9yIGEgc2luZ2xlIC5qc2lpIGZpbGUgaW50byB0aGUgdHlwZSBzeXN0ZW0uXG4gICAqXG4gICAqIElmIGBmaWxlT3JEaXJlY3RvcnlgIGlzIGEgZGlyZWN0b3J5LCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBqc2lpIG5wbSBtb2R1bGUsXG4gICAqIGFuZCBpdHMgZGVwZW5kZW5jaWVzIChhcyBkZXRlcm1pbmVkIGJ5IGl0cyAncGFja2FnZS5qc29uJyBmaWxlKSB3aWxsIGJlIGxvYWRlZFxuICAgKiBhcyB3ZWxsLlxuICAgKlxuICAgKiBJZiBgZmlsZU9yRGlyZWN0b3J5YCBpcyBhIGZpbGUsIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHNpbmdsZSAuanNpaSBmaWxlLlxuICAgKiBObyBkZXBlbmRlbmNpZXMgd2lsbCBiZSBsb2FkZWQuIFlvdSBhbG1vc3QgbmV2ZXIgd2FudCB0aGlzLlxuICAgKlxuICAgKiBOb3QgdmFsaWRhdGluZyBtYWtlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGxvYWRpbmcgYXNzZW1ibGllcyB3aXRoIGxvdHNcbiAgICogb2YgZGVwZW5kZW5jaWVzIChzdWNoIGFzIGFwcC1kZWxpdmVyeSkgaW4gOTBtcyB2cyAzNTAwbXMuXG4gICAqXG4gICAqIEBwYXJhbSBmaWxlT3JEaXJlY3RvcnkgQSAuanNpaSBmaWxlIHBhdGggb3IgYSBtb2R1bGUgZGlyZWN0b3J5XG4gICAqIEBwYXJhbSB2YWxpZGF0ZSBXaGV0aGVyIG9yIG5vdCB0byB2YWxpZGF0ZSB0aGUgYXNzZW1ibHkgd2hpbGUgbG9hZGluZyBpdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsb2FkKFxuICAgIGZpbGVPckRpcmVjdG9yeTogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHsgdmFsaWRhdGU/OiBib29sZWFuIH0gPSB7fSxcbiAgKSB7XG4gICAgaWYgKChhd2FpdCBmcy5zdGF0KGZpbGVPckRpcmVjdG9yeSkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRNb2R1bGUoZmlsZU9yRGlyZWN0b3J5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9hZEZpbGUoZmlsZU9yRGlyZWN0b3J5LCB7IC4uLm9wdGlvbnMsIGlzUm9vdDogdHJ1ZSB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBsb2FkTW9kdWxlKFxuICAgIGRpcjogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHsgdmFsaWRhdGU/OiBib29sZWFuIH0gPSB7fSxcbiAgKTogUHJvbWlzZTxBc3NlbWJseT4ge1xuICAgIGNvbnN0IG91dCA9IGF3YWl0IF9sb2FkTW9kdWxlLmNhbGwodGhpcywgZGlyLCB0cnVlKTtcbiAgICBpZiAoIW91dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBtb2R1bGUgZnJvbSBkaXJlY3Rvcnk6ICR7ZGlyfWApO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBfbG9hZE1vZHVsZShcbiAgICAgIHRoaXM6IFR5cGVTeXN0ZW0sXG4gICAgICBtb2R1bGVEaXJlY3Rvcnk6IHN0cmluZyxcbiAgICAgIGlzUm9vdCA9IGZhbHNlLFxuICAgICkge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4obW9kdWxlRGlyZWN0b3J5LCAncGFja2FnZS5qc29uJyk7XG4gICAgICBjb25zdCBwa2cgPSBKU09OLnBhcnNlKFxuICAgICAgICBhd2FpdCBmcy5yZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSxcbiAgICAgICk7XG4gICAgICBpZiAoIXBrZy5qc2lpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gXCJqc2lpXCIgc2VjdGlvbiBpbiAke2ZpbGVQYXRofWApO1xuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIHRoZSBhc3NlbWJseSwgYnV0IGRvbid0IHJlY3Vyc2UgaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGFzc2VtYmx5IHdpdGggdGhlIHNhbWUgbmFtZS5cbiAgICAgIC8vIFZhbGlkYXRpb24gaXMgbm90IGFuIGluc2lnbmlmaWNhbnQgdGltZSBzaW5rLCBhbmQgbG9hZGluZyBJUyBpbnNpZ25pZmljYW50LCBzbyBkbyBhXG4gICAgICAvLyBsb2FkIHdpdGhvdXQgdmFsaWRhdGlvbiBmaXJzdC4gVGhpcyBzYXZlcyBhYm91dCAyLzNyZHMgb2YgcHJvY2Vzc2luZyB0aW1lLlxuICAgICAgY29uc3QgYXNtID0gYXdhaXQgdGhpcy5sb2FkQXNzZW1ibHkoXG4gICAgICAgIHBhdGguam9pbihtb2R1bGVEaXJlY3RvcnksICcuanNpaScpLFxuICAgICAgICBmYWxzZSxcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5pbmNsdWRlc0Fzc2VtYmx5KGFzbS5uYW1lKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZmluZEFzc2VtYmx5KGFzbS5uYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nLnZlcnNpb24gIT09IGFzbS52ZXJzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYENvbmZsaWN0aW5nIHZlcnNpb25zIG9mICR7YXNtLm5hbWV9IGluIHR5cGUgc3lzdGVtOiBwcmV2aW91c2x5IGxvYWRlZCAke2V4aXN0aW5nLnZlcnNpb259LCB0cnlpbmcgdG8gbG9hZCAke2FzbS52ZXJzaW9ufWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBtYXJrIHRoaXMgdGhpbmcgYXMgcm9vdCBhZnRlciBhbGwgaWYgaXQgd2Fzbid0IHlldC5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgIHRoaXMuYWRkUm9vdChhc20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgYXNtLnZhbGlkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmFkZEFzc2VtYmx5KGFzbSwgeyBpc1Jvb3QgfSk7XG4gICAgICAvLyBVc2luZyB8fCBpbnN0ZWFkIG9mID8/IGJlY2F1c2UgbnBtanMuY29tIHdpbGwgYWx0ZXIgdGhlIHBhY2thZ2UuanNvbiBmaWxlIGFuZCBwb3NzaWJseSBwdXQgYGZhbHNlYCBpbiBwa2cuYnVuZGxlRGVwZW5kZW5jaWVzLlxuICAgICAgLy8gVGhpcyBpcyBhY3R1YWxseSBub24gY29tcGxpYW50IHRvIHRoZSBwYWNrYWdlLmpzb24gc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQncyBob3cgaXQgaXMuLi5cbiAgICAgIGNvbnN0IGJ1bmRsZWQ6IHN0cmluZ1tdID1cbiAgICAgICAgcGtnLmJ1bmRsZWREZXBlbmRlbmNpZXMgfHwgcGtnLmJ1bmRsZURlcGVuZGVuY2llcyB8fCBbXTtcblxuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGRlcGVuZGVuY2llc09mKHBrZykpIHtcbiAgICAgICAgaWYgKGJ1bmRsZWQuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgIGNvbnN0IGRlcERpciA9IGF3YWl0IGZpbmREZXBlbmRlbmN5RGlyZWN0b3J5KG5hbWUsIG1vZHVsZURpcmVjdG9yeSk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgYXdhaXQgX2xvYWRNb2R1bGUuY2FsbCh0aGlzLCBkZXBEaXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbG9hZEZpbGUoXG4gICAgZmlsZTogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHsgaXNSb290PzogYm9vbGVhbjsgdmFsaWRhdGU/OiBib29sZWFuIH0gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCB0aGlzLmxvYWRBc3NlbWJseShmaWxlLCBvcHRpb25zLnZhbGlkYXRlICE9PSBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuYWRkQXNzZW1ibHkoYXNzZW1ibHksIG9wdGlvbnMpO1xuICB9XG5cbiAgcHVibGljIGFkZEFzc2VtYmx5KGFzbTogQXNzZW1ibHksIG9wdGlvbnM6IHsgaXNSb290PzogYm9vbGVhbiB9ID0ge30pIHtcbiAgICBpZiAoYXNtLnN5c3RlbSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NlbWJseSBoYXMgYmVlbiBjcmVhdGVkIGZvciBkaWZmZXJlbnQgdHlwZXN5c3RlbScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fYXNzZW1ibHlMb29rdXBbYXNtLm5hbWVdKSB7XG4gICAgICB0aGlzLl9hc3NlbWJseUxvb2t1cFthc20ubmFtZV0gPSBhc207XG4gICAgICB0aGlzLmFzc2VtYmxpZXMucHVzaChhc20pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlzUm9vdCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWRkUm9vdChhc20pO1xuICAgIH1cblxuICAgIHJldHVybiBhc207XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgVHlwZVN5c3RlbSBpbmNsdWRlcyBhIGdpdmVuIGFzc2VtYmx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYXNzZW1ibHkgYmVpbmcgbG9va2VkIGZvci5cbiAgICovXG4gIHB1YmxpYyBpbmNsdWRlc0Fzc2VtYmx5KG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuYW1lIGluIHRoaXMuX2Fzc2VtYmx5TG9va3VwO1xuICB9XG5cbiAgcHVibGljIGlzUm9vdChuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5yb290cy5tYXAoKHIpID0+IHIubmFtZSkuaW5jbHVkZXMobmFtZSk7XG4gIH1cblxuICBwdWJsaWMgZmluZEFzc2VtYmx5KG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHJldCA9IHRoaXMudHJ5RmluZEFzc2VtYmx5KG5hbWUpO1xuICAgIGlmICghcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2VtYmx5IFwiJHtuYW1lfVwiIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgcHVibGljIHRyeUZpbmRBc3NlbWJseShuYW1lOiBzdHJpbmcpOiBBc3NlbWJseSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2VtYmx5TG9va3VwW25hbWVdO1xuICB9XG5cbiAgcHVibGljIGZpbmRGcW4oZnFuOiBzdHJpbmcpOiBUeXBlIHtcbiAgICBjb25zdCBbYXNzZW1ibHldID0gZnFuLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgYXNtID0gdGhpcy5maW5kQXNzZW1ibHkoYXNzZW1ibHkpO1xuICAgIHJldHVybiBhc20uZmluZFR5cGUoZnFuKTtcbiAgfVxuXG4gIHB1YmxpYyB0cnlGaW5kRnFuKGZxbjogc3RyaW5nKTogVHlwZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgW2Fzc2VtYmx5XSA9IGZxbi5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGFzbSA9IHRoaXMudHJ5RmluZEFzc2VtYmx5KGFzc2VtYmx5KTtcbiAgICByZXR1cm4gYXNtPy50cnlGaW5kVHlwZShmcW4pO1xuICB9XG5cbiAgcHVibGljIGZpbmRDbGFzcyhmcW46IHN0cmluZyk6IENsYXNzVHlwZSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmluZEZxbihmcW4pO1xuICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBDbGFzc1R5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZRTiAke2Zxbn0gaXMgbm90IGEgY2xhc3NgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBwdWJsaWMgZmluZEludGVyZmFjZShmcW46IHN0cmluZyk6IEludGVyZmFjZVR5cGUge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZpbmRGcW4oZnFuKTtcbiAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgSW50ZXJmYWNlVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRlFOICR7ZnFufSBpcyBub3QgYW4gaW50ZXJmYWNlYCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgcHVibGljIGZpbmRFbnVtKGZxbjogc3RyaW5nKTogRW51bVR5cGUge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZpbmRGcW4oZnFuKTtcbiAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgRW51bVR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZRTiAke2Zxbn0gaXMgbm90IGFuIGVudW1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQWxsIG1ldGhvZHMgaW4gdGhlIHR5cGUgc3lzdGVtLlxuICAgKi9cbiAgcHVibGljIGdldCBtZXRob2RzKCkge1xuICAgIGNvbnN0IGdldE1ldGhvZHMgPSAobW9kOiBNb2R1bGVMaWtlKTogcmVhZG9ubHkgTWV0aG9kW10gPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4uZmxhdE1hcChtb2Quc3VibW9kdWxlcywgZ2V0TWV0aG9kcyksXG4gICAgICAgIC4uLmZsYXRNYXAobW9kLmludGVyZmFjZXMsIChpZmFjZSkgPT4gaWZhY2Uub3duTWV0aG9kcyksXG4gICAgICAgIC4uLmZsYXRNYXAobW9kLmNsYXNzZXMsIChjbGF6eikgPT4gY2xhenoub3duTWV0aG9kcyksXG4gICAgICBdO1xuICAgIH07XG5cbiAgICByZXR1cm4gZmxhdE1hcCh0aGlzLmFzc2VtYmxpZXMsIGdldE1ldGhvZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbCBwcm9wZXJ0aWVzIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICBjb25zdCBnZXRQcm9wZXJ0aWVzID0gKG1vZDogTW9kdWxlTGlrZSk6IHJlYWRvbmx5IFByb3BlcnR5W10gPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4uZmxhdE1hcChtb2Quc3VibW9kdWxlcywgZ2V0UHJvcGVydGllcyksXG4gICAgICAgIC4uLmZsYXRNYXAobW9kLmludGVyZmFjZXMsIChpZmFjZSkgPT4gaWZhY2Uub3duUHJvcGVydGllcyksXG4gICAgICAgIC4uLmZsYXRNYXAobW9kLmNsYXNzZXMsIChjbGF6eikgPT4gY2xhenoub3duUHJvcGVydGllcyksXG4gICAgICBdO1xuICAgIH07XG5cbiAgICByZXR1cm4gZmxhdE1hcCh0aGlzLmFzc2VtYmxpZXMsIGdldFByb3BlcnRpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbCBjbGFzc2VzIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAgICovXG4gIHB1YmxpYyBnZXQgY2xhc3NlcygpOiByZWFkb25seSBDbGFzc1R5cGVbXSB7XG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5PENsYXNzVHlwZT4oKTtcbiAgICB0aGlzLmFzc2VtYmxpZXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgb3V0LnB1c2goLi4uY29sbGVjdFR5cGVzKGEsIChpdGVtKSA9PiBpdGVtLmNsYXNzZXMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbCBpbnRlcmZhY2VzIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAgICovXG4gIHB1YmxpYyBnZXQgaW50ZXJmYWNlcygpOiByZWFkb25seSBJbnRlcmZhY2VUeXBlW10ge1xuICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheTxJbnRlcmZhY2VUeXBlPigpO1xuICAgIHRoaXMuYXNzZW1ibGllcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBvdXQucHVzaCguLi5jb2xsZWN0VHlwZXMoYSwgKGl0ZW0pID0+IGl0ZW0uaW50ZXJmYWNlcykpO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogQWxsIGVudW1zIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAgICovXG4gIHB1YmxpYyBnZXQgZW51bXMoKTogcmVhZG9ubHkgRW51bVR5cGVbXSB7XG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5PEVudW1UeXBlPigpO1xuICAgIHRoaXMuYXNzZW1ibGllcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBvdXQucHVzaCguLi5jb2xsZWN0VHlwZXMoYSwgKGl0ZW0pID0+IGl0ZW0uZW51bXMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYW4gYXNzZW1ibHkgd2l0aG91dCBhZGRpbmcgaXQgdG8gdGhlIHR5cGVzeXN0ZW1cbiAgICogQHBhcmFtIGZpbGUgQXNzZW1ibHkgZmlsZSB0byBsb2FkXG4gICAqIEBwYXJhbSB2YWxpZGF0ZSBXaGV0aGVyIHRvIHZhbGlkYXRlIHRoZSBhc3NlbWJseSBvciBqdXN0IGFzc3VtZSBpdCBtYXRjaGVzIHRoZSBzY2hlbWFcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZEFzc2VtYmx5KGZpbGU6IHN0cmluZywgdmFsaWRhdGUgPSB0cnVlKSB7XG4gICAgY29uc3Qgc3BlYyA9IEpTT04ucGFyc2UoYXdhaXQgZnMucmVhZEZpbGUoZmlsZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSk7XG4gICAgY29uc3QgYXNzID0gdmFsaWRhdGVcbiAgICAgID8ganNpaS52YWxpZGF0ZUFzc2VtYmx5KHNwZWMpXG4gICAgICA6IChzcGVjIGFzIGpzaWkuQXNzZW1ibHkpO1xuICAgIHJldHVybiBuZXcgQXNzZW1ibHkodGhpcywgYXNzKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkUm9vdChhc206IEFzc2VtYmx5KSB7XG4gICAgaWYgKCF0aGlzLnJvb3RzLm1hcCgocikgPT4gci5uYW1lKS5pbmNsdWRlcyhhc20ubmFtZSkpIHtcbiAgICAgIHRoaXMucm9vdHMucHVzaChhc20pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZXBlbmRlbmNpZXNPZihwYWNrYWdlSnNvbjogYW55KSB7XG4gIGNvbnN0IGRlcHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgT2JqZWN0LmtleXMocGFja2FnZUpzb24uZGVwZW5kZW5jaWVzID8/IHt9KS5mb3JFYWNoKGRlcHMuYWRkLmJpbmQoZGVwcykpO1xuICBPYmplY3Qua2V5cyhwYWNrYWdlSnNvbi5wZWVyRGVwZW5kZW5jaWVzID8/IHt9KS5mb3JFYWNoKGRlcHMuYWRkLmJpbmQoZGVwcykpO1xuICByZXR1cm4gQXJyYXkuZnJvbShkZXBzKTtcbn1cblxuZnVuY3Rpb24gY29sbGVjdFR5cGVzPFQgZXh0ZW5kcyBUeXBlPihcbiAgbW9kdWxlOiBNb2R1bGVMaWtlLFxuICBnZXR0ZXI6IChtb2R1bGU6IE1vZHVsZUxpa2UpID0+IHJlYWRvbmx5IFRbXSxcbik6IHJlYWRvbmx5IFRbXSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxUPigpO1xuICBmb3IgKGNvbnN0IHN1Ym1vZHVsZSBvZiBtb2R1bGUuc3VibW9kdWxlcykge1xuICAgIHJlc3VsdC5wdXNoKC4uLmNvbGxlY3RUeXBlcyhzdWJtb2R1bGUsIGdldHRlcikpO1xuICB9XG4gIHJlc3VsdC5wdXNoKC4uLmdldHRlcihtb2R1bGUpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmxhdE1hcDxULCBSPihcbiAgY29sbGVjdGlvbjogcmVhZG9ubHkgVFtdLFxuICBtYXBwZXI6ICh2YWx1ZTogVCkgPT4gcmVhZG9ubHkgUltdLFxuKTogcmVhZG9ubHkgUltdIHtcbiAgcmV0dXJuIGNvbGxlY3Rpb25cbiAgICAubWFwKG1hcHBlcilcbiAgICAucmVkdWNlKChhY2MsIGVsdCkgPT4gYWNjLmNvbmNhdChlbHQpLCBuZXcgQXJyYXk8Uj4oKSk7XG59XG4iXX0=