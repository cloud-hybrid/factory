"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnippetParameters = exports.renderMetadataline = exports.parseMetadataLine = exports.parseKeyValueList = exports.completeSource = exports.updateParameters = exports.typeScriptSnippetFromCompleteSource = exports.typeScriptSnippetFromSource = exports.typeScriptSnippetFromVisibleSource = exports.renderApiLocation = exports.formatLocation = exports.INITIALIZER_METHOD_NAME = void 0;
const visible_spans_1 = require("./typescript/visible-spans");
/**
 * How to represent the initializer in a 'parameter' type.
 *
 * (Don't feel like making everyone's `case` statement worse by adding an
 * 'initializer-parameter' variant).
 */
exports.INITIALIZER_METHOD_NAME = '<initializer>';
/**
 * Render an API location to a human readable representation
 */
function formatLocation(location) {
    var _a;
    switch ((_a = location.field) === null || _a === void 0 ? void 0 : _a.field) {
        case 'example':
            return `${renderApiLocation(location.api)}-example`;
        case 'markdown':
            return `${renderApiLocation(location.api)}-L${location.field.line}`;
        case undefined:
            return renderApiLocation(location.api);
    }
}
exports.formatLocation = formatLocation;
/**
 * Render an API location to an unique string
 *
 * This function is used in hashing examples for reuse, and so the formatting
 * here should not be changed lightly.
 */
function renderApiLocation(apiLoc) {
    switch (apiLoc.api) {
        case 'file':
            return apiLoc.fileName;
        case 'moduleReadme':
            return `${apiLoc.moduleFqn}-README`;
        case 'type':
            return apiLoc.fqn;
        case 'initializer':
            return `${apiLoc.fqn}#initializer`;
        case 'member':
            return `${apiLoc.fqn}#${apiLoc.memberName}`;
        case 'parameter':
            return `${apiLoc.fqn}#${apiLoc.methodName}!#${apiLoc.parameterName}`;
    }
}
exports.renderApiLocation = renderApiLocation;
/**
 * Construct a TypeScript snippet from visible source
 *
 * Will parse parameters from a directive in the given source, but will not
 * interpret `/// !show` and `/// !hide` directives.
 *
 * `/// !show` and `/// !hide` directives WILL affect what gets displayed by
 * the translator, but they will NOT affect the snippet's cache key (i.e. the
 * cache key will be based on the full source given here).
 *
 * Use this if you are looking up a snippet in a tablet, which has been translated
 * previously using a fixture.
 */
function typeScriptSnippetFromVisibleSource(typeScriptSource, location, strict, parameters = {}) {
    const [source, sourceParameters] = parametersFromSourceDirectives(typeScriptSource);
    const visibleSource = source.trimRight();
    return {
        visibleSource,
        location,
        parameters: Object.assign({}, parameters, sourceParameters),
        strict,
    };
}
exports.typeScriptSnippetFromVisibleSource = typeScriptSnippetFromVisibleSource;
/**
 * Construct a TypeScript snippet from literal source
 *
 * @deprecated Use `typeScriptSnippetFromVisibleSource`
 */
function typeScriptSnippetFromSource(typeScriptSource, location, strict, parameters = {}) {
    return typeScriptSnippetFromVisibleSource(typeScriptSource, location, strict, parameters);
}
exports.typeScriptSnippetFromSource = typeScriptSnippetFromSource;
/**
 * Construct a TypeScript snippet from complete source
 *
 * Will parse parameters from a directive in the given source, and will
 * interpret `/// !show` and `/// !hide` directives.
 *
 * The snippet's cache key will be based on the source that remains after
 * these directives are processed.
 *
 * Use this if you are building a snippet to be translated, and take care
 * to store the return object's `visibleSource` in the assembly (not the original
 * source you passed in).
 */
function typeScriptSnippetFromCompleteSource(typeScriptSource, location, strict, parameters = {}) {
    const [source, sourceParameters] = parametersFromSourceDirectives(typeScriptSource);
    const completeSource = source.trimRight();
    const visibleSource = visible_spans_1.trimCompleteSourceToVisible(completeSource);
    return {
        visibleSource,
        completeSource: visibleSource !== completeSource ? completeSource : undefined,
        location,
        parameters: Object.assign({}, parameters, sourceParameters),
        strict,
    };
}
exports.typeScriptSnippetFromCompleteSource = typeScriptSnippetFromCompleteSource;
function updateParameters(snippet, params) {
    var _a;
    return {
        ...snippet,
        parameters: Object.assign(Object.create(null), (_a = snippet.parameters) !== null && _a !== void 0 ? _a : {}, params),
    };
}
exports.updateParameters = updateParameters;
/**
 * Get the complete (compilable) source of a snippet
 */
function completeSource(snippet) {
    var _a;
    return (_a = snippet.completeSource) !== null && _a !== void 0 ? _a : snippet.visibleSource;
}
exports.completeSource = completeSource;
/**
 * Extract snippet parameters from the first line of the source if it's a compiler directive
 */
function parametersFromSourceDirectives(source) {
    const [firstLine, ...rest] = source.split('\n');
    // Also extract parameters from an initial line starting with '/// ' (getting rid of that line).
    const m = /[/]{3}(.*)$/.exec(firstLine);
    if (m) {
        return [rest.join('\n'), parseMetadataLine(m[1])];
    }
    return [source, {}];
}
/**
 * Parse a set of 'param param=value' directives into an object
 */
function parseKeyValueList(parameters) {
    const ret = {};
    for (const param of parameters) {
        const parts = param.split('=', 2);
        if (parts.length === 2) {
            ret[parts[0]] = parts[1];
        }
        else {
            ret[parts[0]] = '';
        }
    }
    return ret;
}
exports.parseKeyValueList = parseKeyValueList;
function parseMetadataLine(metadata) {
    return parseKeyValueList(parseMetadata(metadata));
    function parseMetadata(metadata) {
        return metadata
            .trim()
            .split(' ')
            .map((s) => s.trim())
            .filter((s) => s !== '');
    }
}
exports.parseMetadataLine = parseMetadataLine;
function renderMetadataline(metadata = {}) {
    const line = Object.entries(metadata)
        .filter(([key, _]) => !key.startsWith('$'))
        .map(([key, value]) => (value !== '' ? `${key}=${value}` : key))
        .join(' ');
    return line ? line : undefined;
}
exports.renderMetadataline = renderMetadataline;
/**
 * Recognized snippet parameters
 */
var SnippetParameters;
(function (SnippetParameters) {
    /**
     * Use fixture with the given name (author parameter)
     */
    SnippetParameters["FIXTURE"] = "fixture";
    /**
     * Don't use a fixture (author parameter)
     */
    SnippetParameters["NO_FIXTURE"] = "nofixture";
    /**
     * Snippet was extracted from this literate file (backwards compatibility)
     *
     * Parameter attached by 'jsii'; load the given file instead of any fixture,
     * process as usual.
     */
    SnippetParameters["LITERATE_SOURCE"] = "lit";
    /**
     * What directory to resolve fixtures in for this snippet (system parameter)
     *
     * Attached during processing, should not be used by authors.
     */
    SnippetParameters["$PROJECT_DIRECTORY"] = "$directory";
    /**
     * What directory to pretend the file is in (system parameter)
     *
     * Attached when compiling a literate file, as they compile in
     * the location where they are stored.
     */
    SnippetParameters["$COMPILATION_DIRECTORY"] = "$compilation";
})(SnippetParameters = exports.SnippetParameters || (exports.SnippetParameters = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic25pcHBldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInNuaXBwZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOERBQXlFO0FBeUR6RTs7Ozs7R0FLRztBQUNVLFFBQUEsdUJBQXVCLEdBQUcsZUFBZSxDQUFDO0FBaUJ2RDs7R0FFRztBQUNILFNBQWdCLGNBQWMsQ0FBQyxRQUF5Qjs7SUFDdEQsY0FBUSxRQUFRLENBQUMsS0FBSywwQ0FBRSxLQUFLLEVBQUU7UUFDN0IsS0FBSyxTQUFTO1lBQ1osT0FBTyxHQUFHLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO1FBQ3RELEtBQUssVUFBVTtZQUNiLE9BQU8sR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN0RSxLQUFLLFNBQVM7WUFDWixPQUFPLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUMxQztBQUNILENBQUM7QUFURCx3Q0FTQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsTUFBbUI7SUFDbkQsUUFBUSxNQUFNLENBQUMsR0FBRyxFQUFFO1FBQ2xCLEtBQUssTUFBTTtZQUNULE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUN6QixLQUFLLGNBQWM7WUFDakIsT0FBTyxHQUFHLE1BQU0sQ0FBQyxTQUFTLFNBQVMsQ0FBQztRQUN0QyxLQUFLLE1BQU07WUFDVCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUM7UUFDcEIsS0FBSyxhQUFhO1lBQ2hCLE9BQU8sR0FBRyxNQUFNLENBQUMsR0FBRyxjQUFjLENBQUM7UUFDckMsS0FBSyxRQUFRO1lBQ1gsT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzlDLEtBQUssV0FBVztZQUNkLE9BQU8sR0FBRyxNQUFN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QyxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMvRCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFYixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDakMsQ0FBQztBQVBELGdEQU9DO0FBRUQ7O0dBRUc7QUFDSCxJQUFZLGlCQWlDWDtBQWpDRCxXQUFZLGlCQUFpQjtJQUMzQjs7T0FFRztJQUNILHdDQUFtQixDQUFBO0lBRW5COztPQUVHO0lBQ0gsNkNBQXdCLENBQUE7SUFFeEI7Ozs7O09BS0c7SUFDSCw0Q0FBdUIsQ0FBQTtJQUV2Qjs7OztPQUlHO0lBQ0gsc0RBQWlDLENBQUE7SUFFakM7Ozs7O09BS0c7SUFDSCw0REFBdUMsQ0FBQTtBQUN6QyxDQUFDLEVBakNXLGlCQUFpQixHQUFqQix5QkFBaUIsS0FBakIseUJBQWlCLFFBaUM1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRyaW1Db21wbGV0ZVNvdXJjZVRvVmlzaWJsZSB9IGZyb20gJy4vdHlwZXNjcmlwdC92aXNpYmxlLXNwYW5zJztcblxuLyoqXG4gKiBBIHBpZWNlIG9mIFR5cGVTY3JpcHQgY29kZSBmb3VuZCBpbiBhbiBhc3NlbWJseSwgcmVhZHkgdG8gYmUgdHJhbnNsYXRlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVTY3JpcHRTbmlwcGV0IHtcbiAgLyoqXG4gICAqIFRoZSBzbmlwcGV0IGNvZGUgdGhhdCBlbmRzIHVwIGluIHRoZSBKU0lJIGFzc2VtYmx5XG4gICAqL1xuICByZWFkb25seSB2aXNpYmxlU291cmNlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlc2NyaXB0aW9uIG9mIHdoZXJlIHRoZSBzbmlwcGV0IHdhcyBmb3VuZFxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246IFNuaXBwZXRMb2NhdGlvbjtcblxuICAvKipcbiAgICogV2hlbiBlbmhhbmNlZCB3aXRoIGEgZml4dHVyZSwgdGhlIHNuaXBwZXQncyBjb21wbGV0ZSBzb3VyY2UgY29kZVxuICAgKi9cbiAgcmVhZG9ubHkgY29tcGxldGVTb3VyY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFBhcmFtZXRlcnMgZm9yIHRoZSBjb252ZXJzaW9uXG4gICAqL1xuICByZWFkb25seSBwYXJhbWV0ZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHNuaXBwZXQgbXVzdCBiZSBwcm9jZXNzZWQgYXMgaWYgYC0tc3RyaWN0YCB3YXMgYWx3YXlzIHN1cHBsaWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RyaWN0PzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBEZXNjcmlwdGlvbiBvZiBhIGxvY2F0aW9uIHdoZXJlIHRoZSBzbmlwcGV0IGlzIGZvdW5kXG4gKlxuICogVGhlIGxvY2F0aW9uIGRvZXMgbm90IG5lY2Vzc2FyaWx5IGluZGljYXRlIGFuIGV4YWN0IHNvdXJjZSBmaWxlLFxuICogYnV0IGl0IHdpbGwgZ2VuZXJhbGx5IHJlZmVyIHRvIGEgbG9jYXRpb24gdGhhdCBjYW4gY29udGFpbiBvbmUgb3IgbW9yZVxuICogc25pcHBldHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU25pcHBldExvY2F0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBqc2lpIEFQSSB3aXRoIHdoaWNoIHRoaXMgc25pcHBldCBpcyBhc3NvY2lhdGVkXG4gICAqL1xuICByZWFkb25seSBhcGk6IEFwaUxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgQVBJIGZpZWxkIGluIHdoaWNoIHRoZSBzbmlwcGV0IGlzIGZvdW5kLCBpZiBhbnlcbiAgICpcbiAgICogQWJzZW5jZSBvZiB0aGlzIGZpZWxkIGlzIGFwcHJvcHJpYXRlIGZvciBzb3VyY2UgZmlsZXMgKG9yIHRlc3RzKSxcbiAgICogYnV0IGZvciBNYXJrZG93biBmaWxlcyAnZmllbGQnIHNob3VsZCByZWFsbHkgYmUgc2V0IHRvIGEgTWFya2Rvd25cbiAgICogbG9jYXRpb24uXG4gICAqL1xuICByZWFkb25seSBmaWVsZD86IEZpZWxkTG9jYXRpb247XG59XG5cbi8qKlxuICogSG93IHRvIHJlcHJlc2VudCB0aGUgaW5pdGlhbGl6ZXIgaW4gYSAncGFyYW1ldGVyJyB0eXBlLlxuICpcbiAqIChEb24ndCBmZWVsIGxpa2UgbWFraW5nIGV2ZXJ5b25lJ3MgYGNhc2VgIHN0YXRlbWVudCB3b3JzZSBieSBhZGRpbmcgYW5cbiAqICdpbml0aWFsaXplci1wYXJhbWV0ZXInIHZhcmlhbnQpLlxuICovXG5leHBvcnQgY29uc3QgSU5JVElBTElaRVJfTUVUSE9EX05BTUUgPSAnPGluaXRpYWxpemVyPic7XG5cbmV4cG9ydCB0eXBlIEFwaUxvY2F0aW9uID1cbiAgfCB7IHJlYWRvbmx5IGFwaTogJ2ZpbGUnOyByZWFkb25seSBmaWxlTmFtZTogc3RyaW5nIH1cbiAgfCB7IHJlYWRvbmx5IGFwaTogJ21vZHVsZVJlYWRtZSc7IHJlYWRvbmx5IG1vZHVsZUZxbjogc3RyaW5nIH1cbiAgfCB7IHJlYWRvbmx5IGFwaTogJ3R5cGUnOyByZWFkb25seSBmcW46IHN0cmluZyB9XG4gIHwgeyByZWFkb25seSBhcGk6ICdpbml0aWFsaXplcic7IHJlYWRvbmx5IGZxbjogc3RyaW5nIH1cbiAgfCB7IHJlYWRvbmx5IGFwaTogJ21lbWJlcic7IHJlYWRvbmx5IGZxbjogc3RyaW5nOyByZWFkb25seSBtZW1iZXJOYW1lOiBzdHJpbmcgfVxuICB8IHtcbiAgICAgIHJlYWRvbmx5IGFwaTogJ3BhcmFtZXRlcic7XG4gICAgICByZWFkb25seSBmcW46IHN0cmluZztcbiAgICAgIHJlYWRvbmx5IG1ldGhvZE5hbWU6IHN0cmluZyB8IHR5cGVvZiBJTklUSUFMSVpFUl9NRVRIT0RfTkFNRTtcbiAgICAgIHJlYWRvbmx5IHBhcmFtZXRlck5hbWU6IHN0cmluZztcbiAgICB9O1xuXG5leHBvcnQgdHlwZSBGaWVsZExvY2F0aW9uID0geyByZWFkb25seSBmaWVsZDogJ21hcmtkb3duJzsgcmVhZG9ubHkgbGluZTogbnVtYmVyIH0gfCB7IHJlYWRvbmx5IGZpZWxkOiAnZXhhbXBsZScgfTtcblxuLyoqXG4gKiBSZW5kZXIgYW4gQVBJIGxvY2F0aW9uIHRvIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdExvY2F0aW9uKGxvY2F0aW9uOiBTbmlwcGV0TG9jYXRpb24pOiBzdHJpbmcge1xuICBzd2l0Y2ggKGxvY2F0aW9uLmZpZWxkPy5maWVsZCkge1xuICAgIGNhc2UgJ2V4YW1wbGUnOlxuICAgICAgcmV0dXJuIGAke3JlbmRlckFwaUxvY2F0aW9uKGxvY2F0aW9uLmFwaSl9LWV4YW1wbGVgO1xuICAgIGNhc2UgJ21hcmtkb3duJzpcbiAgICAgIHJldHVybiBgJHtyZW5kZXJBcGlMb2NhdGlvbihsb2NhdGlvbi5hcGkpfS1MJHtsb2NhdGlvbi5maWVsZC5saW5lfWA7XG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICByZXR1cm4gcmVuZGVyQXBpTG9jYXRpb24obG9jYXRpb24uYXBpKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlciBhbiBBUEkgbG9jYXRpb24gdG8gYW4gdW5pcXVlIHN0cmluZ1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbiBoYXNoaW5nIGV4YW1wbGVzIGZvciByZXVzZSwgYW5kIHNvIHRoZSBmb3JtYXR0aW5nXG4gKiBoZXJlIHNob3VsZCBub3QgYmUgY2hhbmdlZCBsaWdodGx5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQXBpTG9jYXRpb24oYXBpTG9jOiBBcGlMb2NhdGlvbik6IHN0cmluZyB7XG4gIHN3aXRjaCAoYXBpTG9jLmFwaSkge1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgcmV0dXJuIGFwaUxvYy5maWxlTmFtZTtcbiAgICBjYXNlICdtb2R1bGVSZWFkbWUnOlxuICAgICAgcmV0dXJuIGAke2FwaUxvYy5tb2R1bGVGcW59LVJFQURNRWA7XG4gICAgY2FzZSAndHlwZSc6XG4gICAgICByZXR1cm4gYXBpTG9jLmZxbjtcbiAgICBjYXNlICdpbml0aWFsaXplcic6XG4gICAgICByZXR1cm4gYCR7YXBpTG9jLmZxbn0jaW5pdGlhbGl6ZXJgO1xuICAgIGNhc2UgJ21lbWJlcic6XG4gICAgICByZXR1cm4gYCR7YXBpTG9jLmZxbn0jJHthcGlMb2MubWVtYmVyTmFtZX1gO1xuICAgIGNhc2UgJ3BhcmFtZXRlcic6XG4gICAgICByZXR1cm4gYCR7YXBpTG9jLmZxbn0jJHthcGlMb2MubWV0aG9kTmFtZX0hIyR7YXBpTG9jLnBhcmFtZXRlck5hbWV9YDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIFR5cGVTY3JpcHQgc25pcHBldCBmcm9tIHZpc2libGUgc291cmNlXG4gKlxuICogV2lsbCBwYXJzZSBwYXJhbWV0ZXJzIGZyb20gYSBkaXJlY3RpdmUgaW4gdGhlIGdpdmVuIHNvdXJjZSwgYnV0IHdpbGwgbm90XG4gKiBpbnRlcnByZXQgYC8vLyAhc2hvd2AgYW5kIGAvLy8gIWhpZGVgIGRpcmVjdGl2ZXMuXG4gKlxuICogYC8vLyAhc2hvd2AgYW5kIGAvLy8gIWhpZGVgIGRpcmVjdGl2ZXMgV0lMTCBhZmZlY3Qgd2hhdCBnZXRzIGRpc3BsYXllZCBieVxuICogdGhlIHRyYW5zbGF0b3IsIGJ1dCB0aGV5IHdpbGwgTk9UIGFmZmVjdCB0aGUgc25pcHBldCdzIGNhY2hlIGtleSAoaS5lLiB0aGVcbiAqIGNhY2hlIGtleSB3aWxsIGJlIGJhc2VkIG9uIHRoZSBmdWxsIHNvdXJjZSBnaXZlbiBoZXJlKS5cbiAqXG4gKiBVc2UgdGhpcyBpZiB5b3UgYXJlIGxvb2tpbmcgdXAgYSBzbmlwcGV0IGluIGEgdGFibGV0LCB3aGljaCBoYXMgYmVlbiB0cmFuc2xhdGVkXG4gKiBwcmV2aW91c2x5IHVzaW5nIGEgZml4dHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVTY3JpcHRTbmlwcGV0RnJvbVZpc2libGVTb3VyY2UoXG4gIHR5cGVTY3JpcHRTb3VyY2U6IHN0cmluZyxcbiAgbG9jYXRpb246IFNuaXBwZXRMb2NhdGlvbixcbiAgc3RyaWN0OiBib29sZWFuLFxuICBwYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge30sXG4pOiBUeXBlU2NyaXB0U25pcHBldCB7XG4gIGNvbnN0IFtzb3VyY2UsIHNvdXJjZVBhcmFtZXRlcnNdID0gcGFyYW1ldGVyc0Zyb21Tb3VyY2VEaXJlY3RpdmVzKHR5cGVTY3JpcHRTb3VyY2UpO1xuICBjb25zdCB2aXNpYmxlU291cmNlID0gc291cmNlLnRyaW1SaWdodCgpO1xuXG4gIHJldHVybiB7XG4gICAgdmlzaWJsZVNvdXJjZSxcbiAgICBsb2NhdGlvbixcbiAgICBwYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBwYXJhbWV0ZXJzLCBzb3VyY2VQYXJhbWV0ZXJzKSxcbiAgICBzdHJpY3QsXG4gIH07XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgVHlwZVNjcmlwdCBzbmlwcGV0IGZyb20gbGl0ZXJhbCBzb3VyY2VcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHR5cGVTY3JpcHRTbmlwcGV0RnJvbVZpc2libGVTb3VyY2VgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0eXBlU2NyaXB0U25pcHBldEZyb21Tb3VyY2UoXG4gIHR5cGVTY3JpcHRTb3VyY2U6IHN0cmluZyxcbiAgbG9jYXRpb246IFNuaXBwZXRMb2NhdGlvbixcbiAgc3RyaWN0OiBib29sZWFuLFxuICBwYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge30sXG4pOiBUeXBlU2NyaXB0U25pcHBldCB7XG4gIHJldHVybiB0eXBlU2NyaXB0U25pcHBldEZyb21WaXNpYmxlU291cmNlKHR5cGVTY3JpcHRTb3VyY2UsIGxvY2F0aW9uLCBzdHJpY3QsIHBhcmFtZXRlcnMpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIFR5cGVTY3JpcHQgc25pcHBldCBmcm9tIGNvbXBsZXRlIHNvdXJjZVxuICpcbiAqIFdpbGwgcGFyc2UgcGFyYW1ldGVycyBmcm9tIGEgZGlyZWN0aXZlIGluIHRoZSBnaXZlbiBzb3VyY2UsIGFuZCB3aWxsXG4gKiBpbnRlcnByZXQgYC8vLyAhc2hvd2AgYW5kIGAvLy8gIWhpZGVgIGRpcmVjdGl2ZXMuXG4gKlxuICogVGhlIHNuaXBwZXQncyBjYWNoZSBrZXkgd2lsbCBiZSBiYXNlZCBvbiB0aGUgc291cmNlIHRoYXQgcmVtYWlucyBhZnRlclxuICogdGhlc2UgZGlyZWN0aXZlcyBhcmUgcHJvY2Vzc2VkLlxuICpcbiAqIFVzZSB0aGlzIGlmIHlvdSBhcmUgYnVpbGRpbmcgYSBzbmlwcGV0IHRvIGJlIHRyYW5zbGF0ZWQsIGFuZCB0YWtlIGNhcmVcbiAqIHRvIHN0b3JlIHRoZSByZXR1cm4gb2JqZWN0J3MgYHZpc2libGVTb3VyY2VgIGluIHRoZSBhc3NlbWJseSAobm90IHRoZSBvcmlnaW5hbFxuICogc291cmNlIHlvdSBwYXNzZWQgaW4pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHlwZVNjcmlwdFNuaXBwZXRGcm9tQ29tcGxldGVTb3VyY2UoXG4gIHR5cGVTY3JpcHRTb3VyY2U6IHN0cmluZyxcbiAgbG9jYXRpb246IFNuaXBwZXRMb2NhdGlvbixcbiAgc3RyaWN0OiBib29sZWFuLFxuICBwYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge30sXG4pOiBUeXBlU2NyaXB0U25pcHBldCB7XG4gIGNvbnN0IFtzb3VyY2UsIHNvdXJjZVBhcmFtZXRlcnNdID0gcGFyYW1ldGVyc0Zyb21Tb3VyY2VEaXJlY3RpdmVzKHR5cGVTY3JpcHRTb3VyY2UpO1xuICBjb25zdCBjb21wbGV0ZVNvdXJjZSA9IHNvdXJjZS50cmltUmlnaHQoKTtcblxuICBjb25zdCB2aXNpYmxlU291cmNlID0gdHJpbUNvbXBsZXRlU291cmNlVG9WaXNpYmxlKGNvbXBsZXRlU291cmNlKTtcblxuICByZXR1cm4ge1xuICAgIHZpc2libGVTb3VyY2UsXG4gICAgY29tcGxldGVTb3VyY2U6IHZpc2libGVTb3VyY2UgIT09IGNvbXBsZXRlU291cmNlID8gY29tcGxldGVTb3VyY2UgOiB1bmRlZmluZWQsXG4gICAgbG9jYXRpb24sXG4gICAgcGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1ldGVycywgc291cmNlUGFyYW1ldGVycyksXG4gICAgc3RyaWN0LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUGFyYW1ldGVycyhzbmlwcGV0OiBUeXBlU2NyaXB0U25pcHBldCwgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogVHlwZVNjcmlwdFNuaXBwZXQge1xuICByZXR1cm4ge1xuICAgIC4uLnNuaXBwZXQsXG4gICAgcGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBzbmlwcGV0LnBhcmFtZXRlcnMgPz8ge30sIHBhcmFtcyksXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb21wbGV0ZSAoY29tcGlsYWJsZSkgc291cmNlIG9mIGEgc25pcHBldFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGxldGVTb3VyY2Uoc25pcHBldDogVHlwZVNjcmlwdFNuaXBwZXQpIHtcbiAgcmV0dXJuIHNuaXBwZXQuY29tcGxldGVTb3VyY2UgPz8gc25pcHBldC52aXNpYmxlU291cmNlO1xufVxuXG4vKipcbiAqIEV4dHJhY3Qgc25pcHBldCBwYXJhbWV0ZXJzIGZyb20gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIHNvdXJjZSBpZiBpdCdzIGEgY29tcGlsZXIgZGlyZWN0aXZlXG4gKi9cbmZ1bmN0aW9uIHBhcmFtZXRlcnNGcm9tU291cmNlRGlyZWN0aXZlcyhzb3VyY2U6IHN0cmluZyk6IFtzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZz5dIHtcbiAgY29uc3QgW2ZpcnN0TGluZSwgLi4ucmVzdF0gPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAvLyBBbHNvIGV4dHJhY3QgcGFyYW1ldGVycyBmcm9tIGFuIGluaXRpYWwgbGluZSBzdGFydGluZyB3aXRoICcvLy8gJyAoZ2V0dGluZyByaWQgb2YgdGhhdCBsaW5lKS5cbiAgY29uc3QgbSA9IC9bL117M30oLiopJC8uZXhlYyhmaXJzdExpbmUpO1xuICBpZiAobSkge1xuICAgIHJldHVybiBbcmVzdC5qb2luKCdcXG4nKSwgcGFyc2VNZXRhZGF0YUxpbmUobVsxXSldO1xuICB9XG5cbiAgcmV0dXJuIFtzb3VyY2UsIHt9XTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHNldCBvZiAncGFyYW0gcGFyYW09dmFsdWUnIGRpcmVjdGl2ZXMgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlS2V5VmFsdWVMaXN0KHBhcmFtZXRlcnM6IHN0cmluZ1tdKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhcmFtLnNwbGl0KCc9JywgMik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0W3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRbcGFydHNbMF1dID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1ldGFkYXRhTGluZShtZXRhZGF0YTogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIHJldHVybiBwYXJzZUtleVZhbHVlTGlzdChwYXJzZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG5cbiAgZnVuY3Rpb24gcGFyc2VNZXRhZGF0YShtZXRhZGF0YTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBtZXRhZGF0YVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoKHMpID0+IHMudHJpbSgpKVxuICAgICAgLmZpbHRlcigocykgPT4gcyAhPT0gJycpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNZXRhZGF0YWxpbmUobWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGxpbmUgPSBPYmplY3QuZW50cmllcyhtZXRhZGF0YSlcbiAgICAuZmlsdGVyKChba2V5LCBfXSkgPT4gIWtleS5zdGFydHNXaXRoKCckJykpXG4gICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAodmFsdWUgIT09ICcnID8gYCR7a2V5fT0ke3ZhbHVlfWAgOiBrZXkpKVxuICAgIC5qb2luKCcgJyk7XG5cbiAgcmV0dXJuIGxpbmUgPyBsaW5lIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJlY29nbml6ZWQgc25pcHBldCBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBlbnVtIFNuaXBwZXRQYXJhbWV0ZXJzIHtcbiAgLyoqXG4gICAqIFVzZSBmaXh0dXJlIHdpdGggdGhlIGdpdmVuIG5hbWUgKGF1dGhvciBwYXJhbWV0ZXIpXG4gICAqL1xuICBGSVhUVVJFID0gJ2ZpeHR1cmUnLFxuXG4gIC8qKlxuICAgKiBEb24ndCB1c2UgYSBmaXh0dXJlIChhdXRob3IgcGFyYW1ldGVyKVxuICAgKi9cbiAgTk9fRklYVFVSRSA9ICdub2ZpeHR1cmUnLFxuXG4gIC8qKlxuICAgKiBTbmlwcGV0IHdhcyBleHRyYWN0ZWQgZnJvbSB0aGlzIGxpdGVyYXRlIGZpbGUgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgKlxuICAgKiBQYXJhbWV0ZXIgYXR0YWNoZWQgYnkgJ2pzaWknOyBsb2FkIHRoZSBnaXZlbiBmaWxlIGluc3RlYWQgb2YgYW55IGZpeHR1cmUsXG4gICAqIHByb2Nlc3MgYXMgdXN1YWwuXG4gICAqL1xuICBMSVRFUkFURV9TT1VSQ0UgPSAnbGl0JyxcblxuICAvKipcbiAgICogV2hhdCBkaXJlY3RvcnkgdG8gcmVzb2x2ZSBmaXh0dXJlcyBpbiBmb3IgdGhpcyBzbmlwcGV0IChzeXN0ZW0gcGFyYW1ldGVyKVxuICAgKlxuICAgKiBBdHRhY2hlZCBkdXJpbmcgcHJvY2Vzc2luZywgc2hvdWxkIG5vdCBiZSB1c2VkIGJ5IGF1dGhvcnMuXG4gICAqL1xuICAkUFJPSkVDVF9ESVJFQ1RPUlkgPSAnJGRpcmVjdG9yeScsXG5cbiAgLyoqXG4gICAqIFdoYXQgZGlyZWN0b3J5IHRvIHByZXRlbmQgdGhlIGZpbGUgaXMgaW4gKHN5c3RlbSBwYXJhbWV0ZXIpXG4gICAqXG4gICAqIEF0dGFjaGVkIHdoZW4gY29tcGlsaW5nIGEgbGl0ZXJhdGUgZmlsZSwgYXMgdGhleSBjb21waWxlIGluXG4gICAqIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGV5IGFyZSBzdG9yZWQuXG4gICAqL1xuICAkQ09NUElMQVRJT05fRElSRUNUT1JZID0gJyRjb21waWxhdGlvbicsXG59XG4iXX0=