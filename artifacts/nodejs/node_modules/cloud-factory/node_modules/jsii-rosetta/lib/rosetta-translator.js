"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RosettaTranslator = void 0;
const fingerprinting_1 = require("./jsii/fingerprinting");
const languages_1 = require("./languages");
const logging = require("./logging");
const snippet_1 = require("./snippet");
const key_1 = require("./tablets/key");
const tablets_1 = require("./tablets/tablets");
const translate_all_1 = require("./translate_all");
/**
 * Entry point for consumers that want to translate code on-the-fly
 *
 * If you want to generate and translate code on-the-fly, in ways that cannot
 * be achieved by the rosetta CLI, use this class.
 */
class RosettaTranslator {
    constructor(options = {}) {
        var _a, _b;
        /**
         * Tablet with fresh translations
         *
         * All new translations (not read from cache) are added to this tablet.
         */
        this.tablet = new tablets_1.LanguageTablet();
        this.cache = new tablets_1.LanguageTablet();
        this.fingerprinter = new fingerprinting_1.TypeFingerprinter((_a = options === null || options === void 0 ? void 0 : options.assemblies) !== null && _a !== void 0 ? _a : []);
        this.includeCompilerDiagnostics = (_b = options.includeCompilerDiagnostics) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * @deprecated use `addToCache` instead
     */
    async loadCache(fileName) {
        try {
            await this.cache.load(fileName);
        }
        catch (e) {
            logging.warn(`Error reading cache ${fileName}: ${e.message}`);
        }
    }
    async addToCache(filename) {
        const tab = await tablets_1.LanguageTablet.fromOptionalFile(filename);
        this.cache.addTablet(tab);
    }
    addTabletsToCache(...tablets) {
        for (const tab of tablets) {
            this.cache.addTablet(tab);
        }
    }
    hasCache() {
        return this.cache.count > 0;
    }
    /**
     * For all the given snippets, try to read translations from the cache
     *
     * Will remove the cached snippets from the input array.
     */
    readFromCache(snippets, addToTablet = true, compiledOnly = false) {
        const remaining = [...snippets];
        const translations = new Array();
        let i = 0;
        while (i < remaining.length) {
            const fromCache = tryReadFromCache(remaining[i], this.cache, this.fingerprinter);
            // If compiledOnly is set, do not consider cached snippets that do not compile
            if (fromCache && (!compiledOnly || fromCache.snippet.didCompile)) {
                if (addToTablet) {
                    this.tablet.addSnippet(fromCache);
                }
                remaining.splice(i, 1);
                translations.push(fromCache);
            }
            else {
                i += 1;
            }
        }
        return { translations, remaining };
    }
    async translateAll(snippets, addToTablet = true) {
        const result = await translate_all_1.translateAll(snippets, this.includeCompilerDiagnostics);
        const fingerprinted = result.translatedSnippets.map((snippet) => snippet.withFingerprint(this.fingerprinter.fingerprintAll(snippet.fqnsReferenced())));
        if (addToTablet) {
            for (const translation of fingerprinted) {
                this.tablet.addSnippet(translation);
            }
        }
        return {
            translatedSnippets: fingerprinted,
            diagnostics: result.diagnostics,
        };
    }
}
exports.RosettaTranslator = RosettaTranslator;
/**
 * Try to find the translation for the given snippet in the given cache
 *
 * Rules for cacheability are:
 * - id is the same (== visible source didn't change)
 * - complete source is the same (== fixture didn't change)
 * - all types involved have the same fingerprint (== API surface didn't change)
 * - the versions of all translations match the versions on the available translators (== translator itself didn't change)
 *
 * For the versions check: we could have selectively picked some translations
 * from the cache while performing others. However, since the big work is in
 * parsing the TypeScript, and the rendering itself is peanutes (assumption), it
 * doesn't really make a lot of difference.  So, for simplification's sake,
 * we'll regen all translations if there's at least one that's outdated.
 */
function tryReadFromCache(sourceSnippet, cache, fingerprinter) {
    const fromCache = cache.tryGetSnippet(key_1.snippetKey(sourceSnippet));
    // infused snippets won't pass the full source check or the fingerprinter
    // but there is no reason to try to recompile it, so return cached snippet
    // if there exists one.
    if (isInfused(sourceSnippet)) {
        return fromCache;
    }
    const cacheable = fromCache &&
        snippet_1.completeSource(sourceSnippet) === fromCache.snippet.fullSource &&
        Object.entries(languages_1.TARGET_LANGUAGES).every(([lang, translator]) => { var _a, _b; return ((_b = (_a = fromCache.snippet.translations) === null || _a === void 0 ? void 0 : _a[lang]) === null || _b === void 0 ? void 0 : _b.version) === translator.version; }) &&
        fingerprinter.fingerprintAll(fromCache.fqnsReferenced()) === fromCache.snippet.fqnsFingerprint;
    return cacheable ? fromCache : undefined;
}
function isInfused(snippet) {
    var _a;
    return ((_a = snippet.parameters) === null || _a === void 0 ? void 0 : _a.infused) !== undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9zZXR0YS10cmFuc2xhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicm9zZXR0YS10cmFuc2xhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLDBEQUEwRDtBQUMxRCwyQ0FBK0M7QUFDL0MscUNBQXFDO0FBQ3JDLHVDQUE4RDtBQUM5RCx1Q0FBMkM7QUFDM0MsK0NBQXNFO0FBQ3RFLG1EQUFtRTtBQTZCbkU7Ozs7O0dBS0c7QUFDSCxNQUFhLGlCQUFpQjtJQVk1QixZQUFtQixVQUFvQyxFQUFFOztRQVh6RDs7OztXQUlHO1FBQ2EsV0FBTSxHQUFHLElBQUksd0JBQWMsRUFBRSxDQUFDO1FBRzdCLFVBQUssR0FBRyxJQUFJLHdCQUFjLEVBQUUsQ0FBQztRQUk1QyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksa0NBQWlCLE9BQUMsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFVBQVUsbUNBQUksRUFBRSxDQUFDLENBQUM7UUFDdEUsSUFBSSxDQUFDLDBCQUEwQixTQUFHLE9BQU8sQ0FBQywwQkFBMEIsbUNBQUksS0FBSyxDQUFDO0lBQ2hGLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxTQUFTLENBQUMsUUFBZ0I7UUFDckMsSUFBSTtZQUNGLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDakM7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLFFBQVEsS0FBSyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUMvRDtJQUNILENBQUM7SUFFTSxLQUFLLENBQUMsVUFBVSxDQUFDLFFBQWdCO1FBQ3RDLE1BQU0sR0FBRyxHQUFHLE1BQU0sd0JBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM1RCxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1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cEMsQ0FBQyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsRUFBRSxFQUFFLGVBQUMsT0FBQSxhQUFBLFNBQVMsQ0FBQyxPQUFPLENBQUMsWUFBWSwwQ0FBRyxJQUFJLDJDQUFHLE9BQU8sTUFBSyxVQUFVLENBQUMsT0FBTyxDQUFBLEVBQUEsQ0FDL0Y7UUFDRCxhQUFhLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDO0lBRWpHLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUMzQyxDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUMsT0FBMEI7O0lBQzNDLE9BQU8sT0FBQSxPQUFPLENBQUMsVUFBVSwwQ0FBRSxPQUFPLE1BQUssU0FBUyxDQUFDO0FBQ25ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzcGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuXG5pbXBvcnQgeyBUeXBlRmluZ2VycHJpbnRlciB9IGZyb20gJy4vanNpaS9maW5nZXJwcmludGluZyc7XG5pbXBvcnQgeyBUQVJHRVRfTEFOR1VBR0VTIH0gZnJvbSAnLi9sYW5ndWFnZXMnO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICcuL2xvZ2dpbmcnO1xuaW1wb3J0IHsgVHlwZVNjcmlwdFNuaXBwZXQsIGNvbXBsZXRlU291cmNlIH0gZnJvbSAnLi9zbmlwcGV0JztcbmltcG9ydCB7IHNuaXBwZXRLZXkgfSBmcm9tICcuL3RhYmxldHMva2V5JztcbmltcG9ydCB7IExhbmd1YWdlVGFibGV0LCBUcmFuc2xhdGVkU25pcHBldCB9IGZyb20gJy4vdGFibGV0cy90YWJsZXRzJztcbmltcG9ydCB7IHRyYW5zbGF0ZUFsbCwgVHJhbnNsYXRlQWxsUmVzdWx0IH0gZnJvbSAnLi90cmFuc2xhdGVfYWxsJztcblxuZXhwb3J0IGludGVyZmFjZSBSb3NldHRhVHJhbnNsYXRvck9wdGlvbnMge1xuICAvKipcbiAgICogQXNzZW1ibGllcyB0byB1c2UgZm9yIGZpbmdlcnByaW50aW5nXG4gICAqXG4gICAqIFRoZSBzZXQgb2YgYXNzZW1ibGllcyBoZXJlIGFyZSB1c2VkIHRvIGludmFsaWRhdGUgdGhlIGNhY2hlLiBBbnkgdHlwZXMgdGhhdCBhcmVcbiAgICogdXNlZCBpbiBzbmlwcGV0cyBhcmUgbG9va2VkIHVwIGluIHRoaXMgc2V0IG9mIGFzc2VtYmxpZXMuIElmIGZvdW5kLCB0aGVpciB0eXBlXG4gICAqIGluZm9ybWF0aW9uIGlzIGZpbmdlcnByaW50ZWQgYW5kIGNvbXBhcmVkIHRvIHRoZSB0eXBlIGluZm9ybWF0aW9uIGF0IHRoZSB0aW1lXG4gICAqIGNvbXBpbGF0aW9uIG9mIHRoZSBjYWNoZWQgc2FtcGxlLiBJZiBkaWZmZXJlbnQsIHRoaXMgaXMgY29uc2lkZXJlZCB0byBiZSBhIGNhY2hlXG4gICAqIG1pc3MuXG4gICAqXG4gICAqIFlvdSBtdXN0IHVzZSB0aGUgc2FtZSBzZXQgb2YgYXNzZW1ibGllcyB3aGVuIGdlbmVyYXRpbmcgYW5kIHJlYWRpbmcgdGhlIGNhY2hlXG4gICAqIGZpbGUsIG90aGVyd2lzZSB0aGUgZmluZ2VycHJpbnQgaXMgZ3VhcmFudGVlZCB0byBiZSBkaWZmZXJlbnQgYW5kIHRoZSBjYWNoZSB3aWxsXG4gICAqIGJlIHVzZWxlc3MgKGUuZy4gaWYgeW91IGdlbmVyYXRlIHRoZSBjYWNoZSBXSVRIIGFzc2VtYmx5IGluZm9ybWF0aW9uIGJ1dFxuICAgKiByZWFkIGl0IHdpdGhvdXQsIG9yIHZpY2UgdmVyc2EpLlxuICAgKlxuICAgKiBAZGVmYXVsdCBObyBhc3NlbWJsaWVzLlxuICAgKi9cbiAgcmVhZG9ubHkgYXNzZW1ibGllcz86IHNwZWMuQXNzZW1ibHlbXTtcblxuICAvKipcbiAgICogV2hldGhlciB0byBpbmNsdWRlIGNvbXBpbGVyIGRpYWdub3N0aWNzIGluIHRoZSBjb21waWxhdGlvbiByZXN1bHRzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3M/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEVudHJ5IHBvaW50IGZvciBjb25zdW1lcnMgdGhhdCB3YW50IHRvIHRyYW5zbGF0ZSBjb2RlIG9uLXRoZS1mbHlcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBnZW5lcmF0ZSBhbmQgdHJhbnNsYXRlIGNvZGUgb24tdGhlLWZseSwgaW4gd2F5cyB0aGF0IGNhbm5vdFxuICogYmUgYWNoaWV2ZWQgYnkgdGhlIHJvc2V0dGEgQ0xJLCB1c2UgdGhpcyBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJvc2V0dGFUcmFuc2xhdG9yIHtcbiAgLyoqXG4gICAqIFRhYmxldCB3aXRoIGZyZXNoIHRyYW5zbGF0aW9uc1xuICAgKlxuICAgKiBBbGwgbmV3IHRyYW5zbGF0aW9ucyAobm90IHJlYWQgZnJvbSBjYWNoZSkgYXJlIGFkZGVkIHRvIHRoaXMgdGFibGV0LlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHRhYmxldCA9IG5ldyBMYW5ndWFnZVRhYmxldCgpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgZmluZ2VycHJpbnRlcjogVHlwZUZpbmdlcnByaW50ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGUgPSBuZXcgTGFuZ3VhZ2VUYWJsZXQoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljczogYm9vbGVhbjtcblxuICBwdWJsaWMgY29uc3RydWN0b3Iob3B0aW9uczogUm9zZXR0YVRyYW5zbGF0b3JPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmZpbmdlcnByaW50ZXIgPSBuZXcgVHlwZUZpbmdlcnByaW50ZXIob3B0aW9ucz8uYXNzZW1ibGllcyA/PyBbXSk7XG4gICAgdGhpcy5pbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljcyA9IG9wdGlvbnMuaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3MgPz8gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBhZGRUb0NhY2hlYCBpbnN0ZWFkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbG9hZENhY2hlKGZpbGVOYW1lOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jYWNoZS5sb2FkKGZpbGVOYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnaW5nLndhcm4oYEVycm9yIHJlYWRpbmcgY2FjaGUgJHtmaWxlTmFtZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhZGRUb0NhY2hlKGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCB0YWIgPSBhd2FpdCBMYW5ndWFnZVRhYmxldC5mcm9tT3B0aW9uYWxGaWxlKGZpbGVuYW1lKTtcbiAgICB0aGlzLmNhY2hlLmFkZFRhYmxldCh0YWIpO1xuICB9XG5cbiAgcHVibGljIGFkZFRhYmxldHNUb0NhY2hlKC4uLnRhYmxldHM6IExhbmd1YWdlVGFibGV0W10pIHtcbiAgICBmb3IgKGNvbnN0IHRhYiBvZiB0YWJsZXRzKSB7XG4gICAgICB0aGlzLmNhY2hlLmFkZFRhYmxldCh0YWIpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBoYXNDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5jb3VudCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGFsbCB0aGUgZ2l2ZW4gc25pcHBldHMsIHRyeSB0byByZWFkIHRyYW5zbGF0aW9ucyBmcm9tIHRoZSBjYWNoZVxuICAgKlxuICAgKiBXaWxsIHJlbW92ZSB0aGUgY2FjaGVkIHNuaXBwZXRzIGZyb20gdGhlIGlucHV0IGFycmF5LlxuICAgKi9cbiAgcHVibGljIHJlYWRGcm9tQ2FjaGUoc25pcHBldHM6IFR5cGVTY3JpcHRTbmlwcGV0W10sIGFkZFRvVGFibGV0ID0gdHJ1ZSwgY29tcGlsZWRPbmx5ID0gZmFsc2UpOiBSZWFkRnJvbUNhY2hlUmVzdWx0cyB7XG4gICAgY29uc3QgcmVtYWluaW5nID0gWy4uLnNuaXBwZXRzXTtcbiAgICBjb25zdCB0cmFuc2xhdGlvbnMgPSBuZXcgQXJyYXk8VHJhbnNsYXRlZFNuaXBwZXQ+KCk7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCByZW1haW5pbmcubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmcm9tQ2FjaGUgPSB0cnlSZWFkRnJvbUNhY2hlKHJlbWFpbmluZ1tpXSwgdGhpcy5jYWNoZSwgdGhpcy5maW5nZXJwcmludGVyKTtcbiAgICAgIC8vIElmIGNvbXBpbGVkT25seSBpcyBzZXQsIGRvIG5vdCBjb25zaWRlciBjYWNoZWQgc25pcHBldHMgdGhhdCBkbyBub3QgY29tcGlsZVxuICAgICAgaWYgKGZyb21DYWNoZSAmJiAoIWNvbXBpbGVkT25seSB8fCBmcm9tQ2FjaGUuc25pcHBldC5kaWRDb21waWxlKSkge1xuICAgICAgICBpZiAoYWRkVG9UYWJsZXQpIHtcbiAgICAgICAgICB0aGlzLnRhYmxldC5hZGRTbmlwcGV0KGZyb21DYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgdHJhbnNsYXRpb25zLnB1c2goZnJvbUNhY2hlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmFuc2xhdGlvbnMsIHJlbWFpbmluZyB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHRyYW5zbGF0ZUFsbChzbmlwcGV0czogVHlwZVNjcmlwdFNuaXBwZXRbXSwgYWRkVG9UYWJsZXQgPSB0cnVlKTogUHJvbWlzZTxUcmFuc2xhdGVBbGxSZXN1bHQ+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0cmFuc2xhdGVBbGwoc25pcHBldHMsIHRoaXMuaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3MpO1xuXG4gICAgY29uc3QgZmluZ2VycHJpbnRlZCA9IHJlc3VsdC50cmFuc2xhdGVkU25pcHBldHMubWFwKChzbmlwcGV0KSA9PlxuICAgICAgc25pcHBldC53aXRoRmluZ2VycHJpbnQodGhpcy5maW5nZXJwcmludGVyLmZpbmdlcnByaW50QWxsKHNuaXBwZXQuZnFuc1JlZmVyZW5jZWQoKSkpLFxuICAgICk7XG5cbiAgICBpZiAoYWRkVG9UYWJsZXQpIHtcbiAgICAgIGZvciAoY29uc3QgdHJhbnNsYXRpb24gb2YgZmluZ2VycHJpbnRlZCkge1xuICAgICAgICB0aGlzLnRhYmxldC5hZGRTbmlwcGV0KHRyYW5zbGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNsYXRlZFNuaXBwZXRzOiBmaW5nZXJwcmludGVkLFxuICAgICAgZGlhZ25vc3RpY3M6IHJlc3VsdC5kaWFnbm9zdGljcyxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogVHJ5IHRvIGZpbmQgdGhlIHRyYW5zbGF0aW9uIGZvciB0aGUgZ2l2ZW4gc25pcHBldCBpbiB0aGUgZ2l2ZW4gY2FjaGVcbiAqXG4gKiBSdWxlcyBmb3IgY2FjaGVhYmlsaXR5IGFyZTpcbiAqIC0gaWQgaXMgdGhlIHNhbWUgKD09IHZpc2libGUgc291cmNlIGRpZG4ndCBjaGFuZ2UpXG4gKiAtIGNvbXBsZXRlIHNvdXJjZSBpcyB0aGUgc2FtZSAoPT0gZml4dHVyZSBkaWRuJ3QgY2hhbmdlKVxuICogLSBhbGwgdHlwZXMgaW52b2x2ZWQgaGF2ZSB0aGUgc2FtZSBmaW5nZXJwcmludCAoPT0gQVBJIHN1cmZhY2UgZGlkbid0IGNoYW5nZSlcbiAqIC0gdGhlIHZlcnNpb25zIG9mIGFsbCB0cmFuc2xhdGlvbnMgbWF0Y2ggdGhlIHZlcnNpb25zIG9uIHRoZSBhdmFpbGFibGUgdHJhbnNsYXRvcnMgKD09IHRyYW5zbGF0b3IgaXRzZWxmIGRpZG4ndCBjaGFuZ2UpXG4gKlxuICogRm9yIHRoZSB2ZXJzaW9ucyBjaGVjazogd2UgY291bGQgaGF2ZSBzZWxlY3RpdmVseSBwaWNrZWQgc29tZSB0cmFuc2xhdGlvbnNcbiAqIGZyb20gdGhlIGNhY2hlIHdoaWxlIHBlcmZvcm1pbmcgb3RoZXJzLiBIb3dldmVyLCBzaW5jZSB0aGUgYmlnIHdvcmsgaXMgaW5cbiAqIHBhcnNpbmcgdGhlIFR5cGVTY3JpcHQsIGFuZCB0aGUgcmVuZGVyaW5nIGl0c2VsZiBpcyBwZWFudXRlcyAoYXNzdW1wdGlvbiksIGl0XG4gKiBkb2Vzbid0IHJlYWxseSBtYWtlIGEgbG90IG9mIGRpZmZlcmVuY2UuICBTbywgZm9yIHNpbXBsaWZpY2F0aW9uJ3Mgc2FrZSxcbiAqIHdlJ2xsIHJlZ2VuIGFsbCB0cmFuc2xhdGlvbnMgaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgdGhhdCdzIG91dGRhdGVkLlxuICovXG5mdW5jdGlvbiB0cnlSZWFkRnJvbUNhY2hlKHNvdXJjZVNuaXBwZXQ6IFR5cGVTY3JpcHRTbmlwcGV0LCBjYWNoZTogTGFuZ3VhZ2VUYWJsZXQsIGZpbmdlcnByaW50ZXI6IFR5cGVGaW5nZXJwcmludGVyKSB7XG4gIGNvbnN0IGZyb21DYWNoZSA9IGNhY2hlLnRyeUdldFNuaXBwZXQoc25pcHBldEtleShzb3VyY2VTbmlwcGV0KSk7XG5cbiAgLy8gaW5mdXNlZCBzbmlwcGV0cyB3b24ndCBwYXNzIHRoZSBmdWxsIHNvdXJjZSBjaGVjayBvciB0aGUgZmluZ2VycHJpbnRlclxuICAvLyBidXQgdGhlcmUgaXMgbm8gcmVhc29uIHRvIHRyeSB0byByZWNvbXBpbGUgaXQsIHNvIHJldHVybiBjYWNoZWQgc25pcHBldFxuICAvLyBpZiB0aGVyZSBleGlzdHMgb25lLlxuICBpZiAoaXNJbmZ1c2VkKHNvdXJjZVNuaXBwZXQpKSB7XG4gICAgcmV0dXJuIGZyb21DYWNoZTtcbiAgfVxuXG4gIGNvbnN0IGNhY2hlYWJsZSA9XG4gICAgZnJvbUNhY2hlICYmXG4gICAgY29tcGxldGVTb3VyY2Uoc291cmNlU25pcHBldCkgPT09IGZyb21DYWNoZS5zbmlwcGV0LmZ1bGxTb3VyY2UgJiZcbiAgICBPYmplY3QuZW50cmllcyhUQVJHRVRfTEFOR1VBR0VTKS5ldmVyeShcbiAgICAgIChbbGFuZywgdHJhbnNsYXRvcl0pID0+IGZyb21DYWNoZS5zbmlwcGV0LnRyYW5zbGF0aW9ucz8uW2xhbmddPy52ZXJzaW9uID09PSB0cmFuc2xhdG9yLnZlcnNpb24sXG4gICAgKSAmJlxuICAgIGZpbmdlcnByaW50ZXIuZmluZ2VycHJpbnRBbGwoZnJvbUNhY2hlLmZxbnNSZWZlcmVuY2VkKCkpID09PSBmcm9tQ2FjaGUuc25pcHBldC5mcW5zRmluZ2VycHJpbnQ7XG5cbiAgcmV0dXJuIGNhY2hlYWJsZSA/IGZyb21DYWNoZSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNJbmZ1c2VkKHNuaXBwZXQ6IFR5cGVTY3JpcHRTbmlwcGV0KSB7XG4gIHJldHVybiBzbmlwcGV0LnBhcmFtZXRlcnM/LmluZnVzZWQgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWFkRnJvbUNhY2hlUmVzdWx0cyB7XG4gIHJlYWRvbmx5IHRyYW5zbGF0aW9uczogVHJhbnNsYXRlZFNuaXBwZXRbXTtcbiAgcmVhZG9ubHkgcmVtYWluaW5nOiBUeXBlU2NyaXB0U25pcHBldFtdO1xufVxuIl19