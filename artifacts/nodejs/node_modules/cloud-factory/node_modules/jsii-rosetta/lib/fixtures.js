"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixturize = void 0;
const fs = require("fs-extra");
const path = require("path");
const typescript_1 = require("typescript");
const snippet_1 = require("./snippet");
/**
 * Complete snippets with fixtures, if required
 */
function fixturize(snippet, loose = false) {
    var _a;
    let source = snippet.visibleSource;
    const parameters = (_a = snippet.parameters) !== null && _a !== void 0 ? _a : {};
    const directory = parameters[snippet_1.SnippetParameters.$PROJECT_DIRECTORY];
    if (!directory) {
        return snippet;
    }
    const literateSource = parameters[snippet_1.SnippetParameters.LITERATE_SOURCE];
    if (literateSource) {
        // Compatibility with the "old school" example inclusion mechanism.
        // Completely load this file and attach a parameter with its directory.
        try {
            source = loadLiterateSource(directory, literateSource);
        }
        catch (ex) {
            // In loose mode, we ignore this failure and stick to the visible source.
            if (!loose) {
                throw ex;
            }
        }
        parameters[snippet_1.SnippetParameters.$COMPILATION_DIRECTORY] = path.join(directory, path.dirname(literateSource));
    }
    else if (parameters[snippet_1.SnippetParameters.FIXTURE]) {
        // Explicitly requested fixture must exist, unless we are operating in loose mode
        source = loadAndSubFixture(directory, snippet.location.api, parameters.fixture, source, !loose);
    }
    else if (parameters[snippet_1.SnippetParameters.NO_FIXTURE] === undefined) {
        // Don't explicitly request no fixture, load the default.
        source = loadAndSubFixture(directory, snippet.location.api, 'default', source, false);
    }
    return {
        ...snippet,
        completeSource: source,
        parameters,
    };
}
exports.fixturize = fixturize;
function loadLiterateSource(directory, literateFileName) {
    const fullPath = path.join(directory, literateFileName);
    const exists = fs.existsSync(fullPath);
    if (!exists) {
        // This couldn't really happen in practice, but do the check anyway
        throw new Error(`Sample uses literate source ${literateFileName}, but not found: ${fullPath}`);
    }
    return fs.readFileSync(fullPath, { encoding: 'utf-8' });
}
/**
 * Load the fixture with the given name, and substitute the source into it
 *
 * If no fixture could be found and `mustExist` is true, and error will be thrown.
 *
 * In principle, the fixture we're looking for is `rosetta/FIXTURE.ts-fixture`.
 * However, we want to support an automatic transform of many small packages
 * combined into a single large package, perhaps into submodules (i.e., we want
 * to support monocdk), and in those cases the names of fixtures might conflict.
 * For example, all of them will have a `default.ts-fixture`, and there won't be
 * any explicit reference to that file anywhere... yet in the combined
 * monopackage we have to distinguish those fixtures.
 *
 * Therefore, we will consider submodule names as subdirectories, based on the
 * API location of the snippet we're fixturizing.
 *
 * (For example, the fixtures for a type called `monocdk.aws_s3.Bucket` will be
 * searched both in `rosetta/aws_s3/default.ts-fixture` as well as
 * `rosetta/default.ts-fixture`).
 */
function loadAndSubFixture(directory, location, fixtureName, source, mustExist) {
    const candidates = fixtureCandidates(directory, fixtureName, location);
    const fixtureFileName = candidates.find((n) => fs.existsSync(n));
    if (!fixtureFileName) {
        if (mustExist) {
            throw new Error(`Sample uses fixture ${fixtureName}, but not found: ${JSON.stringify(candidates)}`);
        }
        return source;
    }
    const fixtureContents = fs.readFileSync(fixtureFileName, {
        encoding: 'utf-8',
    });
    const subRegex = /[/]{3}[ \t]*here[ \t]*$/im;
    if (!subRegex.test(fixtureContents)) {
        throw new Error(`Fixture does not contain '/// here': ${fixtureFileName}`);
    }
    const { imports, statements } = sidelineImports(source);
    const show = '/// !show';
    const hide = '/// !hide';
    const result = fixtureContents.replace(subRegex, [
        '// Code snippet begins after !show marker below',
        show,
        statements,
        hide,
        '// Code snippet ended before !hide marker above',
    ].join('\n'));
    return imports
        ? [
            '// Hoisted imports begin after !show marker below',
            show,
            imports,
            hide,
            '// Hoisted imports ended before !hide marker above',
            result,
        ].join('\n')
        : result;
}
function fixtureCandidates(directory, fixtureName, location) {
    const ret = new Array();
    const fileName = `${fixtureName}.ts-fixture`;
    const mods = submodules(location);
    ret.push(path.join(directory, 'rosetta', fileName));
    for (let i = 0; i < mods.length; i++) {
        ret.push(path.join(directory, 'rosetta', ...mods.slice(0, i + 1), fileName));
    }
    // Most specific one up front
    ret.reverse();
    return ret;
}
/**
 * Return the submodule parts from a given ApiLocation
 */
function submodules(location) {
    switch (location.api) {
        case 'file':
            return [];
        case 'initializer':
        case 'member':
        case 'type':
        case 'parameter':
            return middle(location.fqn.split('.'));
        case 'moduleReadme':
            return location.moduleFqn.split('.').slice(1);
    }
    function middle(xs) {
        return xs.slice(1, xs.length - 1);
    }
}
/**
 * When embedding code fragments in a fixture, "import" statements must be
 * hoisted up to the top of the resulting document, as TypeScript only allows
 * those to be present in the top-level context of an ESM.
 *
 * @param source a block of TypeScript source
 *
 * @returns an object containing the import statements on one end, and the rest
 *          on the other hand.
 */
function sidelineImports(source) {
    let imports = '';
    let statements = '';
    const sourceFile = typescript_1.createSourceFile('index.ts', source, typescript_1.ScriptTarget.Latest, true, typescript_1.ScriptKind.TS);
    for (const statement of sourceFile.statements) {
        if (statement.kind === typescript_1.SyntaxKind.ImportDeclaration ||
            statement.kind === typescript_1.SyntaxKind.ImportEqualsDeclaration ||
            (statement.kind === typescript_1.SyntaxKind.VariableStatement &&
                statement.getChildAt(0).getChildAt(0).kind === typescript_1.SyntaxKind.DeclareKeyword)) {
            imports += statement.getFullText(sourceFile);
        }
        else {
            statements += statement.getFullText(sourceFile);
        }
    }
    return { imports, statements };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZml4dHVyZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaXh0dXJlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLDJDQUFvRjtBQUVwRix1Q0FBOEU7QUFFOUU7O0dBRUc7QUFDSCxTQUFnQixTQUFTLENBQUMsT0FBMEIsRUFBRSxLQUFLLEdBQUcsS0FBSzs7SUFDakUsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQztJQUNuQyxNQUFNLFVBQVUsU0FBRyxPQUFPLENBQUMsVUFBVSxtQ0FBSSxFQUFFLENBQUM7SUFFNUMsTUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLDJCQUFpQixDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDbkUsSUFBSSxDQUFDLFNBQVMsRUFBRTtRQUNkLE9BQU8sT0FBTyxDQUFDO0tBQ2hCO0lBRUQsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLDJCQUFpQixDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ3JFLElBQUksY0FBYyxFQUFFO1FBQ2xCLG1FQUFtRTtRQUNuRSx1RUFBdUU7UUFDdkUsSUFBSTtZQUNGLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDLENBQUM7U0FDeEQ7UUFBQyxPQUFPLEVBQUUsRUFBRTtZQUNYLHlFQUF5RTtZQUN6RSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNWLE1BQU0sRUFBRSxDQUFDO2FBQ1Y7U0FDRjtRQUNELFVBQVUsQ0FBQywyQkFBaUIsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztLQUMzRztTQUFNLElBQUksVUFBVSxDQUFDLDJCQUFpQixDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ2hELGlGQUFpRjtRQUNqRixNQUFNLEdBQUcsaUJBQWlCLENBQUMsU0FBUyxFQUFFLE9B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bmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVTb3VyY2VGaWxlLCBTY3JpcHRLaW5kLCBTY3JpcHRUYXJnZXQsIFN5bnRheEtpbmQgfSBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHsgVHlwZVNjcmlwdFNuaXBwZXQsIFNuaXBwZXRQYXJhbWV0ZXJzLCBBcGlMb2NhdGlvbiB9IGZyb20gJy4vc25pcHBldCc7XG5cbi8qKlxuICogQ29tcGxldGUgc25pcHBldHMgd2l0aCBmaXh0dXJlcywgaWYgcmVxdWlyZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeHR1cml6ZShzbmlwcGV0OiBUeXBlU2NyaXB0U25pcHBldCwgbG9vc2UgPSBmYWxzZSk6IFR5cGVTY3JpcHRTbmlwcGV0IHtcbiAgbGV0IHNvdXJjZSA9IHNuaXBwZXQudmlzaWJsZVNvdXJjZTtcbiAgY29uc3QgcGFyYW1ldGVycyA9IHNuaXBwZXQucGFyYW1ldGVycyA/PyB7fTtcblxuICBjb25zdCBkaXJlY3RvcnkgPSBwYXJhbWV0ZXJzW1NuaXBwZXRQYXJhbWV0ZXJzLiRQUk9KRUNUX0RJUkVDVE9SWV07XG4gIGlmICghZGlyZWN0b3J5KSB7XG4gICAgcmV0dXJuIHNuaXBwZXQ7XG4gIH1cblxuICBjb25zdCBsaXRlcmF0ZVNvdXJjZSA9IHBhcmFtZXRlcnNbU25pcHBldFBhcmFtZXRlcnMuTElURVJBVEVfU09VUkNFXTtcbiAgaWYgKGxpdGVyYXRlU291cmNlKSB7XG4gICAgLy8gQ29tcGF0aWJpbGl0eSB3aXRoIHRoZSBcIm9sZCBzY2hvb2xcIiBleGFtcGxlIGluY2x1c2lvbiBtZWNoYW5pc20uXG4gICAgLy8gQ29tcGxldGVseSBsb2FkIHRoaXMgZmlsZSBhbmQgYXR0YWNoIGEgcGFyYW1ldGVyIHdpdGggaXRzIGRpcmVjdG9yeS5cbiAgICB0cnkge1xuICAgICAgc291cmNlID0gbG9hZExpdGVyYXRlU291cmNlKGRpcmVjdG9yeSwgbGl0ZXJhdGVTb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAvLyBJbiBsb29zZSBtb2RlLCB3ZSBpZ25vcmUgdGhpcyBmYWlsdXJlIGFuZCBzdGljayB0byB0aGUgdmlzaWJsZSBzb3VyY2UuXG4gICAgICBpZiAoIWxvb3NlKSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJhbWV0ZXJzW1NuaXBwZXRQYXJhbWV0ZXJzLiRDT01QSUxBVElPTl9ESVJFQ1RPUlldID0gcGF0aC5qb2luKGRpcmVjdG9yeSwgcGF0aC5kaXJuYW1lKGxpdGVyYXRlU291cmNlKSk7XG4gIH0gZWxzZSBpZiAocGFyYW1ldGVyc1tTbmlwcGV0UGFyYW1ldGVycy5GSVhUVVJFXSkge1xuICAgIC8vIEV4cGxpY2l0bHkgcmVxdWVzdGVkIGZpeHR1cmUgbXVzdCBleGlzdCwgdW5sZXNzIHdlIGFyZSBvcGVyYXRpbmcgaW4gbG9vc2UgbW9kZVxuICAgIHNvdXJjZSA9IGxvYWRBbmRTdWJGaXh0dXJlKGRpcmVjdG9yeSwgc25pcHBldC5sb2NhdGlvbi5hcGksIHBhcmFtZXRlcnMuZml4dHVyZSwgc291cmNlLCAhbG9vc2UpO1xuICB9IGVsc2UgaWYgKHBhcmFtZXRlcnNbU25pcHBldFBhcmFtZXRlcnMuTk9fRklYVFVSRV0gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIERvbid0IGV4cGxpY2l0bHkgcmVxdWVzdCBubyBmaXh0dXJlLCBsb2FkIHRoZSBkZWZhdWx0LlxuICAgIHNvdXJjZSA9IGxvYWRBbmRTdWJGaXh0dXJlKGRpcmVjdG9yeSwgc25pcHBldC5sb2NhdGlvbi5hcGksICdkZWZhdWx0Jywgc291cmNlLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnNuaXBwZXQsXG4gICAgY29tcGxldGVTb3VyY2U6IHNvdXJjZSxcbiAgICBwYXJhbWV0ZXJzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBsb2FkTGl0ZXJhdGVTb3VyY2UoZGlyZWN0b3J5OiBzdHJpbmcsIGxpdGVyYXRlRmlsZU5hbWU6IHN0cmluZykge1xuICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIGxpdGVyYXRlRmlsZU5hbWUpO1xuICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGZ1bGxQYXRoKTtcbiAgaWYgKCFleGlzdHMpIHtcbiAgICAvLyBUaGlzIGNvdWxkbid0IHJlYWxseSBoYXBwZW4gaW4gcHJhY3RpY2UsIGJ1dCBkbyB0aGUgY2hlY2sgYW55d2F5XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTYW1wbGUgdXNlcyBsaXRlcmF0ZSBzb3VyY2UgJHtsaXRlcmF0ZUZpbGVOYW1lfSwgYnV0IG5vdCBmb3VuZDogJHtmdWxsUGF0aH1gKTtcbiAgfVxuICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZ1bGxQYXRoLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xufVxuXG4vKipcbiAqIExvYWQgdGhlIGZpeHR1cmUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgYW5kIHN1YnN0aXR1dGUgdGhlIHNvdXJjZSBpbnRvIGl0XG4gKlxuICogSWYgbm8gZml4dHVyZSBjb3VsZCBiZSBmb3VuZCBhbmQgYG11c3RFeGlzdGAgaXMgdHJ1ZSwgYW5kIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIEluIHByaW5jaXBsZSwgdGhlIGZpeHR1cmUgd2UncmUgbG9va2luZyBmb3IgaXMgYHJvc2V0dGEvRklYVFVSRS50cy1maXh0dXJlYC5cbiAqIEhvd2V2ZXIsIHdlIHdhbnQgdG8gc3VwcG9ydCBhbiBhdXRvbWF0aWMgdHJhbnNmb3JtIG9mIG1hbnkgc21hbGwgcGFja2FnZXNcbiAqIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgbGFyZ2UgcGFja2FnZSwgcGVyaGFwcyBpbnRvIHN1Ym1vZHVsZXMgKGkuZS4sIHdlIHdhbnRcbiAqIHRvIHN1cHBvcnQgbW9ub2NkayksIGFuZCBpbiB0aG9zZSBjYXNlcyB0aGUgbmFtZXMgb2YgZml4dHVyZXMgbWlnaHQgY29uZmxpY3QuXG4gKiBGb3IgZXhhbXBsZSwgYWxsIG9mIHRoZW0gd2lsbCBoYXZlIGEgYGRlZmF1bHQudHMtZml4dHVyZWAsIGFuZCB0aGVyZSB3b24ndCBiZVxuICogYW55IGV4cGxpY2l0IHJlZmVyZW5jZSB0byB0aGF0IGZpbGUgYW55d2hlcmUuLi4geWV0IGluIHRoZSBjb21iaW5lZFxuICogbW9ub3BhY2thZ2Ugd2UgaGF2ZSB0byBkaXN0aW5ndWlzaCB0aG9zZSBmaXh0dXJlcy5cbiAqXG4gKiBUaGVyZWZvcmUsIHdlIHdpbGwgY29uc2lkZXIgc3VibW9kdWxlIG5hbWVzIGFzIHN1YmRpcmVjdG9yaWVzLCBiYXNlZCBvbiB0aGVcbiAqIEFQSSBsb2NhdGlvbiBvZiB0aGUgc25pcHBldCB3ZSdyZSBmaXh0dXJpemluZy5cbiAqXG4gKiAoRm9yIGV4YW1wbGUsIHRoZSBmaXh0dXJlcyBmb3IgYSB0eXBlIGNhbGxlZCBgbW9ub2Nkay5hd3NfczMuQnVja2V0YCB3aWxsIGJlXG4gKiBzZWFyY2hlZCBib3RoIGluIGByb3NldHRhL2F3c19zMy9kZWZhdWx0LnRzLWZpeHR1cmVgIGFzIHdlbGwgYXNcbiAqIGByb3NldHRhL2RlZmF1bHQudHMtZml4dHVyZWApLlxuICovXG5mdW5jdGlvbiBsb2FkQW5kU3ViRml4dHVyZShcbiAgZGlyZWN0b3J5OiBzdHJpbmcsXG4gIGxvY2F0aW9uOiBBcGlMb2NhdGlvbixcbiAgZml4dHVyZU5hbWU6IHN0cmluZyxcbiAgc291cmNlOiBzdHJpbmcsXG4gIG11c3RFeGlzdDogYm9vbGVhbixcbikge1xuICBjb25zdCBjYW5kaWRhdGVzID0gZml4dHVyZUNhbmRpZGF0ZXMoZGlyZWN0b3J5LCBmaXh0dXJlTmFtZSwgbG9jYXRpb24pO1xuICBjb25zdCBmaXh0dXJlRmlsZU5hbWUgPSBjYW5kaWRhdGVzLmZpbmQoKG4pID0+IGZzLmV4aXN0c1N5bmMobikpO1xuXG4gIGlmICghZml4dHVyZUZpbGVOYW1lKSB7XG4gICAgaWYgKG11c3RFeGlzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTYW1wbGUgdXNlcyBmaXh0dXJlICR7Zml4dHVyZU5hbWV9LCBidXQgbm90IGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KGNhbmRpZGF0ZXMpfWApO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgY29uc3QgZml4dHVyZUNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKGZpeHR1cmVGaWxlTmFtZSwge1xuICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICB9KTtcblxuICBjb25zdCBzdWJSZWdleCA9IC9bL117M31bIFxcdF0qaGVyZVsgXFx0XSokL2ltO1xuICBpZiAoIXN1YlJlZ2V4LnRlc3QoZml4dHVyZUNvbnRlbnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRml4dHVyZSBkb2VzIG5vdCBjb250YWluICcvLy8gaGVyZSc6ICR7Zml4dHVyZUZpbGVOYW1lfWApO1xuICB9XG5cbiAgY29uc3QgeyBpbXBvcnRzLCBzdGF0ZW1lbnRzIH0gPSBzaWRlbGluZUltcG9ydHMoc291cmNlKTtcbiAgY29uc3Qgc2hvdyA9ICcvLy8gIXNob3cnO1xuICBjb25zdCBoaWRlID0gJy8vLyAhaGlkZSc7XG5cbiAgY29uc3QgcmVzdWx0ID0gZml4dHVyZUNvbnRlbnRzLnJlcGxhY2UoXG4gICAgc3ViUmVnZXgsXG4gICAgW1xuICAgICAgJy8vIENvZGUgc25pcHBldCBiZWdpbnMgYWZ0ZXIgIXNob3cgbWFya2VyIGJlbG93JyxcbiAgICAgIHNob3csXG4gICAgICBzdGF0ZW1lbnRzLFxuICAgICAgaGlkZSxcbiAgICAgICcvLyBDb2RlIHNuaXBwZXQgZW5kZWQgYmVmb3JlICFoaWRlIG1hcmtlciBhYm92ZScsXG4gICAgXS5qb2luKCdcXG4nKSxcbiAgKTtcblxuICByZXR1cm4gaW1wb3J0c1xuICAgID8gW1xuICAgICAgICAnLy8gSG9pc3RlZCBpbXBvcnRzIGJlZ2luIGFmdGVyICFzaG93IG1hcmtlciBiZWxvdycsXG4gICAgICAgIHNob3csXG4gICAgICAgIGltcG9ydHMsXG4gICAgICAgIGhpZGUsXG4gICAgICAgICcvLyBIb2lzdGVkIGltcG9ydHMgZW5kZWQgYmVmb3JlICFoaWRlIG1hcmtlciBhYm92ZScsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgIF0uam9pbignXFxuJylcbiAgICA6IHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZml4dHVyZUNhbmRpZGF0ZXMoZGlyZWN0b3J5OiBzdHJpbmcsIGZpeHR1cmVOYW1lOiBzdHJpbmcsIGxvY2F0aW9uOiBBcGlMb2NhdGlvbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgY29uc3QgZmlsZU5hbWUgPSBgJHtmaXh0dXJlTmFtZX0udHMtZml4dHVyZWA7XG4gIGNvbnN0IG1vZHMgPSBzdWJtb2R1bGVzKGxvY2F0aW9uKTtcblxuICByZXQucHVzaChwYXRoLmpvaW4oZGlyZWN0b3J5LCAncm9zZXR0YScsIGZpbGVOYW1lKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kcy5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHBhdGguam9pbihkaXJlY3RvcnksICdyb3NldHRhJywgLi4ubW9kcy5zbGljZSgwLCBpICsgMSksIGZpbGVOYW1lKSk7XG4gIH1cblxuICAvLyBNb3N0IHNwZWNpZmljIG9uZSB1cCBmcm9udFxuICByZXQucmV2ZXJzZSgpO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc3VibW9kdWxlIHBhcnRzIGZyb20gYSBnaXZlbiBBcGlMb2NhdGlvblxuICovXG5mdW5jdGlvbiBzdWJtb2R1bGVzKGxvY2F0aW9uOiBBcGlMb2NhdGlvbik6IHN0cmluZ1tdIHtcbiAgc3dpdGNoIChsb2NhdGlvbi5hcGkpIHtcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiBbXTtcbiAgICBjYXNlICdpbml0aWFsaXplcic6XG4gICAgY2FzZSAnbWVtYmVyJzpcbiAgICBjYXNlICd0eXBlJzpcbiAgICBjYXNlICdwYXJhbWV0ZXInOlxuICAgICAgcmV0dXJuIG1pZGRsZShsb2NhdGlvbi5mcW4uc3BsaXQoJy4nKSk7XG4gICAgY2FzZSAnbW9kdWxlUmVhZG1lJzpcbiAgICAgIHJldHVybiBsb2NhdGlvbi5tb2R1bGVGcW4uc3BsaXQoJy4nKS5zbGljZSgxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pZGRsZSh4czogc3RyaW5nW10pIHtcbiAgICByZXR1cm4geHMuc2xpY2UoMSwgeHMubGVuZ3RoIC0gMSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXaGVuIGVtYmVkZGluZyBjb2RlIGZyYWdtZW50cyBpbiBhIGZpeHR1cmUsIFwiaW1wb3J0XCIgc3RhdGVtZW50cyBtdXN0IGJlXG4gKiBob2lzdGVkIHVwIHRvIHRoZSB0b3Agb2YgdGhlIHJlc3VsdGluZyBkb2N1bWVudCwgYXMgVHlwZVNjcmlwdCBvbmx5IGFsbG93c1xuICogdGhvc2UgdG8gYmUgcHJlc2VudCBpbiB0aGUgdG9wLWxldmVsIGNvbnRleHQgb2YgYW4gRVNNLlxuICpcbiAqIEBwYXJhbSBzb3VyY2UgYSBibG9jayBvZiBUeXBlU2NyaXB0IHNvdXJjZVxuICpcbiAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpbXBvcnQgc3RhdGVtZW50cyBvbiBvbmUgZW5kLCBhbmQgdGhlIHJlc3RcbiAqICAgICAgICAgIG9uIHRoZSBvdGhlciBoYW5kLlxuICovXG5mdW5jdGlvbiBzaWRlbGluZUltcG9ydHMoc291cmNlOiBzdHJpbmcpOiB7XG4gIGltcG9ydHM6IHN0cmluZztcbiAgc3RhdGVtZW50czogc3RyaW5nO1xufSB7XG4gIGxldCBpbXBvcnRzID0gJyc7XG4gIGxldCBzdGF0ZW1lbnRzID0gJyc7XG5cbiAgY29uc3Qgc291cmNlRmlsZSA9IGNyZWF0ZVNvdXJjZUZpbGUoJ2luZGV4LnRzJywgc291cmNlLCBTY3JpcHRUYXJnZXQuTGF0ZXN0LCB0cnVlLCBTY3JpcHRLaW5kLlRTKTtcbiAgZm9yIChjb25zdCBzdGF0ZW1lbnQgb2Ygc291cmNlRmlsZS5zdGF0ZW1lbnRzKSB7XG4gICAgaWYgKFxuICAgICAgc3RhdGVtZW50LmtpbmQgPT09IFN5bnRheEtpbmQuSW1wb3J0RGVjbGFyYXRpb24gfHxcbiAgICAgIHN0YXRlbWVudC5raW5kID09PSBTeW50YXhLaW5kLkltcG9ydEVxdWFsc0RlY2xhcmF0aW9uIHx8XG4gICAgICAoc3RhdGVtZW50LmtpbmQgPT09IFN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQgJiZcbiAgICAgICAgc3RhdGVtZW50LmdldENoaWxkQXQoMCkuZ2V0Q2hpbGRBdCgwKS5raW5kID09PSBTeW50YXhLaW5kLkRlY2xhcmVLZXl3b3JkKVxuICAgICkge1xuICAgICAgaW1wb3J0cyArPSBzdGF0ZW1lbnQuZ2V0RnVsbFRleHQoc291cmNlRmlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlbWVudHMgKz0gc3RhdGVtZW50LmdldEZ1bGxUZXh0KHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGltcG9ydHMsIHN0YXRlbWVudHMgfTtcbn1cbiJdfQ==