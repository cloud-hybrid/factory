"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.infuse = exports.DEFAULT_INFUSION_RESULTS_NAME = void 0;
const spec = require("@jsii/spec");
const fs = require("fs-extra");
const path = require("path");
const assemblies_1 = require("../jsii/assemblies");
const snippet_1 = require("../snippet");
const snippet_selectors_1 = require("../snippet-selectors");
const key_1 = require("../tablets/key");
const tablets_1 = require("../tablets/tablets");
const util_1 = require("../util");
exports.DEFAULT_INFUSION_RESULTS_NAME = 'infusion-results.html';
const ADDITIONAL_SELECTORS = { meanLength: snippet_selectors_1.meanLength, shortest: snippet_selectors_1.shortest, longest: snippet_selectors_1.longest };
class DefaultRecord {
    constructor() {
        this.index = {};
    }
    add(key, value) {
        if (!this.index[key]) {
            this.index[key] = [];
        }
        this.index[key].push(value);
    }
}
/**
 * Infuse will analyze the snippets in a set of tablets, and update the assembly to add
 * examples to types that don't have any yet, based on snippets that use the given type.
 */
async function infuse(assemblyLocations, options) {
    let stream = undefined;
    if (options === null || options === void 0 ? void 0 : options.logFile) {
        // Create stream for html file and insert some styling
        stream = fs.createWriteStream(options.logFile, { encoding: 'utf-8' });
        startFile(stream);
    }
    // Load tablet file and assemblies
    const assemblies = await assemblies_1.loadAssemblies(assemblyLocations, false);
    const defaultTablets = await assemblies_1.loadAllDefaultTablets(assemblies);
    const availableTranslations = new tablets_1.LanguageTablet();
    if (options === null || options === void 0 ? void 0 : options.cacheFromFile) {
        availableTranslations.addTablet(await tablets_1.LanguageTablet.fromOptionalFile(options.cacheFromFile));
    }
    availableTranslations.addTablets(...Object.values(defaultTablets));
    const { translationsByFqn, originalsByKey } = availableSnippetsPerFqn(assemblies, availableTranslations);
    const additionalOutputTablet = (options === null || options === void 0 ? void 0 : options.cacheToFile) ? await tablets_1.LanguageTablet.fromOptionalFile(options === null || options === void 0 ? void 0 : options.cacheToFile)
        : new tablets_1.LanguageTablet();
    const coverageResults = util_1.mkDict(await Promise.all(assemblies.map(async ({ assembly, directory }) => {
        var _a;
        stream === null || stream === void 0 ? void 0 : stream.write(`<h1>${assembly.name}</h1>\n`);
        const implicitTablet = defaultTablets[directory];
        if (!implicitTablet) {
            throw new Error(`No tablet found for ${directory}`);
        }
        let insertedExamples = 0;
        const filteredTypes = filterForTypesWithoutExamples((_a = assembly.types) !== null && _a !== void 0 ? _a : {});
        for (const [typeFqn, type] of Object.entries(filteredTypes)) {
            const available = translationsByFqn[typeFqn];
            if (!available) {
                continue;
            }
            const example = pickBestExample(typeFqn, available, stream);
            const original = originalsByKey[example.key];
            insertExample(example, original, type, [implicitTablet, additionalOutputTablet]);
            insertedExamples++;
        }
        if (insertedExamples > 0) {
            // Save the updated assembly and implicit tablets
            // eslint-disable-next-line no-await-in-loop
            await Promise.all([
                assemblies_1.replaceAssembly(assembly, directory),
                implicitTablet.save(path.join(directory, tablets_1.DEFAULT_TABLET_NAME)),
            ]);
        }
        return [
            directory,
            {
                types: Object.keys(filteredTypes).length,
                typesWithInsertedExamples: insertedExamples,
            },
        ];
    })));
    stream === null || stream === void 0 ? void 0 : stream.close();
    // If we copied examples onto different types, we'll also have inserted new snippets
    // with different keys into the tablet. We must now write the updated tablet somewhere.
    if (options === null || options === void 0 ? void 0 : options.cacheToFile) {
        await additionalOutputTablet.save(options.cacheToFile);
    }
    return {
        coverageResults: coverageResults,
    };
}
exports.infuse = infuse;
function pickBestExample(typeFqn, choices, logStream) {
    const meanResult = snippet_selectors_1.mean(choices);
    if (logStream) {
        const selected = Object.entries(ADDITIONAL_SELECTORS).map(([name, fn]) => [name, fn(choices)]);
        const selectedFromSelector = {
            ...makeDict(selected),
            mean: meanResult,
        };
        logOutput(logStream, typeFqn, createHtmlEntry(selectedFromSelector));
    }
    return meanResult;
}
function startFile(stream) {
    stream.write('<style>\n');
    stream.write('h2 { color: blue; clear: both; }\n');
    stream.write('h1 { color: red; clear: both; }\n');
    stream.write('div { float: left; height: 31em; width: 22em; overflow: auto; margin: 1em; background-color: #ddd; }\n');
    stream.write('pre { float: left; height: 30em; width: 25em; overflow: auto; padding: 0.5em; background-color: #ddd; }\n');
    stream.write('</style>\n');
}
function createHtmlEntry(results) {
    const entry = new DefaultRecord();
    for (const [key, value] of Object.entries(results)) {
        entry.add(value.originalSource.source, key);
    }
    return entry.index;
}
function logOutput(stream, typeFqn, algorithmMap) {
    stream === null || stream === void 0 ? void 0 : stream.write(`<h2>${typeFqn}</h2>\n`);
    for (const [key, value] of Object.entries(algorithmMap)) {
        stream === null || stream === void 0 ? void 0 : stream.write(`<div class="snippet"><h3>${value.toString()}</h3>\n<pre>${key}</pre>\n</div>\n`);
    }
    for (let i = 0; i < 4 - Object.keys(algorithmMap).length; i++) {
        stream === null || stream === void 0 ? void 0 : stream.write('<div class="padding"></div>\n');
    }
}
function filterForTypesWithoutExamples(types) {
    var _a;
    const filteredTypes = {};
    for (const [typeFqn, type] of Object.entries(types)) {
        // Ignore Interfaces that contain only properties
        if (type.kind === spec.TypeKind.Interface && !type.datatype) {
            continue;
        }
        // Already has example
        if (((_a = type.docs) === null || _a === void 0 ? void 0 : _a.example) !== undefined) {
            continue;
        }
        filteredTypes[typeFqn] = type;
    }
    return filteredTypes;
}
/**
 * Insert an example into the docs of a type, and insert it back into the tablet under a new key
 */
function insertExample(example, original, type, tablets) {
    var _a;
    const parameters = {
        ...original === null || original === void 0 ? void 0 : original.parameters,
        infused: '',
    };
    // exampleMetadata should always be nonempty since we always have a parameter.
    const exampleMetadata = (_a = snippet_1.renderMetadataline(parameters)) !== null && _a !== void 0 ? _a : '';
    if (type.docs) {
        type.docs.example = example.originalSource.source;
        type.docs.custom = { ...type.docs.custom, exampleMetadata };
    }
    else {
        type.docs = {
            example: example.originalSource.source,
            custom: { exampleMetadata },
        };
    }
    for (const tablet of tablets) {
        tablet.addSnippet(example.withLocation({
            api: { api: 'type', fqn: type.fqn },
            field: { field: 'example' },
        }));
    }
}
/**
 * Return a map of FQN -> snippet keys that exercise that FQN.
 *
 * For a snippet to qualify, it must both:
 *
 * a) be current (i.e.: exist in the input assemblies)
 * b) have been analyzed (i.e.: exist in one of the translated tablets)
 *
 * Returns a map of fqns to a list of keys that represent snippets that include the fqn.
 */
function availableSnippetsPerFqn(asms, translationsTablet) {
    var _a;
    const ret = new DefaultRecord();
    const originalsByKey = util_1.indexBy(assemblies_1.allTypeScriptSnippets(asms), key_1.snippetKey);
    const translations = Object.keys(originalsByKey)
        .map((key) => translationsTablet.tryGetSnippet(key))
        .filter(util_1.isDefined);
    for (const trans of translations) {
        for (const fqn of (_a = trans.snippet.fqnsReferenced) !== null && _a !== void 0 ? _a : []) {
            ret.add(fqn, trans);
        }
    }
    return { originalsByKey, translationsByFqn: ret.index };
}
function makeDict(xs) {
    const ret = {};
    for (const [str, a] of xs) {
        ret[str] = a;
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5mdXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW5mdXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsNkJBQTZCO0FBRTdCLG1EQU00QjtBQUM1Qix3Q0FBbUU7QUFDbkUsNERBQTRGO0FBQzVGLHdDQUE0QztBQUM1QyxnREFBNEY7QUFDNUYsa0NBQXFEO0FBeUJ4QyxRQUFBLDZCQUE2QixHQUFHLHVCQUF1QixDQUFDO0FBRXJFLE1BQU0sb0JBQW9CLEdBQW9DLEVBQUUsVUFBVSxFQUFWLDhCQUFVLEVBQUUsUUFBUSxFQUFSLDRCQUFRLEVBQUUsT0FBTyxFQUFQLDJCQUFPLEVBQUUsQ0FBQztBQUVoRyxNQUFNLGFBQWE7SUFBbkI7UUFDa0IsVUFBSyxHQUF3QixFQUFFLENBQUM7SUFRbEQsQ0FBQztJQU5RLEdBQUcsQ0FBQyxHQUFXLEVBQUUsS0FBUTtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNwQixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztTQUN0QjtRQUNELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlCLENBQUM7Q0FDRjtBQUVEOzs7R0FHRztBQUNJLEtBQUssVUFBVSxNQUFNLENBQUMsaUJBQTJCLEVBQUUsT0FBdUI7SUFDL0UsSUFBSSxNQUFNLEdBQStCLFNBQVMsQ0FBQztJQUNuRCxJQUFJLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxPQUFPLEVBQUU7UUFDcEIsc0RBQXNEO1FBQ3RELE1BQU0sR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ3RFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FB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QUM7QUFDMUQsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUFJLEVBQStCO0lBQ2xELE1BQU0sR0FBRyxHQUFzQixFQUFFLENBQUM7SUFDbEMsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUN6QixHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ2Q7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzcGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHtcbiAgbG9hZEFzc2VtYmxpZXMsXG4gIHJlcGxhY2VBc3NlbWJseSxcbiAgbG9hZEFsbERlZmF1bHRUYWJsZXRzLFxuICBMb2FkZWRBc3NlbWJseSxcbiAgYWxsVHlwZVNjcmlwdFNuaXBwZXRzLFxufSBmcm9tICcuLi9qc2lpL2Fzc2VtYmxpZXMnO1xuaW1wb3J0IHsgcmVuZGVyTWV0YWRhdGFsaW5lLCBUeXBlU2NyaXB0U25pcHBldCB9IGZyb20gJy4uL3NuaXBwZXQnO1xuaW1wb3J0IHsgU25pcHBldFNlbGVjdG9yLCBtZWFuLCBtZWFuTGVuZ3RoLCBzaG9ydGVzdCwgbG9uZ2VzdCB9IGZyb20gJy4uL3NuaXBwZXQtc2VsZWN0b3JzJztcbmltcG9ydCB7IHNuaXBwZXRLZXkgfSBmcm9tICcuLi90YWJsZXRzL2tleSc7XG5pbXBvcnQgeyBMYW5ndWFnZVRhYmxldCwgVHJhbnNsYXRlZFNuaXBwZXQsIERFRkFVTFRfVEFCTEVUX05BTUUgfSBmcm9tICcuLi90YWJsZXRzL3RhYmxldHMnO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBta0RpY3QsIGluZGV4QnkgfSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBJbmZ1c2VSZXN1bHQge1xuICByZWFkb25seSBjb3ZlcmFnZVJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIEluZnVzZVR5cGVzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmZ1c2VUeXBlcyB7XG4gIHJlYWRvbmx5IHR5cGVzOiBudW1iZXI7XG4gIHJlYWRvbmx5IHR5cGVzV2l0aEluc2VydGVkRXhhbXBsZXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmZ1c2VPcHRpb25zIHtcbiAgcmVhZG9ubHkgbG9nRmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hlcmUgdG8gcmVhZCBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgY2FjaGVGcm9tRmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIGltcGxpY2l0IHRhYmxldHMsIGFsc28gd3JpdGUgYWxsIGFkZGVkIGV4YW1wbGVzIHRvIHRoaXMgYWRkaXRpb25hbCBvdXRwdXQgdGFibGV0XG4gICAqL1xuICByZWFkb25seSBjYWNoZVRvRmlsZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSU5GVVNJT05fUkVTVUxUU19OQU1FID0gJ2luZnVzaW9uLXJlc3VsdHMuaHRtbCc7XG5cbmNvbnN0IEFERElUSU9OQUxfU0VMRUNUT1JTOiBSZWNvcmQ8c3RyaW5nLCBTbmlwcGV0U2VsZWN0b3I+ID0geyBtZWFuTGVuZ3RoLCBzaG9ydGVzdCwgbG9uZ2VzdCB9O1xuXG5jbGFzcyBEZWZhdWx0UmVjb3JkPEE+IHtcbiAgcHVibGljIHJlYWRvbmx5IGluZGV4OiBSZWNvcmQ8c3RyaW5nLCBBW10+ID0ge307XG5cbiAgcHVibGljIGFkZChrZXk6IHN0cmluZywgdmFsdWU6IEEpIHtcbiAgICBpZiAoIXRoaXMuaW5kZXhba2V5XSkge1xuICAgICAgdGhpcy5pbmRleFtrZXldID0gW107XG4gICAgfVxuICAgIHRoaXMuaW5kZXhba2V5XS5wdXNoKHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluZnVzZSB3aWxsIGFuYWx5emUgdGhlIHNuaXBwZXRzIGluIGEgc2V0IG9mIHRhYmxldHMsIGFuZCB1cGRhdGUgdGhlIGFzc2VtYmx5IHRvIGFkZFxuICogZXhhbXBsZXMgdG8gdHlwZXMgdGhhdCBkb24ndCBoYXZlIGFueSB5ZXQsIGJhc2VkIG9uIHNuaXBwZXRzIHRoYXQgdXNlIHRoZSBnaXZlbiB0eXBlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5mdXNlKGFzc2VtYmx5TG9jYXRpb25zOiBzdHJpbmdbXSwgb3B0aW9ucz86IEluZnVzZU9wdGlvbnMpOiBQcm9taXNlPEluZnVzZVJlc3VsdD4ge1xuICBsZXQgc3RyZWFtOiBmcy5Xcml0ZVN0cmVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgaWYgKG9wdGlvbnM/LmxvZ0ZpbGUpIHtcbiAgICAvLyBDcmVhdGUgc3RyZWFtIGZvciBodG1sIGZpbGUgYW5kIGluc2VydCBzb21lIHN0eWxpbmdcbiAgICBzdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zLmxvZ0ZpbGUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgc3RhcnRGaWxlKHN0cmVhbSk7XG4gIH1cblxuICAvLyBMb2FkIHRhYmxldCBmaWxlIGFuZCBhc3NlbWJsaWVzXG4gIGNvbnN0IGFzc2VtYmxpZXMgPSBhd2FpdCBsb2FkQXNzZW1ibGllcyhhc3NlbWJseUxvY2F0aW9ucywgZmFsc2UpO1xuICBjb25zdCBkZWZhdWx0VGFibGV0cyA9IGF3YWl0IGxvYWRBbGxEZWZhdWx0VGFibGV0cyhhc3NlbWJsaWVzKTtcblxuICBjb25zdCBhdmFpbGFibGVUcmFuc2xhdGlvbnMgPSBuZXcgTGFuZ3VhZ2VUYWJsZXQoKTtcbiAgaWYgKG9wdGlvbnM/LmNhY2hlRnJvbUZpbGUpIHtcbiAgICBhdmFpbGFibGVUcmFuc2xhdGlvbnMuYWRkVGFibGV0KGF3YWl0IExhbmd1YWdlVGFibGV0LmZyb21PcHRpb25hbEZpbGUob3B0aW9ucy5jYWNoZUZyb21GaWxlKSk7XG4gIH1cbiAgYXZhaWxhYmxlVHJhbnNsYXRpb25zLmFkZFRhYmxldHMoLi4uT2JqZWN0LnZhbHVlcyhkZWZhdWx0VGFibGV0cykpO1xuXG4gIGNvbnN0IHsgdHJhbnNsYXRpb25zQnlGcW4sIG9yaWdpbmFsc0J5S2V5IH0gPSBhdmFpbGFibGVTbmlwcGV0c1BlckZxbihhc3NlbWJsaWVzLCBhdmFpbGFibGVUcmFuc2xhdGlvbnMpO1xuXG4gIGNvbnN0IGFkZGl0aW9uYWxPdXRwdXRUYWJsZXQgPSBvcHRpb25zPy5jYWNoZVRvRmlsZVxuICAgID8gYXdhaXQgTGFuZ3VhZ2VUYWJsZXQuZnJvbU9wdGlvbmFsRmlsZShvcHRpb25zPy5jYWNoZVRvRmlsZSlcbiAgICA6IG5ldyBMYW5ndWFnZVRhYmxldCgpO1xuXG4gIGNvbnN0IGNvdmVyYWdlUmVzdWx0cyA9IG1rRGljdChcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGFzc2VtYmxpZXMubWFwKGFzeW5jICh7IGFzc2VtYmx5LCBkaXJlY3RvcnkgfSkgPT4ge1xuICAgICAgICBzdHJlYW0/LndyaXRlKGA8aDE+JHthc3NlbWJseS5uYW1lfTwvaDE+XFxuYCk7XG5cbiAgICAgICAgY29uc3QgaW1wbGljaXRUYWJsZXQgPSBkZWZhdWx0VGFibGV0c1tkaXJlY3RvcnldO1xuICAgICAgICBpZiAoIWltcGxpY2l0VGFibGV0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0YWJsZXQgZm91bmQgZm9yICR7ZGlyZWN0b3J5fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluc2VydGVkRXhhbXBsZXMgPSAwO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFR5cGVzID0gZmlsdGVyRm9yVHlwZXNXaXRob3V0RXhhbXBsZXMoYXNzZW1ibHkudHlwZXMgPz8ge30pO1xuICAgICAgICBmb3IgKGNvbnN0IFt0eXBlRnFuLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhmaWx0ZXJlZFR5cGVzKSkge1xuICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHRyYW5zbGF0aW9uc0J5RnFuW3R5cGVGcW5dO1xuICAgICAgICAgIGlmICghYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBleGFtcGxlID0gcGlja0Jlc3RFeGFtcGxlKHR5cGVGcW4sIGF2YWlsYWJsZSwgc3RyZWFtKTtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG9yaWdpbmFsc0J5S2V5W2V4YW1wbGUua2V5XTtcbiAgICAgICAgICBpbnNlcnRFeGFtcGxlKGV4YW1wbGUsIG9yaWdpbmFsLCB0eXBlLCBbaW1wbGljaXRUYWJsZXQsIGFkZGl0aW9uYWxPdXRwdXRUYWJsZXRdKTtcbiAgICAgICAgICBpbnNlcnRlZEV4YW1wbGVzKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zZXJ0ZWRFeGFtcGxlcyA+IDApIHtcbiAgICAgICAgICAvLyBTYXZlIHRoZSB1cGRhdGVkIGFzc2VtYmx5IGFuZCBpbXBsaWNpdCB0YWJsZXRzXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICByZXBsYWNlQXNzZW1ibHkoYXNzZW1ibHksIGRpcmVjdG9yeSksXG4gICAgICAgICAgICBpbXBsaWNpdFRhYmxldC5zYXZlKHBhdGguam9pbihkaXJlY3RvcnksIERFRkFVTFRfVEFCTEVUX05BTUUpKSxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZGlyZWN0b3J5LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGVzOiBPYmplY3Qua2V5cyhmaWx0ZXJlZFR5cGVzKS5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlc1dpdGhJbnNlcnRlZEV4YW1wbGVzOiBpbnNlcnRlZEV4YW1wbGVzLFxuICAgICAgICAgIH0gYXMgSW5mdXNlVHlwZXMsXG4gICAgICAgIF0gYXMgY29uc3Q7XG4gICAgICB9KSxcbiAgICApLFxuICApO1xuXG4gIHN0cmVhbT8uY2xvc2UoKTtcblxuICAvLyBJZiB3ZSBjb3BpZWQgZXhhbXBsZXMgb250byBkaWZmZXJlbnQgdHlwZXMsIHdlJ2xsIGFsc28gaGF2ZSBpbnNlcnRlZCBuZXcgc25pcHBldHNcbiAgLy8gd2l0aCBkaWZmZXJlbnQga2V5cyBpbnRvIHRoZSB0YWJsZXQuIFdlIG11c3Qgbm93IHdyaXRlIHRoZSB1cGRhdGVkIHRhYmxldCBzb21ld2hlcmUuXG4gIGlmIChvcHRpb25zPy5jYWNoZVRvRmlsZSkge1xuICAgIGF3YWl0IGFkZGl0aW9uYWxPdXRwdXRUYWJsZXQuc2F2ZShvcHRpb25zLmNhY2hlVG9GaWxlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY292ZXJhZ2VSZXN1bHRzOiBjb3ZlcmFnZVJlc3VsdHMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBpY2tCZXN0RXhhbXBsZSh0eXBlRnFuOiBzdHJpbmcsIGNob2ljZXM6IFRyYW5zbGF0ZWRTbmlwcGV0W10sIGxvZ1N0cmVhbT86IGZzLldyaXRlU3RyZWFtKSB7XG4gIGNvbnN0IG1lYW5SZXN1bHQgPSBtZWFuKGNob2ljZXMpO1xuICBpZiAobG9nU3RyZWFtKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBPYmplY3QuZW50cmllcyhBRERJVElPTkFMX1NFTEVDVE9SUykubWFwKChbbmFtZSwgZm5dKSA9PiBbbmFtZSwgZm4oY2hvaWNlcyldIGFzIGNvbnN0KTtcbiAgICBjb25zdCBzZWxlY3RlZEZyb21TZWxlY3RvciA9IHtcbiAgICAgIC4uLm1ha2VEaWN0KHNlbGVjdGVkKSxcbiAgICAgIG1lYW46IG1lYW5SZXN1bHQsXG4gICAgfTtcbiAgICBsb2dPdXRwdXQobG9nU3RyZWFtLCB0eXBlRnFuLCBjcmVhdGVIdG1sRW50cnkoc2VsZWN0ZWRGcm9tU2VsZWN0b3IpKTtcbiAgfVxuICByZXR1cm4gbWVhblJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc3RhcnRGaWxlKHN0cmVhbTogZnMuV3JpdGVTdHJlYW0pIHtcbiAgc3RyZWFtLndyaXRlKCc8c3R5bGU+XFxuJyk7XG4gIHN0cmVhbS53cml0ZSgnaDIgeyBjb2xvcjogYmx1ZTsgY2xlYXI6IGJvdGg7IH1cXG4nKTtcbiAgc3RyZWFtLndyaXRlKCdoMSB7IGNvbG9yOiByZWQ7IGNsZWFyOiBib3RoOyB9XFxuJyk7XG4gIHN0cmVhbS53cml0ZShcbiAgICAnZGl2IHsgZmxvYXQ6IGxlZnQ7IGhlaWdodDogMzFlbTsgd2lkdGg6IDIyZW07IG92ZXJmbG93OiBhdXRvOyBtYXJnaW46IDFlbTsgYmFja2dyb3VuZC1jb2xvcjogI2RkZDsgfVxcbicsXG4gICk7XG4gIHN0cmVhbS53cml0ZShcbiAgICAncHJlIHsgZmxvYXQ6IGxlZnQ7IGhlaWdodDogMzBlbTsgd2lkdGg6IDI1ZW07IG92ZXJmbG93OiBhdXRvOyBwYWRkaW5nOiAwLjVlbTsgYmFja2dyb3VuZC1jb2xvcjogI2RkZDsgfVxcbicsXG4gICk7XG4gIHN0cmVhbS53cml0ZSgnPC9zdHlsZT5cXG4nKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSHRtbEVudHJ5KHJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIFRyYW5zbGF0ZWRTbmlwcGV0Pik6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiB7XG4gIGNvbnN0IGVudHJ5ID0gbmV3IERlZmF1bHRSZWNvcmQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHRzKSkge1xuICAgIGVudHJ5LmFkZCh2YWx1ZS5vcmlnaW5hbFNvdXJjZS5zb3VyY2UsIGtleSk7XG4gIH1cbiAgcmV0dXJuIGVudHJ5LmluZGV4O1xufVxuXG5mdW5jdGlvbiBsb2dPdXRwdXQoc3RyZWFtOiBmcy5Xcml0ZVN0cmVhbSB8IHVuZGVmaW5lZCwgdHlwZUZxbjogc3RyaW5nLCBhbGdvcml0aG1NYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPikge1xuICBzdHJlYW0/LndyaXRlKGA8aDI+JHt0eXBlRnFufTwvaDI+XFxuYCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFsZ29yaXRobU1hcCkpIHtcbiAgICBzdHJlYW0/LndyaXRlKGA8ZGl2IGNsYXNzPVwic25pcHBldFwiPjxoMz4ke3ZhbHVlLnRvU3RyaW5nKCl9PC9oMz5cXG48cHJlPiR7a2V5fTwvcHJlPlxcbjwvZGl2PlxcbmApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNCAtIE9iamVjdC5rZXlzKGFsZ29yaXRobU1hcCkubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJlYW0/LndyaXRlKCc8ZGl2IGNsYXNzPVwicGFkZGluZ1wiPjwvZGl2PlxcbicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckZvclR5cGVzV2l0aG91dEV4YW1wbGVzKHR5cGVzOiB7IFtmcW46IHN0cmluZ106IHNwZWMuVHlwZSB9KTogUmVjb3JkPHN0cmluZywgc3BlYy5UeXBlPiB7XG4gIGNvbnN0IGZpbHRlcmVkVHlwZXM6IFJlY29yZDxzdHJpbmcsIHNwZWMuVHlwZT4gPSB7fTtcbiAgZm9yIChjb25zdCBbdHlwZUZxbiwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModHlwZXMpKSB7XG4gICAgLy8gSWdub3JlIEludGVyZmFjZXMgdGhhdCBjb250YWluIG9ubHkgcHJvcGVydGllc1xuICAgIGlmICh0eXBlLmtpbmQgPT09IHNwZWMuVHlwZUtpbmQuSW50ZXJmYWNlICYmICF0eXBlLmRhdGF0eXBlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gQWxyZWFkeSBoYXMgZXhhbXBsZVxuICAgIGlmICh0eXBlLmRvY3M/LmV4YW1wbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZpbHRlcmVkVHlwZXNbdHlwZUZxbl0gPSB0eXBlO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFR5cGVzO1xufVxuXG4vKipcbiAqIEluc2VydCBhbiBleGFtcGxlIGludG8gdGhlIGRvY3Mgb2YgYSB0eXBlLCBhbmQgaW5zZXJ0IGl0IGJhY2sgaW50byB0aGUgdGFibGV0IHVuZGVyIGEgbmV3IGtleVxuICovXG5mdW5jdGlvbiBpbnNlcnRFeGFtcGxlKFxuICBleGFtcGxlOiBUcmFuc2xhdGVkU25pcHBldCxcbiAgb3JpZ2luYWw6IFR5cGVTY3JpcHRTbmlwcGV0IHwgdW5kZWZpbmVkLFxuICB0eXBlOiBzcGVjLlR5cGUsXG4gIHRhYmxldHM6IExhbmd1YWdlVGFibGV0W10sXG4pOiB2b2lkIHtcbiAgY29uc3QgcGFyYW1ldGVycyA9IHtcbiAgICAuLi5vcmlnaW5hbD8ucGFyYW1ldGVycyxcbiAgICBpbmZ1c2VkOiAnJyxcbiAgfTtcbiAgLy8gZXhhbXBsZU1ldGFkYXRhIHNob3VsZCBhbHdheXMgYmUgbm9uZW1wdHkgc2luY2Ugd2UgYWx3YXlzIGhhdmUgYSBwYXJhbWV0ZXIuXG4gIGNvbnN0IGV4YW1wbGVNZXRhZGF0YSA9IHJlbmRlck1ldGFkYXRhbGluZShwYXJhbWV0ZXJzKSA/PyAnJztcblxuICBpZiAodHlwZS5kb2NzKSB7XG4gICAgdHlwZS5kb2NzLmV4YW1wbGUgPSBleGFtcGxlLm9yaWdpbmFsU291cmNlLnNvdXJjZTtcbiAgICB0eXBlLmRvY3MuY3VzdG9tID0geyAuLi50eXBlLmRvY3MuY3VzdG9tLCBleGFtcGxlTWV0YWRhdGEgfTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlLmRvY3MgPSB7XG4gICAgICBleGFtcGxlOiBleGFtcGxlLm9yaWdpbmFsU291cmNlLnNvdXJjZSxcbiAgICAgIGN1c3RvbTogeyBleGFtcGxlTWV0YWRhdGEgfSxcbiAgICB9O1xuICB9XG5cbiAgZm9yIChjb25zdCB0YWJsZXQgb2YgdGFibGV0cykge1xuICAgIHRhYmxldC5hZGRTbmlwcGV0KFxuICAgICAgZXhhbXBsZS53aXRoTG9jYXRpb24oe1xuICAgICAgICBhcGk6IHsgYXBpOiAndHlwZScsIGZxbjogdHlwZS5mcW4gfSxcbiAgICAgICAgZmllbGQ6IHsgZmllbGQ6ICdleGFtcGxlJyB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBhIG1hcCBvZiBGUU4gLT4gc25pcHBldCBrZXlzIHRoYXQgZXhlcmNpc2UgdGhhdCBGUU4uXG4gKlxuICogRm9yIGEgc25pcHBldCB0byBxdWFsaWZ5LCBpdCBtdXN0IGJvdGg6XG4gKlxuICogYSkgYmUgY3VycmVudCAoaS5lLjogZXhpc3QgaW4gdGhlIGlucHV0IGFzc2VtYmxpZXMpXG4gKiBiKSBoYXZlIGJlZW4gYW5hbHl6ZWQgKGkuZS46IGV4aXN0IGluIG9uZSBvZiB0aGUgdHJhbnNsYXRlZCB0YWJsZXRzKVxuICpcbiAqIFJldHVybnMgYSBtYXAgb2YgZnFucyB0byBhIGxpc3Qgb2Yga2V5cyB0aGF0IHJlcHJlc2VudCBzbmlwcGV0cyB0aGF0IGluY2x1ZGUgdGhlIGZxbi5cbiAqL1xuZnVuY3Rpb24gYXZhaWxhYmxlU25pcHBldHNQZXJGcW4oYXNtczogcmVhZG9ubHkgTG9hZGVkQXNzZW1ibHlbXSwgdHJhbnNsYXRpb25zVGFibGV0OiBMYW5ndWFnZVRhYmxldCkge1xuICBjb25zdCByZXQgPSBuZXcgRGVmYXVsdFJlY29yZDxUcmFuc2xhdGVkU25pcHBldD4oKTtcblxuICBjb25zdCBvcmlnaW5hbHNCeUtleSA9IGluZGV4QnkoYWxsVHlwZVNjcmlwdFNuaXBwZXRzKGFzbXMpLCBzbmlwcGV0S2V5KTtcblxuICBjb25zdCB0cmFuc2xhdGlvbnMgPSBPYmplY3Qua2V5cyhvcmlnaW5hbHNCeUtleSlcbiAgICAubWFwKChrZXkpID0+IHRyYW5zbGF0aW9uc1RhYmxldC50cnlHZXRTbmlwcGV0KGtleSkpXG4gICAgLmZpbHRlcihpc0RlZmluZWQpO1xuXG4gIGZvciAoY29uc3QgdHJhbnMgb2YgdHJhbnNsYXRpb25zKSB7XG4gICAgZm9yIChjb25zdCBmcW4gb2YgdHJhbnMuc25pcHBldC5mcW5zUmVmZXJlbmNlZCA/PyBbXSkge1xuICAgICAgcmV0LmFkZChmcW4sIHRyYW5zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBvcmlnaW5hbHNCeUtleSwgdHJhbnNsYXRpb25zQnlGcW46IHJldC5pbmRleCB9O1xufVxuXG5mdW5jdGlvbiBtYWtlRGljdDxBPih4czogQXJyYXk8cmVhZG9ubHkgW3N0cmluZywgQV0+KTogUmVjb3JkPHN0cmluZywgQT4ge1xuICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIEE+ID0ge307XG4gIGZvciAoY29uc3QgW3N0ciwgYV0gb2YgeHMpIHtcbiAgICByZXRbc3RyXSA9IGE7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==