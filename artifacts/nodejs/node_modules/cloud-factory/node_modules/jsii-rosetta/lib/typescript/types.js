"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineReturnType = exports.renderFlags = exports.isStaticReadonlyAccess = exports.isEnumAccess = exports.isNumber = exports.inferredTypeOfExpression = exports.typeOfExpression = exports.arrayElementType = exports.inferMapElementType = exports.mapElementType = exports.renderTypeFlags = exports.typeContainsUndefined = exports.parameterAcceptsUndefined = exports.renderType = exports.builtInTypeName = exports.firstTypeInUnion = void 0;
const ts = require("typescript");
const jsii_utils_1 = require("../jsii/jsii-utils");
const util_1 = require("../util");
/**
 * Return the first non-undefined type from a union
 */
function firstTypeInUnion(typeChecker, type) {
    type = typeChecker.getNonNullableType(type);
    if (!type.isUnion()) {
        return type;
    }
    return type.types[0];
}
exports.firstTypeInUnion = firstTypeInUnion;
function builtInTypeName(type) {
    if (jsii_utils_1.hasAnyFlag(type.flags, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
        return 'any';
    }
    if (jsii_utils_1.hasAnyFlag(type.flags, ts.TypeFlags.BooleanLike)) {
        return 'boolean';
    }
    if (jsii_utils_1.hasAnyFlag(type.flags, ts.TypeFlags.NumberLike)) {
        return 'number';
    }
    if (jsii_utils_1.hasAnyFlag(type.flags, ts.TypeFlags.StringLike)) {
        return 'string';
    }
    return undefined;
}
exports.builtInTypeName = builtInTypeName;
function renderType(type) {
    if (type.isClassOrInterface()) {
        return type.symbol.name;
    }
    if (type.isLiteral()) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        return `${type.value}`;
    }
    return renderTypeFlags(type);
}
exports.renderType = renderType;
function parameterAcceptsUndefined(param, type) {
    if (param.initializer !== undefined) {
        return true;
    }
    if (param.questionToken !== undefined) {
        return true;
    }
    if (type) {
        return typeContainsUndefined(type);
    }
    return false;
}
exports.parameterAcceptsUndefined = parameterAcceptsUndefined;
/**
 * This is a simplified check that should be good enough for most purposes
 */
function typeContainsUndefined(type) {
    if (type.getFlags() & ts.TypeFlags.Undefined) {
        return true;
    }
    if (type.isUnion()) {
        return type.types.some(typeContainsUndefined);
    }
    return false;
}
exports.typeContainsUndefined = typeContainsUndefined;
function renderTypeFlags(type) {
    return renderFlags(type.flags, ts.TypeFlags);
}
exports.renderTypeFlags = renderTypeFlags;
/**
 * If this is a map type, return the type mapped *to* (key must always be `string` anyway).
 */
function mapElementType(type, typeChecker) {
    if (jsii_utils_1.hasAnyFlag(type.flags, ts.TypeFlags.Object) && type.symbol) {
        if (type.symbol.name === '__type') {
            // Declared map type: {[k: string]: A}
            return { result: 'map', elementType: type.getStringIndexType() };
        }
        if (type.symbol.name === '__object') {
            // Derived map type from object literal: typeof({ k: "value" })
            // For every property, get the node that created it (PropertyAssignment), and get the type of the initializer of that node
            const initializerTypes = type.getProperties().map((p) => {
                const expression = p.valueDeclaration;
                return typeOfObjectLiteralProperty(typeChecker, expression);
            });
            return {
                result: 'map',
                elementType: typeIfSame([...initializerTypes, type.getStringIndexType()].filter(util_1.isDefined)),
            };
        }
    }
    return { result: 'nonMap' };
}
exports.mapElementType = mapElementType;
/**
 * Try to infer the map element type from the properties if they're all the same
 */
function inferMapElementType(elements, typeChecker) {
    const types = elements.map((e) => typeOfObjectLiteralProperty(typeChecker, e)).filter(util_1.isDefined);
    return types.every((t) => isSameType(types[0], t)) ? types[0] : undefined;
}
exports.inferMapElementType = inferMapElementType;
function typeOfObjectLiteralProperty(typeChecker, el) {
    if (ts.isPropertyAssignment(el)) {
        return typeOfExpression(typeChecker, el.initializer);
    }
    if (ts.isShorthandPropertyAssignment(el)) {
        return typeOfExpression(typeChecker, el.name);
    }
    return undefined;
}
function isSameType(a, b) {
    var _a, _b;
    return a.flags === b.flags && ((_a = a.symbol) === null || _a === void 0 ? void 0 : _a.name) === ((_b = b.symbol) === null || _b === void 0 ? void 0 : _b.name);
}
function typeIfSame(types) {
    const ttypes = types.filter(util_1.isDefined);
    if (types.length === 0) {
        return undefined;
    }
    return ttypes.every((t) => isSameType(ttypes[0], t)) ? ttypes[0] : undefined;
}
/**
 * If this is an array type, return the element type of the array
 */
function arrayElementType(type) {
    if (type.symbol && type.symbol.name === 'Array') {
        const tr = type;
        return tr.aliasTypeArguments && tr.aliasTypeArguments[0];
    }
    return undefined;
}
exports.arrayElementType = arrayElementType;
function typeOfExpression(typeChecker, node) {
    var _a;
    const t = (_a = typeChecker.getContextualType(node)) !== null && _a !== void 0 ? _a : typeChecker.getTypeAtLocation(node);
    return jsii_utils_1.resolveEnumLiteral(typeChecker, t);
}
exports.typeOfExpression = typeOfExpression;
/**
 * Infer type of expression by the argument it is assigned to
 *
 * If the type of the expression can include undefined (if the value is
 * optional), `undefined` will be removed from the union.
 *
 * (Will return undefined for object literals not unified with a declared type)
 */
function inferredTypeOfExpression(typeChecker, node) {
    const type = typeChecker.getContextualType(node);
    return type ? typeChecker.getNonNullableType(type) : undefined;
}
exports.inferredTypeOfExpression = inferredTypeOfExpression;
function isNumber(x) {
    return typeof x === 'number';
}
exports.isNumber = isNumber;
function isEnumAccess(typeChecker, access) {
    const symbol = jsii_utils_1.resolvedSymbolAtLocation(typeChecker, access.expression);
    return symbol ? jsii_utils_1.hasAnyFlag(symbol.flags, ts.SymbolFlags.Enum) : false;
}
exports.isEnumAccess = isEnumAccess;
function isStaticReadonlyAccess(typeChecker, access) {
    const symbol = jsii_utils_1.resolvedSymbolAtLocation(typeChecker, access);
    const decl = symbol === null || symbol === void 0 ? void 0 : symbol.getDeclarations();
    if (decl && decl[0] && ts.isPropertyDeclaration(decl[0])) {
        const flags = ts.getCombinedModifierFlags(decl[0]);
        return jsii_utils_1.hasAllFlags(flags, ts.ModifierFlags.Readonly | ts.ModifierFlags.Static);
    }
    return false;
}
exports.isStaticReadonlyAccess = isStaticReadonlyAccess;
function renderFlags(flags, flagObject) {
    if (flags === undefined) {
        return '';
    }
    return Object.values(flagObject)
        .filter(isNumber)
        .filter((f) => jsii_utils_1.hasAllFlags(flags, f))
        .map((f) => flagObject[f])
        .join(',');
}
exports.renderFlags = renderFlags;
function determineReturnType(typeChecker, node) {
    const signature = typeChecker.getSignatureFromDeclaration(node);
    if (!signature) {
        return undefined;
    }
    return typeChecker.getReturnTypeOfSignature(signature);
}
exports.determineReturnType = determineReturnType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpQ0FBaUM7QUFFakMsbURBQTJHO0FBQzNHLGtDQUFvQztBQUVwQzs7R0FFRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLFdBQTJCLEVBQUUsSUFBYTtJQUN6RSxJQUFJLEdBQUcsV0FBVyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBRTVDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QixDQUFDO0FBUkQsNENBUUM7QUFHRCxTQUFnQixlQUFlLENBQUMsSUFBYTtJQUMzQyxJQUFJLHVCQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ25FLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLHVCQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQ3BELE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsSUFBSSx1QkFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUNuRCxPQUFPLFFBQVEsQ0FBQztLQUNqQjtJQUNELElBQUksdUJBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDbkQsT0FBTyxRQUFRLENBQUM7S0FDakI7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBZEQsMENBY0M7QUFFRCxTQUFnQixVQUFVLENB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QUFDLFFBQVEsQ0FBQztTQUNoQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLHdCQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3BDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3pCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNmLENBQUM7QUFWRCxrQ0FVQztBQUVELFNBQWdCLG1CQUFtQixDQUFDLFdBQTJCLEVBQUUsSUFBNkI7SUFDNUYsTUFBTSxTQUFTLEdBQUcsV0FBVyxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hFLElBQUksQ0FBQyxTQUFTLEVBQUU7UUFDZCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUNELE9BQU8sV0FBVyxDQUFDLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3pELENBQUM7QUFORCxrREFNQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQgeyBoYXNBbGxGbGFncywgaGFzQW55RmxhZywgcmVzb2x2ZUVudW1MaXRlcmFsLCByZXNvbHZlZFN5bWJvbEF0TG9jYXRpb24gfSBmcm9tICcuLi9qc2lpL2pzaWktdXRpbHMnO1xuaW1wb3J0IHsgaXNEZWZpbmVkIH0gZnJvbSAnLi4vdXRpbCc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBub24tdW5kZWZpbmVkIHR5cGUgZnJvbSBhIHVuaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdFR5cGVJblVuaW9uKHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgdHlwZTogdHMuVHlwZSk6IHRzLlR5cGUge1xuICB0eXBlID0gdHlwZUNoZWNrZXIuZ2V0Tm9uTnVsbGFibGVUeXBlKHR5cGUpO1xuXG4gIGlmICghdHlwZS5pc1VuaW9uKCkpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlLnR5cGVzWzBdO1xufVxuXG5leHBvcnQgdHlwZSBCdWlsdEluVHlwZSA9ICdhbnknIHwgJ2Jvb2xlYW4nIHwgJ251bWJlcicgfCAnc3RyaW5nJztcbmV4cG9ydCBmdW5jdGlvbiBidWlsdEluVHlwZU5hbWUodHlwZTogdHMuVHlwZSk6IEJ1aWx0SW5UeXBlIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGhhc0FueUZsYWcodHlwZS5mbGFncywgdHMuVHlwZUZsYWdzLkFueSB8IHRzLlR5cGVGbGFncy5Vbmtub3duKSkge1xuICAgIHJldHVybiAnYW55JztcbiAgfVxuICBpZiAoaGFzQW55RmxhZyh0eXBlLmZsYWdzLCB0cy5UeXBlRmxhZ3MuQm9vbGVhbkxpa2UpKSB7XG4gICAgcmV0dXJuICdib29sZWFuJztcbiAgfVxuICBpZiAoaGFzQW55RmxhZyh0eXBlLmZsYWdzLCB0cy5UeXBlRmxhZ3MuTnVtYmVyTGlrZSkpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cbiAgaWYgKGhhc0FueUZsYWcodHlwZS5mbGFncywgdHMuVHlwZUZsYWdzLlN0cmluZ0xpa2UpKSB7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUeXBlKHR5cGU6IHRzLlR5cGUpOiBzdHJpbmcge1xuICBpZiAodHlwZS5pc0NsYXNzT3JJbnRlcmZhY2UoKSkge1xuICAgIHJldHVybiB0eXBlLnN5bWJvbC5uYW1lO1xuICB9XG4gIGlmICh0eXBlLmlzTGl0ZXJhbCgpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgIHJldHVybiBgJHt0eXBlLnZhbHVlfWA7XG4gIH1cbiAgcmV0dXJuIHJlbmRlclR5cGVGbGFncyh0eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmFtZXRlckFjY2VwdHNVbmRlZmluZWQocGFyYW06IHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uLCB0eXBlPzogdHMuVHlwZSk6IGJvb2xlYW4ge1xuICBpZiAocGFyYW0uaW5pdGlhbGl6ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwYXJhbS5xdWVzdGlvblRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSkge1xuICAgIHJldHVybiB0eXBlQ29udGFpbnNVbmRlZmluZWQodHlwZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGNoZWNrIHRoYXQgc2hvdWxkIGJlIGdvb2QgZW5vdWdoIGZvciBtb3N0IHB1cnBvc2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0eXBlQ29udGFpbnNVbmRlZmluZWQodHlwZTogdHMuVHlwZSk6IGJvb2xlYW4ge1xuICBpZiAodHlwZS5nZXRGbGFncygpICYgdHMuVHlwZUZsYWdzLlVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlLmlzVW5pb24oKSkge1xuICAgIHJldHVybiB0eXBlLnR5cGVzLnNvbWUodHlwZUNvbnRhaW5zVW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUeXBlRmxhZ3ModHlwZTogdHMuVHlwZSk6IHN0cmluZyB7XG4gIHJldHVybiByZW5kZXJGbGFncyh0eXBlLmZsYWdzLCB0cy5UeXBlRmxhZ3MpO1xufVxuXG5leHBvcnQgdHlwZSBNYXBBbmFseXNpcyA9IHsgcmVzdWx0OiAnbm9uTWFwJyB9IHwgeyByZXN1bHQ6ICdtYXAnOyBlbGVtZW50VHlwZTogdHMuVHlwZSB8IHVuZGVmaW5lZCB9O1xuXG4vKipcbiAqIElmIHRoaXMgaXMgYSBtYXAgdHlwZSwgcmV0dXJuIHRoZSB0eXBlIG1hcHBlZCAqdG8qIChrZXkgbXVzdCBhbHdheXMgYmUgYHN0cmluZ2AgYW55d2F5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEVsZW1lbnRUeXBlKHR5cGU6IHRzLlR5cGUsIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcik6IE1hcEFuYWx5c2lzIHtcbiAgaWYgKGhhc0FueUZsYWcodHlwZS5mbGFncywgdHMuVHlwZUZsYWdzLk9iamVjdCkgJiYgdHlwZS5zeW1ib2wpIHtcbiAgICBpZiAodHlwZS5zeW1ib2wubmFtZSA9PT0gJ19fdHlwZScpIHtcbiAgICAgIC8vIERlY2xhcmVkIG1hcCB0eXBlOiB7W2s6IHN0cmluZ106IEF9XG4gICAgICByZXR1cm4geyByZXN1bHQ6ICdtYXAnLCBlbGVtZW50VHlwZTogdHlwZS5nZXRTdHJpbmdJbmRleFR5cGUoKSB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlLnN5bWJvbC5uYW1lID09PSAnX19vYmplY3QnKSB7XG4gICAgICAvLyBEZXJpdmVkIG1hcCB0eXBlIGZyb20gb2JqZWN0IGxpdGVyYWw6IHR5cGVvZih7IGs6IFwidmFsdWVcIiB9KVxuICAgICAgLy8gRm9yIGV2ZXJ5IHByb3BlcnR5LCBnZXQgdGhlIG5vZGUgdGhhdCBjcmVhdGVkIGl0IChQcm9wZXJ0eUFzc2lnbm1lbnQpLCBhbmQgZ2V0IHRoZSB0eXBlIG9mIHRoZSBpbml0aWFsaXplciBvZiB0aGF0IG5vZGVcbiAgICAgIGNvbnN0IGluaXRpYWxpemVyVHlwZXMgPSB0eXBlLmdldFByb3BlcnRpZXMoKS5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHAudmFsdWVEZWNsYXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHR5cGVPZk9iamVjdExpdGVyYWxQcm9wZXJ0eSh0eXBlQ2hlY2tlciwgZXhwcmVzc2lvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogJ21hcCcsXG4gICAgICAgIGVsZW1lbnRUeXBlOiB0eXBlSWZTYW1lKFsuLi5pbml0aWFsaXplclR5cGVzLCB0eXBlLmdldFN0cmluZ0luZGV4VHlwZSgpXS5maWx0ZXIoaXNEZWZpbmVkKSksXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHJlc3VsdDogJ25vbk1hcCcgfTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gaW5mZXIgdGhlIG1hcCBlbGVtZW50IHR5cGUgZnJvbSB0aGUgcHJvcGVydGllcyBpZiB0aGV5J3JlIGFsbCB0aGUgc2FtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mZXJNYXBFbGVtZW50VHlwZShcbiAgZWxlbWVudHM6IHJlYWRvbmx5IHRzLk9iamVjdExpdGVyYWxFbGVtZW50TGlrZVtdLFxuICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4pOiB0cy5UeXBlIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdHlwZXMgPSBlbGVtZW50cy5tYXAoKGUpID0+IHR5cGVPZk9iamVjdExpdGVyYWxQcm9wZXJ0eSh0eXBlQ2hlY2tlciwgZSkpLmZpbHRlcihpc0RlZmluZWQpO1xuXG4gIHJldHVybiB0eXBlcy5ldmVyeSgodCkgPT4gaXNTYW1lVHlwZSh0eXBlc1swXSwgdCkpID8gdHlwZXNbMF0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZk9iamVjdExpdGVyYWxQcm9wZXJ0eSh0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIGVsOiB0cy5Ob2RlKTogdHMuVHlwZSB8IHVuZGVmaW5lZCB7XG4gIGlmICh0cy5pc1Byb3BlcnR5QXNzaWdubWVudChlbCkpIHtcbiAgICByZXR1cm4gdHlwZU9mRXhwcmVzc2lvbih0eXBlQ2hlY2tlciwgZWwuaW5pdGlhbGl6ZXIpO1xuICB9XG4gIGlmICh0cy5pc1Nob3J0aGFuZFByb3BlcnR5QXNzaWdubWVudChlbCkpIHtcbiAgICByZXR1cm4gdHlwZU9mRXhwcmVzc2lvbih0eXBlQ2hlY2tlciwgZWwubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZShhOiB0cy5UeXBlLCBiOiB0cy5UeXBlKSB7XG4gIHJldHVybiBhLmZsYWdzID09PSBiLmZsYWdzICYmIGEuc3ltYm9sPy5uYW1lID09PSBiLnN5bWJvbD8ubmFtZTtcbn1cblxuZnVuY3Rpb24gdHlwZUlmU2FtZSh0eXBlczogQXJyYXk8dHMuVHlwZSB8IHVuZGVmaW5lZD4pOiB0cy5UeXBlIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdHR5cGVzID0gdHlwZXMuZmlsdGVyKGlzRGVmaW5lZCk7XG4gIGlmICh0eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHR0eXBlcy5ldmVyeSgodCkgPT4gaXNTYW1lVHlwZSh0dHlwZXNbMF0sIHQpKSA/IHR0eXBlc1swXSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJZiB0aGlzIGlzIGFuIGFycmF5IHR5cGUsIHJldHVybiB0aGUgZWxlbWVudCB0eXBlIG9mIHRoZSBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlFbGVtZW50VHlwZSh0eXBlOiB0cy5UeXBlKTogdHMuVHlwZSB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlLnN5bWJvbCAmJiB0eXBlLnN5bWJvbC5uYW1lID09PSAnQXJyYXknKSB7XG4gICAgY29uc3QgdHIgPSB0eXBlIGFzIHRzLlR5cGVSZWZlcmVuY2U7XG4gICAgcmV0dXJuIHRyLmFsaWFzVHlwZUFyZ3VtZW50cyAmJiB0ci5hbGlhc1R5cGVBcmd1bWVudHNbMF07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVPZkV4cHJlc3Npb24odHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBub2RlOiB0cy5FeHByZXNzaW9uKSB7XG4gIGNvbnN0IHQgPSB0eXBlQ2hlY2tlci5nZXRDb250ZXh0dWFsVHlwZShub2RlKSA/PyB0eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihub2RlKTtcbiAgcmV0dXJuIHJlc29sdmVFbnVtTGl0ZXJhbCh0eXBlQ2hlY2tlciwgdCk7XG59XG5cbi8qKlxuICogSW5mZXIgdHlwZSBvZiBleHByZXNzaW9uIGJ5IHRoZSBhcmd1bWVudCBpdCBpcyBhc3NpZ25lZCB0b1xuICpcbiAqIElmIHRoZSB0eXBlIG9mIHRoZSBleHByZXNzaW9uIGNhbiBpbmNsdWRlIHVuZGVmaW5lZCAoaWYgdGhlIHZhbHVlIGlzXG4gKiBvcHRpb25hbCksIGB1bmRlZmluZWRgIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSB1bmlvbi5cbiAqXG4gKiAoV2lsbCByZXR1cm4gdW5kZWZpbmVkIGZvciBvYmplY3QgbGl0ZXJhbHMgbm90IHVuaWZpZWQgd2l0aCBhIGRlY2xhcmVkIHR5cGUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZlcnJlZFR5cGVPZkV4cHJlc3Npb24odHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBub2RlOiB0cy5FeHByZXNzaW9uKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlQ2hlY2tlci5nZXRDb250ZXh0dWFsVHlwZShub2RlKTtcbiAgcmV0dXJuIHR5cGUgPyB0eXBlQ2hlY2tlci5nZXROb25OdWxsYWJsZVR5cGUodHlwZSkgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih4OiBhbnkpOiB4IGlzIG51bWJlciB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VudW1BY2Nlc3ModHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBhY2Nlc3M6IHRzLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbikge1xuICBjb25zdCBzeW1ib2wgPSByZXNvbHZlZFN5bWJvbEF0TG9jYXRpb24odHlwZUNoZWNrZXIsIGFjY2Vzcy5leHByZXNzaW9uKTtcbiAgcmV0dXJuIHN5bWJvbCA/IGhhc0FueUZsYWcoc3ltYm9sLmZsYWdzLCB0cy5TeW1ib2xGbGFncy5FbnVtKSA6IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGF0aWNSZWFkb25seUFjY2Vzcyh0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIGFjY2VzczogdHMuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKSB7XG4gIGNvbnN0IHN5bWJvbCA9IHJlc29sdmVkU3ltYm9sQXRMb2NhdGlvbih0eXBlQ2hlY2tlciwgYWNjZXNzKTtcbiAgY29uc3QgZGVjbCA9IHN5bWJvbD8uZ2V0RGVjbGFyYXRpb25zKCk7XG4gIGlmIChkZWNsICYmIGRlY2xbMF0gJiYgdHMuaXNQcm9wZXJ0eURlY2xhcmF0aW9uKGRlY2xbMF0pKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoZGVjbFswXSk7XG4gICAgcmV0dXJuIGhhc0FsbEZsYWdzKGZsYWdzLCB0cy5Nb2RpZmllckZsYWdzLlJlYWRvbmx5IHwgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckZsYWdzKGZsYWdzOiBudW1iZXIgfCB1bmRlZmluZWQsIGZsYWdPYmplY3Q6IFJlY29yZDxzdHJpbmcsIG51bWJlciB8IHN0cmluZz4pIHtcbiAgaWYgKGZsYWdzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhmbGFnT2JqZWN0KVxuICAgIC5maWx0ZXIoaXNOdW1iZXIpXG4gICAgLmZpbHRlcigoZikgPT4gaGFzQWxsRmxhZ3MoZmxhZ3MsIGYpKVxuICAgIC5tYXAoKGYpID0+IGZsYWdPYmplY3RbZl0pXG4gICAgLmpvaW4oJywnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZVJldHVyblR5cGUodHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBub2RlOiB0cy5TaWduYXR1cmVEZWNsYXJhdGlvbik6IHRzLlR5cGUgfCB1bmRlZmluZWQge1xuICBjb25zdCBzaWduYXR1cmUgPSB0eXBlQ2hlY2tlci5nZXRTaWduYXR1cmVGcm9tRGVjbGFyYXRpb24obm9kZSk7XG4gIGlmICghc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdHlwZUNoZWNrZXIuZ2V0UmV0dXJuVHlwZU9mU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG59XG4iXX0=