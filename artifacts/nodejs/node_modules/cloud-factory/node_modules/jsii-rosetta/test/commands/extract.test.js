"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const lib_1 = require("../../lib");
const extract = require("../../lib/commands/extract");
const assemblies_1 = require("../../lib/jsii/assemblies");
const languages_1 = require("../../lib/languages");
const testutil_1 = require("../testutil");
const DUMMY_README = `
  Here is an example of how to use ClassA:

  \`\`\`ts
  import * as ass from 'my_assembly';
  const aClass = new ass.ClassA();
  aClass.someMethod();
  \`\`\`
`;
const defaultExtractOptions = {
    includeCompilerDiagnostics: false,
    validateAssemblies: false,
};
let assembly;
beforeEach(async () => {
    // Create an assembly in a temp directory
    assembly = await testutil_1.TestJsiiModule.fromSource({
        'index.ts': `
      export class ClassA {
        public someMethod() {
        }
      }
      export class ClassB {
        public anotherMethod() {
        }
      }
      `,
        'README.md': DUMMY_README,
    }, {
        name: 'my_assembly',
        jsii: testutil_1.DUMMY_JSII_CONFIG,
    });
});
afterEach(async () => assembly.cleanup());
test('extract samples from test assembly', async () => {
    const cacheToFile = path.join(assembly.moduleDirectory, 'test.tabl.json');
    await extract.extractSnippets([assembly.moduleDirectory], {
        cacheToFile,
        ...defaultExtractOptions,
    });
    const tablet = new lib_1.LanguageTablet();
    await tablet.load(cacheToFile);
    expect(tablet.snippetKeys.length).toEqual(1);
});
describe('with cache file', () => {
    let cacheTabletFile;
    beforeEach(async () => {
        cacheTabletFile = path.join(assembly.moduleDirectory, 'cache.tabl.json');
        await extract.extractSnippets([assembly.moduleDirectory], {
            cacheToFile: cacheTabletFile,
            ...defaultExtractOptions,
        });
    });
    async function givenThatDefaultTabletDoesNotExist() {
        await fs.unlink(path.join(assembly.moduleDirectory, lib_1.DEFAULT_TABLET_NAME));
    }
    describe('translation does not happen ', () => {
        test('if it can be read from cache', async () => {
            const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
            // GIVEN
            await givenThatDefaultTabletDoesNotExist();
            // WHEN
            await extract.extractSnippets([assembly.moduleDirectory], {
                cacheToFile: path.join(assembly.moduleDirectory, 'dummy.tabl.json'),
                cacheFromFile: cacheTabletFile,
                translatorFactory: (o) => new MockTranslator(o, translationFunction),
                ...defaultExtractOptions,
            });
            expect(translationFunction).not.toHaveBeenCalled();
        });
        test('because output file acts as cache', async () => {
            const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
            // GIVEN
            await givenThatDefaultTabletDoesNotExist();
            // WHEN
            await extract.extractSnippets([assembly.moduleDirectory], {
                cacheFromFile: cacheTabletFile,
                translatorFactory: (o) => new MockTranslator(o, translationFunction),
                ...defaultExtractOptions,
            });
            expect(translationFunction).not.toHaveBeenCalled();
        });
        test('because default tablet file acts as cache', async () => {
            const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
            // WHEN
            await extract.extractSnippets([assembly.moduleDirectory], {
                translatorFactory: (o) => new MockTranslator(o, translationFunction),
                ...defaultExtractOptions,
            });
            expect(translationFunction).not.toHaveBeenCalled();
        });
    });
    test('translation does happen if translator version is different', async () => {
        const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
        // GIVEN
        await givenThatDefaultTabletDoesNotExist();
        // WHEN
        const oldJavaVersion = languages_1.TARGET_LANGUAGES.java.version;
        languages_1.TARGET_LANGUAGES.java.version = '999';
        try {
            await extract.extractSnippets([assembly.moduleDirectory], {
                cacheToFile: path.join(assembly.moduleDirectory, 'dummy.tabl.json'),
                cacheFromFile: cacheTabletFile,
                translatorFactory: (o) => new MockTranslator(o, translationFunction),
                ...defaultExtractOptions,
            });
            expect(translationFunction).toHaveBeenCalled();
        }
        finally {
            languages_1.TARGET_LANGUAGES.java.version = oldJavaVersion;
        }
    });
    test('both default and explicit tablet are written', async () => {
        // WHEN
        await extract.extractSnippets([assembly.moduleDirectory], {
            cacheToFile: path.join(assembly.moduleDirectory, 'dummy.tabl.json'),
            ...defaultExtractOptions,
        });
        // THEN
        expect(await fs.pathExists(path.join(assembly.moduleDirectory, 'dummy.tabl.json'))).toBeTruthy();
        expect(await fs.pathExists(path.join(assembly.moduleDirectory, '.jsii.tabl.json'))).toBeTruthy();
    });
    describe('when the cache output tablet has unrelated snippets', () => {
        let cacheToFile;
        beforeEach(async () => {
            cacheToFile = path.join(assembly.moduleDirectory, 'dummy.tabl.json');
            const tbl = new lib_1.LanguageTablet();
            tbl.addSnippet(bogusTranslatedSnippet());
            await tbl.save(cacheToFile);
        });
        test('it is not trimmed by default', async () => {
            // WHEN
            await extract.extractSnippets([assembly.moduleDirectory], {
                cacheToFile,
                ...defaultExtractOptions,
            });
            // THEN
            const cacheTablet = await lib_1.LanguageTablet.fromFile(cacheToFile);
            expect(cacheTablet.count).toEqual(2);
        });
        test('it can be trimmed with an option', async () => {
            // WHEN
            await extract.extractSnippets([assembly.moduleDirectory], {
                cacheToFile,
                trimCache: true,
                ...defaultExtractOptions,
            });
            // THEN
            const cacheTablet = await lib_1.LanguageTablet.fromFile(cacheToFile);
            expect(cacheTablet.count).toEqual(1);
        });
    });
    test('default tablet is always trimmed', async () => {
        const defaultTabletFile = path.join(assembly.moduleDirectory, lib_1.DEFAULT_TABLET_NAME);
        // GIVEN - the '.jsii.tabl.json' file contains something already
        const tbl = new lib_1.LanguageTablet();
        tbl.addSnippet(bogusTranslatedSnippet());
        await tbl.save(defaultTabletFile);
        // WHEN - we run extract
        await extract.extractSnippets([assembly.moduleDirectory], defaultExtractOptions);
        // THEN - the default tablet file now only contains one snippet, the new one
        const defaultTablet = await lib_1.LanguageTablet.fromFile(defaultTabletFile);
        expect(defaultTablet.translatedSnippets.map((s) => s.snippet.location)).toEqual([
            {
                api: { api: 'moduleReadme', moduleFqn: 'my_assembly' },
                field: { field: 'markdown', line: 4 },
            },
        ]);
    });
    test('existing tablet is updated when assembly changes', async () => {
        // Modify the assembly with a new example
        assembly.assembly.types['my_assembly.ClassB'].docs = {
            example: 'ClassB.anotherMethod();',
        };
        await assembly.updateAssembly();
        const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
        await extract.extractSnippets([assembly.moduleDirectory], {
            cacheToFile: cacheTabletFile,
            translatorFactory: (o) => new MockTranslator(o, translationFunction),
            ...defaultExtractOptions,
        });
        // There are two examples, one should be cached and the other should be translated
        expect(translationFunction).toHaveBeenCalledTimes(1);
    });
    test('compiler diagnostics property is passed on', async () => {
        const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
        await extract.extractSnippets([assembly.moduleDirectory], {
            cacheToFile: path.join(assembly.moduleDirectory, 'dummy.tabl.json'),
            validateAssemblies: false,
            includeCompilerDiagnostics: true,
            translatorFactory: (o) => {
                expect(o.includeCompilerDiagnostics).toEqual(true);
                return new MockTranslator(o, translationFunction);
            },
        });
    });
});
describe('non-compiling cached examples', () => {
    let otherAssembly;
    let cacheToFile;
    beforeEach(async () => {
        // Create an assembly in a temp directory
        otherAssembly = await testutil_1.TestJsiiModule.fromSource({
            'index.ts': `
        export class ClassA {
          /**
           * Some method
           * @example x
           */
          public someMethod() {
          }
        }
        `,
        }, {
            name: 'my_assembly',
            jsii: testutil_1.DUMMY_JSII_CONFIG,
        });
        // add non-compiling snippet to cache
        cacheToFile = path.join(otherAssembly.moduleDirectory, 'test.tabl.json');
        await extract.extractSnippets([otherAssembly.moduleDirectory], {
            cacheToFile,
            includeCompilerDiagnostics: true,
            validateAssemblies: false,
        });
        const tablet = await lib_1.LanguageTablet.fromFile(cacheToFile);
        expect(tablet.count).toEqual(1);
        const tr = tablet.tryGetSnippet(tablet.snippetKeys[0]);
        expect(tr === null || tr === void 0 ? void 0 : tr.snippet.didCompile).toBeFalsy();
    });
    afterEach(async () => assembly.cleanup());
    test('are ignored with strict mode', async () => {
        // second run of extract snippets should still evaluate the snippet
        // even though it is present in the cache
        const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
        await extract.extractSnippets([otherAssembly.moduleDirectory], {
            cacheToFile,
            cacheFromFile: cacheToFile,
            includeCompilerDiagnostics: true,
            validateAssemblies: false,
            translatorFactory: (o) => new MockTranslator(o, translationFunction),
        });
        expect(translationFunction).toHaveBeenCalledTimes(1);
    });
    test('are utilized with strict mode off', async () => {
        const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
        await extract.extractSnippets([otherAssembly.moduleDirectory], {
            cacheToFile,
            cacheFromFile: cacheToFile,
            includeCompilerDiagnostics: false,
            validateAssemblies: false,
            translatorFactory: (o) => new MockTranslator(o, translationFunction),
        });
        expect(translationFunction).toHaveBeenCalledTimes(0);
    });
});
test('do not ignore example strings', async () => {
    // Create an assembly in a temp directory
    const otherAssembly = await testutil_1.TestJsiiModule.fromSource({
        'index.ts': `
      export class ClassA {
        /**
         * Some method
         * @example x
         */
        public someMethod() {
        }
      }
      `,
    }, {
        name: 'my_assembly',
        jsii: testutil_1.DUMMY_JSII_CONFIG,
    });
    try {
        const cacheToFile = path.join(otherAssembly.moduleDirectory, 'test.tabl.json');
        await extract.extractSnippets([otherAssembly.moduleDirectory], {
            cacheToFile,
            ...defaultExtractOptions,
        });
        const tablet = await lib_1.LanguageTablet.fromFile(cacheToFile);
        expect(tablet.count).toEqual(1);
        const tr = tablet.tryGetSnippet(tablet.snippetKeys[0]);
        expect(tr === null || tr === void 0 ? void 0 : tr.originalSource.source).toEqual('x');
    }
    finally {
        await otherAssembly.cleanup();
    }
});
describe('can find fqns via symbolId when ', () => {
    test('there is an outDir', async () => {
        const outDir = 'jsii-outDir';
        const otherAssembly = await createAssemblyWithDirectories(undefined, outDir);
        try {
            const outputFile = path.join(otherAssembly.moduleDirectory, 'test.tabl.json');
            await extract.extractSnippets([otherAssembly.moduleDirectory], {
                cacheToFile: outputFile,
                ...defaultExtractOptions,
            });
            const tablet = await lib_1.LanguageTablet.fromFile(outputFile);
            const tr = tablet.tryGetSnippet(tablet.snippetKeys[0]);
            expect(tr === null || tr === void 0 ? void 0 : tr.fqnsReferenced()).toEqual(['my_assembly.ClassA']);
        }
        finally {
            await otherAssembly.cleanup();
        }
    });
    test('there is an outDir and rootDir', async () => {
        const outDir = 'jsii-outDir';
        const rootDir = '.';
        const otherAssembly = await createAssemblyWithDirectories(rootDir, outDir);
        try {
            const outputFile = path.join(otherAssembly.moduleDirectory, 'test.tabl.json');
            await extract.extractSnippets([otherAssembly.moduleDirectory], {
                cacheToFile: outputFile,
                ...defaultExtractOptions,
            });
            const tablet = await lib_1.LanguageTablet.fromFile(outputFile);
            const tr = tablet.tryGetSnippet(tablet.snippetKeys[0]);
            expect(tr === null || tr === void 0 ? void 0 : tr.fqnsReferenced()).toEqual(['my_assembly.ClassA']);
        }
        finally {
            await otherAssembly.cleanup();
        }
    });
});
test('extract and infuse in one command', async () => {
    var _a, _b;
    const cacheToFile = path.join(assembly.moduleDirectory, 'test.tabl.json');
    await extract.extractAndInfuse([assembly.moduleDirectory], {
        cacheToFile,
        ...defaultExtractOptions,
    });
    const tablet = new lib_1.LanguageTablet();
    await tablet.load(cacheToFile);
    // extract works as expected, with a caveat
    // the infuse part of this call will re-insert the example back
    // into the tablet under a new key and new location.
    // so we confirm that the locations of the snippets are as expected.
    expect(tablet.snippetKeys.length).toEqual(2);
    const locations = new Set();
    for (const key of tablet.snippetKeys) {
        locations.add((_a = tablet.tryGetSnippet(key)) === null || _a === void 0 ? void 0 : _a.snippet.location.api.api);
    }
    expect(locations).toContain('type');
    expect(locations).toContain('moduleReadme');
    const assemblies = await assemblies_1.loadAssemblies([assembly.moduleDirectory], false);
    const types = assemblies[0].assembly.types;
    // infuse works as expected
    expect(types).toBeDefined();
    expect((_b = types['my_assembly.ClassA'].docs) === null || _b === void 0 ? void 0 : _b.example).toBeDefined();
});
describe('infused examples', () => {
    let infusedAssembly;
    beforeEach(async () => {
        infusedAssembly = await testutil_1.TestJsiiModule.fromSource({
            'index.ts': `
        /**
         * ClassA
         * 
         * @exampleMetadata infused 
         * @example x
         */
        export class ClassA {
          public someMethod() {
          }
        }
        `,
        }, {
            name: 'my_assembly',
            jsii: testutil_1.DUMMY_JSII_CONFIG,
        });
    });
    afterEach(async () => {
        await infusedAssembly.cleanup();
    });
    test('always returned from cache', async () => {
        const cacheFile = path.join(infusedAssembly.moduleDirectory, 'test.tabl.json');
        // Cache to file
        await extract.extractSnippets([infusedAssembly.moduleDirectory], {
            cacheToFile: cacheFile,
            ...defaultExtractOptions,
        });
        // Update the example with a fixture that would fail compilation
        // Nothing like this should happen in practice
        infusedAssembly.assembly.types['my_assembly.ClassA'].docs.custom.exampleMetadata =
            'infused fixture=myfix.ts-fixture';
        await infusedAssembly.updateAssembly();
        // Expect to return cached snippet regardless of change
        // No compilation should happen
        const translationFunction = jest.fn().mockResolvedValue({ diagnostics: [], translatedSnippets: [] });
        await extract.extractSnippets([infusedAssembly.moduleDirectory], {
            cacheFromFile: cacheFile,
            ...defaultExtractOptions,
            translatorFactory: (o) => new MockTranslator(o, translationFunction),
        });
        expect(translationFunction).not.toHaveBeenCalled();
    });
    test('skip loose mode', async () => {
        // Remove infused for now and add lit metadata that should fail
        infusedAssembly.assembly.types['my_assembly.ClassA'].docs.custom.exampleMetadata = 'lit=integ.test.ts';
        await infusedAssembly.updateAssembly();
        const cacheToFile = path.join(infusedAssembly.moduleDirectory, 'test.tabl.json');
        // Without exampleMetadata infused, expect an error
        await expect(extract.extractSnippets([infusedAssembly.moduleDirectory], {
            cacheToFile,
            ...defaultExtractOptions,
        })).rejects.toThrowError(/Sample uses literate source/);
        // Add infused to metadata and update assembly
        infusedAssembly.assembly.types['my_assembly.ClassA'].docs.custom.exampleMetadata = 'lit=integ.test.ts infused';
        await infusedAssembly.updateAssembly();
        // Expect same function call to succeed now
        await extract.extractSnippets([infusedAssembly.moduleDirectory], {
            cacheToFile,
            ...defaultExtractOptions,
        });
        const tablet = await lib_1.LanguageTablet.fromFile(cacheToFile);
        expect(tablet.count).toEqual(1);
        const tr = tablet.tryGetSnippet(tablet.snippetKeys[0]);
        expect(tr === null || tr === void 0 ? void 0 : tr.originalSource.source).toEqual('x');
    });
});
test('infused examples have no diagnostics', async () => {
    const otherAssembly = await testutil_1.TestJsiiModule.fromSource({
        'index.ts': `
      /**
       * ClassA
       * 
       * @exampleMetadata infused
       * @example x
       */
      export class ClassA {
        public someMethod() {
        }
      }
      `,
    }, {
        name: 'my_assembly',
        jsii: {
            ...testutil_1.DUMMY_JSII_CONFIG,
        },
    });
    try {
        const cacheToFile = path.join(otherAssembly.moduleDirectory, 'test.tabl.json');
        const results = await extract.extractSnippets([otherAssembly.moduleDirectory], {
            cacheToFile,
            includeCompilerDiagnostics: true,
            loose: false,
        });
        expect(results.diagnostics).toEqual([]);
    }
    finally {
        await otherAssembly.cleanup();
    }
});
class MockTranslator extends lib_1.RosettaTranslator {
    constructor(opts, translatorFn) {
        super(opts);
        this.translateAll = translatorFn;
    }
}
async function createAssemblyWithDirectories(rootDir, outDir) {
    return testutil_1.TestJsiiModule.fromSource({
        'index.ts': `
      export class ClassA {
        /**
         * Some method
         *
         * @example
         * import * as ass from 'my_assembly';
         * new ass.ClassA.someMethod();
         */
        public someMethod() {
        }
      }
      `,
        'README.md': '',
    }, {
        name: 'my_assembly',
        main: `${outDir}/index.js`,
        types: `${outDir}/index.d.ts`,
        jsii: {
            ...testutil_1.DUMMY_JSII_CONFIG,
            tsc: {
                outDir,
                rootDir,
            },
        },
    });
}
function bogusTranslatedSnippet() {
    return lib_1.TranslatedSnippet.fromTypeScript(lib_1.typeScriptSnippetFromVisibleSource('console.log("hello");', testutil_1.testSnippetLocation('x.ts'), true), true);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmFjdC50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZXh0cmFjdC50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUU3QixtQ0FPbUI7QUFDbkIsc0RBQXNEO0FBQ3RELDBEQUEyRDtBQUMzRCxtREFBdUQ7QUFDdkQsMENBQXFGO0FBRXJGLE1BQU0sWUFBWSxHQUFHOzs7Ozs7OztDQVFwQixDQUFDO0FBRUYsTUFBTSxxQkFBcUIsR0FBRztJQUM1QiwwQkFBMEIsRUFBRSxLQUFLO0lBQ2pDLGtCQUFrQixFQUFFLEtBQUs7Q0FDMUIsQ0FBQztBQUVGLElBQUksUUFBd0IsQ0FBQztBQUM3QixVQUFVLENBQUMsS0FBSyxJQUFJLEVBQUU7SUFDcEIseUNBQXlDO0lBQ3pDLFFBQVEsR0FBRyxNQUFNLHlCQUFjLENBQUMsVUFBVSxDQUN4QztRQUNFLFVBQVUsRUFBRTs7Ozs7Ozs7O09BU1g7UUFDRCxXQUFXLEVBQUUsWUFBWTtLQUMxQixFQUNEO1FBQ0UsSUFBSSxFQUFFLGFBQWE7UUFDbkIsSUFBSSxFQUFFLDRCQUFpQjtLQUN4QixDQUNGLENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQztBQUVILFNBQVMsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBRTFDLElBQUksQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLElBQUksRUFBRTtJQUNwRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUMxRSxNQUFNLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLEVBQUU7UUFDeEQsV0FBVztRQUNYLEdBQUcscUJBQXFCO0tBQ3pCLENBQUMsQ0FBQztJQUVILE1BQU0sTUFBTSxHQUFHLElBQUksb0JBQWMsRUFBRSxDQUFDO0lBQ3BD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RyxNQUFNLGFBQWE7UUFDN0IsSUFBSSxFQUFFO1lBQ0osR0FBRyw0QkFBaUI7WUFDcEIsR0FBRyxFQUFFO2dCQUNILE1BQU07Z0JBQ04sT0FBTzthQUNSO1NBQ0Y7S0FDRixDQUNGLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxzQkFBc0I7SUFDN0IsT0FBTyx1QkFBaUIsQ0FBQyxjQUFjLENBQ3JDLHdDQUFrQyxDQUFDLHVCQUF1QixFQUFFLDhCQUFtQixDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUM5RixJQUFJLENBQ0wsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQge1xuICBMYW5ndWFnZVRhYmxldCxcbiAgUm9zZXR0YVRyYW5zbGF0b3IsXG4gIFJvc2V0dGFUcmFuc2xhdG9yT3B0aW9ucyxcbiAgREVGQVVMVF9UQUJMRVRfTkFNRSxcbiAgVHJhbnNsYXRlZFNuaXBwZXQsXG4gIHR5cGVTY3JpcHRTbmlwcGV0RnJvbVZpc2libGVTb3VyY2UsXG59IGZyb20gJy4uLy4uL2xpYic7XG5pbXBvcnQgKiBhcyBleHRyYWN0IGZyb20gJy4uLy4uL2xpYi9jb21tYW5kcy9leHRyYWN0JztcbmltcG9ydCB7IGxvYWRBc3NlbWJsaWVzIH0gZnJvbSAnLi4vLi4vbGliL2pzaWkvYXNzZW1ibGllcyc7XG5pbXBvcnQgeyBUQVJHRVRfTEFOR1VBR0VTIH0gZnJvbSAnLi4vLi4vbGliL2xhbmd1YWdlcyc7XG5pbXBvcnQgeyBUZXN0SnNpaU1vZHVsZSwgRFVNTVlfSlNJSV9DT05GSUcsIHRlc3RTbmlwcGV0TG9jYXRpb24gfSBmcm9tICcuLi90ZXN0dXRpbCc7XG5cbmNvbnN0IERVTU1ZX1JFQURNRSA9IGBcbiAgSGVyZSBpcyBhbiBleGFtcGxlIG9mIGhvdyB0byB1c2UgQ2xhc3NBOlxuXG4gIFxcYFxcYFxcYHRzXG4gIGltcG9ydCAqIGFzIGFzcyBmcm9tICdteV9hc3NlbWJseSc7XG4gIGNvbnN0IGFDbGFzcyA9IG5ldyBhc3MuQ2xhc3NBKCk7XG4gIGFDbGFzcy5zb21lTWV0aG9kKCk7XG4gIFxcYFxcYFxcYFxuYDtcblxuY29uc3QgZGVmYXVsdEV4dHJhY3RPcHRpb25zID0ge1xuICBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljczogZmFsc2UsXG4gIHZhbGlkYXRlQXNzZW1ibGllczogZmFsc2UsXG59O1xuXG5sZXQgYXNzZW1ibHk6IFRlc3RKc2lpTW9kdWxlO1xuYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gIC8vIENyZWF0ZSBhbiBhc3NlbWJseSBpbiBhIHRlbXAgZGlyZWN0b3J5XG4gIGFzc2VtYmx5ID0gYXdhaXQgVGVzdEpzaWlNb2R1bGUuZnJvbVNvdXJjZShcbiAgICB7XG4gICAgICAnaW5kZXgudHMnOiBgXG4gICAgICBleHBvcnQgY2xhc3MgQ2xhc3NBIHtcbiAgICAgICAgcHVibGljIHNvbWVNZXRob2QoKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV4cG9ydCBjbGFzcyBDbGFzc0Ige1xuICAgICAgICBwdWJsaWMgYW5vdGhlck1ldGhvZCgpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYCxcbiAgICAgICdSRUFETUUubWQnOiBEVU1NWV9SRUFETUUsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbXlfYXNzZW1ibHknLFxuICAgICAganNpaTogRFVNTVlfSlNJSV9DT05GSUcsXG4gICAgfSxcbiAgKTtcbn0pO1xuXG5hZnRlckVhY2goYXN5bmMgKCkgPT4gYXNzZW1ibHkuY2xlYW51cCgpKTtcblxudGVzdCgnZXh0cmFjdCBzYW1wbGVzIGZyb20gdGVzdCBhc3NlbWJseScsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgY2FjaGVUb0ZpbGUgPSBwYXRoLmpvaW4oYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCAndGVzdC50YWJsLmpzb24nKTtcbiAgYXdhaXQgZXh0cmFjdC5leHRyYWN0U25pcHBldHMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICBjYWNoZVRvRmlsZSxcbiAgICAuLi5kZWZhdWx0RXh0cmFjdE9wdGlvbnMsXG4gIH0pO1xuXG4gIGNvbnN0IHRhYmxldCA9IG5ldyBMYW5ndWFnZVRhYmxldCgpO1xuICBhd2FpdCB0YWJsZXQubG9hZChjYWNoZVRvRmlsZSk7XG5cbiAgZXhwZWN0KHRhYmxldC5zbmlwcGV0S2V5cy5sZW5ndGgpLnRvRXF1YWwoMSk7XG59KTtcblxuZGVzY3JpYmUoJ3dpdGggY2FjaGUgZmlsZScsICgpID0+IHtcbiAgbGV0IGNhY2hlVGFibGV0RmlsZTogc3RyaW5nO1xuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBjYWNoZVRhYmxldEZpbGUgPSBwYXRoLmpvaW4oYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCAnY2FjaGUudGFibC5qc29uJyk7XG4gICAgYXdhaXQgZXh0cmFjdC5leHRyYWN0U25pcHBldHMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgIGNhY2hlVG9GaWxlOiBjYWNoZVRhYmxldEZpbGUsXG4gICAgICAuLi5kZWZhdWx0RXh0cmFjdE9wdGlvbnMsXG4gICAgfSk7XG4gIH0pO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGdpdmVuVGhhdERlZmF1bHRUYWJsZXREb2VzTm90RXhpc3QoKSB7XG4gICAgYXdhaXQgZnMudW5saW5rKHBhdGguam9pbihhc3NlbWJseS5tb2R1bGVEaXJlY3RvcnksIERFRkFVTFRfVEFCTEVUX05BTUUpKTtcbiAgfVxuXG4gIGRlc2NyaWJlKCd0cmFuc2xhdGlvbiBkb2VzIG5vdCBoYXBwZW4gJywgKCkgPT4ge1xuICAgIHRlc3QoJ2lmIGl0IGNhbiBiZSByZWFkIGZyb20gY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2xhdGlvbkZ1bmN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGlhZ25vc3RpY3M6IFtdLCB0cmFuc2xhdGVkU25pcHBldHM6IFtdIH0pO1xuXG4gICAgICAvLyBHSVZFTlxuICAgICAgYXdhaXQgZ2l2ZW5UaGF0RGVmYXVsdFRhYmxldERvZXNOb3RFeGlzdCgpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBhd2FpdCBleHRyYWN0LmV4dHJhY3RTbmlwcGV0cyhbYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5XSwge1xuICAgICAgICBjYWNoZVRvRmlsZTogcGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgJ2R1bW15LnRhYmwuanNvbicpLFxuICAgICAgICBjYWNoZUZyb21GaWxlOiBjYWNoZVRhYmxldEZpbGUsXG4gICAgICAgIHRyYW5zbGF0b3JGYWN0b3J5OiAobykgPT4gbmV3IE1vY2tUcmFuc2xhdG9yKG8sIHRyYW5zbGF0aW9uRnVuY3Rpb24pLFxuICAgICAgICAuLi5kZWZhdWx0RXh0cmFjdE9wdGlvbnMsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHRyYW5zbGF0aW9uRnVuY3Rpb24pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdiZWNhdXNlIG91dHB1dCBmaWxlIGFjdHMgYXMgY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2xhdGlvbkZ1bmN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGlhZ25vc3RpY3M6IFtdLCB0cmFuc2xhdGVkU25pcHBldHM6IFtdIH0pO1xuXG4gICAgICAvLyBHSVZFTlxuICAgICAgYXdhaXQgZ2l2ZW5UaGF0RGVmYXVsdFRhYmxldERvZXNOb3RFeGlzdCgpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBhd2FpdCBleHRyYWN0LmV4dHJhY3RTbmlwcGV0cyhbYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5XSwge1xuICAgICAgICBjYWNoZUZyb21GaWxlOiBjYWNoZVRhYmxldEZpbGUsXG4gICAgICAgIHRyYW5zbGF0b3JGYWN0b3J5OiAobykgPT4gbmV3IE1vY2tUcmFuc2xhdG9yKG8sIHRyYW5zbGF0aW9uRnVuY3Rpb24pLFxuICAgICAgICAuLi5kZWZhdWx0RXh0cmFjdE9wdGlvbnMsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHRyYW5zbGF0aW9uRnVuY3Rpb24pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdiZWNhdXNlIGRlZmF1bHQgdGFibGV0IGZpbGUgYWN0cyBhcyBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uRnVuY3Rpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkaWFnbm9zdGljczogW10sIHRyYW5zbGF0ZWRTbmlwcGV0czogW10gfSk7XG5cbiAgICAgIC8vIFdIRU5cbiAgICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFthc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldLCB7XG4gICAgICAgIHRyYW5zbGF0b3JGYWN0b3J5OiAobykgPT4gbmV3IE1vY2tUcmFuc2xhdG9yKG8sIHRyYW5zbGF0aW9uRnVuY3Rpb24pLFxuICAgICAgICAuLi5kZWZhdWx0RXh0cmFjdE9wdGlvbnMsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHRyYW5zbGF0aW9uRnVuY3Rpb24pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHRlc3QoJ3RyYW5zbGF0aW9uIGRvZXMgaGFwcGVuIGlmIHRyYW5zbGF0b3IgdmVyc2lvbiBpcyBkaWZmZXJlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdHJhbnNsYXRpb25GdW5jdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRpYWdub3N0aWNzOiBbXSwgdHJhbnNsYXRlZFNuaXBwZXRzOiBbXSB9KTtcblxuICAgIC8vIEdJVkVOXG4gICAgYXdhaXQgZ2l2ZW5UaGF0RGVmYXVsdFRhYmxldERvZXNOb3RFeGlzdCgpO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IG9sZEphdmFWZXJzaW9uID0gVEFSR0VUX0xBTkdVQUdFUy5qYXZhLnZlcnNpb247XG4gICAgKFRBUkdFVF9MQU5HVUFHRVMuamF2YSBhcyBhbnkpLnZlcnNpb24gPSAnOTk5JztcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXh0cmFjdC5leHRyYWN0U25pcHBldHMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgICAgY2FjaGVUb0ZpbGU6IHBhdGguam9pbihhc3NlbWJseS5tb2R1bGVEaXJlY3RvcnksICdkdW1teS50YWJsLmpzb24nKSxcbiAgICAgICAgY2FjaGVGcm9tRmlsZTogY2FjaGVUYWJsZXRGaWxlLFxuICAgICAgICB0cmFuc2xhdG9yRmFjdG9yeTogKG8pID0+IG5ldyBNb2NrVHJhbnNsYXRvcihvLCB0cmFuc2xhdGlvbkZ1bmN0aW9uKSxcbiAgICAgICAgLi4uZGVmYXVsdEV4dHJhY3RPcHRpb25zLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdCh0cmFuc2xhdGlvbkZ1bmN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIChUQVJHRVRfTEFOR1VBR0VTLmphdmEgYXMgYW55KS52ZXJzaW9uID0gb2xkSmF2YVZlcnNpb247XG4gICAgfVxuICB9KTtcblxuICB0ZXN0KCdib3RoIGRlZmF1bHQgYW5kIGV4cGxpY2l0IHRhYmxldCBhcmUgd3JpdHRlbicsIGFzeW5jICgpID0+IHtcbiAgICAvLyBXSEVOXG4gICAgYXdhaXQgZXh0cmFjdC5leHRyYWN0U25pcHBldHMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgIGNhY2hlVG9GaWxlOiBwYXRoLmpvaW4oYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCAnZHVtbXkudGFibC5qc29uJyksXG4gICAgICAuLi5kZWZhdWx0RXh0cmFjdE9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgJ2R1bW15LnRhYmwuanNvbicpKSkudG9CZVRydXRoeSgpO1xuICAgIGV4cGVjdChhd2FpdCBmcy5wYXRoRXhpc3RzKHBhdGguam9pbihhc3NlbWJseS5tb2R1bGVEaXJlY3RvcnksICcuanNpaS50YWJsLmpzb24nKSkpLnRvQmVUcnV0aHkoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3doZW4gdGhlIGNhY2hlIG91dHB1dCB0YWJsZXQgaGFzIHVucmVsYXRlZCBzbmlwcGV0cycsICgpID0+IHtcbiAgICBsZXQgY2FjaGVUb0ZpbGU6IHN0cmluZztcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIGNhY2hlVG9GaWxlID0gcGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgJ2R1bW15LnRhYmwuanNvbicpO1xuXG4gICAgICBjb25zdCB0YmwgPSBuZXcgTGFuZ3VhZ2VUYWJsZXQoKTtcbiAgICAgIHRibC5hZGRTbmlwcGV0KGJvZ3VzVHJhbnNsYXRlZFNuaXBwZXQoKSk7XG4gICAgICBhd2FpdCB0Ymwuc2F2ZShjYWNoZVRvRmlsZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdpdCBpcyBub3QgdHJpbW1lZCBieSBkZWZhdWx0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gV0hFTlxuICAgICAgYXdhaXQgZXh0cmFjdC5leHRyYWN0U25pcHBldHMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgICAgY2FjaGVUb0ZpbGUsXG4gICAgICAgIC4uLmRlZmF1bHRFeHRyYWN0T3B0aW9ucyxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBjb25zdCBjYWNoZVRhYmxldCA9IGF3YWl0IExhbmd1YWdlVGFibGV0LmZyb21GaWxlKGNhY2hlVG9GaWxlKTtcblxuICAgICAgZXhwZWN0KGNhY2hlVGFibGV0LmNvdW50KS50b0VxdWFsKDIpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaXQgY2FuIGJlIHRyaW1tZWQgd2l0aCBhbiBvcHRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBXSEVOXG4gICAgICBhd2FpdCBleHRyYWN0LmV4dHJhY3RTbmlwcGV0cyhbYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5XSwge1xuICAgICAgICBjYWNoZVRvRmlsZSxcbiAgICAgICAgdHJpbUNhY2hlOiB0cnVlLFxuICAgICAgICAuLi5kZWZhdWx0RXh0cmFjdE9wdGlvbnMsXG4gICAgICB9KTtcblxuICAgICAgLy8gVEhFTlxuICAgICAgY29uc3QgY2FjaGVUYWJsZXQgPSBhd2FpdCBMYW5ndWFnZVRhYmxldC5mcm9tRmlsZShjYWNoZVRvRmlsZSk7XG5cbiAgICAgIGV4cGVjdChjYWNoZVRhYmxldC5jb3VudCkudG9FcXVhbCgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgnZGVmYXVsdCB0YWJsZXQgaXMgYWx3YXlzIHRyaW1tZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdFRhYmxldEZpbGUgPSBwYXRoLmpvaW4oYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCBERUZBVUxUX1RBQkxFVF9OQU1FKTtcblxuICAgIC8vIEdJVkVOIC0gdGhlICcuanNpaS50YWJsLmpzb24nIGZpbGUgY29udGFpbnMgc29tZXRoaW5nIGFscmVhZHlcbiAgICBjb25zdCB0YmwgPSBuZXcgTGFuZ3VhZ2VUYWJsZXQoKTtcbiAgICB0YmwuYWRkU25pcHBldChib2d1c1RyYW5zbGF0ZWRTbmlwcGV0KCkpO1xuICAgIGF3YWl0IHRibC5zYXZlKGRlZmF1bHRUYWJsZXRGaWxlKTtcblxuICAgIC8vIFdIRU4gLSB3ZSBydW4gZXh0cmFjdFxuICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFthc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldLCBkZWZhdWx0RXh0cmFjdE9wdGlvbnMpO1xuXG4gICAgLy8gVEhFTiAtIHRoZSBkZWZhdWx0IHRhYmxldCBmaWxlIG5vdyBvbmx5IGNvbnRhaW5zIG9uZSBzbmlwcGV0LCB0aGUgbmV3IG9uZVxuICAgIGNvbnN0IGRlZmF1bHRUYWJsZXQgPSBhd2FpdCBMYW5ndWFnZVRhYmxldC5mcm9tRmlsZShkZWZhdWx0VGFibGV0RmlsZSk7XG5cbiAgICBleHBlY3QoZGVmYXVsdFRhYmxldC50cmFuc2xhdGVkU25pcHBldHMubWFwKChzKSA9PiBzLnNuaXBwZXQubG9jYXRpb24pKS50b0VxdWFsKFtcbiAgICAgIHtcbiAgICAgICAgYXBpOiB7IGFwaTogJ21vZHVsZVJlYWRtZScsIG1vZHVsZUZxbjogJ215X2Fzc2VtYmx5JyB9LFxuICAgICAgICBmaWVsZDogeyBmaWVsZDogJ21hcmtkb3duJywgbGluZTogNCB9LFxuICAgICAgfSxcbiAgICBdKTtcbiAgfSk7XG5cbiAgdGVzdCgnZXhpc3RpbmcgdGFibGV0IGlzIHVwZGF0ZWQgd2hlbiBhc3NlbWJseSBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIE1vZGlmeSB0aGUgYXNzZW1ibHkgd2l0aCBhIG5ldyBleGFtcGxlXG4gICAgYXNzZW1ibHkuYXNzZW1ibHkudHlwZXMhWydteV9hc3NlbWJseS5DbGFzc0InXS5kb2NzID0ge1xuICAgICAgZXhhbXBsZTogJ0NsYXNzQi5hbm90aGVyTWV0aG9kKCk7JyxcbiAgICB9O1xuICAgIGF3YWl0IGFzc2VtYmx5LnVwZGF0ZUFzc2VtYmx5KCk7XG5cbiAgICBjb25zdCB0cmFuc2xhdGlvbkZ1bmN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGlhZ25vc3RpY3M6IFtdLCB0cmFuc2xhdGVkU25pcHBldHM6IFtdIH0pO1xuXG4gICAgYXdhaXQgZXh0cmFjdC5leHRyYWN0U25pcHBldHMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgIGNhY2hlVG9GaWxlOiBjYWNoZVRhYmxldEZpbGUsXG4gICAgICB0cmFuc2xhdG9yRmFjdG9yeTogKG8pID0+IG5ldyBNb2NrVHJhbnNsYXRvcihvLCB0cmFuc2xhdGlvbkZ1bmN0aW9uKSxcbiAgICAgIC4uLmRlZmF1bHRFeHRyYWN0T3B0aW9ucyxcbiAgICB9KTtcblxuICAgIC8vIFRoZXJlIGFyZSB0d28gZXhhbXBsZXMsIG9uZSBzaG91bGQgYmUgY2FjaGVkIGFuZCB0aGUgb3RoZXIgc2hvdWxkIGJlIHRyYW5zbGF0ZWRcbiAgICBleHBlY3QodHJhbnNsYXRpb25GdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICB9KTtcblxuICB0ZXN0KCdjb21waWxlciBkaWFnbm9zdGljcyBwcm9wZXJ0eSBpcyBwYXNzZWQgb24nLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdHJhbnNsYXRpb25GdW5jdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRpYWdub3N0aWNzOiBbXSwgdHJhbnNsYXRlZFNuaXBwZXRzOiBbXSB9KTtcblxuICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFthc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldLCB7XG4gICAgICBjYWNoZVRvRmlsZTogcGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgJ2R1bW15LnRhYmwuanNvbicpLFxuICAgICAgdmFsaWRhdGVBc3NlbWJsaWVzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVDb21waWxlckRpYWdub3N0aWNzOiB0cnVlLFxuICAgICAgdHJhbnNsYXRvckZhY3Rvcnk6IChvKSA9PiB7XG4gICAgICAgIGV4cGVjdChvLmluY2x1ZGVDb21waWxlckRpYWdub3N0aWNzKS50b0VxdWFsKHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IE1vY2tUcmFuc2xhdG9yKG8sIHRyYW5zbGF0aW9uRnVuY3Rpb24pO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ25vbi1jb21waWxpbmcgY2FjaGVkIGV4YW1wbGVzJywgKCkgPT4ge1xuICBsZXQgb3RoZXJBc3NlbWJseTogVGVzdEpzaWlNb2R1bGU7XG4gIGxldCBjYWNoZVRvRmlsZTogc3RyaW5nO1xuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAvLyBDcmVhdGUgYW4gYXNzZW1ibHkgaW4gYSB0ZW1wIGRpcmVjdG9yeVxuICAgIG90aGVyQXNzZW1ibHkgPSBhd2FpdCBUZXN0SnNpaU1vZHVsZS5mcm9tU291cmNlKFxuICAgICAge1xuICAgICAgICAnaW5kZXgudHMnOiBgXG4gICAgICAgIGV4cG9ydCBjbGFzcyBDbGFzc0Ege1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNvbWUgbWV0aG9kXG4gICAgICAgICAgICogQGV4YW1wbGUgeFxuICAgICAgICAgICAqL1xuICAgICAgICAgIHB1YmxpYyBzb21lTWV0aG9kKCkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ215X2Fzc2VtYmx5JyxcbiAgICAgICAganNpaTogRFVNTVlfSlNJSV9DT05GSUcsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICAvLyBhZGQgbm9uLWNvbXBpbGluZyBzbmlwcGV0IHRvIGNhY2hlXG4gICAgY2FjaGVUb0ZpbGUgPSBwYXRoLmpvaW4ob3RoZXJBc3NlbWJseS5tb2R1bGVEaXJlY3RvcnksICd0ZXN0LnRhYmwuanNvbicpO1xuICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFtvdGhlckFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgIGNhY2hlVG9GaWxlLFxuICAgICAgaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3M6IHRydWUsXG4gICAgICB2YWxpZGF0ZUFzc2VtYmxpZXM6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdGFibGV0ID0gYXdhaXQgTGFuZ3VhZ2VUYWJsZXQuZnJvbUZpbGUoY2FjaGVUb0ZpbGUpO1xuICAgIGV4cGVjdCh0YWJsZXQuY291bnQpLnRvRXF1YWwoMSk7XG4gICAgY29uc3QgdHIgPSB0YWJsZXQudHJ5R2V0U25pcHBldCh0YWJsZXQuc25pcHBldEtleXNbMF0pO1xuICAgIGV4cGVjdCh0cj8uc25pcHBldC5kaWRDb21waWxlKS50b0JlRmFsc3koKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IGFzc2VtYmx5LmNsZWFudXAoKSk7XG5cbiAgdGVzdCgnYXJlIGlnbm9yZWQgd2l0aCBzdHJpY3QgbW9kZScsIGFzeW5jICgpID0+IHtcbiAgICAvLyBzZWNvbmQgcnVuIG9mIGV4dHJhY3Qgc25pcHBldHMgc2hvdWxkIHN0aWxsIGV2YWx1YXRlIHRoZSBzbmlwcGV0XG4gICAgLy8gZXZlbiB0aG91Z2ggaXQgaXMgcHJlc2VudCBpbiB0aGUgY2FjaGVcbiAgICBjb25zdCB0cmFuc2xhdGlvbkZ1bmN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGlhZ25vc3RpY3M6IFtdLCB0cmFuc2xhdGVkU25pcHBldHM6IFtdIH0pO1xuICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFtvdGhlckFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgIGNhY2hlVG9GaWxlLFxuICAgICAgY2FjaGVGcm9tRmlsZTogY2FjaGVUb0ZpbGUsXG4gICAgICBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljczogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlQXNzZW1ibGllczogZmFsc2UsXG4gICAgICB0cmFuc2xhdG9yRmFjdG9yeTogKG8pID0+IG5ldyBNb2NrVHJhbnNsYXRvcihvLCB0cmFuc2xhdGlvbkZ1bmN0aW9uKSxcbiAgICB9KTtcblxuICAgIGV4cGVjdCh0cmFuc2xhdGlvbkZ1bmN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gIH0pO1xuXG4gIHRlc3QoJ2FyZSB1dGlsaXplZCB3aXRoIHN0cmljdCBtb2RlIG9mZicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB0cmFuc2xhdGlvbkZ1bmN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGlhZ25vc3RpY3M6IFtdLCB0cmFuc2xhdGVkU25pcHBldHM6IFtdIH0pO1xuICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFtvdGhlckFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgIGNhY2hlVG9GaWxlLFxuICAgICAgY2FjaGVGcm9tRmlsZTogY2FjaGVUb0ZpbGUsXG4gICAgICBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljczogZmFsc2UsXG4gICAgICB2YWxpZGF0ZUFzc2VtYmxpZXM6IGZhbHNlLFxuICAgICAgdHJhbnNsYXRvckZhY3Rvcnk6IChvKSA9PiBuZXcgTW9ja1RyYW5zbGF0b3IobywgdHJhbnNsYXRpb25GdW5jdGlvbiksXG4gICAgfSk7XG5cbiAgICBleHBlY3QodHJhbnNsYXRpb25GdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDApO1xuICB9KTtcbn0pO1xuXG50ZXN0KCdkbyBub3QgaWdub3JlIGV4YW1wbGUgc3RyaW5ncycsIGFzeW5jICgpID0+IHtcbiAgLy8gQ3JlYXRlIGFuIGFzc2VtYmx5IGluIGEgdGVtcCBkaXJlY3RvcnlcbiAgY29uc3Qgb3RoZXJBc3NlbWJseSA9IGF3YWl0IFRlc3RKc2lpTW9kdWxlLmZyb21Tb3VyY2UoXG4gICAge1xuICAgICAgJ2luZGV4LnRzJzogYFxuICAgICAgZXhwb3J0IGNsYXNzIENsYXNzQSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb21lIG1ldGhvZFxuICAgICAgICAgKiBAZXhhbXBsZSB4XG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgc29tZU1ldGhvZCgpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdteV9hc3NlbWJseScsXG4gICAgICBqc2lpOiBEVU1NWV9KU0lJX0NPTkZJRyxcbiAgICB9LFxuICApO1xuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlVG9GaWxlID0gcGF0aC5qb2luKG90aGVyQXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCAndGVzdC50YWJsLmpzb24nKTtcbiAgICBhd2FpdCBleHRyYWN0LmV4dHJhY3RTbmlwcGV0cyhbb3RoZXJBc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldLCB7XG4gICAgICBjYWNoZVRvRmlsZSxcbiAgICAgIC4uLmRlZmF1bHRFeHRyYWN0T3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnN0IHRhYmxldCA9IGF3YWl0IExhbmd1YWdlVGFibGV0LmZyb21GaWxlKGNhY2hlVG9GaWxlKTtcbiAgICBleHBlY3QodGFibGV0LmNvdW50KS50b0VxdWFsKDEpO1xuICAgIGNvbnN0IHRyID0gdGFibGV0LnRyeUdldFNuaXBwZXQodGFibGV0LnNuaXBwZXRLZXlzWzBdKTtcbiAgICBleHBlY3QodHI/Lm9yaWdpbmFsU291cmNlLnNvdXJjZSkudG9FcXVhbCgneCcpO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IG90aGVyQXNzZW1ibHkuY2xlYW51cCgpO1xuICB9XG59KTtcblxuZGVzY3JpYmUoJ2NhbiBmaW5kIGZxbnMgdmlhIHN5bWJvbElkIHdoZW4gJywgKCkgPT4ge1xuICB0ZXN0KCd0aGVyZSBpcyBhbiBvdXREaXInLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgb3V0RGlyID0gJ2pzaWktb3V0RGlyJztcbiAgICBjb25zdCBvdGhlckFzc2VtYmx5ID0gYXdhaXQgY3JlYXRlQXNzZW1ibHlXaXRoRGlyZWN0b3JpZXModW5kZWZpbmVkLCBvdXREaXIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXRGaWxlID0gcGF0aC5qb2luKG90aGVyQXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCAndGVzdC50YWJsLmpzb24nKTtcbiAgICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFtvdGhlckFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgICAgY2FjaGVUb0ZpbGU6IG91dHB1dEZpbGUsXG4gICAgICAgIC4uLmRlZmF1bHRFeHRyYWN0T3B0aW9ucyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0YWJsZXQgPSBhd2FpdCBMYW5ndWFnZVRhYmxldC5mcm9tRmlsZShvdXRwdXRGaWxlKTtcbiAgICAgIGNvbnN0IHRyID0gdGFibGV0LnRyeUdldFNuaXBwZXQodGFibGV0LnNuaXBwZXRLZXlzWzBdKTtcbiAgICAgIGV4cGVjdCh0cj8uZnFuc1JlZmVyZW5jZWQoKSkudG9FcXVhbChbJ215X2Fzc2VtYmx5LkNsYXNzQSddKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgb3RoZXJBc3NlbWJseS5jbGVhbnVwKCk7XG4gICAgfVxuICB9KTtcblxuICB0ZXN0KCd0aGVyZSBpcyBhbiBvdXREaXIgYW5kIHJvb3REaXInLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgb3V0RGlyID0gJ2pzaWktb3V0RGlyJztcbiAgICBjb25zdCByb290RGlyID0gJy4nO1xuICAgIGNvbnN0IG90aGVyQXNzZW1ibHkgPSBhd2FpdCBjcmVhdGVBc3NlbWJseVdpdGhEaXJlY3Rvcmllcyhyb290RGlyLCBvdXREaXIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXRGaWxlID0gcGF0aC5qb2luKG90aGVyQXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCAndGVzdC50YWJsLmpzb24nKTtcbiAgICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFtvdGhlckFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgICAgY2FjaGVUb0ZpbGU6IG91dHB1dEZpbGUsXG4gICAgICAgIC4uLmRlZmF1bHRFeHRyYWN0T3B0aW9ucyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0YWJsZXQgPSBhd2FpdCBMYW5ndWFnZVRhYmxldC5mcm9tRmlsZShvdXRwdXRGaWxlKTtcbiAgICAgIGNvbnN0IHRyID0gdGFibGV0LnRyeUdldFNuaXBwZXQodGFibGV0LnNuaXBwZXRLZXlzWzBdKTtcbiAgICAgIGV4cGVjdCh0cj8uZnFuc1JlZmVyZW5jZWQoKSkudG9FcXVhbChbJ215X2Fzc2VtYmx5LkNsYXNzQSddKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgb3RoZXJBc3NlbWJseS5jbGVhbnVwKCk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG50ZXN0KCdleHRyYWN0IGFuZCBpbmZ1c2UgaW4gb25lIGNvbW1hbmQnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGNhY2hlVG9GaWxlID0gcGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgJ3Rlc3QudGFibC5qc29uJyk7XG4gIGF3YWl0IGV4dHJhY3QuZXh0cmFjdEFuZEluZnVzZShbYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5XSwge1xuICAgIGNhY2hlVG9GaWxlLFxuICAgIC4uLmRlZmF1bHRFeHRyYWN0T3B0aW9ucyxcbiAgfSk7XG5cbiAgY29uc3QgdGFibGV0ID0gbmV3IExhbmd1YWdlVGFibGV0KCk7XG4gIGF3YWl0IHRhYmxldC5sb2FkKGNhY2hlVG9GaWxlKTtcblxuICAvLyBleHRyYWN0IHdvcmtzIGFzIGV4cGVjdGVkLCB3aXRoIGEgY2F2ZWF0XG4gIC8vIHRoZSBpbmZ1c2UgcGFydCBvZiB0aGlzIGNhbGwgd2lsbCByZS1pbnNlcnQgdGhlIGV4YW1wbGUgYmFja1xuICAvLyBpbnRvIHRoZSB0YWJsZXQgdW5kZXIgYSBuZXcga2V5IGFuZCBuZXcgbG9jYXRpb24uXG4gIC8vIHNvIHdlIGNvbmZpcm0gdGhhdCB0aGUgbG9jYXRpb25zIG9mIHRoZSBzbmlwcGV0cyBhcmUgYXMgZXhwZWN0ZWQuXG4gIGV4cGVjdCh0YWJsZXQuc25pcHBldEtleXMubGVuZ3RoKS50b0VxdWFsKDIpO1xuICBjb25zdCBsb2NhdGlvbnMgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIHRhYmxldC5zbmlwcGV0S2V5cykge1xuICAgIGxvY2F0aW9ucy5hZGQodGFibGV0LnRyeUdldFNuaXBwZXQoa2V5KT8uc25pcHBldC5sb2NhdGlvbi5hcGkuYXBpKTtcbiAgfVxuICBleHBlY3QobG9jYXRpb25zKS50b0NvbnRhaW4oJ3R5cGUnKTtcbiAgZXhwZWN0KGxvY2F0aW9ucykudG9Db250YWluKCdtb2R1bGVSZWFkbWUnKTtcblxuICBjb25zdCBhc3NlbWJsaWVzID0gYXdhaXQgbG9hZEFzc2VtYmxpZXMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIGZhbHNlKTtcbiAgY29uc3QgdHlwZXMgPSBhc3NlbWJsaWVzWzBdLmFzc2VtYmx5LnR5cGVzO1xuXG4gIC8vIGluZnVzZSB3b3JrcyBhcyBleHBlY3RlZFxuICBleHBlY3QodHlwZXMpLnRvQmVEZWZpbmVkKCk7XG4gIGV4cGVjdCh0eXBlcyFbJ215X2Fzc2VtYmx5LkNsYXNzQSddLmRvY3M/LmV4YW1wbGUpLnRvQmVEZWZpbmVkKCk7XG59KTtcblxuZGVzY3JpYmUoJ2luZnVzZWQgZXhhbXBsZXMnLCAoKSA9PiB7XG4gIGxldCBpbmZ1c2VkQXNzZW1ibHk6IFRlc3RKc2lpTW9kdWxlO1xuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBpbmZ1c2VkQXNzZW1ibHkgPSBhd2FpdCBUZXN0SnNpaU1vZHVsZS5mcm9tU291cmNlKFxuICAgICAge1xuICAgICAgICAnaW5kZXgudHMnOiBgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGFzc0FcbiAgICAgICAgICogXG4gICAgICAgICAqIEBleGFtcGxlTWV0YWRhdGEgaW5mdXNlZCBcbiAgICAgICAgICogQGV4YW1wbGUgeFxuICAgICAgICAgKi9cbiAgICAgICAgZXhwb3J0IGNsYXNzIENsYXNzQSB7XG4gICAgICAgICAgcHVibGljIHNvbWVNZXRob2QoKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnbXlfYXNzZW1ibHknLFxuICAgICAgICBqc2lpOiBEVU1NWV9KU0lJX0NPTkZJRyxcbiAgICAgIH0sXG4gICAgKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBpbmZ1c2VkQXNzZW1ibHkuY2xlYW51cCgpO1xuICB9KTtcblxuICB0ZXN0KCdhbHdheXMgcmV0dXJuZWQgZnJvbSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjYWNoZUZpbGUgPSBwYXRoLmpvaW4oaW5mdXNlZEFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgJ3Rlc3QudGFibC5qc29uJyk7XG5cbiAgICAvLyBDYWNoZSB0byBmaWxlXG4gICAgYXdhaXQgZXh0cmFjdC5leHRyYWN0U25pcHBldHMoW2luZnVzZWRBc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldLCB7XG4gICAgICBjYWNoZVRvRmlsZTogY2FjaGVGaWxlLFxuICAgICAgLi4uZGVmYXVsdEV4dHJhY3RPcHRpb25zLFxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBleGFtcGxlIHdpdGggYSBmaXh0dXJlIHRoYXQgd291bGQgZmFpbCBjb21waWxhdGlvblxuICAgIC8vIE5vdGhpbmcgbGlrZSB0aGlzIHNob3VsZCBoYXBwZW4gaW4gcHJhY3RpY2VcbiAgICBpbmZ1c2VkQXNzZW1ibHkuYXNzZW1ibHkudHlwZXMhWydteV9hc3NlbWJseS5DbGFzc0EnXS5kb2NzIS5jdXN0b20hLmV4YW1wbGVNZXRhZGF0YSA9XG4gICAgICAnaW5mdXNlZCBmaXh0dXJlPW15Zml4LnRzLWZpeHR1cmUnO1xuICAgIGF3YWl0IGluZnVzZWRBc3NlbWJseS51cGRhdGVBc3NlbWJseSgpO1xuXG4gICAgLy8gRXhwZWN0IHRvIHJldHVybiBjYWNoZWQgc25pcHBldCByZWdhcmRsZXNzIG9mIGNoYW5nZVxuICAgIC8vIE5vIGNvbXBpbGF0aW9uIHNob3VsZCBoYXBwZW5cbiAgICBjb25zdCB0cmFuc2xhdGlvbkZ1bmN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGlhZ25vc3RpY3M6IFtdLCB0cmFuc2xhdGVkU25pcHBldHM6IFtdIH0pO1xuICAgIGF3YWl0IGV4dHJhY3QuZXh0cmFjdFNuaXBwZXRzKFtpbmZ1c2VkQXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5XSwge1xuICAgICAgY2FjaGVGcm9tRmlsZTogY2FjaGVGaWxlLFxuICAgICAgLi4uZGVmYXVsdEV4dHJhY3RPcHRpb25zLFxuICAgICAgdHJhbnNsYXRvckZhY3Rvcnk6IChvKSA9PiBuZXcgTW9ja1RyYW5zbGF0b3IobywgdHJhbnNsYXRpb25GdW5jdGlvbiksXG4gICAgfSk7XG5cbiAgICBleHBlY3QodHJhbnNsYXRpb25GdW5jdGlvbikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgfSk7XG5cbiAgdGVzdCgnc2tpcCBsb29zZSBtb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIFJlbW92ZSBpbmZ1c2VkIGZvciBub3cgYW5kIGFkZCBsaXQgbWV0YWRhdGEgdGhhdCBzaG91bGQgZmFpbFxuICAgIGluZnVzZWRBc3NlbWJseS5hc3NlbWJseS50eXBlcyFbJ215X2Fzc2VtYmx5LkNsYXNzQSddLmRvY3MhLmN1c3RvbSEuZXhhbXBsZU1ldGFkYXRhID0gJ2xpdD1pbnRlZy50ZXN0LnRzJztcbiAgICBhd2FpdCBpbmZ1c2VkQXNzZW1ibHkudXBkYXRlQXNzZW1ibHkoKTtcblxuICAgIGNvbnN0IGNhY2hlVG9GaWxlID0gcGF0aC5qb2luKGluZnVzZWRBc3NlbWJseS5tb2R1bGVEaXJlY3RvcnksICd0ZXN0LnRhYmwuanNvbicpO1xuXG4gICAgLy8gV2l0aG91dCBleGFtcGxlTWV0YWRhdGEgaW5mdXNlZCwgZXhwZWN0IGFuIGVycm9yXG4gICAgYXdhaXQgZXhwZWN0KFxuICAgICAgZXh0cmFjdC5leHRyYWN0U25pcHBldHMoW2luZnVzZWRBc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldLCB7XG4gICAgICAgIGNhY2hlVG9GaWxlLFxuICAgICAgICAuLi5kZWZhdWx0RXh0cmFjdE9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApLnJlamVjdHMudG9UaHJvd0Vycm9yKC9TYW1wbGUgdXNlcyBsaXRlcmF0ZSBzb3VyY2UvKTtcblxuICAgIC8vIEFkZCBpbmZ1c2VkIHRvIG1ldGFkYXRhIGFuZCB1cGRhdGUgYXNzZW1ibHlcbiAgICBpbmZ1c2VkQXNzZW1ibHkuYXNzZW1ibHkudHlwZXMhWydteV9hc3NlbWJseS5DbGFzc0EnXS5kb2NzIS5jdXN0b20hLmV4YW1wbGVNZXRhZGF0YSA9ICdsaXQ9aW50ZWcudGVzdC50cyBpbmZ1c2VkJztcbiAgICBhd2FpdCBpbmZ1c2VkQXNzZW1ibHkudXBkYXRlQXNzZW1ibHkoKTtcblxuICAgIC8vIEV4cGVjdCBzYW1lIGZ1bmN0aW9uIGNhbGwgdG8gc3VjY2VlZCBub3dcbiAgICBhd2FpdCBleHRyYWN0LmV4dHJhY3RTbmlwcGV0cyhbaW5mdXNlZEFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICAgIGNhY2hlVG9GaWxlLFxuICAgICAgLi4uZGVmYXVsdEV4dHJhY3RPcHRpb25zLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdGFibGV0ID0gYXdhaXQgTGFuZ3VhZ2VUYWJsZXQuZnJvbUZpbGUoY2FjaGVUb0ZpbGUpO1xuICAgIGV4cGVjdCh0YWJsZXQuY291bnQpLnRvRXF1YWwoMSk7XG4gICAgY29uc3QgdHIgPSB0YWJsZXQudHJ5R2V0U25pcHBldCh0YWJsZXQuc25pcHBldEtleXNbMF0pO1xuICAgIGV4cGVjdCh0cj8ub3JpZ2luYWxTb3VyY2Uuc291cmNlKS50b0VxdWFsKCd4Jyk7XG4gIH0pO1xufSk7XG5cbnRlc3QoJ2luZnVzZWQgZXhhbXBsZXMgaGF2ZSBubyBkaWFnbm9zdGljcycsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgb3RoZXJBc3NlbWJseSA9IGF3YWl0IFRlc3RKc2lpTW9kdWxlLmZyb21Tb3VyY2UoXG4gICAge1xuICAgICAgJ2luZGV4LnRzJzogYFxuICAgICAgLyoqXG4gICAgICAgKiBDbGFzc0FcbiAgICAgICAqIFxuICAgICAgICogQGV4YW1wbGVNZXRhZGF0YSBpbmZ1c2VkXG4gICAgICAgKiBAZXhhbXBsZSB4XG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBjbGFzcyBDbGFzc0Ege1xuICAgICAgICBwdWJsaWMgc29tZU1ldGhvZCgpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdteV9hc3NlbWJseScsXG4gICAgICBqc2lpOiB7XG4gICAgICAgIC4uLkRVTU1ZX0pTSUlfQ09ORklHLFxuICAgICAgfSxcbiAgICB9LFxuICApO1xuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlVG9GaWxlID0gcGF0aC5qb2luKG90aGVyQXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCAndGVzdC50YWJsLmpzb24nKTtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBleHRyYWN0LmV4dHJhY3RTbmlwcGV0cyhbb3RoZXJBc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldLCB7XG4gICAgICBjYWNoZVRvRmlsZSxcbiAgICAgIGluY2x1ZGVDb21waWxlckRpYWdub3N0aWNzOiB0cnVlLFxuICAgICAgbG9vc2U6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgZXhwZWN0KHJlc3VsdHMuZGlhZ25vc3RpY3MpLnRvRXF1YWwoW10pO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IG90aGVyQXNzZW1ibHkuY2xlYW51cCgpO1xuICB9XG59KTtcblxuY2xhc3MgTW9ja1RyYW5zbGF0b3IgZXh0ZW5kcyBSb3NldHRhVHJhbnNsYXRvciB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihvcHRzOiBSb3NldHRhVHJhbnNsYXRvck9wdGlvbnMsIHRyYW5zbGF0b3JGbjogamVzdC5Nb2NrKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy50cmFuc2xhdGVBbGwgPSB0cmFuc2xhdG9yRm47XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQXNzZW1ibHlXaXRoRGlyZWN0b3JpZXMocm9vdERpcj86IHN0cmluZywgb3V0RGlyPzogc3RyaW5nKSB7XG4gIHJldHVybiBUZXN0SnNpaU1vZHVsZS5mcm9tU291cmNlKFxuICAgIHtcbiAgICAgICdpbmRleC50cyc6IGBcbiAgICAgIGV4cG9ydCBjbGFzcyBDbGFzc0Ege1xuICAgICAgICAvKipcbiAgICAgICAgICogU29tZSBtZXRob2RcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogaW1wb3J0ICogYXMgYXNzIGZyb20gJ215X2Fzc2VtYmx5JztcbiAgICAgICAgICogbmV3IGFzcy5DbGFzc0Euc29tZU1ldGhvZCgpO1xuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHNvbWVNZXRob2QoKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGAsXG4gICAgICAnUkVBRE1FLm1kJzogJycsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbXlfYXNzZW1ibHknLFxuICAgICAgbWFpbjogYCR7b3V0RGlyfS9pbmRleC5qc2AsXG4gICAgICB0eXBlczogYCR7b3V0RGlyfS9pbmRleC5kLnRzYCxcbiAgICAgIGpzaWk6IHtcbiAgICAgICAgLi4uRFVNTVlfSlNJSV9DT05GSUcsXG4gICAgICAgIHRzYzoge1xuICAgICAgICAgIG91dERpcixcbiAgICAgICAgICByb290RGlyLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICApO1xufVxuXG5mdW5jdGlvbiBib2d1c1RyYW5zbGF0ZWRTbmlwcGV0KCkge1xuICByZXR1cm4gVHJhbnNsYXRlZFNuaXBwZXQuZnJvbVR5cGVTY3JpcHQoXG4gICAgdHlwZVNjcmlwdFNuaXBwZXRGcm9tVmlzaWJsZVNvdXJjZSgnY29uc29sZS5sb2coXCJoZWxsb1wiKTsnLCB0ZXN0U25pcHBldExvY2F0aW9uKCd4LnRzJyksIHRydWUpLFxuICAgIHRydWUsXG4gICk7XG59XG4iXX0=