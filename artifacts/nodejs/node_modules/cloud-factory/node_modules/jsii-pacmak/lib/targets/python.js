"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const spec = require("@jsii/spec");
const assert = require("assert");
const codemaker_1 = require("codemaker");
const escapeStringRegexp = require("escape-string-regexp");
const fs = require("fs-extra");
const jsii_rosetta_1 = require("jsii-rosetta");
const path = require("path");
const generator_1 = require("../generator");
const logging_1 = require("../logging");
const markdown_1 = require("../markdown");
const target_1 = require("../target");
const util_1 = require("../util");
const _utils_1 = require("./_utils");
const type_name_1 = require("./python/type-name");
const util_2 = require("./python/util");
const version_utils_1 = require("./version-utils");
const _1 = require(".");
// eslint-disable-next-line @typescript-eslint/no-var-requires,@typescript-eslint/no-require-imports
const spdxLicenseList = require('spdx-license-list');
const requirementsFile = path.resolve(__dirname, 'python', 'requirements-dev.txt');
// we use single-quotes for multi-line strings to allow examples within the
// docstrings themselves to include double-quotes (see https://github.com/aws/jsii/issues/2569)
const DOCSTRING_QUOTES = "'''";
class Python extends target_1.Target {
    constructor(options) {
        super(options);
        this.generator = new PythonGenerator(options.rosetta);
    }
    async generateCode(outDir, tarball) {
        await super.generateCode(outDir, tarball);
    }
    async build(sourceDir, outDir) {
        // Create a fresh virtual env
        const venv = await fs.mkdtemp(path.join(sourceDir, '.env-'));
        const venvBin = path.join(venv, process.platform === 'win32' ? 'Scripts' : 'bin');
        await util_1.shell('python3', [
            '-m',
            'venv',
            '--system-site-packages',
            venv,
        ]);
        const env = {
            ...process.env,
            PATH: `${venvBin}:${process.env.PATH}`,
            VIRTUAL_ENV: venv,
        };
        const python = path.join(venvBin, 'python');
        // Install the necessary things
        await util_1.shell(python, ['-m', 'pip', 'install', '--no-input', '-r', requirementsFile], {
            cwd: sourceDir,
            env,
            retry: { maxAttempts: 5 },
        });
        // Actually package up our code, both as a sdist and a wheel for publishing.
        await util_1.shell(python, ['setup.py', 'sdist', '--dist-dir', outDir], {
            cwd: sourceDir,
            env,
        });
        await util_1.shell(python, ['-m', 'pip', 'wheel', '--no-deps', '--wheel-dir', outDir, sourceDir], {
            cwd: sourceDir,
            env,
            retry: { maxAttempts: 5 },
        });
        await util_1.shell(python, ['-m', 'twine', 'check', path.join(outDir, '*')], {
            cwd: sourceDir,
            env,
        });
    }
}
exports.default = Python;
const pythonModuleNameToFilename = (name) => {
    return path.join(...name.split('.'));
};
const toPythonMethodName = (name, protectedItem = false) => {
    let value = util_2.toPythonIdentifier(codemaker_1.toSnakeCase(name));
    if (protectedItem) {
        value = `_${value}`;
    }
    return value;
};
const toPythonPropertyName = (name, constant = false, protectedItem = false) => {
    let value = util_2.toPythonIdentifier(codemaker_1.toSnakeCase(name));
    if (constant) {
        value = value.toUpperCase();
    }
    if (protectedItem) {
        value = `_${value}`;
    }
    return value;
};
/**
 * Converts a given signature's parameter name to what should be emitted in Python. It slugifies the
 * positional parameter names that collide with a lifted prop by appending trailing `_`. There is no
 * risk of conflicting with an other positional parameter that ends with a `_` character because
 * this is prohibited by the `jsii` compiler (parameter names MUST be camelCase, and only a single
 * `_` is permitted when it is on **leading** position)
 *
 * @param name              the name of the parameter that needs conversion.
 * @param liftedParamNames  the list of "lifted" keyword parameters in this signature. This must be
 *                          omitted when generating a name for a parameter that **is** lifted.
 */
function toPythonParameterName(name, liftedParamNames = new Set()) {
    let result = util_2.toPythonIdentifier(codemaker_1.toSnakeCase(name));
    while (liftedParamNames.has(result)) {
        result += '_';
    }
    return result;
}
const setDifference = (setA, setB) => {
    const result = new Set();
    for (const item of setA) {
        if (!setB.has(item)) {
            result.add(item);
        }
    }
    return result;
};
/**
 * Prepare python members for emission.
 *
 * If there are multiple members of the same name, they will all map to the same python
 * name, so we will filter all deprecated members and expect that there will be only one
 * left.
 *
 * Returns the members in a sorted list.
 */
function prepareMembers(members, resolver) {
    // create a map from python name to list of members
    const map = {};
    for (const m of members) {
        let list = map[m.pythonName];
        if (!list) {
            list = map[m.pythonName] = [];
        }
        list.push(m);
    }
    // now return all the members
    const ret = new Array();
    for (const [name, list] of Object.entries(map)) {
        let member;
        if (list.length === 1) {
            // if we have a single member for this normalized name, then use it
            member = list[0];
        }
        else {
            // we found more than one member with the same python name, filter all
            // deprecated versions and check that we are left with exactly one.
            // otherwise, they will overwrite each other
            // see https://github.com/aws/jsii/issues/2508
            const nonDeprecated = list.filter((x) => !isDeprecated(x));
            if (nonDeprecated.length > 1) {
                throw new Error(`Multiple non-deprecated members which map to the Python name "${name}"`);
            }
            if (nonDeprecated.length === 0) {
                throw new Error(`Multiple members which map to the Python name "${name}", but all of them are deprecated`);
            }
            member = nonDeprecated[0];
        }
        ret.push(member);
    }
    return sortMembers(ret, resolver);
}
const sortMembers = (members, resolver) => {
    let sortable = new Array();
    const sorted = new Array();
    const seen = new Set();
    // The first thing we want to do, is push any item which is not sortable to the very
    // front of the list. This will be things like methods, properties, etc.
    for (const member of members) {
        if (!isSortableType(member)) {
            sorted.push(member);
            seen.add(member);
        }
        else {
            sortable.push({ member, dependsOn: new Set(member.dependsOn(resolver)) });
        }
    }
    // Now that we've pulled out everything that couldn't possibly have dependencies,
    // we will go through the remaining items, and pull off any items which have no
    // dependencies that we haven't already sorted.
    while (sortable.length > 0) {
        for (const { member, dependsOn } of sortable) {
            const diff = setDifference(dependsOn, seen);
            if ([...diff].find((dep) => !(dep instanceof PythonModule)) == null) {
                sorted.push(member);
                seen.add(member);
            }
        }
        const leftover = sortable.filter(({ member }) => !seen.has(member));
        if (leftover.length === sortable.length) {
            throw new Error(`Could not sort members (circular dependency?). Leftover: ${leftover
                .map((lo) => lo.member.pythonName)
                .join(', ')}`);
        }
        else {
            sortable = leftover;
        }
    }
    return sorted;
};
function isSortableType(arg) {
    return arg.dependsOn !== undefined;
}
class BasePythonClassType {
    constructor(generator, pythonName, spec, fqn, opts, docs) {
        this.generator = generator;
        this.pythonName = pythonName;
        this.spec = spec;
        this.fqn = fqn;
        this.docs = docs;
        this.separateMembers = true;
        const { bases = [] } = opts;
        this.bases = bases;
        this.members = [];
    }
    dependsOn(resolver) {
        const dependencies = new Array();
        const parent = resolver.getParent(this.fqn);
        // We need to return any bases that are in the same module at the same level of
        // nesting.
        const seen = new Set();
        for (const base of this.bases) {
            if (spec.isNamedTypeReference(base)) {
                if (resolver.isInModule(base)) {
                    // Given a base, we need to locate the base's parent that is the same as
                    // our parent, because we only care about dependencies that are at the
                    // same level of our own.
                    // TODO: We might need to recurse into our members to also find their
                    //       dependencies.
                    let baseItem = resolver.getType(base);
                    let baseParent = resolver.getParent(base);
                    while (baseParent !== parent) {
                        baseItem = baseParent;
                        baseParent = resolver.getParent(baseItem.fqn);
                    }
                    if (!seen.has(baseItem.fqn)) {
                        dependencies.push(baseItem);
                        seen.add(baseItem.fqn);
                    }
                }
            }
        }
        return dependencies;
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(...this.bases.map((base) => type_name_1.toTypeName(base).requiredImports(context)), ...this.members.map((mem) => mem.requiredImports(context)));
    }
    addMember(member) {
        this.members.push(member);
    }
    get apiLocation() {
        if (!this.fqn) {
            throw new Error(`Cannot make apiLocation for ${this.pythonName}, does not have FQN`);
        }
        return { api: 'type', fqn: this.fqn };
    }
    emit(code, context) {
        context = nestedContext(context, this.fqn);
        const classParams = this.getClassParams(context);
        openSignature(code, 'class', this.pythonName, classParams);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `class-${this.pythonName}`,
            trailingNewLine: true,
        });
        if (this.members.length > 0) {
            const resolver = this.boundResolver(context.resolver);
            let shouldSeparate = false;
            for (const member of prepareMembers(this.members, resolver)) {
                if (shouldSeparate) {
                    code.line();
                }
                shouldSeparate = this.separateMembers;
                member.emit(code, { ...context, resolver });
            }
        }
        else {
            code.line('pass');
        }
        code.closeBlock();
        if (this.fqn != null) {
            context.emittedTypes.add(this.fqn);
        }
    }
    boundResolver(resolver) {
        if (this.fqn == null) {
            return resolver;
        }
        return resolver.bind(this.fqn);
    }
}
class BaseMethod {
    constructor(generator, pythonName, jsName, parameters, returns, docs, isStatic, opts) {
        this.generator = generator;
        this.pythonName = pythonName;
        this.jsName = jsName;
        this.parameters = parameters;
        this.returns = returns;
        this.docs = docs;
        this.isStatic = isStatic;
        this.classAsFirstParameter = false;
        this.returnFromJSIIMethod = true;
        this.shouldEmitBody = true;
        this.abstract = !!opts.abstract;
        this.liftedProp = opts.liftedProp;
        this.parent = opts.parent;
    }
    get apiLocation() {
        var _a;
        return {
            api: 'member',
            fqn: this.parent.fqn,
            memberName: (_a = this.jsName) !== null && _a !== void 0 ? _a : '',
        };
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(type_name_1.toTypeName(this.returns).requiredImports(context), ...this.parameters.map((param) => type_name_1.toTypeName(param).requiredImports(context)), ...liftedProperties(this.liftedProp));
        function* liftedProperties(struct) {
            var _a, _b;
            if (struct == null) {
                return;
            }
            for (const prop of (_a = struct.properties) !== null && _a !== void 0 ? _a : []) {
                yield type_name_1.toTypeName(prop.type).requiredImports(context);
            }
            for (const base of (_b = struct.interfaces) !== null && _b !== void 0 ? _b : []) {
                const iface = context.resolver.dereference(base);
                for (const imports of liftedProperties(iface)) {
                    yield imports;
                }
            }
        }
    }
    emit(code, context, opts) {
        var _a;
        const { renderAbstract = true, forceEmitBody = false } = opts !== null && opts !== void 0 ? opts : {};
        const returnType = type_name_1.toTypeName(this.returns).pythonType(context);
        // We cannot (currently?) blindly use the names given to us by the JSII for
        // initializers, because our keyword lifting will allow two names to clash.
        // This can hopefully be removed once we get https://github.com/aws/jsii/issues/288
        // resolved, so build up a list of all of the prop names so we can check against
        // them later.
        const liftedPropNames = new Set();
        if (((_a = this.liftedProp) === null || _a === void 0 ? void 0 : _a.properties) != null) {
            for (const prop of this.liftedProp.properties) {
                liftedPropNames.add(toPythonParameterName(prop.name));
            }
        }
        // We need to turn a list of JSII parameters, into Python style arguments with
        // gradual typing, so we'll have to iterate over the list of parameters, and
        // build the list, converting as we go.
        const pythonParams = [];
        for (const param of this.parameters) {
            // We cannot (currently?) blindly use the names given to us by the JSII for
            // initializers, because our keyword lifting will allow two names to clash.
            // This can hopefully be removed once we get https://github.com/aws/jsii/issues/288
            // resolved.
            const paramName = toPythonParameterName(param.name, liftedPropNames);
            const paramType = type_name_1.toTypeName(param).pythonType({
                ...context,
                parameterType: true,
            });
            const paramDefault = param.optional ? ' = None' : '';
            pythonParams.push(`${paramName}: ${paramType}${paramDefault}`);
        }
        const documentableArgs = this.parameters
            .map((p) => ({
            name: p.name,
            docs: p.docs,
            definingType: this.parent,
        }))
            // If there's liftedProps, the last argument is the struct and it won't be _actually_ emitted.
            .filter((_, index) => this.liftedProp != null ? index < this.parameters.length - 1 : true)
            .map((param) => ({
            ...param,
            name: toPythonParameterName(param.name, liftedPropNames),
        }));
        // If we have a lifted parameter, then we'll drop the last argument to our params
        // and then we'll lift all of the params of the lifted type as keyword arguments
        // to the function.
        if (this.liftedProp !== undefined) {
            // Remove our last item.
            pythonParams.pop();
            const liftedProperties = this.getLiftedProperties(context.resolver);
            if (liftedProperties.length >= 1) {
                // All of these parameters are keyword only arguments, so we'll mark them
                // as such.
                pythonParams.push('*');
                // Iterate over all of our props, and reflect them into our params.
                for (const prop of liftedProperties) {
                    const paramName = toPythonParameterName(prop.prop.name);
                    const paramType = type_name_1.toTypeName(prop.prop).pythonType({
                        ...context,
                        parameterType: true,
                    });
                    const paramDefault = prop.prop.optional ? ' = None' : '';
                    pythonParams.push(`${paramName}: ${paramType}${paramDefault}`);
                }
            }
            // Document them as keyword arguments
            documentableArgs.push(...liftedProperties.map((p) => ({
                name: p.prop.name,
                docs: p.prop.docs,
                definingType: p.definingType,
            })));
        }
        else if (this.parameters.length >= 1 &&
            this.parameters[this.parameters.length - 1].variadic) {
            // Another situation we could be in, is that instead of having a plain parameter
            // we have a variadic parameter where we need to expand the last parameter as a
            // *args.
            pythonParams.pop();
            const lastParameter = this.parameters.slice(-1)[0];
            const paramName = toPythonParameterName(lastParameter.name);
            const paramType = type_name_1.toTypeName(lastParameter.type).pythonType(context);
            pythonParams.push(`*${paramName}: ${paramType}`);
        }
        const decorators = new Array();
        if (this.jsName !== undefined) {
            // "# type: ignore[misc]" needed because mypy does not know how to check decorated declarations
            decorators.push(`@jsii.member(jsii_name="${this.jsName}")`);
        }
        if (this.decorator !== undefined) {
            decorators.push(`@${this.decorator}`);
        }
        if (renderAbstract && this.abstract) {
            decorators.push('@abc.abstractmethod');
        }
        if (decorators.length > 0) {
            // "# type: ignore[misc]" needed because mypy does not know how to check decorated declarations
            for (const decorator of decorators
                .join(' # type: ignore[misc]\n')
                .split('\n')) {
                code.line(decorator);
            }
        }
        pythonParams.unshift(slugifyAsNeeded(this.implicitParameter, pythonParams.map((param) => param.split(':')[0].trim())));
        openSignature(code, 'def', this.pythonName, pythonParams, false, returnType);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            arguments: documentableArgs,
            documentableItem: `method-${this.pythonName}`,
        });
        this.emitBody(code, context, renderAbstract, forceEmitBody, liftedPropNames, pythonParams[0], returnType);
        code.closeBlock();
    }
    emitBody(code, context, renderAbstract, forceEmitBody, liftedPropNames, implicitParameter, returnType) {
        if ((!this.shouldEmitBody && !forceEmitBody) ||
            (renderAbstract && this.abstract)) {
            code.line('...');
        }
        else {
            if (this.liftedProp !== undefined) {
                this.emitAutoProps(code, context, liftedPropNames);
            }
            this.emitJsiiMethodCall(code, context, liftedPropNames, implicitParameter, returnType);
        }
    }
    emitAutoProps(code, context, liftedPropNames) {
        const lastParameter = this.parameters.slice(-1)[0];
        const argName = toPythonParameterName(lastParameter.name, liftedPropNames);
        const typeName = type_name_1.toTypeName(lastParameter.type).pythonType({
            ...context,
            typeAnnotation: false,
        });
        // We need to build up a list of properties, which are mandatory, these are the
        // ones we will specifiy to start with in our dictionary literal.
        const liftedProps = this.getLiftedProperties(context.resolver).map((p) => new StructField(this.generator, p.prop, p.definingType));
        const assignments = liftedProps
            .map((p) => p.pythonName)
            .map((v) => `${v}=${v}`);
        assignCallResult(code, argName, typeName, assignments);
        code.line();
    }
    emitJsiiMethodCall(code, context, liftedPropNames, implicitParameter, returnType) {
        const methodPrefix = this.returnFromJSIIMethod ? 'return ' : '';
        const jsiiMethodParams = [];
        if (this.classAsFirstParameter) {
            if (this.parent === undefined) {
                throw new Error('Parent not known.');
            }
            if (this.isStatic) {
                jsiiMethodParams.push(type_name_1.toTypeName(this.parent).pythonType({
                    ...context,
                    typeAnnotation: false,
                }));
            }
            else {
                // Using the dynamic class of `self`.
                jsiiMethodParams.push(`${implicitParameter}.__class__`);
            }
        }
        jsiiMethodParams.push(implicitParameter);
        if (this.jsName !== undefined) {
            jsiiMethodParams.push(`"${this.jsName}"`);
        }
        // If the last arg is variadic, expand the tuple
        const params = [];
        for (const param of this.parameters) {
            let expr = toPythonParameterName(param.name, liftedPropNames);
            if (param.variadic) {
                expr = `*${expr}`;
            }
            params.push(expr);
        }
        const value = `jsii.${this.jsiiMethod}(${jsiiMethodParams.join(', ')}, [${params.join(', ')}])`;
        code.line(`${methodPrefix}${this.returnFromJSIIMethod && returnType
            ? `typing.cast(${returnType}, ${value})`
            : value}`);
    }
    getLiftedProperties(resolver) {
        const liftedProperties = [];
        const stack = [this.liftedProp];
        const knownIfaces = new Set();
        const knownProps = new Set();
        for (let current = stack.shift(); current != null; current = stack.shift()) {
            knownIfaces.add(current.fqn);
            // Add any interfaces that this interface depends on, to the list.
            if (current.interfaces !== undefined) {
                for (const iface of current.interfaces) {
                    if (knownIfaces.has(iface)) {
                        continue;
                    }
                    stack.push(resolver.dereference(iface));
                    knownIfaces.add(iface);
                }
            }
            // Add all of the properties of this interface to our list of properties.
            if (current.properties !== undefined) {
                for (const prop of current.properties) {
                    if (knownProps.has(prop.name)) {
                        continue;
                    }
                    liftedProperties.push({ prop, definingType: current });
                    knownProps.add(prop.name);
                }
            }
        }
        return liftedProperties;
    }
}
class BaseProperty {
    constructor(generator, pythonName, jsName, type, docs, opts) {
        this.generator = generator;
        this.pythonName = pythonName;
        this.jsName = jsName;
        this.type = type;
        this.docs = docs;
        this.shouldEmitBody = true;
        const { abstract = false, immutable = false, isStatic = false } = opts;
        this.abstract = abstract;
        this.immutable = immutable;
        this.isStatic = isStatic;
        this.parent = opts.parent;
    }
    get apiLocation() {
        return { api: 'member', fqn: this.parent.fqn, memberName: this.jsName };
    }
    requiredImports(context) {
        return type_name_1.toTypeName(this.type).requiredImports(context);
    }
    emit(code, context, opts) {
        const { renderAbstract = true, forceEmitBody = false } = opts !== null && opts !== void 0 ? opts : {};
        const pythonType = type_name_1.toTypeName(this.type).pythonType(context);
        // "# type: ignore[misc]" is needed because mypy cannot check decorated things
        code.line(`@${this.decorator} # type: ignore[misc]`);
        code.line(`@jsii.member(jsii_name="${this.jsName}")`);
        if (renderAbstract && this.abstract) {
            code.line('@abc.abstractmethod');
        }
        openSignature(code, 'def', this.pythonName, [this.implicitParameter], true, pythonType);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `prop-${this.pythonName}`,
        });
        if ((this.shouldEmitBody || forceEmitBody) &&
            (!renderAbstract || !this.abstract)) {
            code.line(`return typing.cast(${pythonType}, jsii.${this.jsiiGetMethod}(${this.implicitParameter}, "${this.jsName}"))`);
        }
        else {
            code.line('...');
        }
        code.closeBlock();
        if (!this.immutable) {
            code.line();
            code.line(`@${this.pythonName}.setter${this.isStatic ? ' # type: ignore[no-redef]' : ''}`);
            if (renderAbstract && this.abstract) {
                code.line('@abc.abstractmethod');
            }
            openSignature(code, 'def', this.pythonName, [this.implicitParameter, `value: ${pythonType}`], false, 'None');
            if ((this.shouldEmitBody || forceEmitBody) &&
                (!renderAbstract || !this.abstract)) {
                code.line(`jsii.${this.jsiiSetMethod}(${this.implicitParameter}, "${this.jsName}", value)`);
            }
            else {
                code.line('...');
            }
            code.closeBlock();
        }
    }
}
class Interface extends BasePythonClassType {
    emit(code, context) {
        context = nestedContext(context, this.fqn);
        emitList(code, '@jsii.interface(', [`jsii_type="${this.fqn}"`], ')');
        // First we do our normal class logic for emitting our members.
        super.emit(code, context);
        code.line();
        code.line();
        // Then, we have to emit a Proxy class which implements our proxy interface.
        const proxyBases = this.bases.map((b) => 
        // "# type: ignore[misc]" because MyPy cannot check dynamic base classes (naturally)
        `jsii.proxy_for(${type_name_1.toTypeName(b).pythonType({
            ...context,
            typeAnnotation: false,
        })}) # type: ignore[misc]`);
        openSignature(code, 'class', this.proxyClassName, proxyBases);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `class-${this.pythonName}`,
            trailingNewLine: true,
        });
        code.line(`__jsii_type__: typing.ClassVar[str] = "${this.fqn}"`);
        if (this.members.length > 0) {
            for (const member of this.members) {
                if (this.separateMembers) {
                    code.line();
                }
                member.emit(code, context, { forceEmitBody: true });
            }
        }
        else {
            code.line('pass');
        }
        code.closeBlock();
        code.line();
        code.line('# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface');
        code.line(`typing.cast(typing.Any, ${this.pythonName}).__jsii_proxy_class__ = lambda : ${this.proxyClassName}`);
        if (this.fqn != null) {
            context.emittedTypes.add(this.fqn);
        }
    }
    getClassParams(context) {
        const params = this.bases.map((b) => type_name_1.toTypeName(b).pythonType({ ...context, typeAnnotation: false }));
        params.push('typing_extensions.Protocol');
        return params;
    }
    get proxyClassName() {
        return `_${this.pythonName}Proxy`;
    }
}
class InterfaceMethod extends BaseMethod {
    constructor() {
        super(...arguments);
        this.implicitParameter = 'self';
        this.jsiiMethod = 'invoke';
        this.shouldEmitBody = false;
    }
}
class InterfaceProperty extends BaseProperty {
    constructor() {
        super(...arguments);
        this.decorator = 'builtins.property';
        this.implicitParameter = 'self';
        this.jsiiGetMethod = 'get';
        this.jsiiSetMethod = 'set';
        this.shouldEmitBody = false;
    }
}
class Struct extends BasePythonClassType {
    constructor() {
        super(...arguments);
        this.directMembers = new Array();
    }
    addMember(member) {
        if (!(member instanceof StructField)) {
            throw new Error('Must add StructField to Struct');
        }
        this.directMembers.push(member);
    }
    emit(code, context) {
        context = nestedContext(context, this.fqn);
        const baseInterfaces = this.getClassParams(context);
        code.indent('@jsii.data_type(');
        code.line(`jsii_type=${JSON.stringify(this.fqn)},`);
        emitList(code, 'jsii_struct_bases=[', baseInterfaces, '],');
        assignDictionary(code, 'name_mapping', this.propertyMap(), ',', true);
        code.unindent(')');
        openSignature(code, 'class', this.pythonName, baseInterfaces);
        this.emitConstructor(code, context);
        for (const member of this.allMembers) {
            code.line();
            this.emitGetter(member, code, context);
        }
        this.emitMagicMethods(code);
        code.closeBlock();
        if (this.fqn != null) {
            context.emittedTypes.add(this.fqn);
        }
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(super.requiredImports(context), ...this.allMembers.map((mem) => mem.requiredImports(context)));
    }
    getClassParams(context) {
        return this.bases.map((b) => type_name_1.toTypeName(b).pythonType({ ...context, typeAnnotation: false }));
    }
    /**
     * Find all fields (inherited as well)
     */
    get allMembers() {
        return this.thisInterface.allProperties.map((x) => new StructField(this.generator, x.spec, x.definingType.spec));
    }
    get thisInterface() {
        if (this.fqn == null) {
            throw new Error('FQN not set');
        }
        return this.generator.reflectAssembly.system.findInterface(this.fqn);
    }
    emitConstructor(code, context) {
        const members = this.allMembers;
        const kwargs = members.map((m) => m.constructorDecl(context));
        const implicitParameter = slugifyAsNeeded('self', members.map((m) => m.pythonName));
        const constructorArguments = kwargs.length > 0
            ? [implicitParameter, '*', ...kwargs]
            : [implicitParameter];
        openSignature(code, 'def', '__init__', constructorArguments, false, 'None');
        this.emitConstructorDocstring(code);
        // Re-type struct arguments that were passed as "dict"
        for (const member of members.filter((m) => m.isStruct(this.generator))) {
            // Note that "None" is NOT an instance of dict (that's convenient!)
            const typeName = type_name_1.toTypeName(member.type.type).pythonType({
                ...context,
                typeAnnotation: false,
            });
            code.openBlock(`if isinstance(${member.pythonName}, dict)`);
            code.line(`${member.pythonName} = ${typeName}(**${member.pythonName})`);
            code.closeBlock();
        }
        // Required properties, those will always be put into the dict
        assignDictionary(code, `${implicitParameter}._values: typing.Dict[str, typing.Any]`, members
            .filter((m) => !m.optional)
            .map((member) => `${JSON.stringify(member.pythonName)}: ${member.pythonName}`));
        // Optional properties, will only be put into the dict if they're not None
        for (const member of members.filter((m) => m.optional)) {
            code.openBlock(`if ${member.pythonName} is not None`);
            code.line(`${implicitParameter}._values["${member.pythonName}"] = ${member.pythonName}`);
            code.closeBlock();
        }
        code.closeBlock();
    }
    emitConstructorDocstring(code) {
        const args = this.allMembers.map((m) => ({
            name: m.pythonName,
            docs: m.docs,
            definingType: this.spec,
        }));
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            arguments: args,
            documentableItem: `class-${this.pythonName}`,
        });
    }
    emitGetter(member, code, context) {
        const pythonType = member.typeAnnotation(context);
        code.line('@builtins.property');
        openSignature(code, 'def', member.pythonName, ['self'], true, pythonType);
        member.emitDocString(code);
        code.line(`result = self._values.get(${JSON.stringify(member.pythonName)})`);
        if (!member.optional) {
            // Add an assertion to maye MyPY happy!
            code.line(`assert result is not None, "Required property '${member.pythonName}' is missing"`);
        }
        code.line(`return typing.cast(${pythonType}, result)`);
        code.closeBlock();
    }
    emitMagicMethods(code) {
        code.line();
        code.openBlock('def __eq__(self, rhs: typing.Any) -> builtins.bool');
        code.line('return isinstance(rhs, self.__class__) and rhs._values == self._values');
        code.closeBlock();
        code.line();
        code.openBlock('def __ne__(self, rhs: typing.Any) -> builtins.bool');
        code.line('return not (rhs == self)');
        code.closeBlock();
        code.line();
        code.openBlock('def __repr__(self) -> str');
        code.indent(`return "${this.pythonName}(%s)" % ", ".join(`);
        code.line('k + "=" + repr(v) for k, v in self._values.items()');
        code.unindent(')');
        code.closeBlock();
    }
    propertyMap() {
        const ret = new Array();
        for (const member of this.allMembers) {
            ret.push(`${JSON.stringify(member.pythonName)}: ${JSON.stringify(member.jsiiName)}`);
        }
        return ret;
    }
}
class StructField {
    constructor(generator, prop, definingType) {
        this.generator = generator;
        this.prop = prop;
        this.definingType = definingType;
        this.pythonName = toPythonPropertyName(prop.name);
        this.jsiiName = prop.name;
        this.type = prop;
        this.docs = prop.docs;
    }
    get apiLocation() {
        return {
            api: 'member',
            fqn: this.definingType.fqn,
            memberName: this.jsiiName,
        };
    }
    get optional() {
        return !!this.type.optional;
    }
    requiredImports(context) {
        return type_name_1.toTypeName(this.type).requiredImports(context);
    }
    isStruct(generator) {
        return isStruct(generator.reflectAssembly.system, this.type.type);
    }
    constructorDecl(context) {
        const opt = this.optional ? ' = None' : '';
        return `${this.pythonName}: ${this.typeAnnotation({
            ...context,
            parameterType: true,
        })}${opt}`;
    }
    /**
     * Return the Python type annotation for this type
     */
    typeAnnotation(context) {
        return type_name_1.toTypeName(this.type).pythonType(context);
    }
    emitDocString(code) {
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `prop-${this.pythonName}`,
        });
    }
    emit(code, context) {
        const resolvedType = this.typeAnnotation(context);
        code.line(`${this.pythonName}: ${resolvedType}`);
        this.emitDocString(code);
    }
}
class Class extends BasePythonClassType {
    constructor(generator, name, spec, fqn, opts, docs) {
        super(generator, name, spec, fqn, opts, docs);
        const { abstract = false, interfaces = [], abstractBases = [] } = opts;
        this.abstract = abstract;
        this.interfaces = interfaces;
        this.abstractBases = abstractBases;
    }
    dependsOn(resolver) {
        const dependencies = super.dependsOn(resolver);
        const parent = resolver.getParent(this.fqn);
        // We need to return any ifaces that are in the same module at the same level of
        // nesting.
        const seen = new Set();
        for (const iface of this.interfaces) {
            if (resolver.isInModule(iface)) {
                // Given a iface, we need to locate the ifaces's parent that is the same
                // as our parent, because we only care about dependencies that are at the
                // same level of our own.
                // TODO: We might need to recurse into our members to also find their
                //       dependencies.
                let ifaceItem = resolver.getType(iface);
                let ifaceParent = resolver.getParent(iface);
                while (ifaceParent !== parent) {
                    ifaceItem = ifaceParent;
                    ifaceParent = resolver.getParent(ifaceItem.fqn);
                }
                if (!seen.has(ifaceItem.fqn)) {
                    dependencies.push(ifaceItem);
                    seen.add(ifaceItem.fqn);
                }
            }
        }
        return dependencies;
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(super.requiredImports(context), // Takes care of base & members
        ...this.interfaces.map((base) => type_name_1.toTypeName(base).requiredImports(context)));
    }
    emit(code, context) {
        // First we emit our implments decorator
        if (this.interfaces.length > 0) {
            const interfaces = this.interfaces.map((b) => type_name_1.toTypeName(b).pythonType({ ...context, typeAnnotation: false }));
            code.line(`@jsii.implements(${interfaces.join(', ')})`);
        }
        // Then we do our normal class logic for emitting our members.
        super.emit(code, context);
        // Then, if our class is Abstract, we have to go through and redo all of
        // this logic, except only emiting abstract methods and properties as non
        // abstract, and subclassing our initial class.
        if (this.abstract) {
            context = nestedContext(context, this.fqn);
            const proxyBases = [this.pythonName];
            for (const base of this.abstractBases) {
                // "# type: ignore[misc]" because MyPy cannot check dynamic base classes (naturally)
                proxyBases.push(`jsii.proxy_for(${type_name_1.toTypeName(base).pythonType({
                    ...context,
                    typeAnnotation: false,
                })}) # type: ignore[misc]`);
            }
            code.line();
            code.line();
            openSignature(code, 'class', this.proxyClassName, proxyBases);
            // Filter our list of members to *only* be abstract members, and not any
            // other types.
            const abstractMembers = this.members.filter((m) => (m instanceof BaseMethod || m instanceof BaseProperty) && m.abstract);
            if (abstractMembers.length > 0) {
                let first = true;
                for (const member of abstractMembers) {
                    if (this.separateMembers) {
                        if (first) {
                            first = false;
                        }
                        else {
                            code.line();
                        }
                    }
                    member.emit(code, context, { renderAbstract: false });
                }
            }
            else {
                code.line('pass');
            }
            code.closeBlock();
            code.line();
            code.line('# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class');
            code.line(`typing.cast(typing.Any, ${this.pythonName}).__jsii_proxy_class__ = lambda : ${this.proxyClassName}`);
        }
    }
    getClassParams(context) {
        const params = this.bases.map((b) => type_name_1.toTypeName(b).pythonType({ ...context, typeAnnotation: false }));
        const metaclass = this.abstract ? 'JSIIAbstractClass' : 'JSIIMeta';
        params.push(`metaclass=jsii.${metaclass}`);
        params.push(`jsii_type="${this.fqn}"`);
        return params;
    }
    get proxyClassName() {
        return `_${this.pythonName}Proxy`;
    }
}
class StaticMethod extends BaseMethod {
    constructor() {
        super(...arguments);
        this.decorator = 'builtins.classmethod';
        this.implicitParameter = 'cls';
        this.jsiiMethod = 'sinvoke';
    }
}
class Initializer extends BaseMethod {
    constructor() {
        super(...arguments);
        this.implicitParameter = 'self';
        this.jsiiMethod = 'create';
        this.classAsFirstParameter = true;
        this.returnFromJSIIMethod = false;
    }
}
class Method extends BaseMethod {
    constructor() {
        super(...arguments);
        this.implicitParameter = 'self';
        this.jsiiMethod = 'invoke';
    }
}
class AsyncMethod extends BaseMethod {
    constructor() {
        super(...arguments);
        this.implicitParameter = 'self';
        this.jsiiMethod = 'ainvoke';
    }
}
class StaticProperty extends BaseProperty {
    constructor() {
        super(...arguments);
        this.decorator = 'jsii.python.classproperty';
        this.implicitParameter = 'cls';
        this.jsiiGetMethod = 'sget';
        this.jsiiSetMethod = 'sset';
    }
}
class Property extends BaseProperty {
    constructor() {
        super(...arguments);
        this.decorator = 'builtins.property';
        this.implicitParameter = 'self';
        this.jsiiGetMethod = 'get';
        this.jsiiSetMethod = 'set';
    }
}
class Enum extends BasePythonClassType {
    constructor() {
        super(...arguments);
        this.separateMembers = false;
    }
    emit(code, context) {
        context = nestedContext(context, this.fqn);
        emitList(code, '@jsii.enum(', [`jsii_type="${this.fqn}"`], ')');
        return super.emit(code, context);
    }
    getClassParams(_context) {
        return ['enum.Enum'];
    }
    requiredImports(context) {
        return super.requiredImports(context);
    }
}
class EnumMember {
    constructor(generator, pythonName, value, docs, parent) {
        this.generator = generator;
        this.pythonName = pythonName;
        this.value = value;
        this.docs = docs;
        this.parent = parent;
        this.pythonName = pythonName;
        this.value = value;
    }
    get apiLocation() {
        return { api: 'member', fqn: this.parent.fqn, memberName: this.value };
    }
    dependsOnModules() {
        return new Set();
    }
    emit(code, _context) {
        code.line(`${this.pythonName} = "${this.value}"`);
        this.generator.emitDocString(code, this.apiLocation, this.docs, {
            documentableItem: `enum-${this.pythonName}`,
        });
    }
    requiredImports(_context) {
        return {};
    }
}
/**
 * Python module
 *
 * Will be called for jsii submodules and namespaces.
 */
class PythonModule {
    constructor(pythonName, fqn, opts) {
        this.pythonName = pythonName;
        this.fqn = fqn;
        this.members = new Array();
        this.modules = new Array();
        this.assembly = opts.assembly;
        this.assemblyFilename = opts.assemblyFilename;
        this.loadAssembly = !!opts.loadAssembly;
        this.moduleDocumentation = opts.moduleDocumentation;
    }
    addMember(member) {
        this.members.push(member);
    }
    addPythonModule(pyMod) {
        assert(!this.loadAssembly, 'PythonModule.addPythonModule CANNOT be called on assembly-loading modules (it would cause a load cycle)!');
        this.modules.push(pyMod);
    }
    requiredImports(context) {
        return type_name_1.mergePythonImports(...this.members.map((mem) => mem.requiredImports(context)));
    }
    emit(code, context) {
        var _a;
        this.emitModuleDocumentation(code);
        const resolver = this.fqn
            ? context.resolver.bind(this.fqn, this.pythonName)
            : context.resolver;
        context = {
            ...context,
            submodule: (_a = this.fqn) !== null && _a !== void 0 ? _a : context.submodule,
            resolver,
        };
        // Before we write anything else, we need to write out our module headers, this
        // is where we handle stuff like imports, any required initialization, etc.
        code.line('import abc');
        code.line('import builtins');
        code.line('import datetime');
        code.line('import enum');
        code.line('import typing');
        code.line();
        code.line('import jsii');
        code.line('import publication');
        code.line('import typing_extensions');
        // Determine if we need to write out the kernel load line.
        if (this.loadAssembly) {
            this.emitDependencyImports(code);
            code.line();
            emitList(code, '__jsii_assembly__ = jsii.JSIIAssembly.load(', [
                JSON.stringify(this.assembly.name),
                JSON.stringify(this.assembly.version),
                '__name__[0:-6]',
                `${JSON.stringify(this.assemblyFilename)}`,
            ], ')');
        }
        else {
            // Then we must import the ._jsii subpackage.
            code.line();
            let distanceFromRoot = 0;
            for (let curr = this.fqn; curr !== this.assembly.name; curr = curr.substring(0, curr.lastIndexOf('.'))) {
                distanceFromRoot++;
            }
            code.line(`from ${'.'.repeat(distanceFromRoot + 1)}_jsii import *`);
            this.emitRequiredImports(code, context);
        }
        // Emit all of our members.
        for (const member of prepareMembers(this.members, resolver)) {
            code.line();
            code.line();
            member.emit(code, context);
        }
        // Whatever names we've exported, we'll write out our __all__ that lists them.
        const exportedMembers = this.members.map((m) => `"${m.pythonName}"`);
        if (this.loadAssembly) {
            exportedMembers.push('"__jsii_assembly__"');
        }
        // Declare the list of "public" members this module exports
        if (this.members.length > 0) {
            code.line();
        }
        code.line();
        if (exportedMembers.length > 0) {
            code.indent('__all__ = [');
            for (const member of exportedMembers.sort()) {
                // Writing one by line might be _a lot_ of lines, but it'll make reviewing changes to the list easier. Trust me.
                code.line(`${member},`);
            }
            code.unindent(']');
        }
        else {
            code.line('__all__: typing.List[typing.Any] = []');
        }
        // Next up, we'll use publication to ensure that all of the non-public names
        // get hidden from dir(), tab-complete, etc.
        code.line();
        code.line('publication.publish()');
        // Finally, we'll load all registered python modules
        if (this.modules.length > 0) {
            code.line();
            code.line('# Loading modules to ensure their types are registered with the jsii runtime library');
            for (const module of this.modules.sort((l, r) => l.pythonName.localeCompare(r.pythonName))) {
                // Rather than generating an absolute import like
                // "import jsii_calc.submodule.nested_submodule.deeply_nested"
                // this builds a relative import like
                // "from .submodule.nested_submodule import deeply_nested"
                // This enables distributing python packages and using the
                // generated modules in the same codebase.
                const assemblyName = type_name_1.toPythonFqn(module.assembly.name, module.assembly).pythonFqn;
                const submodule = module.pythonName
                    .replace(`${assemblyName}.`, '')
                    .split('.');
                const submodulePath = submodule
                    .slice(0, submodule.length - 1)
                    .join('.');
                const submoduleName = submodule[submodule.length - 1];
                code.line(`from .${submodulePath} import ${submoduleName}`);
            }
        }
    }
    /**
     * Emit the bin scripts if bin section defined.
     */
    emitBinScripts(code) {
        const scripts = new Array();
        if (this.loadAssembly) {
            if (this.assembly.bin != null) {
                for (const name of Object.keys(this.assembly.bin)) {
                    const script_file = path.join('src', pythonModuleNameToFilename(this.pythonName), 'bin', name);
                    code.openFile(script_file);
                    code.line('#!/usr/bin/env python');
                    code.line();
                    code.line('import jsii');
                    code.line('import sys');
                    code.line();
                    emitList(code, '__jsii_assembly__ = jsii.JSIIAssembly.load(', [
                        JSON.stringify(this.assembly.name),
                        JSON.stringify(this.assembly.version),
                        JSON.stringify(this.pythonName.replace('._jsii', '')),
                        `${JSON.stringify(this.assemblyFilename)}`,
                    ], ')');
                    code.line();
                    emitList(code, '__jsii_assembly__.invokeBinScript(', [
                        JSON.stringify(this.assembly.name),
                        JSON.stringify(name),
                        'sys.argv[1:]',
                    ], ')');
                    code.closeFile(script_file);
                    scripts.push(script_file.replace(/\\/g, '/'));
                }
            }
        }
        return scripts;
    }
    /**
     * Emit the README as module docstring if this is the entry point module (it loads the assembly)
     */
    emitModuleDocumentation(code) {
        if (this.moduleDocumentation) {
            code.line(DOCSTRING_QUOTES);
            code.line(this.moduleDocumentation);
            code.line(DOCSTRING_QUOTES);
        }
    }
    emitDependencyImports(code) {
        var _a;
        // Collect all the (direct) dependencies' ._jsii packages.
        const deps = Object.keys((_a = this.assembly.dependencies) !== null && _a !== void 0 ? _a : {})
            .map((dep) => { var _a, _b, _c, _d, _e; return (_e = (_d = (_c = (_b = (_a = this.assembly.dependencyClosure) === null || _a === void 0 ? void 0 : _a[dep]) === null || _b === void 0 ? void 0 : _b.targets) === null || _c === void 0 ? void 0 : _c.python) === null || _d === void 0 ? void 0 : _d.module) !== null && _e !== void 0 ? _e : util_2.die(`No Python target was configrued for the dependency "${dep}".`); })
            .map((mod) => `${mod}._jsii`)
            .sort();
        // Now actually write the import statements...
        if (deps.length > 0) {
            code.line();
            for (const moduleName of deps) {
                code.line(`import ${moduleName}`);
            }
        }
    }
    emitRequiredImports(code, context) {
        const requiredImports = this.requiredImports(context);
        const statements = Object.entries(requiredImports)
            .map(([sourcePackage, items]) => toImportStatements(sourcePackage, items))
            .reduce((acc, elt) => [...acc, ...elt], new Array())
            .sort(importComparator);
        if (statements.length > 0) {
            code.line();
        }
        for (const statement of statements) {
            statement.emit(code);
        }
        function toImportStatements(sourcePkg, items) {
            const result = new Array();
            if (items.has('')) {
                result.push({
                    comparisonBase: `import ${sourcePkg}`,
                    emit(code) {
                        code.line(this.comparisonBase);
                    },
                });
            }
            const pieceMeal = Array.from(items)
                .filter((i) => i !== '')
                .sort();
            if (pieceMeal.length > 0) {
                result.push({
                    comparisonBase: `from ${sourcePkg} import`,
                    emit: (code) => emitList(code, `from ${sourcePkg} import `, pieceMeal, '', {
                        ifMulti: ['(', ')'],
                    }),
                });
            }
            return result;
        }
        function importComparator(left, right) {
            if (left.comparisonBase.startsWith('import') ===
                right.comparisonBase.startsWith('import')) {
                return left.comparisonBase.localeCompare(right.comparisonBase);
            }
            // We want "from .foo import (...)" to be *after* "import bar"
            return right.comparisonBase.localeCompare(left.comparisonBase);
        }
    }
}
class Package {
    constructor(name, version, metadata) {
        this.modules = new Map();
        this.data = new Map();
        this.name = name;
        this.version = version;
        this.metadata = metadata;
    }
    addModule(module) {
        this.modules.set(module.pythonName, module);
        // This is the module that represents the assembly
        if (module.fqn === this.metadata.name) {
            this.rootModule = module;
        }
    }
    addData(module, filename, data) {
        if (!this.data.has(module.pythonName)) {
            this.data.set(module.pythonName, []);
        }
        this.data.get(module.pythonName).push({ filename, data });
    }
    write(code, context) {
        var _a, _b, _c, _d, _e, _f, _g;
        const modules = [...this.modules.values()].sort((a, b) => a.pythonName.localeCompare(b.pythonName));
        const scripts = new Array();
        // Iterate over all of our modules, and write them out to disk.
        for (const mod of modules) {
            const filename = path.join('src', pythonModuleNameToFilename(mod.pythonName), '__init__.py');
            code.openFile(filename);
            mod.emit(code, context);
            code.closeFile(filename);
            scripts.push(...mod.emitBinScripts(code));
        }
        // Handle our package data.
        const packageData = {};
        for (const [mod, pdata] of this.data) {
            for (const data of pdata) {
                if (data.data != null) {
                    const filepath = path.join('src', pythonModuleNameToFilename(mod), data.filename);
                    code.openFile(filepath);
                    code.line(data.data);
                    code.closeFile(filepath);
                }
            }
            packageData[mod] = pdata.map((pd) => pd.filename);
        }
        // Compute our list of dependencies
        const dependencies = [];
        for (const [depName, version] of Object.entries((_a = this.metadata.dependencies) !== null && _a !== void 0 ? _a : {})) {
            const depInfo = this.metadata.dependencyClosure[depName];
            dependencies.push(`${depInfo.targets.python.distName}${version_utils_1.toPythonVersionRange(version)}`);
        }
        // Need to always write this file as the build process depends on it.
        // Make up some contents if we don't have anything useful to say.
        code.openFile('README.md');
        code.line((_c = (_b = this.rootModule) === null || _b === void 0 ? void 0 : _b.moduleDocumentation) !== null && _c !== void 0 ? _c : `${this.name}\n${'='.repeat(this.name.length)}`);
        code.closeFile('README.md');
        // Strip " (build abcdef)" from the jsii version
        const jsiiVersionSimple = this.metadata.jsiiVersion.replace(/ .*$/, '');
        const setupKwargs = {
            name: this.name,
            version: this.version,
            description: this.metadata.description,
            license: this.metadata.license,
            url: this.metadata.homepage,
            long_description_content_type: 'text/markdown',
            author: this.metadata.author.name +
                (this.metadata.author.email !== undefined
                    ? `<${this.metadata.author.email}>`
                    : ''),
            bdist_wheel: {
                universal: true,
            },
            project_urls: {
                Source: this.metadata.repository.url,
            },
            package_dir: { '': 'src' },
            packages: modules.map((m) => m.pythonName),
            package_data: packageData,
            python_requires: '>=3.6',
            install_requires: [
                `jsii${version_utils_1.toPythonVersionRange(`^${jsiiVersionSimple}`)}`,
                'publication>=0.0.3',
            ]
                .concat(dependencies)
                .sort(),
            classifiers: [
                'Intended Audience :: Developers',
                'Operating System :: OS Independent',
                'Programming Language :: JavaScript',
                'Programming Language :: Python :: 3 :: Only',
                'Programming Language :: Python :: 3.6',
                'Programming Language :: Python :: 3.7',
                'Programming Language :: Python :: 3.8',
                'Programming Language :: Python :: 3.9',
                'Typing :: Typed',
            ],
            scripts,
        };
        switch ((_d = this.metadata.docs) === null || _d === void 0 ? void 0 : _d.stability) {
            case spec.Stability.Experimental:
                setupKwargs.classifiers.push('Development Status :: 4 - Beta');
                break;
            case spec.Stability.Stable:
                setupKwargs.classifiers.push('Development Status :: 5 - Production/Stable');
                break;
            case spec.Stability.Deprecated:
                setupKwargs.classifiers.push('Development Status :: 7 - Inactive');
                break;
            default:
            // No 'Development Status' trove classifier for you!
        }
        if ((_e = spdxLicenseList[this.metadata.license]) === null || _e === void 0 ? void 0 : _e.osiApproved) {
            setupKwargs.classifiers.push('License :: OSI Approved');
        }
        const additionalClassifiers = (_g = (_f = this.metadata.targets) === null || _f === void 0 ? void 0 : _f.python) === null || _g === void 0 ? void 0 : _g.classifiers;
        if (additionalClassifiers != null) {
            if (!Array.isArray(additionalClassifiers)) {
                throw new Error(`The "jsii.targets.python.classifiers" value must be an array of strings if provided, but found ${JSON.stringify(additionalClassifiers, null, 2)}`);
            }
            // We discourage using those since we automatically set a value for them
            for (let classifier of additionalClassifiers.sort()) {
                if (typeof classifier !== 'string') {
                    throw new Error(`The "jsii.targets.python.classifiers" value can only contain strings, but found ${JSON.stringify(classifier, null, 2)}`);
                }
                // We'll split on `::` and re-join later so classifiers are "normalized" to a standard spacing
                const parts = classifier.split('::').map((part) => part.trim());
                const reservedClassifiers = [
                    'Development Status',
                    'License',
                    'Operating System',
                    'Typing',
                ];
                if (reservedClassifiers.includes(parts[0])) {
                    logging_1.warn(`Classifiers starting with ${reservedClassifiers
                        .map((x) => `"${x} ::"`)
                        .join(', ')} are automatically set and should not be manually configured`);
                }
                classifier = parts.join(' :: ');
                if (setupKwargs.classifiers.includes(classifier)) {
                    continue;
                }
                setupKwargs.classifiers.push(classifier);
            }
        }
        // We Need a setup.py to make this Package, actually a Package.
        code.openFile('setup.py');
        code.line('import json');
        code.line('import setuptools');
        code.line();
        code.line('kwargs = json.loads(');
        code.line('    """');
        code.line(JSON.stringify(setupKwargs, null, 4));
        code.line('"""');
        code.line(')');
        code.line();
        code.openBlock('with open("README.md", encoding="utf8") as fp');
        code.line('kwargs["long_description"] = fp.read()');
        code.closeBlock();
        code.line();
        code.line();
        code.line('setuptools.setup(**kwargs)');
        code.closeFile('setup.py');
        // Because we're good citizens, we're going to go ahead and support pyproject.toml
        // as well.
        // TODO: Might be easier to just use a TOML library to write this out.
        code.openFile('pyproject.toml');
        code.line('[build-system]');
        const buildTools = fs
            .readFileSync(requirementsFile, { encoding: 'utf-8' })
            .split('\n')
            .map((line) => { var _a, _b; return (_b = (_a = /^\s*(.+)\s*#\s*build-system\s*$/.exec(line)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.trim(); })
            .reduce((buildTools, entry) => (entry ? [...buildTools, entry] : buildTools), new Array());
        code.line(`requires = [${buildTools.map((x) => `"${x}"`).join(', ')}]`);
        code.line('build-backend = "setuptools.build_meta"');
        code.closeFile('pyproject.toml');
        // We also need to write out a MANIFEST.in to ensure that all of our required
        // files are included.
        code.openFile('MANIFEST.in');
        code.line('include pyproject.toml');
        code.closeFile('MANIFEST.in');
    }
}
class TypeResolver {
    constructor(types, findModule, findType, boundTo, moduleName) {
        this.types = types;
        this.findModule = findModule;
        this.findType = findType;
        this.moduleName = moduleName;
        this.boundTo = boundTo !== undefined ? this.toPythonFQN(boundTo) : boundTo;
        if (this.moduleName !== undefined) {
            this.moduleRe = new RegExp(`^(${escapeStringRegexp(this.moduleName)})\\.(.+)$`);
        }
        if (this.boundTo !== undefined) {
            this.boundRe = new RegExp(`^(${escapeStringRegexp(this.boundTo)})\\.(.+)$`);
        }
    }
    bind(fqn, moduleName) {
        return new TypeResolver(this.types, this.findModule, this.findType, fqn, moduleName !== undefined
            ? moduleName.startsWith('.')
                ? `${this.moduleName}${moduleName}`
                : moduleName
            : this.moduleName);
    }
    isInModule(typeRef) {
        const pythonType = typeof typeRef !== 'string' ? this.toPythonFQN(typeRef.fqn) : typeRef;
        return this.moduleRe.test(pythonType);
    }
    isInNamespace(typeRef) {
        const pythonType = typeof typeRef !== 'string' ? this.toPythonFQN(typeRef.fqn) : typeRef;
        return this.boundRe.test(pythonType);
    }
    getParent(typeRef) {
        const fqn = typeof typeRef !== 'string' ? typeRef.fqn : typeRef;
        const matches = /^(.+)\.[^.]+$/.exec(fqn);
        if (matches == null || !Array.isArray(matches)) {
            throw new Error(`Invalid FQN: ${fqn}`);
        }
        const [, parentFQN] = matches;
        const parent = this.types.get(parentFQN);
        if (parent === undefined) {
            throw new Error(`Could not find parent:  ${parentFQN}`);
        }
        return parent;
    }
    getDefiningPythonModule(typeRef) {
        const fqn = typeof typeRef !== 'string' ? typeRef.fqn : typeRef;
        const parent = this.types.get(fqn);
        if (parent) {
            let mod = parent;
            while (!(mod instanceof PythonModule)) {
                mod = this.getParent(mod.fqn);
            }
            return mod.pythonName;
        }
        const matches = /^([^.]+)\./.exec(fqn);
        if (matches == null || !Array.isArray(matches)) {
            throw new Error(`Invalid FQN: ${fqn}`);
        }
        const [, assm] = matches;
        return this.findModule(assm).targets.python.module;
    }
    getType(typeRef) {
        const type = this.types.get(typeRef.fqn);
        if (type === undefined) {
            throw new Error(`Could not locate type: "${typeRef.fqn}"`);
        }
        return type;
    }
    dereference(typeRef) {
        if (typeof typeRef !== 'string') {
            typeRef = typeRef.fqn;
        }
        return this.findType(typeRef);
    }
    toPythonFQN(fqn) {
        const [assemblyName, ...qualifiedIdentifiers] = fqn.split('.');
        const fqnParts = [
            this.findModule(assemblyName).targets.python.module,
        ];
        for (const part of qualifiedIdentifiers) {
            fqnParts.push(util_2.toPythonIdentifier(part));
        }
        return fqnParts.join('.');
    }
}
class PythonGenerator extends generator_1.Generator {
    constructor(rosetta, options = {}) {
        super(options);
        this.rosetta = rosetta;
        this.code.openBlockFormatter = (s) => `${s}:`;
        this.code.closeBlockFormatter = (_s) => false;
        this.types = new Map();
    }
    // eslint-disable-next-line complexity
    emitDocString(code, apiLocation, docs, options = {}) {
        var _a, _b, _c, _d;
        if ((!docs || Object.keys(docs).length === 0) && !options.arguments) {
            return;
        }
        if (!docs) {
            docs = {};
        }
        const lines = new Array();
        if (docs.summary) {
            lines.push(markdown_1.md2rst(_utils_1.renderSummary(docs)));
            brk();
        }
        else {
            lines.push('');
        }
        function brk() {
            if (lines.length > 0 && lines[lines.length - 1].trim() !== '') {
                lines.push('');
            }
        }
        function block(heading, content, doBrk = true) {
            if (doBrk) {
                brk();
            }
            const contentLines = markdown_1.md2rst(content).split('\n');
            if (contentLines.length <= 1) {
                lines.push(`:${heading}: ${contentLines.join('')}`.trim());
            }
            else {
                lines.push(`:${heading}:`);
                brk();
                for (const line of contentLines) {
                    lines.push(line.trim());
                }
            }
            if (doBrk) {
                brk();
            }
        }
        if (docs.remarks) {
            brk();
            lines.push(...markdown_1.md2rst(this.convertMarkdown((_a = docs.remarks) !== null && _a !== void 0 ? _a : '', apiLocation)).split('\n'));
            brk();
        }
        if ((_c = (_b = options.arguments) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0 > 0) {
            brk();
            for (const param of options.arguments) {
                // Add a line for every argument. Even if there is no description, we need
                // the docstring so that the Sphinx extension can add the type annotations.
                lines.push(`:param ${toPythonParameterName(param.name)}: ${onelineDescription(param.docs)}`);
            }
            brk();
        }
        if (docs.default) {
            block('default', docs.default);
        }
        if (docs.returns) {
            block('return', docs.returns);
        }
        if (docs.deprecated) {
            block('deprecated', docs.deprecated);
        }
        if (docs.see) {
            block('see', docs.see, false);
        }
        if (docs.stability && shouldMentionStability(docs.stability)) {
            block('stability', docs.stability, false);
        }
        if (docs.subclassable) {
            block('subclassable', 'Yes');
        }
        for (const [k, v] of Object.entries((_d = docs.custom) !== null && _d !== void 0 ? _d : {})) {
            block(k, v, false);
        }
        if (docs.example) {
            brk();
            lines.push('Example::');
            lines.push('');
            const exampleText = this.convertExample(docs.example, apiLocation);
            for (const line of exampleText.split('\n')) {
                lines.push(`    ${line}`);
            }
            brk();
        }
        while (lines.length > 0 && lines[lines.length - 1] === '') {
            lines.pop();
        }
        if (lines.length === 0) {
            return;
        }
        if (lines.length === 1) {
            code.line(`${DOCSTRING_QUOTES}${lines[0]}${DOCSTRING_QUOTES}`);
        }
        else {
            code.line(`${DOCSTRING_QUOTES}${lines[0]}`);
            lines.splice(0, 1);
            for (const line of lines) {
                code.line(line);
            }
            code.line(DOCSTRING_QUOTES);
        }
        if (options.trailingNewLine) {
            code.line();
        }
    }
    convertExample(example, apiLoc) {
        const translated = this.rosetta.translateExample(apiLoc, example, jsii_rosetta_1.TargetLanguage.PYTHON, jsii_rosetta_1.enforcesStrictMode(this.assembly));
        return this.prefixDisclaimer(translated);
    }
    convertMarkdown(markdown, apiLoc) {
        return this.rosetta.translateSnippetsInMarkdown(apiLoc, markdown, jsii_rosetta_1.TargetLanguage.PYTHON, jsii_rosetta_1.enforcesStrictMode(this.assembly), (trans) => ({
            language: trans.language,
            source: this.prefixDisclaimer(trans),
        }));
    }
    prefixDisclaimer(translated) {
        if (!translated.didCompile && _1.INCOMPLETE_DISCLAIMER_NONCOMPILING) {
            return `# ${_1.INCOMPLETE_DISCLAIMER_NONCOMPILING}\n${translated.source}`;
        }
        return translated.source;
    }
    getPythonType(fqn) {
        const type = this.types.get(fqn);
        if (type === undefined) {
            throw new Error(`Could not locate type: "${fqn}"`);
        }
        return type;
    }
    getAssemblyOutputDir(assm) {
        return path.join('src', pythonModuleNameToFilename(this.getAssemblyModuleName(assm)));
    }
    onBeginAssembly(assm, _fingerprint) {
        this.package = new Package(assm.targets.python.distName, version_utils_1.toReleaseVersion(assm.version, _1.TargetName.PYTHON), assm);
        // This is the '<packagename>._jsii' module for this assembly
        const assemblyModule = new PythonModule(this.getAssemblyModuleName(assm), undefined, {
            assembly: assm,
            assemblyFilename: this.getAssemblyFileName(),
            loadAssembly: true,
            package: this.package,
        });
        this.package.addModule(assemblyModule);
        this.package.addData(assemblyModule, this.getAssemblyFileName(), undefined);
    }
    onEndAssembly(assm, _fingerprint) {
        const resolver = new TypeResolver(this.types, (fqn) => this.findModule(fqn), (fqn) => this.findType(fqn));
        this.package.write(this.code, {
            assembly: assm,
            emittedTypes: new Set(),
            resolver,
            submodule: assm.name,
        });
    }
    /**
     * Will be called for assembly root, namespaces and submodules (anything that contains other types, based on its FQN)
     */
    onBeginNamespace(ns) {
        var _a, _b;
        // 'ns' contains something like '@scope/jsii-calc-base-of-base'
        const submoduleLike = ns === this.assembly.name
            ? this.assembly
            : (_a = this.assembly.submodules) === null || _a === void 0 ? void 0 : _a[ns];
        const readmeLocation = { api: 'moduleReadme', moduleFqn: ns };
        const module = new PythonModule(type_name_1.toPackageName(ns, this.assembly), ns, {
            assembly: this.assembly,
            assemblyFilename: this.getAssemblyFileName(),
            package: this.package,
            moduleDocumentation: (submoduleLike === null || submoduleLike === void 0 ? void 0 : submoduleLike.readme) ? this.convertMarkdown((_b = submoduleLike.readme) === null || _b === void 0 ? void 0 : _b.markdown, readmeLocation).trim()
                : undefined,
        });
        this.package.addModule(module);
        this.types.set(ns, module);
        if (ns === this.assembly.name) {
            // This applies recursively to submodules, so no need to duplicate!
            this.package.addData(module, 'py.typed', '');
        }
        if (ns === this.assembly.name) {
            this.rootModule = module;
        }
        else {
            this.rootModule.addPythonModule(module);
        }
    }
    onEndNamespace(ns) {
        if (ns === this.assembly.name) {
            delete this.rootModule;
        }
    }
    onBeginClass(cls, abstract) {
        var _a;
        const klass = new Class(this, util_2.toPythonIdentifier(cls.name), cls, cls.fqn, {
            abstract,
            bases: cls.base ? [this.findType(cls.base)] : undefined,
            interfaces: (_a = cls.interfaces) === null || _a === void 0 ? void 0 : _a.map((base) => this.findType(base)),
            abstractBases: abstract ? this.getAbstractBases(cls) : [],
        }, cls.docs);
        if (cls.initializer !== undefined) {
            const { parameters = [] } = cls.initializer;
            klass.addMember(new Initializer(this, '__init__', undefined, parameters, undefined, cls.initializer.docs, false, // Never static
            { liftedProp: this.getliftedProp(cls.initializer), parent: cls }));
        }
        this.addPythonType(klass);
    }
    onStaticMethod(cls, method) {
        const { parameters = [] } = method;
        this.getPythonType(cls.fqn).addMember(new StaticMethod(this, toPythonMethodName(method.name), method.name, parameters, method.returns, method.docs, true, // Always static
        {
            abstract: method.abstract,
            liftedProp: this.getliftedProp(method),
            parent: cls,
        }));
    }
    onStaticProperty(cls, prop) {
        this.getPythonType(cls.fqn).addMember(new StaticProperty(this, toPythonPropertyName(prop.name, prop.const), prop.name, prop, prop.docs, {
            abstract: prop.abstract,
            immutable: prop.immutable,
            isStatic: prop.static,
            parent: cls,
        }));
    }
    onMethod(cls, method) {
        const { parameters = [] } = method;
        if (method.async) {
            this.getPythonType(cls.fqn).addMember(new AsyncMethod(this, toPythonMethodName(method.name, method.protected), method.name, parameters, method.returns, method.docs, !!method.static, {
                abstract: method.abstract,
                liftedProp: this.getliftedProp(method),
                parent: cls,
            }));
        }
        else {
            this.getPythonType(cls.fqn).addMember(new Method(this, toPythonMethodName(method.name, method.protected), method.name, parameters, method.returns, method.docs, !!method.static, {
                abstract: method.abstract,
                liftedProp: this.getliftedProp(method),
                parent: cls,
            }));
        }
    }
    onProperty(cls, prop) {
        this.getPythonType(cls.fqn).addMember(new Property(this, toPythonPropertyName(prop.name, prop.const, prop.protected), prop.name, prop, prop.docs, {
            abstract: prop.abstract,
            immutable: prop.immutable,
            isStatic: prop.static,
            parent: cls,
        }));
    }
    onUnionProperty(cls, prop, _union) {
        this.onProperty(cls, prop);
    }
    onBeginInterface(ifc) {
        var _a, _b;
        let iface;
        if (ifc.datatype) {
            iface = new Struct(this, util_2.toPythonIdentifier(ifc.name), ifc, ifc.fqn, { bases: (_a = ifc.interfaces) === null || _a === void 0 ? void 0 : _a.map((base) => this.findType(base)) }, ifc.docs);
        }
        else {
            iface = new Interface(this, util_2.toPythonIdentifier(ifc.name), ifc, ifc.fqn, { bases: (_b = ifc.interfaces) === null || _b === void 0 ? void 0 : _b.map((base) => this.findType(base)) }, ifc.docs);
        }
        this.addPythonType(iface);
    }
    onEndInterface(_ifc) {
        return;
    }
    onInterfaceMethod(ifc, method) {
        const { parameters = [] } = method;
        this.getPythonType(ifc.fqn).addMember(new InterfaceMethod(this, toPythonMethodName(method.name, method.protected), method.name, parameters, method.returns, method.docs, !!method.static, { liftedProp: this.getliftedProp(method), parent: ifc }));
    }
    onInterfaceProperty(ifc, prop) {
        let ifaceProperty;
        if (ifc.datatype) {
            ifaceProperty = new StructField(this, prop, ifc);
        }
        else {
            ifaceProperty = new InterfaceProperty(this, toPythonPropertyName(prop.name, prop.const, prop.protected), prop.name, prop, prop.docs, { immutable: prop.immutable, isStatic: prop.static, parent: ifc });
        }
        this.getPythonType(ifc.fqn).addMember(ifaceProperty);
    }
    onBeginEnum(enm) {
        this.addPythonType(new Enum(this, util_2.toPythonIdentifier(enm.name), enm, enm.fqn, {}, enm.docs));
    }
    onEnumMember(enm, member) {
        this.getPythonType(enm.fqn).addMember(new EnumMember(this, util_2.toPythonIdentifier(member.name), member.name, member.docs, enm));
    }
    onInterfaceMethodOverload(_ifc, _overload, _originalMethod) {
        throw new Error('Unhandled Type: InterfaceMethodOverload');
    }
    onMethodOverload(_cls, _overload, _originalMethod) {
        throw new Error('Unhandled Type: MethodOverload');
    }
    onStaticMethodOverload(_cls, _overload, _originalMethod) {
        throw new Error('Unhandled Type: StaticMethodOverload');
    }
    getAssemblyModuleName(assm) {
        return `${assm.targets.python.module}._jsii`;
    }
    getParentFQN(fqn) {
        const m = /^(.+)\.[^.]+$/.exec(fqn);
        if (m == null) {
            throw new Error(`Could not determine parent FQN of: ${fqn}`);
        }
        return m[1];
    }
    getParent(fqn) {
        return this.getPythonType(this.getParentFQN(fqn));
    }
    addPythonType(type) {
        if (type.fqn == null) {
            throw new Error('Cannot add a Python type without a FQN.');
        }
        this.getParent(type.fqn).addMember(type);
        this.types.set(type.fqn, type);
    }
    getliftedProp(method) {
        var _a, _b;
        // If there are parameters to this method, and if the last parameter's type is
        // a datatype interface, then we want to lift the members of that last paramter
        // as keyword arguments to this function.
        if ((_b = (_a = method.parameters) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0 >= 1) {
            const lastParameter = method.parameters.slice(-1)[0];
            if (!lastParameter.variadic &&
                spec.isNamedTypeReference(lastParameter.type)) {
                const lastParameterType = this.findType(lastParameter.type.fqn);
                if (spec.isInterfaceType(lastParameterType) &&
                    lastParameterType.datatype) {
                    return lastParameterType;
                }
            }
        }
        return undefined;
    }
    getAbstractBases(cls) {
        const abstractBases = [];
        if (cls.base !== undefined) {
            const base = this.findType(cls.base);
            if (!spec.isClassType(base)) {
                throw new Error("Class inheritence that isn't a class?");
            }
            if (base.abstract) {
                abstractBases.push(base);
            }
        }
        return abstractBases;
    }
}
/**
 * Render a one-line description of the given docs, used for method arguments and inlined properties
 */
function onelineDescription(docs) {
    // Only consider a subset of fields here, we don't have a lot of formatting space
    if (!docs || Object.keys(docs).length === 0) {
        return '-';
    }
    const parts = [];
    if (docs.summary) {
        parts.push(markdown_1.md2rst(_utils_1.renderSummary(docs)));
    }
    if (docs.remarks) {
        parts.push(markdown_1.md2rst(docs.remarks));
    }
    if (docs.default) {
        parts.push(`Default: ${markdown_1.md2rst(docs.default)}`);
    }
    return parts.join(' ').replace(/\s+/g, ' ');
}
function shouldMentionStability(s) {
    // Don't render "stable" or "external", those are both stable by implication.
    return s === spec.Stability.Deprecated || s === spec.Stability.Experimental;
}
function isStruct(typeSystem, ref) {
    if (!spec.isNamedTypeReference(ref)) {
        return false;
    }
    const type = typeSystem.tryFindFqn(ref.fqn);
    return !!((type === null || type === void 0 ? void 0 : type.isInterfaceType()) && (type === null || type === void 0 ? void 0 : type.isDataType()));
}
/**
 * Appends `_` at the end of `name` until it no longer conflicts with any of the
 * entries in `inUse`.
 *
 * @param name  the name to be slugified.
 * @param inUse the names that are already being used.
 *
 * @returns the slugified name.
 */
function slugifyAsNeeded(name, inUse) {
    const inUseSet = new Set(inUse);
    while (inUseSet.has(name)) {
        name = `${name}_`;
    }
    return name;
}
////////////////////////////////////////////////////////////////////////////////
// BEHOLD: Helpers to output code that looks like what Black would format into...
//
// @see https://black.readthedocs.io/en/stable/the_black_code_style.html
const TARGET_LINE_LENGTH = 88;
function openSignature(code, keyword, name, params, trailingComma = false, returnType) {
    const prefix = `${keyword} ${name}`;
    const suffix = returnType ? ` -> ${returnType}` : '';
    if (params.length === 0) {
        code.openBlock(`${prefix}${returnType ? '()' : ''}${suffix}`);
        return;
    }
    const join = ', ';
    const { elementsSize, joinSize } = totalSizeOf(params, join);
    const hasComments = !params.some((param) => /# .+$/.exec(param));
    if (hasComments &&
        TARGET_LINE_LENGTH >
            code.currentIndentLength +
                prefix.length +
                elementsSize +
                joinSize +
                suffix.length +
                2) {
        code.openBlock(`${prefix}(${params.join(join)})${suffix}`);
        return;
    }
    code.indent(`${prefix}(`);
    if (!hasComments &&
        TARGET_LINE_LENGTH >
            code.currentIndentLength +
                elementsSize +
                joinSize +
                (trailingComma ? 1 : 0)) {
        code.line(`${params.join(join)}${trailingComma ? ',' : ''}`);
    }
    else {
        for (const param of params) {
            code.line(param.replace(/(\s*# .+)?$/, ',$1'));
        }
    }
    code.unindent(false);
    code.openBlock(`)${suffix}`);
}
function assignCallResult(code, variable, funct, params) {
    const prefix = `${variable} = ${funct}(`;
    const suffix = ')';
    if (params.length === 0) {
        code.line(`${prefix}${suffix}`);
        return;
    }
    const join = ', ';
    const { elementsSize, joinSize } = totalSizeOf(params, join);
    if (TARGET_LINE_LENGTH >
        code.currentIndentLength +
            prefix.length +
            elementsSize +
            joinSize +
            suffix.length) {
        code.line(`${prefix}${params.join(join)}${suffix}`);
        return;
    }
    code.indent(prefix);
    if (TARGET_LINE_LENGTH > code.currentIndentLength + elementsSize + joinSize) {
        code.line(params.join(join));
    }
    else {
        for (const param of params) {
            code.line(`${param},`);
        }
    }
    code.unindent(suffix);
}
function assignDictionary(code, variable, elements, trailing, compact = false) {
    const space = compact ? '' : ' ';
    const prefix = `${variable}${space}=${space}{`;
    const suffix = `}${trailing !== null && trailing !== void 0 ? trailing : ''}`;
    if (elements.length === 0) {
        code.line(`${prefix}${suffix}`);
        return;
    }
    if (compact) {
        const join = ', ';
        const { elementsSize, joinSize } = totalSizeOf(elements, join);
        if (TARGET_LINE_LENGTH >
            prefix.length +
                code.currentIndentLength +
                elementsSize +
                joinSize +
                suffix.length) {
            code.line(`${prefix}${elements.join(join)}${suffix}`);
            return;
        }
    }
    code.indent(prefix);
    for (const elt of elements) {
        code.line(`${elt},`);
    }
    code.unindent(suffix);
}
function emitList(code, prefix, elements, suffix, opts) {
    var _a;
    if (elements.length === 0) {
        code.line(`${prefix}${suffix}`);
        return;
    }
    const join = ', ';
    const { elementsSize, joinSize } = totalSizeOf(elements, join);
    if (TARGET_LINE_LENGTH >
        code.currentIndentLength +
            prefix.length +
            elementsSize +
            joinSize +
            suffix.length) {
        code.line(`${prefix}${elements.join(join)}${suffix}`);
        return;
    }
    const [before, after] = (_a = opts === null || opts === void 0 ? void 0 : opts.ifMulti) !== null && _a !== void 0 ? _a : ['', ''];
    code.indent(`${prefix}${before}`);
    if (elements.length === 1) {
        code.line(elements[0]);
    }
    else {
        if (TARGET_LINE_LENGTH >
            code.currentIndentLength + elementsSize + joinSize) {
            code.line(elements.join(join));
        }
        else {
            for (const elt of elements) {
                code.line(`${elt},`);
            }
        }
    }
    code.unindent(`${after}${suffix}`);
}
function totalSizeOf(strings, join) {
    return {
        elementsSize: strings
            .map((str) => str.length)
            .reduce((acc, elt) => acc + elt, 0),
        joinSize: strings.length > 1 ? join.length * (strings.length - 1) : 0,
    };
}
function nestedContext(context, fqn) {
    var _a;
    return {
        ...context,
        surroundingTypeFqns: fqn != null
            ? [...((_a = context.surroundingTypeFqns) !== null && _a !== void 0 ? _a : []), fqn]
            : context.surroundingTypeFqns,
    };
}
const isDeprecated = (x) => { var _a; return ((_a = x.docs) === null || _a === void 0 ? void 0 : _a.deprecated) !== undefined; };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHl0aG9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicHl0aG9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQyx5Q0FBbUQ7QUFDbkQsMkRBQTJEO0FBQzNELCtCQUErQjtBQUUvQiwrQ0FNc0I7QUFDdEIsNkJBQTZCO0FBRTdCLDRDQUEyRDtBQUMzRCx3Q0FBa0M7QUFDbEMsMENBQXFDO0FBQ3JDLHNDQUFrRDtBQUNsRCxrQ0FBZ0M7QUFDaEMscUNBQTZEO0FBQzdELGtEQU80QjtBQUM1Qix3Q0FBd0Q7QUFDeEQsbURBQXlFO0FBRXpFLHdCQUFtRTtBQUVuRSxvR0FBb0c7QUFDcEcsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFFckQsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUNuQyxTQUFTLEVBQ1QsUUFBUSxFQUNSLHNCQUFzQixDQUN2QixDQUFDO0FBRUYsMkVBQTJFO0FBQzNFLCtGQUErRjtBQUMvRixNQUFNLGdCQUFnQixHQUFHLEtBQUssQ0FBQztBQUUvQixNQUFxQixNQUFPLFNBQVEsZUFBTTtJQUd4QyxZQUFtQixPQUFzQjtRQUN2QyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFZixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksZUFBZSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUFjLEVBQUUsT0FBZTtRQUN2RCxNQUFNLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQWlCLEVBQUUsTUFBYztRQUNsRCw2QkFBNkI7UUFDN0IsTUFBTSxJQUFJLEdBQUcsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FB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RSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdEUsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FDcEIsT0FBb0IsRUFDcEIsR0FBdUI7O0lBRXZCLE9BQU87UUFDTCxHQUFHLE9BQU87UUFDVixtQkFBbUIsRUFDakIsR0FBRyxJQUFJLElBQUk7WUFDVCxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQUMsT0FBTyxDQUFDLG1CQUFtQixtQ0FBSSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUM7WUFDL0MsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxtQkFBbUI7S0FDbEMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFlBQVksR0FBRyxDQUFDLENBQWEsRUFBRSxFQUFFLFdBQUMsT0FBQSxPQUFBLENBQUMsQ0FBQyxJQUFJLDBDQUFFLFVBQVUsTUFBSyxTQUFTLENBQUEsRUFBQSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3BlYyBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgQ29kZU1ha2VyLCB0b1NuYWtlQ2FzZSB9IGZyb20gJ2NvZGVtYWtlcic7XG5pbXBvcnQgKiBhcyBlc2NhcGVTdHJpbmdSZWdleHAgZnJvbSAnZXNjYXBlLXN0cmluZy1yZWdleHAnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcmVmbGVjdCBmcm9tICdqc2lpLXJlZmxlY3QnO1xuaW1wb3J0IHtcbiAgVGFyZ2V0TGFuZ3VhZ2UsXG4gIFRyYW5zbGF0aW9uLFxuICBSb3NldHRhLFxuICBlbmZvcmNlc1N0cmljdE1vZGUsXG4gIEFwaUxvY2F0aW9uLFxufSBmcm9tICdqc2lpLXJvc2V0dGEnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgR2VuZXJhdG9yLCBHZW5lcmF0b3JPcHRpb25zIH0gZnJvbSAnLi4vZ2VuZXJhdG9yJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IG1kMnJzdCB9IGZyb20gJy4uL21hcmtkb3duJztcbmltcG9ydCB7IFRhcmdldCwgVGFyZ2V0T3B0aW9ucyB9IGZyb20gJy4uL3RhcmdldCc7XG5pbXBvcnQgeyBzaGVsbCB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgcmVuZGVyU3VtbWFyeSwgUHJvcGVydHlEZWZpbml0aW9uIH0gZnJvbSAnLi9fdXRpbHMnO1xuaW1wb3J0IHtcbiAgTmFtaW5nQ29udGV4dCxcbiAgdG9UeXBlTmFtZSxcbiAgUHl0aG9uSW1wb3J0cyxcbiAgbWVyZ2VQeXRob25JbXBvcnRzLFxuICB0b1BhY2thZ2VOYW1lLFxuICB0b1B5dGhvbkZxbixcbn0gZnJvbSAnLi9weXRob24vdHlwZS1uYW1lJztcbmltcG9ydCB7IGRpZSwgdG9QeXRob25JZGVudGlmaWVyIH0gZnJvbSAnLi9weXRob24vdXRpbCc7XG5pbXBvcnQgeyB0b1B5dGhvblZlcnNpb25SYW5nZSwgdG9SZWxlYXNlVmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi11dGlscyc7XG5cbmltcG9ydCB7IElOQ09NUExFVEVfRElTQ0xBSU1FUl9OT05DT01QSUxJTkcsIFRhcmdldE5hbWUgfSBmcm9tICcuJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3Qgc3BkeExpY2Vuc2VMaXN0ID0gcmVxdWlyZSgnc3BkeC1saWNlbnNlLWxpc3QnKTtcblxuY29uc3QgcmVxdWlyZW1lbnRzRmlsZSA9IHBhdGgucmVzb2x2ZShcbiAgX19kaXJuYW1lLFxuICAncHl0aG9uJyxcbiAgJ3JlcXVpcmVtZW50cy1kZXYudHh0Jyxcbik7XG5cbi8vIHdlIHVzZSBzaW5nbGUtcXVvdGVzIGZvciBtdWx0aS1saW5lIHN0cmluZ3MgdG8gYWxsb3cgZXhhbXBsZXMgd2l0aGluIHRoZVxuLy8gZG9jc3RyaW5ncyB0aGVtc2VsdmVzIHRvIGluY2x1ZGUgZG91YmxlLXF1b3RlcyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9pc3N1ZXMvMjU2OSlcbmNvbnN0IERPQ1NUUklOR19RVU9URVMgPSBcIicnJ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQeXRob24gZXh0ZW5kcyBUYXJnZXQge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZ2VuZXJhdG9yOiBQeXRob25HZW5lcmF0b3I7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFRhcmdldE9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuZ2VuZXJhdG9yID0gbmV3IFB5dGhvbkdlbmVyYXRvcihvcHRpb25zLnJvc2V0dGEpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdlbmVyYXRlQ29kZShvdXREaXI6IHN0cmluZywgdGFyYmFsbDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgc3VwZXIuZ2VuZXJhdGVDb2RlKG91dERpciwgdGFyYmFsbCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYnVpbGQoc291cmNlRGlyOiBzdHJpbmcsIG91dERpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQ3JlYXRlIGEgZnJlc2ggdmlydHVhbCBlbnZcbiAgICBjb25zdCB2ZW52ID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4oc291cmNlRGlyLCAnLmVudi0nKSk7XG4gICAgY29uc3QgdmVudkJpbiA9IHBhdGguam9pbihcbiAgICAgIHZlbnYsXG4gICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJ1NjcmlwdHMnIDogJ2JpbicsXG4gICAgKTtcbiAgICBhd2FpdCBzaGVsbCgncHl0aG9uMycsIFtcbiAgICAgICctbScsXG4gICAgICAndmVudicsXG4gICAgICAnLS1zeXN0ZW0tc2l0ZS1wYWNrYWdlcycsIC8vIEFsbG93IHVzaW5nIGdsb2JhbGx5IGluc3RhbGxlZCBwYWNrYWdlcyAoc2F2ZXMgdGltZSAmIGRpc2sgc3BhY2UpXG4gICAgICB2ZW52LFxuICAgIF0pO1xuICAgIGNvbnN0IGVudiA9IHtcbiAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgUEFUSDogYCR7dmVudkJpbn06JHtwcm9jZXNzLmVudi5QQVRIfWAsXG4gICAgICBWSVJUVUFMX0VOVjogdmVudixcbiAgICB9O1xuICAgIGNvbnN0IHB5dGhvbiA9IHBhdGguam9pbih2ZW52QmluLCAncHl0aG9uJyk7XG5cbiAgICAvLyBJbnN0YWxsIHRoZSBuZWNlc3NhcnkgdGhpbmdzXG4gICAgYXdhaXQgc2hlbGwoXG4gICAgICBweXRob24sXG4gICAgICBbJy1tJywgJ3BpcCcsICdpbnN0YWxsJywgJy0tbm8taW5wdXQnLCAnLXInLCByZXF1aXJlbWVudHNGaWxlXSxcbiAgICAgIHtcbiAgICAgICAgY3dkOiBzb3VyY2VEaXIsXG4gICAgICAgIGVudixcbiAgICAgICAgcmV0cnk6IHsgbWF4QXR0ZW1wdHM6IDUgfSxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIC8vIEFjdHVhbGx5IHBhY2thZ2UgdXAgb3VyIGNvZGUsIGJvdGggYXMgYSBzZGlzdCBhbmQgYSB3aGVlbCBmb3IgcHVibGlzaGluZy5cbiAgICBhd2FpdCBzaGVsbChweXRob24sIFsnc2V0dXAucHknLCAnc2Rpc3QnLCAnLS1kaXN0LWRpcicsIG91dERpcl0sIHtcbiAgICAgIGN3ZDogc291cmNlRGlyLFxuICAgICAgZW52LFxuICAgIH0pO1xuICAgIGF3YWl0IHNoZWxsKFxuICAgICAgcHl0aG9uLFxuICAgICAgWyctbScsICdwaXAnLCAnd2hlZWwnLCAnLS1uby1kZXBzJywgJy0td2hlZWwtZGlyJywgb3V0RGlyLCBzb3VyY2VEaXJdLFxuICAgICAge1xuICAgICAgICBjd2Q6IHNvdXJjZURpcixcbiAgICAgICAgZW52LFxuICAgICAgICByZXRyeTogeyBtYXhBdHRlbXB0czogNSB9LFxuICAgICAgfSxcbiAgICApO1xuICAgIGF3YWl0IHNoZWxsKHB5dGhvbiwgWyctbScsICd0d2luZScsICdjaGVjaycsIHBhdGguam9pbihvdXREaXIsICcqJyldLCB7XG4gICAgICBjd2Q6IHNvdXJjZURpcixcbiAgICAgIGVudixcbiAgICB9KTtcbiAgfVxufVxuXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyNcbi8vICMgQ09ERSBHRU5FUkFUT1IgI1xuLy8gIyMjIyMjIyMjIyMjIyMjIyMjXG5cbmludGVyZmFjZSBFbWl0Q29udGV4dCBleHRlbmRzIE5hbWluZ0NvbnRleHQge1xuICAvKiogQGRlcHJlY2F0ZWQgVGhlIFR5cGVSZXNvbHZlciAqL1xuICByZWFkb25seSByZXNvbHZlcjogVHlwZVJlc29sdmVyO1xufVxuXG5jb25zdCBweXRob25Nb2R1bGVOYW1lVG9GaWxlbmFtZSA9IChuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gcGF0aC5qb2luKC4uLm5hbWUuc3BsaXQoJy4nKSk7XG59O1xuXG5jb25zdCB0b1B5dGhvbk1ldGhvZE5hbWUgPSAobmFtZTogc3RyaW5nLCBwcm90ZWN0ZWRJdGVtID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xuICBsZXQgdmFsdWUgPSB0b1B5dGhvbklkZW50aWZpZXIodG9TbmFrZUNhc2UobmFtZSkpO1xuICBpZiAocHJvdGVjdGVkSXRlbSkge1xuICAgIHZhbHVlID0gYF8ke3ZhbHVlfWA7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgdG9QeXRob25Qcm9wZXJ0eU5hbWUgPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgY29uc3RhbnQgPSBmYWxzZSxcbiAgcHJvdGVjdGVkSXRlbSA9IGZhbHNlLFxuKTogc3RyaW5nID0+IHtcbiAgbGV0IHZhbHVlID0gdG9QeXRob25JZGVudGlmaWVyKHRvU25ha2VDYXNlKG5hbWUpKTtcblxuICBpZiAoY29uc3RhbnQpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBpZiAocHJvdGVjdGVkSXRlbSkge1xuICAgIHZhbHVlID0gYF8ke3ZhbHVlfWA7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZ2l2ZW4gc2lnbmF0dXJlJ3MgcGFyYW1ldGVyIG5hbWUgdG8gd2hhdCBzaG91bGQgYmUgZW1pdHRlZCBpbiBQeXRob24uIEl0IHNsdWdpZmllcyB0aGVcbiAqIHBvc2l0aW9uYWwgcGFyYW1ldGVyIG5hbWVzIHRoYXQgY29sbGlkZSB3aXRoIGEgbGlmdGVkIHByb3AgYnkgYXBwZW5kaW5nIHRyYWlsaW5nIGBfYC4gVGhlcmUgaXMgbm9cbiAqIHJpc2sgb2YgY29uZmxpY3Rpbmcgd2l0aCBhbiBvdGhlciBwb3NpdGlvbmFsIHBhcmFtZXRlciB0aGF0IGVuZHMgd2l0aCBhIGBfYCBjaGFyYWN0ZXIgYmVjYXVzZVxuICogdGhpcyBpcyBwcm9oaWJpdGVkIGJ5IHRoZSBganNpaWAgY29tcGlsZXIgKHBhcmFtZXRlciBuYW1lcyBNVVNUIGJlIGNhbWVsQ2FzZSwgYW5kIG9ubHkgYSBzaW5nbGVcbiAqIGBfYCBpcyBwZXJtaXR0ZWQgd2hlbiBpdCBpcyBvbiAqKmxlYWRpbmcqKiBwb3NpdGlvbilcbiAqXG4gKiBAcGFyYW0gbmFtZSAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciB0aGF0IG5lZWRzIGNvbnZlcnNpb24uXG4gKiBAcGFyYW0gbGlmdGVkUGFyYW1OYW1lcyAgdGhlIGxpc3Qgb2YgXCJsaWZ0ZWRcIiBrZXl3b3JkIHBhcmFtZXRlcnMgaW4gdGhpcyBzaWduYXR1cmUuIFRoaXMgbXVzdCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9taXR0ZWQgd2hlbiBnZW5lcmF0aW5nIGEgbmFtZSBmb3IgYSBwYXJhbWV0ZXIgdGhhdCAqKmlzKiogbGlmdGVkLlxuICovXG5mdW5jdGlvbiB0b1B5dGhvblBhcmFtZXRlck5hbWUoXG4gIG5hbWU6IHN0cmluZyxcbiAgbGlmdGVkUGFyYW1OYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpLFxuKTogc3RyaW5nIHtcbiAgbGV0IHJlc3VsdCA9IHRvUHl0aG9uSWRlbnRpZmllcih0b1NuYWtlQ2FzZShuYW1lKSk7XG5cbiAgd2hpbGUgKGxpZnRlZFBhcmFtTmFtZXMuaGFzKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgKz0gJ18nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3Qgc2V0RGlmZmVyZW5jZSA9IDxUPihzZXRBOiBTZXQ8VD4sIHNldEI6IFNldDxUPik6IFNldDxUPiA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8VD4oKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldEEpIHtcbiAgICBpZiAoIXNldEIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXN1bHQuYWRkKGl0ZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQcmVwYXJlIHB5dGhvbiBtZW1iZXJzIGZvciBlbWlzc2lvbi5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lLCB0aGV5IHdpbGwgYWxsIG1hcCB0byB0aGUgc2FtZSBweXRob25cbiAqIG5hbWUsIHNvIHdlIHdpbGwgZmlsdGVyIGFsbCBkZXByZWNhdGVkIG1lbWJlcnMgYW5kIGV4cGVjdCB0aGF0IHRoZXJlIHdpbGwgYmUgb25seSBvbmVcbiAqIGxlZnQuXG4gKlxuICogUmV0dXJucyB0aGUgbWVtYmVycyBpbiBhIHNvcnRlZCBsaXN0LlxuICovXG5mdW5jdGlvbiBwcmVwYXJlTWVtYmVycyhtZW1iZXJzOiBQeXRob25CYXNlW10sIHJlc29sdmVyOiBUeXBlUmVzb2x2ZXIpIHtcbiAgLy8gY3JlYXRlIGEgbWFwIGZyb20gcHl0aG9uIG5hbWUgdG8gbGlzdCBvZiBtZW1iZXJzXG4gIGNvbnN0IG1hcDogeyBbcHl0aG9uTmFtZTogc3RyaW5nXTogUHl0aG9uQmFzZVtdIH0gPSB7fTtcbiAgZm9yIChjb25zdCBtIG9mIG1lbWJlcnMpIHtcbiAgICBsZXQgbGlzdCA9IG1hcFttLnB5dGhvbk5hbWVdO1xuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IG1hcFttLnB5dGhvbk5hbWVdID0gW107XG4gICAgfVxuXG4gICAgbGlzdC5wdXNoKG0pO1xuICB9XG5cbiAgLy8gbm93IHJldHVybiBhbGwgdGhlIG1lbWJlcnNcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PFB5dGhvbkJhc2U+KCk7XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgbGlzdF0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgIGxldCBtZW1iZXI7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgYSBzaW5nbGUgbWVtYmVyIGZvciB0aGlzIG5vcm1hbGl6ZWQgbmFtZSwgdGhlbiB1c2UgaXRcbiAgICAgIG1lbWJlciA9IGxpc3RbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIGZvdW5kIG1vcmUgdGhhbiBvbmUgbWVtYmVyIHdpdGggdGhlIHNhbWUgcHl0aG9uIG5hbWUsIGZpbHRlciBhbGxcbiAgICAgIC8vIGRlcHJlY2F0ZWQgdmVyc2lvbnMgYW5kIGNoZWNrIHRoYXQgd2UgYXJlIGxlZnQgd2l0aCBleGFjdGx5IG9uZS5cbiAgICAgIC8vIG90aGVyd2lzZSwgdGhleSB3aWxsIG92ZXJ3cml0ZSBlYWNoIG90aGVyXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9qc2lpL2lzc3Vlcy8yNTA4XG4gICAgICBjb25zdCBub25EZXByZWNhdGVkID0gbGlzdC5maWx0ZXIoKHgpID0+ICFpc0RlcHJlY2F0ZWQoeCkpO1xuICAgICAgaWYgKG5vbkRlcHJlY2F0ZWQubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE11bHRpcGxlIG5vbi1kZXByZWNhdGVkIG1lbWJlcnMgd2hpY2ggbWFwIHRvIHRoZSBQeXRob24gbmFtZSBcIiR7bmFtZX1cImAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub25EZXByZWNhdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE11bHRpcGxlIG1lbWJlcnMgd2hpY2ggbWFwIHRvIHRoZSBQeXRob24gbmFtZSBcIiR7bmFtZX1cIiwgYnV0IGFsbCBvZiB0aGVtIGFyZSBkZXByZWNhdGVkYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbWVtYmVyID0gbm9uRGVwcmVjYXRlZFswXTtcbiAgICB9XG5cbiAgICByZXQucHVzaChtZW1iZXIpO1xuICB9XG5cbiAgcmV0dXJuIHNvcnRNZW1iZXJzKHJldCwgcmVzb2x2ZXIpO1xufVxuXG5jb25zdCBzb3J0TWVtYmVycyA9IChcbiAgbWVtYmVyczogUHl0aG9uQmFzZVtdLFxuICByZXNvbHZlcjogVHlwZVJlc29sdmVyLFxuKTogUHl0aG9uQmFzZVtdID0+IHtcbiAgbGV0IHNvcnRhYmxlID0gbmV3IEFycmF5PHtcbiAgICBtZW1iZXI6IFB5dGhvbkJhc2UgJiBJU29ydGFibGVUeXBlO1xuICAgIGRlcGVuZHNPbjogU2V0PFB5dGhvblR5cGU+O1xuICB9PigpO1xuICBjb25zdCBzb3J0ZWQgPSBuZXcgQXJyYXk8UHl0aG9uQmFzZT4oKTtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8UHl0aG9uQmFzZT4oKTtcblxuICAvLyBUaGUgZmlyc3QgdGhpbmcgd2Ugd2FudCB0byBkbywgaXMgcHVzaCBhbnkgaXRlbSB3aGljaCBpcyBub3Qgc29ydGFibGUgdG8gdGhlIHZlcnlcbiAgLy8gZnJvbnQgb2YgdGhlIGxpc3QuIFRoaXMgd2lsbCBiZSB0aGluZ3MgbGlrZSBtZXRob2RzLCBwcm9wZXJ0aWVzLCBldGMuXG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIG1lbWJlcnMpIHtcbiAgICBpZiAoIWlzU29ydGFibGVUeXBlKG1lbWJlcikpIHtcbiAgICAgIHNvcnRlZC5wdXNoKG1lbWJlcik7XG4gICAgICBzZWVuLmFkZChtZW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0YWJsZS5wdXNoKHsgbWVtYmVyLCBkZXBlbmRzT246IG5ldyBTZXQobWVtYmVyLmRlcGVuZHNPbihyZXNvbHZlcikpIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyB0aGF0IHdlJ3ZlIHB1bGxlZCBvdXQgZXZlcnl0aGluZyB0aGF0IGNvdWxkbid0IHBvc3NpYmx5IGhhdmUgZGVwZW5kZW5jaWVzLFxuICAvLyB3ZSB3aWxsIGdvIHRocm91Z2ggdGhlIHJlbWFpbmluZyBpdGVtcywgYW5kIHB1bGwgb2ZmIGFueSBpdGVtcyB3aGljaCBoYXZlIG5vXG4gIC8vIGRlcGVuZGVuY2llcyB0aGF0IHdlIGhhdmVuJ3QgYWxyZWFkeSBzb3J0ZWQuXG4gIHdoaWxlIChzb3J0YWJsZS5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChjb25zdCB7IG1lbWJlciwgZGVwZW5kc09uIH0gb2Ygc29ydGFibGUpIHtcbiAgICAgIGNvbnN0IGRpZmYgPSBzZXREaWZmZXJlbmNlKGRlcGVuZHNPbiwgc2Vlbik7XG4gICAgICBpZiAoWy4uLmRpZmZdLmZpbmQoKGRlcCkgPT4gIShkZXAgaW5zdGFuY2VvZiBQeXRob25Nb2R1bGUpKSA9PSBudWxsKSB7XG4gICAgICAgIHNvcnRlZC5wdXNoKG1lbWJlcik7XG4gICAgICAgIHNlZW4uYWRkKG1lbWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGVmdG92ZXIgPSBzb3J0YWJsZS5maWx0ZXIoKHsgbWVtYmVyIH0pID0+ICFzZWVuLmhhcyhtZW1iZXIpKTtcbiAgICBpZiAobGVmdG92ZXIubGVuZ3RoID09PSBzb3J0YWJsZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvdWxkIG5vdCBzb3J0IG1lbWJlcnMgKGNpcmN1bGFyIGRlcGVuZGVuY3k/KS4gTGVmdG92ZXI6ICR7bGVmdG92ZXJcbiAgICAgICAgICAubWFwKChsbykgPT4gbG8ubWVtYmVyLnB5dGhvbk5hbWUpXG4gICAgICAgICAgLmpvaW4oJywgJyl9YCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvcnRhYmxlID0gbGVmdG92ZXI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvcnRlZDtcbn07XG5cbmludGVyZmFjZSBQeXRob25CYXNlIHtcbiAgcmVhZG9ubHkgcHl0aG9uTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBkb2NzPzogc3BlYy5Eb2NzO1xuXG4gIGVtaXQoY29kZTogQ29kZU1ha2VyLCBjb250ZXh0OiBFbWl0Q29udGV4dCwgb3B0cz86IGFueSk6IHZvaWQ7XG5cbiAgcmVxdWlyZWRJbXBvcnRzKGNvbnRleHQ6IEVtaXRDb250ZXh0KTogUHl0aG9uSW1wb3J0cztcbn1cblxuaW50ZXJmYWNlIFB5dGhvblR5cGUgZXh0ZW5kcyBQeXRob25CYXNlIHtcbiAgLy8gVGhlIEpTSUkgRlFOIGZvciB0aGlzIGl0ZW0sIGlmIHRoaXMgaXRlbSBkb2Vzbid0IGV4aXN0IGFzIGEgSlNJSSB0eXBlLCB0aGVuIGl0XG4gIC8vIGRvZXNuJ3QgaGF2ZSBhIEZRTiBhbmQgaXQgc2hvdWxkIGJlIG51bGw7XG4gIHJlYWRvbmx5IGZxbj86IHN0cmluZztcblxuICBhZGRNZW1iZXIobWVtYmVyOiBQeXRob25CYXNlKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIElTb3J0YWJsZVR5cGUge1xuICBkZXBlbmRzT24ocmVzb2x2ZXI6IFR5cGVSZXNvbHZlcik6IFB5dGhvblR5cGVbXTtcbn1cblxuZnVuY3Rpb24gaXNTb3J0YWJsZVR5cGUoYXJnOiB1bmtub3duKTogYXJnIGlzIElTb3J0YWJsZVR5cGUge1xuICByZXR1cm4gKGFyZyBhcyBQYXJ0aWFsPElTb3J0YWJsZVR5cGU+KS5kZXBlbmRzT24gIT09IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIFB5dGhvblR5cGVPcHRzIHtcbiAgYmFzZXM/OiBzcGVjLlR5cGVSZWZlcmVuY2VbXTtcbn1cblxuYWJzdHJhY3QgY2xhc3MgQmFzZVB5dGhvbkNsYXNzVHlwZSBpbXBsZW1lbnRzIFB5dGhvblR5cGUsIElTb3J0YWJsZVR5cGUge1xuICBwcm90ZWN0ZWQgYmFzZXM6IHNwZWMuVHlwZVJlZmVyZW5jZVtdO1xuICBwcm90ZWN0ZWQgbWVtYmVyczogUHl0aG9uQmFzZVtdO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc2VwYXJhdGVNZW1iZXJzOiBib29sZWFuID0gdHJ1ZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGdlbmVyYXRvcjogUHl0aG9uR2VuZXJhdG9yLFxuICAgIHB1YmxpYyByZWFkb25seSBweXRob25OYW1lOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHNwZWM6IHNwZWMuVHlwZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZnFuOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgb3B0czogUHl0aG9uVHlwZU9wdHMsXG4gICAgcHVibGljIHJlYWRvbmx5IGRvY3M6IHNwZWMuRG9jcyB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgY29uc3QgeyBiYXNlcyA9IFtdIH0gPSBvcHRzO1xuXG4gICAgdGhpcy5iYXNlcyA9IGJhc2VzO1xuICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICB9XG5cbiAgcHVibGljIGRlcGVuZHNPbihyZXNvbHZlcjogVHlwZVJlc29sdmVyKTogUHl0aG9uVHlwZVtdIHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBuZXcgQXJyYXk8UHl0aG9uVHlwZT4oKTtcbiAgICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5nZXRQYXJlbnQodGhpcy5mcW4hKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmV0dXJuIGFueSBiYXNlcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBtb2R1bGUgYXQgdGhlIHNhbWUgbGV2ZWwgb2ZcbiAgICAvLyBuZXN0aW5nLlxuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IGJhc2Ugb2YgdGhpcy5iYXNlcykge1xuICAgICAgaWYgKHNwZWMuaXNOYW1lZFR5cGVSZWZlcmVuY2UoYmFzZSkpIHtcbiAgICAgICAgaWYgKHJlc29sdmVyLmlzSW5Nb2R1bGUoYmFzZSkpIHtcbiAgICAgICAgICAvLyBHaXZlbiBhIGJhc2UsIHdlIG5lZWQgdG8gbG9jYXRlIHRoZSBiYXNlJ3MgcGFyZW50IHRoYXQgaXMgdGhlIHNhbWUgYXNcbiAgICAgICAgICAvLyBvdXIgcGFyZW50LCBiZWNhdXNlIHdlIG9ubHkgY2FyZSBhYm91dCBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgYXQgdGhlXG4gICAgICAgICAgLy8gc2FtZSBsZXZlbCBvZiBvdXIgb3duLlxuICAgICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IG5lZWQgdG8gcmVjdXJzZSBpbnRvIG91ciBtZW1iZXJzIHRvIGFsc28gZmluZCB0aGVpclxuICAgICAgICAgIC8vICAgICAgIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICBsZXQgYmFzZUl0ZW0gPSByZXNvbHZlci5nZXRUeXBlKGJhc2UpO1xuICAgICAgICAgIGxldCBiYXNlUGFyZW50ID0gcmVzb2x2ZXIuZ2V0UGFyZW50KGJhc2UpO1xuICAgICAgICAgIHdoaWxlIChiYXNlUGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGJhc2VJdGVtID0gYmFzZVBhcmVudDtcbiAgICAgICAgICAgIGJhc2VQYXJlbnQgPSByZXNvbHZlci5nZXRQYXJlbnQoYmFzZUl0ZW0uZnFuISk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzZWVuLmhhcyhiYXNlSXRlbS5mcW4hKSkge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYmFzZUl0ZW0pO1xuICAgICAgICAgICAgc2Vlbi5hZGQoYmFzZUl0ZW0uZnFuISk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogRW1pdENvbnRleHQpOiBQeXRob25JbXBvcnRzIHtcbiAgICByZXR1cm4gbWVyZ2VQeXRob25JbXBvcnRzKFxuICAgICAgLi4udGhpcy5iYXNlcy5tYXAoKGJhc2UpID0+IHRvVHlwZU5hbWUoYmFzZSkucmVxdWlyZWRJbXBvcnRzKGNvbnRleHQpKSxcbiAgICAgIC4uLnRoaXMubWVtYmVycy5tYXAoKG1lbSkgPT4gbWVtLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSksXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRNZW1iZXIobWVtYmVyOiBQeXRob25CYXNlKSB7XG4gICAgdGhpcy5tZW1iZXJzLnB1c2gobWVtYmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpTG9jYXRpb24oKTogQXBpTG9jYXRpb24ge1xuICAgIGlmICghdGhpcy5mcW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBtYWtlIGFwaUxvY2F0aW9uIGZvciAke3RoaXMucHl0aG9uTmFtZX0sIGRvZXMgbm90IGhhdmUgRlFOYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IGFwaTogJ3R5cGUnLCBmcW46IHRoaXMuZnFuIH07XG4gIH1cblxuICBwdWJsaWMgZW1pdChjb2RlOiBDb2RlTWFrZXIsIGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgY29udGV4dCA9IG5lc3RlZENvbnRleHQoY29udGV4dCwgdGhpcy5mcW4pO1xuXG4gICAgY29uc3QgY2xhc3NQYXJhbXMgPSB0aGlzLmdldENsYXNzUGFyYW1zKGNvbnRleHQpO1xuICAgIG9wZW5TaWduYXR1cmUoY29kZSwgJ2NsYXNzJywgdGhpcy5weXRob25OYW1lLCBjbGFzc1BhcmFtcyk7XG5cbiAgICB0aGlzLmdlbmVyYXRvci5lbWl0RG9jU3RyaW5nKGNvZGUsIHRoaXMuYXBpTG9jYXRpb24sIHRoaXMuZG9jcywge1xuICAgICAgZG9jdW1lbnRhYmxlSXRlbTogYGNsYXNzLSR7dGhpcy5weXRob25OYW1lfWAsXG4gICAgICB0cmFpbGluZ05ld0xpbmU6IHRydWUsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gdGhpcy5ib3VuZFJlc29sdmVyKGNvbnRleHQucmVzb2x2ZXIpO1xuICAgICAgbGV0IHNob3VsZFNlcGFyYXRlID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBwcmVwYXJlTWVtYmVycyh0aGlzLm1lbWJlcnMsIHJlc29sdmVyKSkge1xuICAgICAgICBpZiAoc2hvdWxkU2VwYXJhdGUpIHtcbiAgICAgICAgICBjb2RlLmxpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzaG91bGRTZXBhcmF0ZSA9IHRoaXMuc2VwYXJhdGVNZW1iZXJzO1xuICAgICAgICBtZW1iZXIuZW1pdChjb2RlLCB7IC4uLmNvbnRleHQsIHJlc29sdmVyIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLmxpbmUoJ3Bhc3MnKTtcbiAgICB9XG5cbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcblxuICAgIGlmICh0aGlzLmZxbiAhPSBudWxsKSB7XG4gICAgICBjb250ZXh0LmVtaXR0ZWRUeXBlcy5hZGQodGhpcy5mcW4pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBib3VuZFJlc29sdmVyKHJlc29sdmVyOiBUeXBlUmVzb2x2ZXIpOiBUeXBlUmVzb2x2ZXIge1xuICAgIGlmICh0aGlzLmZxbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlci5iaW5kKHRoaXMuZnFuKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBnZXRDbGFzc1BhcmFtcyhjb250ZXh0OiBFbWl0Q29udGV4dCk6IHN0cmluZ1tdO1xufVxuXG5pbnRlcmZhY2UgQmFzZU1ldGhvZE9wdHMge1xuICBhYnN0cmFjdD86IGJvb2xlYW47XG4gIGxpZnRlZFByb3A/OiBzcGVjLkludGVyZmFjZVR5cGU7XG4gIHBhcmVudDogc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2U7XG59XG5cbmludGVyZmFjZSBCYXNlTWV0aG9kRW1pdE9wdHMge1xuICByZW5kZXJBYnN0cmFjdD86IGJvb2xlYW47XG4gIGZvcmNlRW1pdEJvZHk/OiBib29sZWFuO1xufVxuXG5hYnN0cmFjdCBjbGFzcyBCYXNlTWV0aG9kIGltcGxlbWVudHMgUHl0aG9uQmFzZSB7XG4gIHB1YmxpYyByZWFkb25seSBhYnN0cmFjdDogYm9vbGVhbjtcblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhZG9ubHkgaW1wbGljaXRQYXJhbWV0ZXI6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlNZXRob2QhOiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBkZWNvcmF0b3I/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBjbGFzc0FzRmlyc3RQYXJhbWV0ZXI6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHJldHVybkZyb21KU0lJTWV0aG9kOiBib29sZWFuID0gdHJ1ZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHNob3VsZEVtaXRCb2R5OiBib29sZWFuID0gdHJ1ZTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGxpZnRlZFByb3A/OiBzcGVjLkludGVyZmFjZVR5cGU7XG4gIHByaXZhdGUgcmVhZG9ubHkgcGFyZW50OiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGdlbmVyYXRvcjogUHl0aG9uR2VuZXJhdG9yLFxuICAgIHB1YmxpYyByZWFkb25seSBweXRob25OYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBqc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcmFtZXRlcnM6IHNwZWMuUGFyYW1ldGVyW10sXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXR1cm5zOiBzcGVjLk9wdGlvbmFsVmFsdWUgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IGRvY3M6IHNwZWMuRG9jcyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgaXNTdGF0aWM6IGJvb2xlYW4sXG4gICAgb3B0czogQmFzZU1ldGhvZE9wdHMsXG4gICkge1xuICAgIHRoaXMuYWJzdHJhY3QgPSAhIW9wdHMuYWJzdHJhY3Q7XG4gICAgdGhpcy5saWZ0ZWRQcm9wID0gb3B0cy5saWZ0ZWRQcm9wO1xuICAgIHRoaXMucGFyZW50ID0gb3B0cy5wYXJlbnQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFwaUxvY2F0aW9uKCk6IEFwaUxvY2F0aW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXBpOiAnbWVtYmVyJyxcbiAgICAgIGZxbjogdGhpcy5wYXJlbnQuZnFuLFxuICAgICAgbWVtYmVyTmFtZTogdGhpcy5qc05hbWUgPz8gJycsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogRW1pdENvbnRleHQpOiBQeXRob25JbXBvcnRzIHtcbiAgICByZXR1cm4gbWVyZ2VQeXRob25JbXBvcnRzKFxuICAgICAgdG9UeXBlTmFtZSh0aGlzLnJldHVybnMpLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSxcbiAgICAgIC4uLnRoaXMucGFyYW1ldGVycy5tYXAoKHBhcmFtKSA9PlxuICAgICAgICB0b1R5cGVOYW1lKHBhcmFtKS5yZXF1aXJlZEltcG9ydHMoY29udGV4dCksXG4gICAgICApLFxuICAgICAgLi4ubGlmdGVkUHJvcGVydGllcyh0aGlzLmxpZnRlZFByb3ApLFxuICAgICk7XG5cbiAgICBmdW5jdGlvbiogbGlmdGVkUHJvcGVydGllcyhcbiAgICAgIHN0cnVjdDogc3BlYy5JbnRlcmZhY2VUeXBlIHwgdW5kZWZpbmVkLFxuICAgICk6IEl0ZXJhYmxlSXRlcmF0b3I8UHl0aG9uSW1wb3J0cz4ge1xuICAgICAgaWYgKHN0cnVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzdHJ1Y3QucHJvcGVydGllcyA/PyBbXSkge1xuICAgICAgICB5aWVsZCB0b1R5cGVOYW1lKHByb3AudHlwZSkucmVxdWlyZWRJbXBvcnRzKGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBiYXNlIG9mIHN0cnVjdC5pbnRlcmZhY2VzID8/IFtdKSB7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gY29udGV4dC5yZXNvbHZlci5kZXJlZmVyZW5jZShiYXNlKSBhcyBzcGVjLkludGVyZmFjZVR5cGU7XG4gICAgICAgIGZvciAoY29uc3QgaW1wb3J0cyBvZiBsaWZ0ZWRQcm9wZXJ0aWVzKGlmYWNlKSkge1xuICAgICAgICAgIHlpZWxkIGltcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZW1pdChcbiAgICBjb2RlOiBDb2RlTWFrZXIsXG4gICAgY29udGV4dDogRW1pdENvbnRleHQsXG4gICAgb3B0cz86IEJhc2VNZXRob2RFbWl0T3B0cyxcbiAgKSB7XG4gICAgY29uc3QgeyByZW5kZXJBYnN0cmFjdCA9IHRydWUsIGZvcmNlRW1pdEJvZHkgPSBmYWxzZSB9ID0gb3B0cyA/PyB7fTtcblxuICAgIGNvbnN0IHJldHVyblR5cGU6IHN0cmluZyA9IHRvVHlwZU5hbWUodGhpcy5yZXR1cm5zKS5weXRob25UeXBlKGNvbnRleHQpO1xuXG4gICAgLy8gV2UgY2Fubm90IChjdXJyZW50bHk/KSBibGluZGx5IHVzZSB0aGUgbmFtZXMgZ2l2ZW4gdG8gdXMgYnkgdGhlIEpTSUkgZm9yXG4gICAgLy8gaW5pdGlhbGl6ZXJzLCBiZWNhdXNlIG91ciBrZXl3b3JkIGxpZnRpbmcgd2lsbCBhbGxvdyB0d28gbmFtZXMgdG8gY2xhc2guXG4gICAgLy8gVGhpcyBjYW4gaG9wZWZ1bGx5IGJlIHJlbW92ZWQgb25jZSB3ZSBnZXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9qc2lpL2lzc3Vlcy8yODhcbiAgICAvLyByZXNvbHZlZCwgc28gYnVpbGQgdXAgYSBsaXN0IG9mIGFsbCBvZiB0aGUgcHJvcCBuYW1lcyBzbyB3ZSBjYW4gY2hlY2sgYWdhaW5zdFxuICAgIC8vIHRoZW0gbGF0ZXIuXG4gICAgY29uc3QgbGlmdGVkUHJvcE5hbWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgaWYgKHRoaXMubGlmdGVkUHJvcD8ucHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgdGhpcy5saWZ0ZWRQcm9wLnByb3BlcnRpZXMpIHtcbiAgICAgICAgbGlmdGVkUHJvcE5hbWVzLmFkZCh0b1B5dGhvblBhcmFtZXRlck5hbWUocHJvcC5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byB0dXJuIGEgbGlzdCBvZiBKU0lJIHBhcmFtZXRlcnMsIGludG8gUHl0aG9uIHN0eWxlIGFyZ3VtZW50cyB3aXRoXG4gICAgLy8gZ3JhZHVhbCB0eXBpbmcsIHNvIHdlJ2xsIGhhdmUgdG8gaXRlcmF0ZSBvdmVyIHRoZSBsaXN0IG9mIHBhcmFtZXRlcnMsIGFuZFxuICAgIC8vIGJ1aWxkIHRoZSBsaXN0LCBjb252ZXJ0aW5nIGFzIHdlIGdvLlxuICAgIGNvbnN0IHB5dGhvblBhcmFtczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMucGFyYW1ldGVycykge1xuICAgICAgLy8gV2UgY2Fubm90IChjdXJyZW50bHk/KSBibGluZGx5IHVzZSB0aGUgbmFtZXMgZ2l2ZW4gdG8gdXMgYnkgdGhlIEpTSUkgZm9yXG4gICAgICAvLyBpbml0aWFsaXplcnMsIGJlY2F1c2Ugb3VyIGtleXdvcmQgbGlmdGluZyB3aWxsIGFsbG93IHR3byBuYW1lcyB0byBjbGFzaC5cbiAgICAgIC8vIFRoaXMgY2FuIGhvcGVmdWxseSBiZSByZW1vdmVkIG9uY2Ugd2UgZ2V0IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9pc3N1ZXMvMjg4XG4gICAgICAvLyByZXNvbHZlZC5cbiAgICAgIGNvbnN0IHBhcmFtTmFtZTogc3RyaW5nID0gdG9QeXRob25QYXJhbWV0ZXJOYW1lKFxuICAgICAgICBwYXJhbS5uYW1lLFxuICAgICAgICBsaWZ0ZWRQcm9wTmFtZXMsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwYXJhbVR5cGUgPSB0b1R5cGVOYW1lKHBhcmFtKS5weXRob25UeXBlKHtcbiAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgcGFyYW1ldGVyVHlwZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyYW1EZWZhdWx0ID0gcGFyYW0ub3B0aW9uYWwgPyAnID0gTm9uZScgOiAnJztcblxuICAgICAgcHl0aG9uUGFyYW1zLnB1c2goYCR7cGFyYW1OYW1lfTogJHtwYXJhbVR5cGV9JHtwYXJhbURlZmF1bHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZG9jdW1lbnRhYmxlQXJnczogRG9jdW1lbnRhYmxlQXJndW1lbnRbXSA9IHRoaXMucGFyYW1ldGVyc1xuICAgICAgLm1hcChcbiAgICAgICAgKHApID0+XG4gICAgICAgICAgKHtcbiAgICAgICAgICAgIG5hbWU6IHAubmFtZSxcbiAgICAgICAgICAgIGRvY3M6IHAuZG9jcyxcbiAgICAgICAgICAgIGRlZmluaW5nVHlwZTogdGhpcy5wYXJlbnQsXG4gICAgICAgICAgfSBhcyBEb2N1bWVudGFibGVBcmd1bWVudCksXG4gICAgICApXG4gICAgICAvLyBJZiB0aGVyZSdzIGxpZnRlZFByb3BzLCB0aGUgbGFzdCBhcmd1bWVudCBpcyB0aGUgc3RydWN0IGFuZCBpdCB3b24ndCBiZSBfYWN0dWFsbHlfIGVtaXR0ZWQuXG4gICAgICAuZmlsdGVyKChfLCBpbmRleCkgPT5cbiAgICAgICAgdGhpcy5saWZ0ZWRQcm9wICE9IG51bGwgPyBpbmRleCA8IHRoaXMucGFyYW1ldGVycy5sZW5ndGggLSAxIDogdHJ1ZSxcbiAgICAgIClcbiAgICAgIC5tYXAoKHBhcmFtKSA9PiAoe1xuICAgICAgICAuLi5wYXJhbSxcbiAgICAgICAgbmFtZTogdG9QeXRob25QYXJhbWV0ZXJOYW1lKHBhcmFtLm5hbWUsIGxpZnRlZFByb3BOYW1lcyksXG4gICAgICB9KSk7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgbGlmdGVkIHBhcmFtZXRlciwgdGhlbiB3ZSdsbCBkcm9wIHRoZSBsYXN0IGFyZ3VtZW50IHRvIG91ciBwYXJhbXNcbiAgICAvLyBhbmQgdGhlbiB3ZSdsbCBsaWZ0IGFsbCBvZiB0aGUgcGFyYW1zIG9mIHRoZSBsaWZ0ZWQgdHlwZSBhcyBrZXl3b3JkIGFyZ3VtZW50c1xuICAgIC8vIHRvIHRoZSBmdW5jdGlvbi5cbiAgICBpZiAodGhpcy5saWZ0ZWRQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFJlbW92ZSBvdXIgbGFzdCBpdGVtLlxuICAgICAgcHl0aG9uUGFyYW1zLnBvcCgpO1xuICAgICAgY29uc3QgbGlmdGVkUHJvcGVydGllcyA9IHRoaXMuZ2V0TGlmdGVkUHJvcGVydGllcyhjb250ZXh0LnJlc29sdmVyKTtcblxuICAgICAgaWYgKGxpZnRlZFByb3BlcnRpZXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgLy8gQWxsIG9mIHRoZXNlIHBhcmFtZXRlcnMgYXJlIGtleXdvcmQgb25seSBhcmd1bWVudHMsIHNvIHdlJ2xsIG1hcmsgdGhlbVxuICAgICAgICAvLyBhcyBzdWNoLlxuICAgICAgICBweXRob25QYXJhbXMucHVzaCgnKicpO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgb2Ygb3VyIHByb3BzLCBhbmQgcmVmbGVjdCB0aGVtIGludG8gb3VyIHBhcmFtcy5cbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGxpZnRlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICBjb25zdCBwYXJhbU5hbWUgPSB0b1B5dGhvblBhcmFtZXRlck5hbWUocHJvcC5wcm9wLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IHRvVHlwZU5hbWUocHJvcC5wcm9wKS5weXRob25UeXBlKHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJUeXBlOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHBhcmFtRGVmYXVsdCA9IHByb3AucHJvcC5vcHRpb25hbCA/ICcgPSBOb25lJyA6ICcnO1xuXG4gICAgICAgICAgcHl0aG9uUGFyYW1zLnB1c2goYCR7cGFyYW1OYW1lfTogJHtwYXJhbVR5cGV9JHtwYXJhbURlZmF1bHR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG9jdW1lbnQgdGhlbSBhcyBrZXl3b3JkIGFyZ3VtZW50c1xuICAgICAgZG9jdW1lbnRhYmxlQXJncy5wdXNoKFxuICAgICAgICAuLi5saWZ0ZWRQcm9wZXJ0aWVzLm1hcChcbiAgICAgICAgICAocCkgPT5cbiAgICAgICAgICAgICh7XG4gICAgICAgICAgICAgIG5hbWU6IHAucHJvcC5uYW1lLFxuICAgICAgICAgICAgICBkb2NzOiBwLnByb3AuZG9jcyxcbiAgICAgICAgICAgICAgZGVmaW5pbmdUeXBlOiBwLmRlZmluaW5nVHlwZSxcbiAgICAgICAgICAgIH0gYXMgRG9jdW1lbnRhYmxlQXJndW1lbnQpLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5wYXJhbWV0ZXJzLmxlbmd0aCA+PSAxICYmXG4gICAgICB0aGlzLnBhcmFtZXRlcnNbdGhpcy5wYXJhbWV0ZXJzLmxlbmd0aCAtIDFdLnZhcmlhZGljXG4gICAgKSB7XG4gICAgICAvLyBBbm90aGVyIHNpdHVhdGlvbiB3ZSBjb3VsZCBiZSBpbiwgaXMgdGhhdCBpbnN0ZWFkIG9mIGhhdmluZyBhIHBsYWluIHBhcmFtZXRlclxuICAgICAgLy8gd2UgaGF2ZSBhIHZhcmlhZGljIHBhcmFtZXRlciB3aGVyZSB3ZSBuZWVkIHRvIGV4cGFuZCB0aGUgbGFzdCBwYXJhbWV0ZXIgYXMgYVxuICAgICAgLy8gKmFyZ3MuXG4gICAgICBweXRob25QYXJhbXMucG9wKCk7XG5cbiAgICAgIGNvbnN0IGxhc3RQYXJhbWV0ZXIgPSB0aGlzLnBhcmFtZXRlcnMuc2xpY2UoLTEpWzBdO1xuICAgICAgY29uc3QgcGFyYW1OYW1lID0gdG9QeXRob25QYXJhbWV0ZXJOYW1lKGxhc3RQYXJhbWV0ZXIubmFtZSk7XG4gICAgICBjb25zdCBwYXJhbVR5cGUgPSB0b1R5cGVOYW1lKGxhc3RQYXJhbWV0ZXIudHlwZSkucHl0aG9uVHlwZShjb250ZXh0KTtcblxuICAgICAgcHl0aG9uUGFyYW1zLnB1c2goYCoke3BhcmFtTmFtZX06ICR7cGFyYW1UeXBlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY29yYXRvcnMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgaWYgKHRoaXMuanNOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFwiIyB0eXBlOiBpZ25vcmVbbWlzY11cIiBuZWVkZWQgYmVjYXVzZSBteXB5IGRvZXMgbm90IGtub3cgaG93IHRvIGNoZWNrIGRlY29yYXRlZCBkZWNsYXJhdGlvbnNcbiAgICAgIGRlY29yYXRvcnMucHVzaChgQGpzaWkubWVtYmVyKGpzaWlfbmFtZT1cIiR7dGhpcy5qc05hbWV9XCIpYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGVjb3JhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlY29yYXRvcnMucHVzaChgQCR7dGhpcy5kZWNvcmF0b3J9YCk7XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlckFic3RyYWN0ICYmIHRoaXMuYWJzdHJhY3QpIHtcbiAgICAgIGRlY29yYXRvcnMucHVzaCgnQGFiYy5hYnN0cmFjdG1ldGhvZCcpO1xuICAgIH1cblxuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFwiIyB0eXBlOiBpZ25vcmVbbWlzY11cIiBuZWVkZWQgYmVjYXVzZSBteXB5IGRvZXMgbm90IGtub3cgaG93IHRvIGNoZWNrIGRlY29yYXRlZCBkZWNsYXJhdGlvbnNcbiAgICAgIGZvciAoY29uc3QgZGVjb3JhdG9yIG9mIGRlY29yYXRvcnNcbiAgICAgICAgLmpvaW4oJyAjIHR5cGU6IGlnbm9yZVttaXNjXVxcbicpXG4gICAgICAgIC5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgY29kZS5saW5lKGRlY29yYXRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHl0aG9uUGFyYW1zLnVuc2hpZnQoXG4gICAgICBzbHVnaWZ5QXNOZWVkZWQoXG4gICAgICAgIHRoaXMuaW1wbGljaXRQYXJhbWV0ZXIsXG4gICAgICAgIHB5dGhvblBhcmFtcy5tYXAoKHBhcmFtKSA9PiBwYXJhbS5zcGxpdCgnOicpWzBdLnRyaW0oKSksXG4gICAgICApLFxuICAgICk7XG5cbiAgICBvcGVuU2lnbmF0dXJlKFxuICAgICAgY29kZSxcbiAgICAgICdkZWYnLFxuICAgICAgdGhpcy5weXRob25OYW1lLFxuICAgICAgcHl0aG9uUGFyYW1zLFxuICAgICAgZmFsc2UsXG4gICAgICByZXR1cm5UeXBlLFxuICAgICk7XG4gICAgdGhpcy5nZW5lcmF0b3IuZW1pdERvY1N0cmluZyhjb2RlLCB0aGlzLmFwaUxvY2F0aW9uLCB0aGlzLmRvY3MsIHtcbiAgICAgIGFyZ3VtZW50czogZG9jdW1lbnRhYmxlQXJncyxcbiAgICAgIGRvY3VtZW50YWJsZUl0ZW06IGBtZXRob2QtJHt0aGlzLnB5dGhvbk5hbWV9YCxcbiAgICB9KTtcbiAgICB0aGlzLmVtaXRCb2R5KFxuICAgICAgY29kZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICByZW5kZXJBYnN0cmFjdCxcbiAgICAgIGZvcmNlRW1pdEJvZHksXG4gICAgICBsaWZ0ZWRQcm9wTmFtZXMsXG4gICAgICBweXRob25QYXJhbXNbMF0sXG4gICAgICByZXR1cm5UeXBlLFxuICAgICk7XG4gICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRCb2R5KFxuICAgIGNvZGU6IENvZGVNYWtlcixcbiAgICBjb250ZXh0OiBFbWl0Q29udGV4dCxcbiAgICByZW5kZXJBYnN0cmFjdDogYm9vbGVhbixcbiAgICBmb3JjZUVtaXRCb2R5OiBib29sZWFuLFxuICAgIGxpZnRlZFByb3BOYW1lczogU2V0PHN0cmluZz4sXG4gICAgaW1wbGljaXRQYXJhbWV0ZXI6IHN0cmluZyxcbiAgICByZXR1cm5UeXBlOiBzdHJpbmcsXG4gICkge1xuICAgIGlmIChcbiAgICAgICghdGhpcy5zaG91bGRFbWl0Qm9keSAmJiAhZm9yY2VFbWl0Qm9keSkgfHxcbiAgICAgIChyZW5kZXJBYnN0cmFjdCAmJiB0aGlzLmFic3RyYWN0KVxuICAgICkge1xuICAgICAgY29kZS5saW5lKCcuLi4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubGlmdGVkUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW1pdEF1dG9Qcm9wcyhjb2RlLCBjb250ZXh0LCBsaWZ0ZWRQcm9wTmFtZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXRKc2lpTWV0aG9kQ2FsbChcbiAgICAgICAgY29kZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGlmdGVkUHJvcE5hbWVzLFxuICAgICAgICBpbXBsaWNpdFBhcmFtZXRlcixcbiAgICAgICAgcmV0dXJuVHlwZSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbWl0QXV0b1Byb3BzKFxuICAgIGNvZGU6IENvZGVNYWtlcixcbiAgICBjb250ZXh0OiBFbWl0Q29udGV4dCxcbiAgICBsaWZ0ZWRQcm9wTmFtZXM6IFNldDxzdHJpbmc+LFxuICApIHtcbiAgICBjb25zdCBsYXN0UGFyYW1ldGVyID0gdGhpcy5wYXJhbWV0ZXJzLnNsaWNlKC0xKVswXTtcbiAgICBjb25zdCBhcmdOYW1lID0gdG9QeXRob25QYXJhbWV0ZXJOYW1lKGxhc3RQYXJhbWV0ZXIubmFtZSwgbGlmdGVkUHJvcE5hbWVzKTtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHRvVHlwZU5hbWUobGFzdFBhcmFtZXRlci50eXBlKS5weXRob25UeXBlKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICB0eXBlQW5ub3RhdGlvbjogZmFsc2UsXG4gICAgfSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGJ1aWxkIHVwIGEgbGlzdCBvZiBwcm9wZXJ0aWVzLCB3aGljaCBhcmUgbWFuZGF0b3J5LCB0aGVzZSBhcmUgdGhlXG4gICAgLy8gb25lcyB3ZSB3aWxsIHNwZWNpZml5IHRvIHN0YXJ0IHdpdGggaW4gb3VyIGRpY3Rpb25hcnkgbGl0ZXJhbC5cbiAgICBjb25zdCBsaWZ0ZWRQcm9wcyA9IHRoaXMuZ2V0TGlmdGVkUHJvcGVydGllcyhjb250ZXh0LnJlc29sdmVyKS5tYXAoXG4gICAgICAocCkgPT4gbmV3IFN0cnVjdEZpZWxkKHRoaXMuZ2VuZXJhdG9yLCBwLnByb3AsIHAuZGVmaW5pbmdUeXBlKSxcbiAgICApO1xuICAgIGNvbnN0IGFzc2lnbm1lbnRzID0gbGlmdGVkUHJvcHNcbiAgICAgIC5tYXAoKHApID0+IHAucHl0aG9uTmFtZSlcbiAgICAgIC5tYXAoKHYpID0+IGAke3Z9PSR7dn1gKTtcblxuICAgIGFzc2lnbkNhbGxSZXN1bHQoY29kZSwgYXJnTmFtZSwgdHlwZU5hbWUsIGFzc2lnbm1lbnRzKTtcbiAgICBjb2RlLmxpbmUoKTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdEpzaWlNZXRob2RDYWxsKFxuICAgIGNvZGU6IENvZGVNYWtlcixcbiAgICBjb250ZXh0OiBFbWl0Q29udGV4dCxcbiAgICBsaWZ0ZWRQcm9wTmFtZXM6IFNldDxzdHJpbmc+LFxuICAgIGltcGxpY2l0UGFyYW1ldGVyOiBzdHJpbmcsXG4gICAgcmV0dXJuVHlwZTogc3RyaW5nLFxuICApIHtcbiAgICBjb25zdCBtZXRob2RQcmVmaXg6IHN0cmluZyA9IHRoaXMucmV0dXJuRnJvbUpTSUlNZXRob2QgPyAncmV0dXJuICcgOiAnJztcblxuICAgIGNvbnN0IGpzaWlNZXRob2RQYXJhbXM6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKHRoaXMuY2xhc3NBc0ZpcnN0UGFyYW1ldGVyKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBub3Qga25vd24uJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1N0YXRpYykge1xuICAgICAgICBqc2lpTWV0aG9kUGFyYW1zLnB1c2goXG4gICAgICAgICAgdG9UeXBlTmFtZSh0aGlzLnBhcmVudCkucHl0aG9uVHlwZSh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgdHlwZUFubm90YXRpb246IGZhbHNlLFxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNpbmcgdGhlIGR5bmFtaWMgY2xhc3Mgb2YgYHNlbGZgLlxuICAgICAgICBqc2lpTWV0aG9kUGFyYW1zLnB1c2goYCR7aW1wbGljaXRQYXJhbWV0ZXJ9Ll9fY2xhc3NfX2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBqc2lpTWV0aG9kUGFyYW1zLnB1c2goaW1wbGljaXRQYXJhbWV0ZXIpO1xuICAgIGlmICh0aGlzLmpzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBqc2lpTWV0aG9kUGFyYW1zLnB1c2goYFwiJHt0aGlzLmpzTmFtZX1cImApO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBsYXN0IGFyZyBpcyB2YXJpYWRpYywgZXhwYW5kIHRoZSB0dXBsZVxuICAgIGNvbnN0IHBhcmFtczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMucGFyYW1ldGVycykge1xuICAgICAgbGV0IGV4cHIgPSB0b1B5dGhvblBhcmFtZXRlck5hbWUocGFyYW0ubmFtZSwgbGlmdGVkUHJvcE5hbWVzKTtcbiAgICAgIGlmIChwYXJhbS52YXJpYWRpYykge1xuICAgICAgICBleHByID0gYCoke2V4cHJ9YDtcbiAgICAgIH1cbiAgICAgIHBhcmFtcy5wdXNoKGV4cHIpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gYGpzaWkuJHt0aGlzLmpzaWlNZXRob2R9KCR7anNpaU1ldGhvZFBhcmFtcy5qb2luKFxuICAgICAgJywgJyxcbiAgICApfSwgWyR7cGFyYW1zLmpvaW4oJywgJyl9XSlgO1xuICAgIGNvZGUubGluZShcbiAgICAgIGAke21ldGhvZFByZWZpeH0ke1xuICAgICAgICB0aGlzLnJldHVybkZyb21KU0lJTWV0aG9kICYmIHJldHVyblR5cGVcbiAgICAgICAgICA/IGB0eXBpbmcuY2FzdCgke3JldHVyblR5cGV9LCAke3ZhbHVlfSlgXG4gICAgICAgICAgOiB2YWx1ZVxuICAgICAgfWAsXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TGlmdGVkUHJvcGVydGllcyhyZXNvbHZlcjogVHlwZVJlc29sdmVyKTogUHJvcGVydHlEZWZpbml0aW9uW10ge1xuICAgIGNvbnN0IGxpZnRlZFByb3BlcnRpZXM6IFByb3BlcnR5RGVmaW5pdGlvbltdID0gW107XG5cbiAgICBjb25zdCBzdGFjayA9IFt0aGlzLmxpZnRlZFByb3BdO1xuICAgIGNvbnN0IGtub3duSWZhY2VzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3Qga25vd25Qcm9wcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGZvciAoXG4gICAgICBsZXQgY3VycmVudCA9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICBjdXJyZW50ICE9IG51bGw7XG4gICAgICBjdXJyZW50ID0gc3RhY2suc2hpZnQoKVxuICAgICkge1xuICAgICAga25vd25JZmFjZXMuYWRkKGN1cnJlbnQuZnFuKTtcblxuICAgICAgLy8gQWRkIGFueSBpbnRlcmZhY2VzIHRoYXQgdGhpcyBpbnRlcmZhY2UgZGVwZW5kcyBvbiwgdG8gdGhlIGxpc3QuXG4gICAgICBpZiAoY3VycmVudC5pbnRlcmZhY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZmFjZSBvZiBjdXJyZW50LmludGVyZmFjZXMpIHtcbiAgICAgICAgICBpZiAoa25vd25JZmFjZXMuaGFzKGlmYWNlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnB1c2gocmVzb2x2ZXIuZGVyZWZlcmVuY2UoaWZhY2UpIGFzIHNwZWMuSW50ZXJmYWNlVHlwZSk7XG4gICAgICAgICAga25vd25JZmFjZXMuYWRkKGlmYWNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgaW50ZXJmYWNlIHRvIG91ciBsaXN0IG9mIHByb3BlcnRpZXMuXG4gICAgICBpZiAoY3VycmVudC5wcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGN1cnJlbnQucHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChrbm93blByb3BzLmhhcyhwcm9wLm5hbWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlmdGVkUHJvcGVydGllcy5wdXNoKHsgcHJvcCwgZGVmaW5pbmdUeXBlOiBjdXJyZW50IH0pO1xuICAgICAgICAgIGtub3duUHJvcHMuYWRkKHByb3AubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlmdGVkUHJvcGVydGllcztcbiAgfVxufVxuXG5pbnRlcmZhY2UgQmFzZVByb3BlcnR5T3B0cyB7XG4gIGFic3RyYWN0PzogYm9vbGVhbjtcbiAgaW1tdXRhYmxlPzogYm9vbGVhbjtcbiAgaXNTdGF0aWM/OiBib29sZWFuO1xuICBwYXJlbnQ6IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlO1xufVxuXG5pbnRlcmZhY2UgQmFzZVByb3BlcnR5RW1pdE9wdHMge1xuICByZW5kZXJBYnN0cmFjdD86IGJvb2xlYW47XG4gIGZvcmNlRW1pdEJvZHk/OiBib29sZWFuO1xufVxuXG5hYnN0cmFjdCBjbGFzcyBCYXNlUHJvcGVydHkgaW1wbGVtZW50cyBQeXRob25CYXNlIHtcbiAgcHVibGljIHJlYWRvbmx5IGFic3RyYWN0OiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgaXNTdGF0aWM6IGJvb2xlYW47XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IGRlY29yYXRvcjogc3RyaW5nO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhZG9ubHkgaW1wbGljaXRQYXJhbWV0ZXI6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlHZXRNZXRob2QhOiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpU2V0TWV0aG9kITogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc2hvdWxkRW1pdEJvZHk6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgaW1tdXRhYmxlOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IHBhcmVudDogc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2U7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZ2VuZXJhdG9yOiBQeXRob25HZW5lcmF0b3IsXG4gICAgcHVibGljIHJlYWRvbmx5IHB5dGhvbk5hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGpzTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHlwZTogc3BlYy5PcHRpb25hbFZhbHVlLFxuICAgIHB1YmxpYyByZWFkb25seSBkb2NzOiBzcGVjLkRvY3MgfCB1bmRlZmluZWQsXG4gICAgb3B0czogQmFzZVByb3BlcnR5T3B0cyxcbiAgKSB7XG4gICAgY29uc3QgeyBhYnN0cmFjdCA9IGZhbHNlLCBpbW11dGFibGUgPSBmYWxzZSwgaXNTdGF0aWMgPSBmYWxzZSB9ID0gb3B0cztcblxuICAgIHRoaXMuYWJzdHJhY3QgPSBhYnN0cmFjdDtcbiAgICB0aGlzLmltbXV0YWJsZSA9IGltbXV0YWJsZTtcbiAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgdGhpcy5wYXJlbnQgPSBvcHRzLnBhcmVudDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXBpTG9jYXRpb24oKTogQXBpTG9jYXRpb24ge1xuICAgIHJldHVybiB7IGFwaTogJ21lbWJlcicsIGZxbjogdGhpcy5wYXJlbnQuZnFuLCBtZW1iZXJOYW1lOiB0aGlzLmpzTmFtZSB9O1xuICB9XG5cbiAgcHVibGljIHJlcXVpcmVkSW1wb3J0cyhjb250ZXh0OiBFbWl0Q29udGV4dCk6IFB5dGhvbkltcG9ydHMge1xuICAgIHJldHVybiB0b1R5cGVOYW1lKHRoaXMudHlwZSkucmVxdWlyZWRJbXBvcnRzKGNvbnRleHQpO1xuICB9XG5cbiAgcHVibGljIGVtaXQoXG4gICAgY29kZTogQ29kZU1ha2VyLFxuICAgIGNvbnRleHQ6IEVtaXRDb250ZXh0LFxuICAgIG9wdHM/OiBCYXNlUHJvcGVydHlFbWl0T3B0cyxcbiAgKSB7XG4gICAgY29uc3QgeyByZW5kZXJBYnN0cmFjdCA9IHRydWUsIGZvcmNlRW1pdEJvZHkgPSBmYWxzZSB9ID0gb3B0cyA/PyB7fTtcbiAgICBjb25zdCBweXRob25UeXBlID0gdG9UeXBlTmFtZSh0aGlzLnR5cGUpLnB5dGhvblR5cGUoY29udGV4dCk7XG5cbiAgICAvLyBcIiMgdHlwZTogaWdub3JlW21pc2NdXCIgaXMgbmVlZGVkIGJlY2F1c2UgbXlweSBjYW5ub3QgY2hlY2sgZGVjb3JhdGVkIHRoaW5nc1xuICAgIGNvZGUubGluZShgQCR7dGhpcy5kZWNvcmF0b3J9ICMgdHlwZTogaWdub3JlW21pc2NdYCk7XG4gICAgY29kZS5saW5lKGBAanNpaS5tZW1iZXIoanNpaV9uYW1lPVwiJHt0aGlzLmpzTmFtZX1cIilgKTtcbiAgICBpZiAocmVuZGVyQWJzdHJhY3QgJiYgdGhpcy5hYnN0cmFjdCkge1xuICAgICAgY29kZS5saW5lKCdAYWJjLmFic3RyYWN0bWV0aG9kJyk7XG4gICAgfVxuICAgIG9wZW5TaWduYXR1cmUoXG4gICAgICBjb2RlLFxuICAgICAgJ2RlZicsXG4gICAgICB0aGlzLnB5dGhvbk5hbWUsXG4gICAgICBbdGhpcy5pbXBsaWNpdFBhcmFtZXRlcl0sXG4gICAgICB0cnVlLFxuICAgICAgcHl0aG9uVHlwZSxcbiAgICApO1xuICAgIHRoaXMuZ2VuZXJhdG9yLmVtaXREb2NTdHJpbmcoY29kZSwgdGhpcy5hcGlMb2NhdGlvbiwgdGhpcy5kb2NzLCB7XG4gICAgICBkb2N1bWVudGFibGVJdGVtOiBgcHJvcC0ke3RoaXMucHl0aG9uTmFtZX1gLFxuICAgIH0pO1xuICAgIGlmIChcbiAgICAgICh0aGlzLnNob3VsZEVtaXRCb2R5IHx8IGZvcmNlRW1pdEJvZHkpICYmXG4gICAgICAoIXJlbmRlckFic3RyYWN0IHx8ICF0aGlzLmFic3RyYWN0KVxuICAgICkge1xuICAgICAgY29kZS5saW5lKFxuICAgICAgICBgcmV0dXJuIHR5cGluZy5jYXN0KCR7cHl0aG9uVHlwZX0sIGpzaWkuJHt0aGlzLmpzaWlHZXRNZXRob2R9KCR7dGhpcy5pbXBsaWNpdFBhcmFtZXRlcn0sIFwiJHt0aGlzLmpzTmFtZX1cIikpYCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUubGluZSgnLi4uJyk7XG4gICAgfVxuICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuXG4gICAgaWYgKCF0aGlzLmltbXV0YWJsZSkge1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBjb2RlLmxpbmUoXG4gICAgICAgIGBAJHt0aGlzLnB5dGhvbk5hbWV9LnNldHRlciR7XG4gICAgICAgICAgdGhpcy5pc1N0YXRpYyA/ICcgIyB0eXBlOiBpZ25vcmVbbm8tcmVkZWZdJyA6ICcnXG4gICAgICAgIH1gLFxuICAgICAgKTtcbiAgICAgIGlmIChyZW5kZXJBYnN0cmFjdCAmJiB0aGlzLmFic3RyYWN0KSB7XG4gICAgICAgIGNvZGUubGluZSgnQGFiYy5hYnN0cmFjdG1ldGhvZCcpO1xuICAgICAgfVxuICAgICAgb3BlblNpZ25hdHVyZShcbiAgICAgICAgY29kZSxcbiAgICAgICAgJ2RlZicsXG4gICAgICAgIHRoaXMucHl0aG9uTmFtZSxcbiAgICAgICAgW3RoaXMuaW1wbGljaXRQYXJhbWV0ZXIsIGB2YWx1ZTogJHtweXRob25UeXBlfWBdLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ05vbmUnLFxuICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgKHRoaXMuc2hvdWxkRW1pdEJvZHkgfHwgZm9yY2VFbWl0Qm9keSkgJiZcbiAgICAgICAgKCFyZW5kZXJBYnN0cmFjdCB8fCAhdGhpcy5hYnN0cmFjdClcbiAgICAgICkge1xuICAgICAgICBjb2RlLmxpbmUoXG4gICAgICAgICAgYGpzaWkuJHt0aGlzLmpzaWlTZXRNZXRob2R9KCR7dGhpcy5pbXBsaWNpdFBhcmFtZXRlcn0sIFwiJHt0aGlzLmpzTmFtZX1cIiwgdmFsdWUpYCxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUubGluZSgnLi4uJyk7XG4gICAgICB9XG4gICAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgSW50ZXJmYWNlIGV4dGVuZHMgQmFzZVB5dGhvbkNsYXNzVHlwZSB7XG4gIHB1YmxpYyBlbWl0KGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gbmVzdGVkQ29udGV4dChjb250ZXh0LCB0aGlzLmZxbik7XG4gICAgZW1pdExpc3QoY29kZSwgJ0Bqc2lpLmludGVyZmFjZSgnLCBbYGpzaWlfdHlwZT1cIiR7dGhpcy5mcW59XCJgXSwgJyknKTtcblxuICAgIC8vIEZpcnN0IHdlIGRvIG91ciBub3JtYWwgY2xhc3MgbG9naWMgZm9yIGVtaXR0aW5nIG91ciBtZW1iZXJzLlxuICAgIHN1cGVyLmVtaXQoY29kZSwgY29udGV4dCk7XG5cbiAgICBjb2RlLmxpbmUoKTtcbiAgICBjb2RlLmxpbmUoKTtcblxuICAgIC8vIFRoZW4sIHdlIGhhdmUgdG8gZW1pdCBhIFByb3h5IGNsYXNzIHdoaWNoIGltcGxlbWVudHMgb3VyIHByb3h5IGludGVyZmFjZS5cbiAgICBjb25zdCBwcm94eUJhc2VzOiBzdHJpbmdbXSA9IHRoaXMuYmFzZXMubWFwKFxuICAgICAgKGIpID0+XG4gICAgICAgIC8vIFwiIyB0eXBlOiBpZ25vcmVbbWlzY11cIiBiZWNhdXNlIE15UHkgY2Fubm90IGNoZWNrIGR5bmFtaWMgYmFzZSBjbGFzc2VzIChuYXR1cmFsbHkpXG4gICAgICAgIGBqc2lpLnByb3h5X2Zvcigke3RvVHlwZU5hbWUoYikucHl0aG9uVHlwZSh7XG4gICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICB0eXBlQW5ub3RhdGlvbjogZmFsc2UsXG4gICAgICAgIH0pfSkgIyB0eXBlOiBpZ25vcmVbbWlzY11gLFxuICAgICk7XG4gICAgb3BlblNpZ25hdHVyZShjb2RlLCAnY2xhc3MnLCB0aGlzLnByb3h5Q2xhc3NOYW1lLCBwcm94eUJhc2VzKTtcbiAgICB0aGlzLmdlbmVyYXRvci5lbWl0RG9jU3RyaW5nKGNvZGUsIHRoaXMuYXBpTG9jYXRpb24sIHRoaXMuZG9jcywge1xuICAgICAgZG9jdW1lbnRhYmxlSXRlbTogYGNsYXNzLSR7dGhpcy5weXRob25OYW1lfWAsXG4gICAgICB0cmFpbGluZ05ld0xpbmU6IHRydWUsXG4gICAgfSk7XG4gICAgY29kZS5saW5lKGBfX2pzaWlfdHlwZV9fOiB0eXBpbmcuQ2xhc3NWYXJbc3RyXSA9IFwiJHt0aGlzLmZxbn1cImApO1xuXG4gICAgaWYgKHRoaXMubWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLm1lbWJlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VwYXJhdGVNZW1iZXJzKSB7XG4gICAgICAgICAgY29kZS5saW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVtYmVyLmVtaXQoY29kZSwgY29udGV4dCwgeyBmb3JjZUVtaXRCb2R5OiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLmxpbmUoJ3Bhc3MnKTtcbiAgICB9XG5cbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgICBjb2RlLmxpbmUoKTtcbiAgICBjb2RlLmxpbmUoXG4gICAgICAnIyBBZGRpbmcgYSBcIl9fanNpaV9wcm94eV9jbGFzc19fKCk6IHR5cGluZy5UeXBlXCIgZnVuY3Rpb24gdG8gdGhlIGludGVyZmFjZScsXG4gICAgKTtcbiAgICBjb2RlLmxpbmUoXG4gICAgICBgdHlwaW5nLmNhc3QodHlwaW5nLkFueSwgJHt0aGlzLnB5dGhvbk5hbWV9KS5fX2pzaWlfcHJveHlfY2xhc3NfXyA9IGxhbWJkYSA6ICR7dGhpcy5wcm94eUNsYXNzTmFtZX1gLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy5mcW4gIT0gbnVsbCkge1xuICAgICAgY29udGV4dC5lbWl0dGVkVHlwZXMuYWRkKHRoaXMuZnFuKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Q2xhc3NQYXJhbXMoY29udGV4dDogRW1pdENvbnRleHQpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcGFyYW1zOiBzdHJpbmdbXSA9IHRoaXMuYmFzZXMubWFwKChiKSA9PlxuICAgICAgdG9UeXBlTmFtZShiKS5weXRob25UeXBlKHsgLi4uY29udGV4dCwgdHlwZUFubm90YXRpb246IGZhbHNlIH0pLFxuICAgICk7XG5cbiAgICBwYXJhbXMucHVzaCgndHlwaW5nX2V4dGVuc2lvbnMuUHJvdG9jb2wnKTtcblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBwcml2YXRlIGdldCBwcm94eUNsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgXyR7dGhpcy5weXRob25OYW1lfVByb3h5YDtcbiAgfVxufVxuXG5jbGFzcyBJbnRlcmZhY2VNZXRob2QgZXh0ZW5kcyBCYXNlTWV0aG9kIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGltcGxpY2l0UGFyYW1ldGVyOiBzdHJpbmcgPSAnc2VsZic7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpTWV0aG9kOiBzdHJpbmcgPSAnaW52b2tlJztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHNob3VsZEVtaXRCb2R5OiBib29sZWFuID0gZmFsc2U7XG59XG5cbmNsYXNzIEludGVyZmFjZVByb3BlcnR5IGV4dGVuZHMgQmFzZVByb3BlcnR5IHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRlY29yYXRvcjogc3RyaW5nID0gJ2J1aWx0aW5zLnByb3BlcnR5JztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGltcGxpY2l0UGFyYW1ldGVyOiBzdHJpbmcgPSAnc2VsZic7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpR2V0TWV0aG9kOiBzdHJpbmcgPSAnZ2V0JztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlTZXRNZXRob2Q6IHN0cmluZyA9ICdzZXQnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc2hvdWxkRW1pdEJvZHk6IGJvb2xlYW4gPSBmYWxzZTtcbn1cblxuY2xhc3MgU3RydWN0IGV4dGVuZHMgQmFzZVB5dGhvbkNsYXNzVHlwZSB7XG4gIHByb3RlY3RlZCBkaXJlY3RNZW1iZXJzID0gbmV3IEFycmF5PFN0cnVjdEZpZWxkPigpO1xuXG4gIHB1YmxpYyBhZGRNZW1iZXIobWVtYmVyOiBQeXRob25CYXNlKTogdm9pZCB7XG4gICAgaWYgKCEobWVtYmVyIGluc3RhbmNlb2YgU3RydWN0RmllbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIFN0cnVjdEZpZWxkIHRvIFN0cnVjdCcpO1xuICAgIH1cbiAgICB0aGlzLmRpcmVjdE1lbWJlcnMucHVzaChtZW1iZXIpO1xuICB9XG5cbiAgcHVibGljIGVtaXQoY29kZTogQ29kZU1ha2VyLCBjb250ZXh0OiBFbWl0Q29udGV4dCkge1xuICAgIGNvbnRleHQgPSBuZXN0ZWRDb250ZXh0KGNvbnRleHQsIHRoaXMuZnFuKTtcbiAgICBjb25zdCBiYXNlSW50ZXJmYWNlcyA9IHRoaXMuZ2V0Q2xhc3NQYXJhbXMoY29udGV4dCk7XG5cbiAgICBjb2RlLmluZGVudCgnQGpzaWkuZGF0YV90eXBlKCcpO1xuICAgIGNvZGUubGluZShganNpaV90eXBlPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5mcW4pfSxgKTtcbiAgICBlbWl0TGlzdChjb2RlLCAnanNpaV9zdHJ1Y3RfYmFzZXM9WycsIGJhc2VJbnRlcmZhY2VzLCAnXSwnKTtcbiAgICBhc3NpZ25EaWN0aW9uYXJ5KGNvZGUsICduYW1lX21hcHBpbmcnLCB0aGlzLnByb3BlcnR5TWFwKCksICcsJywgdHJ1ZSk7XG4gICAgY29kZS51bmluZGVudCgnKScpO1xuICAgIG9wZW5TaWduYXR1cmUoY29kZSwgJ2NsYXNzJywgdGhpcy5weXRob25OYW1lLCBiYXNlSW50ZXJmYWNlcyk7XG4gICAgdGhpcy5lbWl0Q29uc3RydWN0b3IoY29kZSwgY29udGV4dCk7XG5cbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLmFsbE1lbWJlcnMpIHtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgICAgdGhpcy5lbWl0R2V0dGVyKG1lbWJlciwgY29kZSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0TWFnaWNNZXRob2RzKGNvZGUpO1xuXG4gICAgY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICBpZiAodGhpcy5mcW4gIT0gbnVsbCkge1xuICAgICAgY29udGV4dC5lbWl0dGVkVHlwZXMuYWRkKHRoaXMuZnFuKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVxdWlyZWRJbXBvcnRzKGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgcmV0dXJuIG1lcmdlUHl0aG9uSW1wb3J0cyhcbiAgICAgIHN1cGVyLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSxcbiAgICAgIC4uLnRoaXMuYWxsTWVtYmVycy5tYXAoKG1lbSkgPT4gbWVtLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRDbGFzc1BhcmFtcyhjb250ZXh0OiBFbWl0Q29udGV4dCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlcy5tYXAoKGIpID0+XG4gICAgICB0b1R5cGVOYW1lKGIpLnB5dGhvblR5cGUoeyAuLi5jb250ZXh0LCB0eXBlQW5ub3RhdGlvbjogZmFsc2UgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFsbCBmaWVsZHMgKGluaGVyaXRlZCBhcyB3ZWxsKVxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgYWxsTWVtYmVycygpOiBTdHJ1Y3RGaWVsZFtdIHtcbiAgICByZXR1cm4gdGhpcy50aGlzSW50ZXJmYWNlLmFsbFByb3BlcnRpZXMubWFwKFxuICAgICAgKHgpID0+IG5ldyBTdHJ1Y3RGaWVsZCh0aGlzLmdlbmVyYXRvciwgeC5zcGVjLCB4LmRlZmluaW5nVHlwZS5zcGVjKSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgdGhpc0ludGVyZmFjZSgpIHtcbiAgICBpZiAodGhpcy5mcW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGUU4gbm90IHNldCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3IucmVmbGVjdEFzc2VtYmx5LnN5c3RlbS5maW5kSW50ZXJmYWNlKHRoaXMuZnFuKTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdENvbnN0cnVjdG9yKGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBjb25zdCBtZW1iZXJzID0gdGhpcy5hbGxNZW1iZXJzO1xuXG4gICAgY29uc3Qga3dhcmdzID0gbWVtYmVycy5tYXAoKG0pID0+IG0uY29uc3RydWN0b3JEZWNsKGNvbnRleHQpKTtcblxuICAgIGNvbnN0IGltcGxpY2l0UGFyYW1ldGVyID0gc2x1Z2lmeUFzTmVlZGVkKFxuICAgICAgJ3NlbGYnLFxuICAgICAgbWVtYmVycy5tYXAoKG0pID0+IG0ucHl0aG9uTmFtZSksXG4gICAgKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckFyZ3VtZW50cyA9XG4gICAgICBrd2FyZ3MubGVuZ3RoID4gMFxuICAgICAgICA/IFtpbXBsaWNpdFBhcmFtZXRlciwgJyonLCAuLi5rd2FyZ3NdXG4gICAgICAgIDogW2ltcGxpY2l0UGFyYW1ldGVyXTtcblxuICAgIG9wZW5TaWduYXR1cmUoY29kZSwgJ2RlZicsICdfX2luaXRfXycsIGNvbnN0cnVjdG9yQXJndW1lbnRzLCBmYWxzZSwgJ05vbmUnKTtcbiAgICB0aGlzLmVtaXRDb25zdHJ1Y3RvckRvY3N0cmluZyhjb2RlKTtcblxuICAgIC8vIFJlLXR5cGUgc3RydWN0IGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIGFzIFwiZGljdFwiXG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgbWVtYmVycy5maWx0ZXIoKG0pID0+IG0uaXNTdHJ1Y3QodGhpcy5nZW5lcmF0b3IpKSkge1xuICAgICAgLy8gTm90ZSB0aGF0IFwiTm9uZVwiIGlzIE5PVCBhbiBpbnN0YW5jZSBvZiBkaWN0ICh0aGF0J3MgY29udmVuaWVudCEpXG4gICAgICBjb25zdCB0eXBlTmFtZSA9IHRvVHlwZU5hbWUobWVtYmVyLnR5cGUudHlwZSkucHl0aG9uVHlwZSh7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHR5cGVBbm5vdGF0aW9uOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgY29kZS5vcGVuQmxvY2soYGlmIGlzaW5zdGFuY2UoJHttZW1iZXIucHl0aG9uTmFtZX0sIGRpY3QpYCk7XG4gICAgICBjb2RlLmxpbmUoYCR7bWVtYmVyLnB5dGhvbk5hbWV9ID0gJHt0eXBlTmFtZX0oKioke21lbWJlci5weXRob25OYW1lfSlgKTtcbiAgICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuICAgIH1cblxuICAgIC8vIFJlcXVpcmVkIHByb3BlcnRpZXMsIHRob3NlIHdpbGwgYWx3YXlzIGJlIHB1dCBpbnRvIHRoZSBkaWN0XG4gICAgYXNzaWduRGljdGlvbmFyeShcbiAgICAgIGNvZGUsXG4gICAgICBgJHtpbXBsaWNpdFBhcmFtZXRlcn0uX3ZhbHVlczogdHlwaW5nLkRpY3Rbc3RyLCB0eXBpbmcuQW55XWAsXG4gICAgICBtZW1iZXJzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICFtLm9wdGlvbmFsKVxuICAgICAgICAubWFwKFxuICAgICAgICAgIChtZW1iZXIpID0+XG4gICAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeShtZW1iZXIucHl0aG9uTmFtZSl9OiAke21lbWJlci5weXRob25OYW1lfWAsXG4gICAgICAgICksXG4gICAgKTtcblxuICAgIC8vIE9wdGlvbmFsIHByb3BlcnRpZXMsIHdpbGwgb25seSBiZSBwdXQgaW50byB0aGUgZGljdCBpZiB0aGV5J3JlIG5vdCBOb25lXG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgbWVtYmVycy5maWx0ZXIoKG0pID0+IG0ub3B0aW9uYWwpKSB7XG4gICAgICBjb2RlLm9wZW5CbG9jayhgaWYgJHttZW1iZXIucHl0aG9uTmFtZX0gaXMgbm90IE5vbmVgKTtcbiAgICAgIGNvZGUubGluZShcbiAgICAgICAgYCR7aW1wbGljaXRQYXJhbWV0ZXJ9Ll92YWx1ZXNbXCIke21lbWJlci5weXRob25OYW1lfVwiXSA9ICR7bWVtYmVyLnB5dGhvbk5hbWV9YCxcbiAgICAgICk7XG4gICAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgICB9XG5cbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdENvbnN0cnVjdG9yRG9jc3RyaW5nKGNvZGU6IENvZGVNYWtlcikge1xuICAgIGNvbnN0IGFyZ3M6IERvY3VtZW50YWJsZUFyZ3VtZW50W10gPSB0aGlzLmFsbE1lbWJlcnMubWFwKChtKSA9PiAoe1xuICAgICAgbmFtZTogbS5weXRob25OYW1lLFxuICAgICAgZG9jczogbS5kb2NzLFxuICAgICAgZGVmaW5pbmdUeXBlOiB0aGlzLnNwZWMsXG4gICAgfSkpO1xuICAgIHRoaXMuZ2VuZXJhdG9yLmVtaXREb2NTdHJpbmcoY29kZSwgdGhpcy5hcGlMb2NhdGlvbiwgdGhpcy5kb2NzLCB7XG4gICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICBkb2N1bWVudGFibGVJdGVtOiBgY2xhc3MtJHt0aGlzLnB5dGhvbk5hbWV9YCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdEdldHRlcihcbiAgICBtZW1iZXI6IFN0cnVjdEZpZWxkLFxuICAgIGNvZGU6IENvZGVNYWtlcixcbiAgICBjb250ZXh0OiBFbWl0Q29udGV4dCxcbiAgKSB7XG4gICAgY29uc3QgcHl0aG9uVHlwZSA9IG1lbWJlci50eXBlQW5ub3RhdGlvbihjb250ZXh0KTtcblxuICAgIGNvZGUubGluZSgnQGJ1aWx0aW5zLnByb3BlcnR5Jyk7XG4gICAgb3BlblNpZ25hdHVyZShjb2RlLCAnZGVmJywgbWVtYmVyLnB5dGhvbk5hbWUsIFsnc2VsZiddLCB0cnVlLCBweXRob25UeXBlKTtcbiAgICBtZW1iZXIuZW1pdERvY1N0cmluZyhjb2RlKTtcbiAgICBjb2RlLmxpbmUoXG4gICAgICBgcmVzdWx0ID0gc2VsZi5fdmFsdWVzLmdldCgke0pTT04uc3RyaW5naWZ5KG1lbWJlci5weXRob25OYW1lKX0pYCxcbiAgICApO1xuICAgIGlmICghbWVtYmVyLm9wdGlvbmFsKSB7XG4gICAgICAvLyBBZGQgYW4gYXNzZXJ0aW9uIHRvIG1heWUgTXlQWSBoYXBweSFcbiAgICAgIGNvZGUubGluZShcbiAgICAgICAgYGFzc2VydCByZXN1bHQgaXMgbm90IE5vbmUsIFwiUmVxdWlyZWQgcHJvcGVydHkgJyR7bWVtYmVyLnB5dGhvbk5hbWV9JyBpcyBtaXNzaW5nXCJgLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29kZS5saW5lKGByZXR1cm4gdHlwaW5nLmNhc3QoJHtweXRob25UeXBlfSwgcmVzdWx0KWApO1xuICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0TWFnaWNNZXRob2RzKGNvZGU6IENvZGVNYWtlcikge1xuICAgIGNvZGUubGluZSgpO1xuICAgIGNvZGUub3BlbkJsb2NrKCdkZWYgX19lcV9fKHNlbGYsIHJoczogdHlwaW5nLkFueSkgLT4gYnVpbHRpbnMuYm9vbCcpO1xuICAgIGNvZGUubGluZShcbiAgICAgICdyZXR1cm4gaXNpbnN0YW5jZShyaHMsIHNlbGYuX19jbGFzc19fKSBhbmQgcmhzLl92YWx1ZXMgPT0gc2VsZi5fdmFsdWVzJyxcbiAgICApO1xuICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuXG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5vcGVuQmxvY2soJ2RlZiBfX25lX18oc2VsZiwgcmhzOiB0eXBpbmcuQW55KSAtPiBidWlsdGlucy5ib29sJyk7XG4gICAgY29kZS5saW5lKCdyZXR1cm4gbm90IChyaHMgPT0gc2VsZiknKTtcbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcblxuICAgIGNvZGUubGluZSgpO1xuICAgIGNvZGUub3BlbkJsb2NrKCdkZWYgX19yZXByX18oc2VsZikgLT4gc3RyJyk7XG4gICAgY29kZS5pbmRlbnQoYHJldHVybiBcIiR7dGhpcy5weXRob25OYW1lfSglcylcIiAlIFwiLCBcIi5qb2luKGApO1xuICAgIGNvZGUubGluZSgnayArIFwiPVwiICsgcmVwcih2KSBmb3IgaywgdiBpbiBzZWxmLl92YWx1ZXMuaXRlbXMoKScpO1xuICAgIGNvZGUudW5pbmRlbnQoJyknKTtcbiAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgcHJvcGVydHlNYXAoKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLmFsbE1lbWJlcnMpIHtcbiAgICAgIHJldC5wdXNoKFxuICAgICAgICBgJHtKU09OLnN0cmluZ2lmeShtZW1iZXIucHl0aG9uTmFtZSl9OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIG1lbWJlci5qc2lpTmFtZSxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuXG5jbGFzcyBTdHJ1Y3RGaWVsZCBpbXBsZW1lbnRzIFB5dGhvbkJhc2Uge1xuICBwdWJsaWMgcmVhZG9ubHkgcHl0aG9uTmFtZTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkganNpaU5hbWU6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGRvY3M/OiBzcGVjLkRvY3M7XG4gIHB1YmxpYyByZWFkb25seSB0eXBlOiBzcGVjLk9wdGlvbmFsVmFsdWU7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZ2VuZXJhdG9yOiBQeXRob25HZW5lcmF0b3IsXG4gICAgcHVibGljIHJlYWRvbmx5IHByb3A6IHNwZWMuUHJvcGVydHksXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZWZpbmluZ1R5cGU6IHNwZWMuVHlwZSxcbiAgKSB7XG4gICAgdGhpcy5weXRob25OYW1lID0gdG9QeXRob25Qcm9wZXJ0eU5hbWUocHJvcC5uYW1lKTtcbiAgICB0aGlzLmpzaWlOYW1lID0gcHJvcC5uYW1lO1xuICAgIHRoaXMudHlwZSA9IHByb3A7XG4gICAgdGhpcy5kb2NzID0gcHJvcC5kb2NzO1xuICB9XG5cbiAgcHVibGljIGdldCBhcGlMb2NhdGlvbigpOiBBcGlMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFwaTogJ21lbWJlcicsXG4gICAgICBmcW46IHRoaXMuZGVmaW5pbmdUeXBlLmZxbixcbiAgICAgIG1lbWJlck5hbWU6IHRoaXMuanNpaU5hbWUsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgb3B0aW9uYWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy50eXBlLm9wdGlvbmFsO1xuICB9XG5cbiAgcHVibGljIHJlcXVpcmVkSW1wb3J0cyhjb250ZXh0OiBFbWl0Q29udGV4dCk6IFB5dGhvbkltcG9ydHMge1xuICAgIHJldHVybiB0b1R5cGVOYW1lKHRoaXMudHlwZSkucmVxdWlyZWRJbXBvcnRzKGNvbnRleHQpO1xuICB9XG5cbiAgcHVibGljIGlzU3RydWN0KGdlbmVyYXRvcjogUHl0aG9uR2VuZXJhdG9yKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzU3RydWN0KGdlbmVyYXRvci5yZWZsZWN0QXNzZW1ibHkuc3lzdGVtLCB0aGlzLnR5cGUudHlwZSk7XG4gIH1cblxuICBwdWJsaWMgY29uc3RydWN0b3JEZWNsKGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgY29uc3Qgb3B0ID0gdGhpcy5vcHRpb25hbCA/ICcgPSBOb25lJyA6ICcnO1xuICAgIHJldHVybiBgJHt0aGlzLnB5dGhvbk5hbWV9OiAke3RoaXMudHlwZUFubm90YXRpb24oe1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHBhcmFtZXRlclR5cGU6IHRydWUsXG4gICAgfSl9JHtvcHR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIFB5dGhvbiB0eXBlIGFubm90YXRpb24gZm9yIHRoaXMgdHlwZVxuICAgKi9cbiAgcHVibGljIHR5cGVBbm5vdGF0aW9uKGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgcmV0dXJuIHRvVHlwZU5hbWUodGhpcy50eXBlKS5weXRob25UeXBlKGNvbnRleHQpO1xuICB9XG5cbiAgcHVibGljIGVtaXREb2NTdHJpbmcoY29kZTogQ29kZU1ha2VyKSB7XG4gICAgdGhpcy5nZW5lcmF0b3IuZW1pdERvY1N0cmluZyhjb2RlLCB0aGlzLmFwaUxvY2F0aW9uLCB0aGlzLmRvY3MsIHtcbiAgICAgIGRvY3VtZW50YWJsZUl0ZW06IGBwcm9wLSR7dGhpcy5weXRob25OYW1lfWAsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgZW1pdChjb2RlOiBDb2RlTWFrZXIsIGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRUeXBlID0gdGhpcy50eXBlQW5ub3RhdGlvbihjb250ZXh0KTtcbiAgICBjb2RlLmxpbmUoYCR7dGhpcy5weXRob25OYW1lfTogJHtyZXNvbHZlZFR5cGV9YCk7XG4gICAgdGhpcy5lbWl0RG9jU3RyaW5nKGNvZGUpO1xuICB9XG59XG5cbmludGVyZmFjZSBDbGFzc09wdHMgZXh0ZW5kcyBQeXRob25UeXBlT3B0cyB7XG4gIGFic3RyYWN0PzogYm9vbGVhbjtcbiAgaW50ZXJmYWNlcz86IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlW107XG4gIGFic3RyYWN0QmFzZXM/OiBzcGVjLkNsYXNzVHlwZVtdO1xufVxuXG5jbGFzcyBDbGFzcyBleHRlbmRzIEJhc2VQeXRob25DbGFzc1R5cGUgaW1wbGVtZW50cyBJU29ydGFibGVUeXBlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBhYnN0cmFjdDogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBhYnN0cmFjdEJhc2VzOiBzcGVjLkNsYXNzVHlwZVtdO1xuICBwcml2YXRlIHJlYWRvbmx5IGludGVyZmFjZXM6IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlW107XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIGdlbmVyYXRvcjogUHl0aG9uR2VuZXJhdG9yLFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBzcGVjOiBzcGVjLlR5cGUsXG4gICAgZnFuOiBzdHJpbmcsXG4gICAgb3B0czogQ2xhc3NPcHRzLFxuICAgIGRvY3M6IHNwZWMuRG9jcyB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgc3VwZXIoZ2VuZXJhdG9yLCBuYW1lLCBzcGVjLCBmcW4sIG9wdHMsIGRvY3MpO1xuXG4gICAgY29uc3QgeyBhYnN0cmFjdCA9IGZhbHNlLCBpbnRlcmZhY2VzID0gW10sIGFic3RyYWN0QmFzZXMgPSBbXSB9ID0gb3B0cztcblxuICAgIHRoaXMuYWJzdHJhY3QgPSBhYnN0cmFjdDtcbiAgICB0aGlzLmludGVyZmFjZXMgPSBpbnRlcmZhY2VzO1xuICAgIHRoaXMuYWJzdHJhY3RCYXNlcyA9IGFic3RyYWN0QmFzZXM7XG4gIH1cblxuICBwdWJsaWMgZGVwZW5kc09uKHJlc29sdmVyOiBUeXBlUmVzb2x2ZXIpOiBQeXRob25UeXBlW10ge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llczogUHl0aG9uVHlwZVtdID0gc3VwZXIuZGVwZW5kc09uKHJlc29sdmVyKTtcbiAgICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5nZXRQYXJlbnQodGhpcy5mcW4hKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmV0dXJuIGFueSBpZmFjZXMgdGhhdCBhcmUgaW4gdGhlIHNhbWUgbW9kdWxlIGF0IHRoZSBzYW1lIGxldmVsIG9mXG4gICAgLy8gbmVzdGluZy5cbiAgICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCBpZmFjZSBvZiB0aGlzLmludGVyZmFjZXMpIHtcbiAgICAgIGlmIChyZXNvbHZlci5pc0luTW9kdWxlKGlmYWNlKSkge1xuICAgICAgICAvLyBHaXZlbiBhIGlmYWNlLCB3ZSBuZWVkIHRvIGxvY2F0ZSB0aGUgaWZhY2VzJ3MgcGFyZW50IHRoYXQgaXMgdGhlIHNhbWVcbiAgICAgICAgLy8gYXMgb3VyIHBhcmVudCwgYmVjYXVzZSB3ZSBvbmx5IGNhcmUgYWJvdXQgZGVwZW5kZW5jaWVzIHRoYXQgYXJlIGF0IHRoZVxuICAgICAgICAvLyBzYW1lIGxldmVsIG9mIG91ciBvd24uXG4gICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IG5lZWQgdG8gcmVjdXJzZSBpbnRvIG91ciBtZW1iZXJzIHRvIGFsc28gZmluZCB0aGVpclxuICAgICAgICAvLyAgICAgICBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGxldCBpZmFjZUl0ZW0gPSByZXNvbHZlci5nZXRUeXBlKGlmYWNlKTtcbiAgICAgICAgbGV0IGlmYWNlUGFyZW50ID0gcmVzb2x2ZXIuZ2V0UGFyZW50KGlmYWNlKTtcbiAgICAgICAgd2hpbGUgKGlmYWNlUGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICBpZmFjZUl0ZW0gPSBpZmFjZVBhcmVudDtcbiAgICAgICAgICBpZmFjZVBhcmVudCA9IHJlc29sdmVyLmdldFBhcmVudChpZmFjZUl0ZW0uZnFuISk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlZW4uaGFzKGlmYWNlSXRlbS5mcW4hKSkge1xuICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGlmYWNlSXRlbSk7XG4gICAgICAgICAgc2Vlbi5hZGQoaWZhY2VJdGVtLmZxbiEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuXG4gIHB1YmxpYyByZXF1aXJlZEltcG9ydHMoY29udGV4dDogRW1pdENvbnRleHQpOiBQeXRob25JbXBvcnRzIHtcbiAgICByZXR1cm4gbWVyZ2VQeXRob25JbXBvcnRzKFxuICAgICAgc3VwZXIucmVxdWlyZWRJbXBvcnRzKGNvbnRleHQpLCAvLyBUYWtlcyBjYXJlIG9mIGJhc2UgJiBtZW1iZXJzXG4gICAgICAuLi50aGlzLmludGVyZmFjZXMubWFwKChiYXNlKSA9PlxuICAgICAgICB0b1R5cGVOYW1lKGJhc2UpLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0KGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICAvLyBGaXJzdCB3ZSBlbWl0IG91ciBpbXBsbWVudHMgZGVjb3JhdG9yXG4gICAgaWYgKHRoaXMuaW50ZXJmYWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpbnRlcmZhY2VzOiBzdHJpbmdbXSA9IHRoaXMuaW50ZXJmYWNlcy5tYXAoKGIpID0+XG4gICAgICAgIHRvVHlwZU5hbWUoYikucHl0aG9uVHlwZSh7IC4uLmNvbnRleHQsIHR5cGVBbm5vdGF0aW9uOiBmYWxzZSB9KSxcbiAgICAgICk7XG4gICAgICBjb2RlLmxpbmUoYEBqc2lpLmltcGxlbWVudHMoJHtpbnRlcmZhY2VzLmpvaW4oJywgJyl9KWApO1xuICAgIH1cblxuICAgIC8vIFRoZW4gd2UgZG8gb3VyIG5vcm1hbCBjbGFzcyBsb2dpYyBmb3IgZW1pdHRpbmcgb3VyIG1lbWJlcnMuXG4gICAgc3VwZXIuZW1pdChjb2RlLCBjb250ZXh0KTtcblxuICAgIC8vIFRoZW4sIGlmIG91ciBjbGFzcyBpcyBBYnN0cmFjdCwgd2UgaGF2ZSB0byBnbyB0aHJvdWdoIGFuZCByZWRvIGFsbCBvZlxuICAgIC8vIHRoaXMgbG9naWMsIGV4Y2VwdCBvbmx5IGVtaXRpbmcgYWJzdHJhY3QgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBhcyBub25cbiAgICAvLyBhYnN0cmFjdCwgYW5kIHN1YmNsYXNzaW5nIG91ciBpbml0aWFsIGNsYXNzLlxuICAgIGlmICh0aGlzLmFic3RyYWN0KSB7XG4gICAgICBjb250ZXh0ID0gbmVzdGVkQ29udGV4dChjb250ZXh0LCB0aGlzLmZxbik7XG5cbiAgICAgIGNvbnN0IHByb3h5QmFzZXMgPSBbdGhpcy5weXRob25OYW1lXTtcbiAgICAgIGZvciAoY29uc3QgYmFzZSBvZiB0aGlzLmFic3RyYWN0QmFzZXMpIHtcbiAgICAgICAgLy8gXCIjIHR5cGU6IGlnbm9yZVttaXNjXVwiIGJlY2F1c2UgTXlQeSBjYW5ub3QgY2hlY2sgZHluYW1pYyBiYXNlIGNsYXNzZXMgKG5hdHVyYWxseSlcbiAgICAgICAgcHJveHlCYXNlcy5wdXNoKFxuICAgICAgICAgIGBqc2lpLnByb3h5X2Zvcigke3RvVHlwZU5hbWUoYmFzZSkucHl0aG9uVHlwZSh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgdHlwZUFubm90YXRpb246IGZhbHNlLFxuICAgICAgICAgIH0pfSkgIyB0eXBlOiBpZ25vcmVbbWlzY11gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgICAgb3BlblNpZ25hdHVyZShjb2RlLCAnY2xhc3MnLCB0aGlzLnByb3h5Q2xhc3NOYW1lLCBwcm94eUJhc2VzKTtcblxuICAgICAgLy8gRmlsdGVyIG91ciBsaXN0IG9mIG1lbWJlcnMgdG8gKm9ubHkqIGJlIGFic3RyYWN0IG1lbWJlcnMsIGFuZCBub3QgYW55XG4gICAgICAvLyBvdGhlciB0eXBlcy5cbiAgICAgIGNvbnN0IGFic3RyYWN0TWVtYmVycyA9IHRoaXMubWVtYmVycy5maWx0ZXIoXG4gICAgICAgIChtKSA9PlxuICAgICAgICAgIChtIGluc3RhbmNlb2YgQmFzZU1ldGhvZCB8fCBtIGluc3RhbmNlb2YgQmFzZVByb3BlcnR5KSAmJiBtLmFic3RyYWN0LFxuICAgICAgKTtcbiAgICAgIGlmIChhYnN0cmFjdE1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBhYnN0cmFjdE1lbWJlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZXBhcmF0ZU1lbWJlcnMpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZS5saW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlci5lbWl0KGNvZGUsIGNvbnRleHQsIHsgcmVuZGVyQWJzdHJhY3Q6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlLmxpbmUoJ3Bhc3MnKTtcbiAgICAgIH1cblxuICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIGNvZGUubGluZShcbiAgICAgICAgJyMgQWRkaW5nIGEgXCJfX2pzaWlfcHJveHlfY2xhc3NfXygpOiB0eXBpbmcuVHlwZVwiIGZ1bmN0aW9uIHRvIHRoZSBhYnN0cmFjdCBjbGFzcycsXG4gICAgICApO1xuICAgICAgY29kZS5saW5lKFxuICAgICAgICBgdHlwaW5nLmNhc3QodHlwaW5nLkFueSwgJHt0aGlzLnB5dGhvbk5hbWV9KS5fX2pzaWlfcHJveHlfY2xhc3NfXyA9IGxhbWJkYSA6ICR7dGhpcy5wcm94eUNsYXNzTmFtZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Q2xhc3NQYXJhbXMoY29udGV4dDogRW1pdENvbnRleHQpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcGFyYW1zOiBzdHJpbmdbXSA9IHRoaXMuYmFzZXMubWFwKChiKSA9PlxuICAgICAgdG9UeXBlTmFtZShiKS5weXRob25UeXBlKHsgLi4uY29udGV4dCwgdHlwZUFubm90YXRpb246IGZhbHNlIH0pLFxuICAgICk7XG4gICAgY29uc3QgbWV0YWNsYXNzOiBzdHJpbmcgPSB0aGlzLmFic3RyYWN0ID8gJ0pTSUlBYnN0cmFjdENsYXNzJyA6ICdKU0lJTWV0YSc7XG5cbiAgICBwYXJhbXMucHVzaChgbWV0YWNsYXNzPWpzaWkuJHttZXRhY2xhc3N9YCk7XG4gICAgcGFyYW1zLnB1c2goYGpzaWlfdHlwZT1cIiR7dGhpcy5mcW59XCJgKTtcblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBwcml2YXRlIGdldCBwcm94eUNsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgXyR7dGhpcy5weXRob25OYW1lfVByb3h5YDtcbiAgfVxufVxuXG5jbGFzcyBTdGF0aWNNZXRob2QgZXh0ZW5kcyBCYXNlTWV0aG9kIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRlY29yYXRvcj86IHN0cmluZyA9ICdidWlsdGlucy5jbGFzc21ldGhvZCc7XG4gIHByb3RlY3RlZCByZWFkb25seSBpbXBsaWNpdFBhcmFtZXRlcjogc3RyaW5nID0gJ2Nscyc7XG4gIHByb3RlY3RlZCByZWFkb25seSBqc2lpTWV0aG9kOiBzdHJpbmcgPSAnc2ludm9rZSc7XG59XG5cbmNsYXNzIEluaXRpYWxpemVyIGV4dGVuZHMgQmFzZU1ldGhvZCB7XG4gIHByb3RlY3RlZCByZWFkb25seSBpbXBsaWNpdFBhcmFtZXRlcjogc3RyaW5nID0gJ3NlbGYnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkganNpaU1ldGhvZDogc3RyaW5nID0gJ2NyZWF0ZSc7XG4gIHByb3RlY3RlZCByZWFkb25seSBjbGFzc0FzRmlyc3RQYXJhbWV0ZXI6IGJvb2xlYW4gPSB0cnVlO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcmV0dXJuRnJvbUpTSUlNZXRob2Q6IGJvb2xlYW4gPSBmYWxzZTtcbn1cblxuY2xhc3MgTWV0aG9kIGV4dGVuZHMgQmFzZU1ldGhvZCB7XG4gIHByb3RlY3RlZCByZWFkb25seSBpbXBsaWNpdFBhcmFtZXRlcjogc3RyaW5nID0gJ3NlbGYnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkganNpaU1ldGhvZDogc3RyaW5nID0gJ2ludm9rZSc7XG59XG5cbmNsYXNzIEFzeW5jTWV0aG9kIGV4dGVuZHMgQmFzZU1ldGhvZCB7XG4gIHByb3RlY3RlZCByZWFkb25seSBpbXBsaWNpdFBhcmFtZXRlcjogc3RyaW5nID0gJ3NlbGYnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkganNpaU1ldGhvZDogc3RyaW5nID0gJ2FpbnZva2UnO1xufVxuXG5jbGFzcyBTdGF0aWNQcm9wZXJ0eSBleHRlbmRzIEJhc2VQcm9wZXJ0eSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBkZWNvcmF0b3I6IHN0cmluZyA9ICdqc2lpLnB5dGhvbi5jbGFzc3Byb3BlcnR5JztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGltcGxpY2l0UGFyYW1ldGVyOiBzdHJpbmcgPSAnY2xzJztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlHZXRNZXRob2Q6IHN0cmluZyA9ICdzZ2V0JztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlTZXRNZXRob2Q6IHN0cmluZyA9ICdzc2V0Jztcbn1cblxuY2xhc3MgUHJvcGVydHkgZXh0ZW5kcyBCYXNlUHJvcGVydHkge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVjb3JhdG9yOiBzdHJpbmcgPSAnYnVpbHRpbnMucHJvcGVydHknO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgaW1wbGljaXRQYXJhbWV0ZXI6IHN0cmluZyA9ICdzZWxmJztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGpzaWlHZXRNZXRob2Q6IHN0cmluZyA9ICdnZXQnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkganNpaVNldE1ldGhvZDogc3RyaW5nID0gJ3NldCc7XG59XG5cbmNsYXNzIEVudW0gZXh0ZW5kcyBCYXNlUHl0aG9uQ2xhc3NUeXBlIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHNlcGFyYXRlTWVtYmVycyA9IGZhbHNlO1xuXG4gIHB1YmxpYyBlbWl0KGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gbmVzdGVkQ29udGV4dChjb250ZXh0LCB0aGlzLmZxbik7XG4gICAgZW1pdExpc3QoY29kZSwgJ0Bqc2lpLmVudW0oJywgW2Bqc2lpX3R5cGU9XCIke3RoaXMuZnFufVwiYF0sICcpJyk7XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoY29kZSwgY29udGV4dCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Q2xhc3NQYXJhbXMoX2NvbnRleHQ6IEVtaXRDb250ZXh0KTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbJ2VudW0uRW51bSddO1xuICB9XG5cbiAgcHVibGljIHJlcXVpcmVkSW1wb3J0cyhjb250ZXh0OiBFbWl0Q29udGV4dCk6IFB5dGhvbkltcG9ydHMge1xuICAgIHJldHVybiBzdXBlci5yZXF1aXJlZEltcG9ydHMoY29udGV4dCk7XG4gIH1cbn1cblxuY2xhc3MgRW51bU1lbWJlciBpbXBsZW1lbnRzIFB5dGhvbkJhc2Uge1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBnZW5lcmF0b3I6IFB5dGhvbkdlbmVyYXRvcixcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHl0aG9uTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdmFsdWU6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZG9jczogc3BlYy5Eb2NzIHwgdW5kZWZpbmVkLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGFyZW50OiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZSxcbiAgKSB7XG4gICAgdGhpcy5weXRob25OYW1lID0gcHl0aG9uTmFtZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFwaUxvY2F0aW9uKCk6IEFwaUxvY2F0aW9uIHtcbiAgICByZXR1cm4geyBhcGk6ICdtZW1iZXInLCBmcW46IHRoaXMucGFyZW50LmZxbiwgbWVtYmVyTmFtZTogdGhpcy52YWx1ZSB9O1xuICB9XG5cbiAgcHVibGljIGRlcGVuZHNPbk1vZHVsZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8c3RyaW5nPigpO1xuICB9XG5cbiAgcHVibGljIGVtaXQoY29kZTogQ29kZU1ha2VyLCBfY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBjb2RlLmxpbmUoYCR7dGhpcy5weXRob25OYW1lfSA9IFwiJHt0aGlzLnZhbHVlfVwiYCk7XG4gICAgdGhpcy5nZW5lcmF0b3IuZW1pdERvY1N0cmluZyhjb2RlLCB0aGlzLmFwaUxvY2F0aW9uLCB0aGlzLmRvY3MsIHtcbiAgICAgIGRvY3VtZW50YWJsZUl0ZW06IGBlbnVtLSR7dGhpcy5weXRob25OYW1lfWAsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVxdWlyZWRJbXBvcnRzKF9jb250ZXh0OiBFbWl0Q29udGV4dCk6IFB5dGhvbkltcG9ydHMge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgTW9kdWxlT3B0cyB7XG4gIHJlYWRvbmx5IGFzc2VtYmx5OiBzcGVjLkFzc2VtYmx5O1xuICByZWFkb25seSBhc3NlbWJseUZpbGVuYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGxvYWRBc3NlbWJseT86IGJvb2xlYW47XG4gIHJlYWRvbmx5IHBhY2thZ2U/OiBQYWNrYWdlO1xuXG4gIC8qKlxuICAgKiBUaGUgZG9jc3RyaW5nIHRvIGVtaXQgYXQgdGhlIHRvcCBvZiB0aGlzIG1vZHVsZSwgaWYgYW55LlxuICAgKi9cbiAgcmVhZG9ubHkgbW9kdWxlRG9jdW1lbnRhdGlvbj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBQeXRob24gbW9kdWxlXG4gKlxuICogV2lsbCBiZSBjYWxsZWQgZm9yIGpzaWkgc3VibW9kdWxlcyBhbmQgbmFtZXNwYWNlcy5cbiAqL1xuY2xhc3MgUHl0aG9uTW9kdWxlIGltcGxlbWVudHMgUHl0aG9uVHlwZSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0ZWQgdG8gcHV0IG9uIHRoZSBtb2R1bGVcbiAgICpcbiAgICogVGhlIGZvcm1hdCBpcyBpbiBtYXJrZG93biwgd2l0aCBjb2RlIHNhbXBsZXMgY29udmVydGVkIGZyb20gVFMgdG8gUHl0aG9uLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG1vZHVsZURvY3VtZW50YXRpb24/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBhc3NlbWJseTogc3BlYy5Bc3NlbWJseTtcbiAgcHJpdmF0ZSByZWFkb25seSBhc3NlbWJseUZpbGVuYW1lOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9hZEFzc2VtYmx5OiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IG1lbWJlcnMgPSBuZXcgQXJyYXk8UHl0aG9uQmFzZT4oKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZXMgPSBuZXcgQXJyYXk8UHl0aG9uTW9kdWxlPigpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHl0aG9uTmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBmcW46IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBvcHRzOiBNb2R1bGVPcHRzLFxuICApIHtcbiAgICB0aGlzLmFzc2VtYmx5ID0gb3B0cy5hc3NlbWJseTtcbiAgICB0aGlzLmFzc2VtYmx5RmlsZW5hbWUgPSBvcHRzLmFzc2VtYmx5RmlsZW5hbWU7XG4gICAgdGhpcy5sb2FkQXNzZW1ibHkgPSAhIW9wdHMubG9hZEFzc2VtYmx5O1xuICAgIHRoaXMubW9kdWxlRG9jdW1lbnRhdGlvbiA9IG9wdHMubW9kdWxlRG9jdW1lbnRhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBhZGRNZW1iZXIobWVtYmVyOiBQeXRob25CYXNlKSB7XG4gICAgdGhpcy5tZW1iZXJzLnB1c2gobWVtYmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRQeXRob25Nb2R1bGUocHlNb2Q6IFB5dGhvbk1vZHVsZSkge1xuICAgIGFzc2VydChcbiAgICAgICF0aGlzLmxvYWRBc3NlbWJseSxcbiAgICAgICdQeXRob25Nb2R1bGUuYWRkUHl0aG9uTW9kdWxlIENBTk5PVCBiZSBjYWxsZWQgb24gYXNzZW1ibHktbG9hZGluZyBtb2R1bGVzIChpdCB3b3VsZCBjYXVzZSBhIGxvYWQgY3ljbGUpIScsXG4gICAgKTtcbiAgICB0aGlzLm1vZHVsZXMucHVzaChweU1vZCk7XG4gIH1cblxuICBwdWJsaWMgcmVxdWlyZWRJbXBvcnRzKGNvbnRleHQ6IEVtaXRDb250ZXh0KTogUHl0aG9uSW1wb3J0cyB7XG4gICAgcmV0dXJuIG1lcmdlUHl0aG9uSW1wb3J0cyhcbiAgICAgIC4uLnRoaXMubWVtYmVycy5tYXAoKG1lbSkgPT4gbWVtLnJlcXVpcmVkSW1wb3J0cyhjb250ZXh0KSksXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0KGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICB0aGlzLmVtaXRNb2R1bGVEb2N1bWVudGF0aW9uKGNvZGUpO1xuXG4gICAgY29uc3QgcmVzb2x2ZXIgPSB0aGlzLmZxblxuICAgICAgPyBjb250ZXh0LnJlc29sdmVyLmJpbmQodGhpcy5mcW4sIHRoaXMucHl0aG9uTmFtZSlcbiAgICAgIDogY29udGV4dC5yZXNvbHZlcjtcbiAgICBjb250ZXh0ID0ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHN1Ym1vZHVsZTogdGhpcy5mcW4gPz8gY29udGV4dC5zdWJtb2R1bGUsXG4gICAgICByZXNvbHZlcixcbiAgICB9O1xuXG4gICAgLy8gQmVmb3JlIHdlIHdyaXRlIGFueXRoaW5nIGVsc2UsIHdlIG5lZWQgdG8gd3JpdGUgb3V0IG91ciBtb2R1bGUgaGVhZGVycywgdGhpc1xuICAgIC8vIGlzIHdoZXJlIHdlIGhhbmRsZSBzdHVmZiBsaWtlIGltcG9ydHMsIGFueSByZXF1aXJlZCBpbml0aWFsaXphdGlvbiwgZXRjLlxuICAgIGNvZGUubGluZSgnaW1wb3J0IGFiYycpO1xuICAgIGNvZGUubGluZSgnaW1wb3J0IGJ1aWx0aW5zJyk7XG4gICAgY29kZS5saW5lKCdpbXBvcnQgZGF0ZXRpbWUnKTtcbiAgICBjb2RlLmxpbmUoJ2ltcG9ydCBlbnVtJyk7XG4gICAgY29kZS5saW5lKCdpbXBvcnQgdHlwaW5nJyk7XG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5saW5lKCdpbXBvcnQganNpaScpO1xuICAgIGNvZGUubGluZSgnaW1wb3J0IHB1YmxpY2F0aW9uJyk7XG4gICAgY29kZS5saW5lKCdpbXBvcnQgdHlwaW5nX2V4dGVuc2lvbnMnKTtcblxuICAgIC8vIERldGVybWluZSBpZiB3ZSBuZWVkIHRvIHdyaXRlIG91dCB0aGUga2VybmVsIGxvYWQgbGluZS5cbiAgICBpZiAodGhpcy5sb2FkQXNzZW1ibHkpIHtcbiAgICAgIHRoaXMuZW1pdERlcGVuZGVuY3lJbXBvcnRzKGNvZGUpO1xuXG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIGVtaXRMaXN0KFxuICAgICAgICBjb2RlLFxuICAgICAgICAnX19qc2lpX2Fzc2VtYmx5X18gPSBqc2lpLkpTSUlBc3NlbWJseS5sb2FkKCcsXG4gICAgICAgIFtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLmFzc2VtYmx5Lm5hbWUpLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuYXNzZW1ibHkudmVyc2lvbiksXG4gICAgICAgICAgJ19fbmFtZV9fWzA6LTZdJyxcbiAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmFzc2VtYmx5RmlsZW5hbWUpfWAsXG4gICAgICAgIF0sXG4gICAgICAgICcpJyxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZW4gd2UgbXVzdCBpbXBvcnQgdGhlIC5fanNpaSBzdWJwYWNrYWdlLlxuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBsZXQgZGlzdGFuY2VGcm9tUm9vdCA9IDA7XG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgY3VyciA9IHRoaXMuZnFuITtcbiAgICAgICAgY3VyciAhPT0gdGhpcy5hc3NlbWJseS5uYW1lO1xuICAgICAgICBjdXJyID0gY3Vyci5zdWJzdHJpbmcoMCwgY3Vyci5sYXN0SW5kZXhPZignLicpKVxuICAgICAgKSB7XG4gICAgICAgIGRpc3RhbmNlRnJvbVJvb3QrKztcbiAgICAgIH1cbiAgICAgIGNvZGUubGluZShgZnJvbSAkeycuJy5yZXBlYXQoZGlzdGFuY2VGcm9tUm9vdCArIDEpfV9qc2lpIGltcG9ydCAqYCk7XG5cbiAgICAgIHRoaXMuZW1pdFJlcXVpcmVkSW1wb3J0cyhjb2RlLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBFbWl0IGFsbCBvZiBvdXIgbWVtYmVycy5cbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBwcmVwYXJlTWVtYmVycyh0aGlzLm1lbWJlcnMsIHJlc29sdmVyKSkge1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIG1lbWJlci5lbWl0KGNvZGUsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIFdoYXRldmVyIG5hbWVzIHdlJ3ZlIGV4cG9ydGVkLCB3ZSdsbCB3cml0ZSBvdXQgb3VyIF9fYWxsX18gdGhhdCBsaXN0cyB0aGVtLlxuICAgIGNvbnN0IGV4cG9ydGVkTWVtYmVycyA9IHRoaXMubWVtYmVycy5tYXAoKG0pID0+IGBcIiR7bS5weXRob25OYW1lfVwiYCk7XG4gICAgaWYgKHRoaXMubG9hZEFzc2VtYmx5KSB7XG4gICAgICBleHBvcnRlZE1lbWJlcnMucHVzaCgnXCJfX2pzaWlfYXNzZW1ibHlfX1wiJyk7XG4gICAgfVxuXG4gICAgLy8gRGVjbGFyZSB0aGUgbGlzdCBvZiBcInB1YmxpY1wiIG1lbWJlcnMgdGhpcyBtb2R1bGUgZXhwb3J0c1xuICAgIGlmICh0aGlzLm1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgfVxuICAgIGNvZGUubGluZSgpO1xuXG4gICAgaWYgKGV4cG9ydGVkTWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICBjb2RlLmluZGVudCgnX19hbGxfXyA9IFsnKTtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGV4cG9ydGVkTWVtYmVycy5zb3J0KCkpIHtcbiAgICAgICAgLy8gV3JpdGluZyBvbmUgYnkgbGluZSBtaWdodCBiZSBfYSBsb3RfIG9mIGxpbmVzLCBidXQgaXQnbGwgbWFrZSByZXZpZXdpbmcgY2hhbmdlcyB0byB0aGUgbGlzdCBlYXNpZXIuIFRydXN0IG1lLlxuICAgICAgICBjb2RlLmxpbmUoYCR7bWVtYmVyfSxgKTtcbiAgICAgIH1cbiAgICAgIGNvZGUudW5pbmRlbnQoJ10nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5saW5lKCdfX2FsbF9fOiB0eXBpbmcuTGlzdFt0eXBpbmcuQW55XSA9IFtdJyk7XG4gICAgfVxuXG4gICAgLy8gTmV4dCB1cCwgd2UnbGwgdXNlIHB1YmxpY2F0aW9uIHRvIGVuc3VyZSB0aGF0IGFsbCBvZiB0aGUgbm9uLXB1YmxpYyBuYW1lc1xuICAgIC8vIGdldCBoaWRkZW4gZnJvbSBkaXIoKSwgdGFiLWNvbXBsZXRlLCBldGMuXG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5saW5lKCdwdWJsaWNhdGlvbi5wdWJsaXNoKCknKTtcblxuICAgIC8vIEZpbmFsbHksIHdlJ2xsIGxvYWQgYWxsIHJlZ2lzdGVyZWQgcHl0aG9uIG1vZHVsZXNcbiAgICBpZiAodGhpcy5tb2R1bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgICAgY29kZS5saW5lKFxuICAgICAgICAnIyBMb2FkaW5nIG1vZHVsZXMgdG8gZW5zdXJlIHRoZWlyIHR5cGVzIGFyZSByZWdpc3RlcmVkIHdpdGggdGhlIGpzaWkgcnVudGltZSBsaWJyYXJ5JyxcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLm1vZHVsZXMuc29ydCgobCwgcikgPT5cbiAgICAgICAgbC5weXRob25OYW1lLmxvY2FsZUNvbXBhcmUoci5weXRob25OYW1lKSxcbiAgICAgICkpIHtcbiAgICAgICAgLy8gUmF0aGVyIHRoYW4gZ2VuZXJhdGluZyBhbiBhYnNvbHV0ZSBpbXBvcnQgbGlrZVxuICAgICAgICAvLyBcImltcG9ydCBqc2lpX2NhbGMuc3VibW9kdWxlLm5lc3RlZF9zdWJtb2R1bGUuZGVlcGx5X25lc3RlZFwiXG4gICAgICAgIC8vIHRoaXMgYnVpbGRzIGEgcmVsYXRpdmUgaW1wb3J0IGxpa2VcbiAgICAgICAgLy8gXCJmcm9tIC5zdWJtb2R1bGUubmVzdGVkX3N1Ym1vZHVsZSBpbXBvcnQgZGVlcGx5X25lc3RlZFwiXG4gICAgICAgIC8vIFRoaXMgZW5hYmxlcyBkaXN0cmlidXRpbmcgcHl0aG9uIHBhY2thZ2VzIGFuZCB1c2luZyB0aGVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIG1vZHVsZXMgaW4gdGhlIHNhbWUgY29kZWJhc2UuXG4gICAgICAgIGNvbnN0IGFzc2VtYmx5TmFtZSA9IHRvUHl0aG9uRnFuKFxuICAgICAgICAgIG1vZHVsZS5hc3NlbWJseS5uYW1lLFxuICAgICAgICAgIG1vZHVsZS5hc3NlbWJseSxcbiAgICAgICAgKS5weXRob25GcW47XG5cbiAgICAgICAgY29uc3Qgc3VibW9kdWxlID0gbW9kdWxlLnB5dGhvbk5hbWVcbiAgICAgICAgICAucmVwbGFjZShgJHthc3NlbWJseU5hbWV9LmAsICcnKVxuICAgICAgICAgIC5zcGxpdCgnLicpO1xuXG4gICAgICAgIGNvbnN0IHN1Ym1vZHVsZVBhdGggPSBzdWJtb2R1bGVcbiAgICAgICAgICAuc2xpY2UoMCwgc3VibW9kdWxlLmxlbmd0aCAtIDEpXG4gICAgICAgICAgLmpvaW4oJy4nKTtcbiAgICAgICAgY29uc3Qgc3VibW9kdWxlTmFtZSA9IHN1Ym1vZHVsZVtzdWJtb2R1bGUubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvZGUubGluZShgZnJvbSAuJHtzdWJtb2R1bGVQYXRofSBpbXBvcnQgJHtzdWJtb2R1bGVOYW1lfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBiaW4gc2NyaXB0cyBpZiBiaW4gc2VjdGlvbiBkZWZpbmVkLlxuICAgKi9cbiAgcHVibGljIGVtaXRCaW5TY3JpcHRzKGNvZGU6IENvZGVNYWtlcik6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBzY3JpcHRzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBpZiAodGhpcy5sb2FkQXNzZW1ibHkpIHtcbiAgICAgIGlmICh0aGlzLmFzc2VtYmx5LmJpbiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLmFzc2VtYmx5LmJpbikpIHtcbiAgICAgICAgICBjb25zdCBzY3JpcHRfZmlsZSA9IHBhdGguam9pbihcbiAgICAgICAgICAgICdzcmMnLFxuICAgICAgICAgICAgcHl0aG9uTW9kdWxlTmFtZVRvRmlsZW5hbWUodGhpcy5weXRob25OYW1lKSxcbiAgICAgICAgICAgICdiaW4nLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvZGUub3BlbkZpbGUoc2NyaXB0X2ZpbGUpO1xuICAgICAgICAgIGNvZGUubGluZSgnIyEvdXNyL2Jpbi9lbnYgcHl0aG9uJyk7XG4gICAgICAgICAgY29kZS5saW5lKCk7XG4gICAgICAgICAgY29kZS5saW5lKCdpbXBvcnQganNpaScpO1xuICAgICAgICAgIGNvZGUubGluZSgnaW1wb3J0IHN5cycpO1xuICAgICAgICAgIGNvZGUubGluZSgpO1xuICAgICAgICAgIGVtaXRMaXN0KFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICdfX2pzaWlfYXNzZW1ibHlfXyA9IGpzaWkuSlNJSUFzc2VtYmx5LmxvYWQoJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5hc3NlbWJseS5uYW1lKSxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5hc3NlbWJseS52ZXJzaW9uKSxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5weXRob25OYW1lLnJlcGxhY2UoJy5fanNpaScsICcnKSksXG4gICAgICAgICAgICAgIGAke0pTT04uc3RyaW5naWZ5KHRoaXMuYXNzZW1ibHlGaWxlbmFtZSl9YCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnKScsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb2RlLmxpbmUoKTtcbiAgICAgICAgICBlbWl0TGlzdChcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAnX19qc2lpX2Fzc2VtYmx5X18uaW52b2tlQmluU2NyaXB0KCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuYXNzZW1ibHkubmFtZSksXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5hbWUpLFxuICAgICAgICAgICAgICAnc3lzLmFyZ3ZbMTpdJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnKScsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb2RlLmNsb3NlRmlsZShzY3JpcHRfZmlsZSk7XG4gICAgICAgICAgc2NyaXB0cy5wdXNoKHNjcmlwdF9maWxlLnJlcGxhY2UoL1xcXFwvZywgJy8nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjcmlwdHM7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgUkVBRE1FIGFzIG1vZHVsZSBkb2NzdHJpbmcgaWYgdGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgbW9kdWxlIChpdCBsb2FkcyB0aGUgYXNzZW1ibHkpXG4gICAqL1xuICBwcml2YXRlIGVtaXRNb2R1bGVEb2N1bWVudGF0aW9uKGNvZGU6IENvZGVNYWtlcikge1xuICAgIGlmICh0aGlzLm1vZHVsZURvY3VtZW50YXRpb24pIHtcbiAgICAgIGNvZGUubGluZShET0NTVFJJTkdfUVVPVEVTKTtcbiAgICAgIGNvZGUubGluZSh0aGlzLm1vZHVsZURvY3VtZW50YXRpb24pO1xuICAgICAgY29kZS5saW5lKERPQ1NUUklOR19RVU9URVMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdERlcGVuZGVuY3lJbXBvcnRzKGNvZGU6IENvZGVNYWtlcikge1xuICAgIC8vIENvbGxlY3QgYWxsIHRoZSAoZGlyZWN0KSBkZXBlbmRlbmNpZXMnIC5fanNpaSBwYWNrYWdlcy5cbiAgICBjb25zdCBkZXBzID0gT2JqZWN0LmtleXModGhpcy5hc3NlbWJseS5kZXBlbmRlbmNpZXMgPz8ge30pXG4gICAgICAubWFwKFxuICAgICAgICAoZGVwKSA9PlxuICAgICAgICAgIHRoaXMuYXNzZW1ibHkuZGVwZW5kZW5jeUNsb3N1cmU/LltkZXBdPy50YXJnZXRzPy5weXRob24/Lm1vZHVsZSA/P1xuICAgICAgICAgIGRpZShgTm8gUHl0aG9uIHRhcmdldCB3YXMgY29uZmlncnVlZCBmb3IgdGhlIGRlcGVuZGVuY3kgXCIke2RlcH1cIi5gKSxcbiAgICAgIClcbiAgICAgIC5tYXAoKG1vZCkgPT4gYCR7bW9kfS5fanNpaWApXG4gICAgICAuc29ydCgpO1xuXG4gICAgLy8gTm93IGFjdHVhbGx5IHdyaXRlIHRoZSBpbXBvcnQgc3RhdGVtZW50cy4uLlxuICAgIGlmIChkZXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvZGUubGluZSgpO1xuICAgICAgZm9yIChjb25zdCBtb2R1bGVOYW1lIG9mIGRlcHMpIHtcbiAgICAgICAgY29kZS5saW5lKGBpbXBvcnQgJHttb2R1bGVOYW1lfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdFJlcXVpcmVkSW1wb3J0cyhjb2RlOiBDb2RlTWFrZXIsIGNvbnRleHQ6IEVtaXRDb250ZXh0KSB7XG4gICAgY29uc3QgcmVxdWlyZWRJbXBvcnRzID0gdGhpcy5yZXF1aXJlZEltcG9ydHMoY29udGV4dCk7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IE9iamVjdC5lbnRyaWVzKHJlcXVpcmVkSW1wb3J0cylcbiAgICAgIC5tYXAoKFtzb3VyY2VQYWNrYWdlLCBpdGVtc10pID0+IHRvSW1wb3J0U3RhdGVtZW50cyhzb3VyY2VQYWNrYWdlLCBpdGVtcykpXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoYWNjLCBlbHQpID0+IFsuLi5hY2MsIC4uLmVsdF0sXG4gICAgICAgIG5ldyBBcnJheTx7IGVtaXQ6ICgpID0+IHZvaWQ7IGNvbXBhcmlzb25CYXNlOiBzdHJpbmcgfT4oKSxcbiAgICAgIClcbiAgICAgIC5zb3J0KGltcG9ydENvbXBhcmF0b3IpO1xuXG4gICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgY29kZS5saW5lKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHN0YXRlbWVudHMpIHtcbiAgICAgIHN0YXRlbWVudC5lbWl0KGNvZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW1wb3J0U3RhdGVtZW50cyhcbiAgICAgIHNvdXJjZVBrZzogc3RyaW5nLFxuICAgICAgaXRlbXM6IFJlYWRvbmx5U2V0PHN0cmluZz4sXG4gICAgKTogQXJyYXk8eyBlbWl0OiAoY29kZTogQ29kZU1ha2VyKSA9PiB2b2lkOyBjb21wYXJpc29uQmFzZTogc3RyaW5nIH0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTx7XG4gICAgICAgIGVtaXQ6IChjb2RlOiBDb2RlTWFrZXIpID0+IHZvaWQ7XG4gICAgICAgIGNvbXBhcmlzb25CYXNlOiBzdHJpbmc7XG4gICAgICB9PigpO1xuICAgICAgaWYgKGl0ZW1zLmhhcygnJykpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIGNvbXBhcmlzb25CYXNlOiBgaW1wb3J0ICR7c291cmNlUGtnfWAsXG4gICAgICAgICAgZW1pdChjb2RlKSB7XG4gICAgICAgICAgICBjb2RlLmxpbmUodGhpcy5jb21wYXJpc29uQmFzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwaWVjZU1lYWwgPSBBcnJheS5mcm9tKGl0ZW1zKVxuICAgICAgICAuZmlsdGVyKChpKSA9PiBpICE9PSAnJylcbiAgICAgICAgLnNvcnQoKTtcbiAgICAgIGlmIChwaWVjZU1lYWwubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgY29tcGFyaXNvbkJhc2U6IGBmcm9tICR7c291cmNlUGtnfSBpbXBvcnRgLFxuICAgICAgICAgIGVtaXQ6IChjb2RlKSA9PlxuICAgICAgICAgICAgZW1pdExpc3QoY29kZSwgYGZyb20gJHtzb3VyY2VQa2d9IGltcG9ydCBgLCBwaWVjZU1lYWwsICcnLCB7XG4gICAgICAgICAgICAgIGlmTXVsdGk6IFsnKCcsICcpJ10sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydENvbXBhcmF0b3IoXG4gICAgICBsZWZ0OiB7IGNvbXBhcmlzb25CYXNlOiBzdHJpbmcgfSxcbiAgICAgIHJpZ2h0OiB7IGNvbXBhcmlzb25CYXNlOiBzdHJpbmcgfSxcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGVmdC5jb21wYXJpc29uQmFzZS5zdGFydHNXaXRoKCdpbXBvcnQnKSA9PT1cbiAgICAgICAgcmlnaHQuY29tcGFyaXNvbkJhc2Uuc3RhcnRzV2l0aCgnaW1wb3J0JylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbGVmdC5jb21wYXJpc29uQmFzZS5sb2NhbGVDb21wYXJlKHJpZ2h0LmNvbXBhcmlzb25CYXNlKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIHdhbnQgXCJmcm9tIC5mb28gaW1wb3J0ICguLi4pXCIgdG8gYmUgKmFmdGVyKiBcImltcG9ydCBiYXJcIlxuICAgICAgcmV0dXJuIHJpZ2h0LmNvbXBhcmlzb25CYXNlLmxvY2FsZUNvbXBhcmUobGVmdC5jb21wYXJpc29uQmFzZSk7XG4gICAgfVxuICB9XG59XG5cbmludGVyZmFjZSBQYWNrYWdlRGF0YSB7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG4gIGRhdGE6IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cblxuY2xhc3MgUGFja2FnZSB7XG4gIC8qKlxuICAgKiBUaGUgUHl0aG9uTW9kdWxlIHRoYXQgcmVwcmVzZW50cyB0aGUgcm9vdCBtb2R1bGUgb2YgdGhlIHBhY2thZ2VcbiAgICovXG4gIHB1YmxpYyByb290TW9kdWxlPzogUHl0aG9uTW9kdWxlO1xuXG4gIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSB2ZXJzaW9uOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBtZXRhZGF0YTogc3BlYy5Bc3NlbWJseTtcblxuICBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZXMgPSBuZXcgTWFwPHN0cmluZywgUHl0aG9uTW9kdWxlPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IGRhdGEgPSBuZXcgTWFwPHN0cmluZywgUGFja2FnZURhdGFbXT4oKTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIG1ldGFkYXRhOiBzcGVjLkFzc2VtYmx5KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRNb2R1bGUobW9kdWxlOiBQeXRob25Nb2R1bGUpIHtcbiAgICB0aGlzLm1vZHVsZXMuc2V0KG1vZHVsZS5weXRob25OYW1lLCBtb2R1bGUpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgbW9kdWxlIHRoYXQgcmVwcmVzZW50cyB0aGUgYXNzZW1ibHlcbiAgICBpZiAobW9kdWxlLmZxbiA9PT0gdGhpcy5tZXRhZGF0YS5uYW1lKSB7XG4gICAgICB0aGlzLnJvb3RNb2R1bGUgPSBtb2R1bGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFkZERhdGEoXG4gICAgbW9kdWxlOiBQeXRob25Nb2R1bGUsXG4gICAgZmlsZW5hbWU6IHN0cmluZyxcbiAgICBkYXRhOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGlmICghdGhpcy5kYXRhLmhhcyhtb2R1bGUucHl0aG9uTmFtZSkpIHtcbiAgICAgIHRoaXMuZGF0YS5zZXQobW9kdWxlLnB5dGhvbk5hbWUsIFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEuZ2V0KG1vZHVsZS5weXRob25OYW1lKSEucHVzaCh7IGZpbGVuYW1lLCBkYXRhIH0pO1xuICB9XG5cbiAgcHVibGljIHdyaXRlKGNvZGU6IENvZGVNYWtlciwgY29udGV4dDogRW1pdENvbnRleHQpIHtcbiAgICBjb25zdCBtb2R1bGVzID0gWy4uLnRoaXMubW9kdWxlcy52YWx1ZXMoKV0uc29ydCgoYSwgYikgPT5cbiAgICAgIGEucHl0aG9uTmFtZS5sb2NhbGVDb21wYXJlKGIucHl0aG9uTmFtZSksXG4gICAgKTtcblxuICAgIGNvbnN0IHNjcmlwdHMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBvZiBvdXIgbW9kdWxlcywgYW5kIHdyaXRlIHRoZW0gb3V0IHRvIGRpc2suXG4gICAgZm9yIChjb25zdCBtb2Qgb2YgbW9kdWxlcykge1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmpvaW4oXG4gICAgICAgICdzcmMnLFxuICAgICAgICBweXRob25Nb2R1bGVOYW1lVG9GaWxlbmFtZShtb2QucHl0aG9uTmFtZSksXG4gICAgICAgICdfX2luaXRfXy5weScsXG4gICAgICApO1xuXG4gICAgICBjb2RlLm9wZW5GaWxlKGZpbGVuYW1lKTtcbiAgICAgIG1vZC5lbWl0KGNvZGUsIGNvbnRleHQpO1xuICAgICAgY29kZS5jbG9zZUZpbGUoZmlsZW5hbWUpO1xuXG4gICAgICBzY3JpcHRzLnB1c2goLi4ubW9kLmVtaXRCaW5TY3JpcHRzKGNvZGUpKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb3VyIHBhY2thZ2UgZGF0YS5cbiAgICBjb25zdCBwYWNrYWdlRGF0YTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9ID0ge307XG4gICAgZm9yIChjb25zdCBbbW9kLCBwZGF0YV0gb2YgdGhpcy5kYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgcGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZmlsZXBhdGggPSBwYXRoLmpvaW4oXG4gICAgICAgICAgICAnc3JjJyxcbiAgICAgICAgICAgIHB5dGhvbk1vZHVsZU5hbWVUb0ZpbGVuYW1lKG1vZCksXG4gICAgICAgICAgICBkYXRhLmZpbGVuYW1lLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb2RlLm9wZW5GaWxlKGZpbGVwYXRoKTtcbiAgICAgICAgICBjb2RlLmxpbmUoZGF0YS5kYXRhKTtcbiAgICAgICAgICBjb2RlLmNsb3NlRmlsZShmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFja2FnZURhdGFbbW9kXSA9IHBkYXRhLm1hcCgocGQpID0+IHBkLmZpbGVuYW1lKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIG91ciBsaXN0IG9mIGRlcGVuZGVuY2llc1xuICAgIGNvbnN0IGRlcGVuZGVuY2llczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtkZXBOYW1lLCB2ZXJzaW9uXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgIHRoaXMubWV0YWRhdGEuZGVwZW5kZW5jaWVzID8/IHt9LFxuICAgICkpIHtcbiAgICAgIGNvbnN0IGRlcEluZm8gPSB0aGlzLm1ldGFkYXRhLmRlcGVuZGVuY3lDbG9zdXJlIVtkZXBOYW1lXTtcbiAgICAgIGRlcGVuZGVuY2llcy5wdXNoKFxuICAgICAgICBgJHtkZXBJbmZvLnRhcmdldHMhLnB5dGhvbiEuZGlzdE5hbWV9JHt0b1B5dGhvblZlcnNpb25SYW5nZSh2ZXJzaW9uKX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBOZWVkIHRvIGFsd2F5cyB3cml0ZSB0aGlzIGZpbGUgYXMgdGhlIGJ1aWxkIHByb2Nlc3MgZGVwZW5kcyBvbiBpdC5cbiAgICAvLyBNYWtlIHVwIHNvbWUgY29udGVudHMgaWYgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB1c2VmdWwgdG8gc2F5LlxuICAgIGNvZGUub3BlbkZpbGUoJ1JFQURNRS5tZCcpO1xuICAgIGNvZGUubGluZShcbiAgICAgIHRoaXMucm9vdE1vZHVsZT8ubW9kdWxlRG9jdW1lbnRhdGlvbiA/P1xuICAgICAgICBgJHt0aGlzLm5hbWV9XFxuJHsnPScucmVwZWF0KHRoaXMubmFtZS5sZW5ndGgpfWAsXG4gICAgKTtcbiAgICBjb2RlLmNsb3NlRmlsZSgnUkVBRE1FLm1kJyk7XG5cbiAgICAvLyBTdHJpcCBcIiAoYnVpbGQgYWJjZGVmKVwiIGZyb20gdGhlIGpzaWkgdmVyc2lvblxuICAgIGNvbnN0IGpzaWlWZXJzaW9uU2ltcGxlID0gdGhpcy5tZXRhZGF0YS5qc2lpVmVyc2lvbi5yZXBsYWNlKC8gLiokLywgJycpO1xuXG4gICAgY29uc3Qgc2V0dXBLd2FyZ3MgPSB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5tZXRhZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgIGxpY2Vuc2U6IHRoaXMubWV0YWRhdGEubGljZW5zZSxcbiAgICAgIHVybDogdGhpcy5tZXRhZGF0YS5ob21lcGFnZSxcbiAgICAgIGxvbmdfZGVzY3JpcHRpb25fY29udGVudF90eXBlOiAndGV4dC9tYXJrZG93bicsXG4gICAgICBhdXRob3I6XG4gICAgICAgIHRoaXMubWV0YWRhdGEuYXV0aG9yLm5hbWUgK1xuICAgICAgICAodGhpcy5tZXRhZGF0YS5hdXRob3IuZW1haWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gYDwke3RoaXMubWV0YWRhdGEuYXV0aG9yLmVtYWlsfT5gXG4gICAgICAgICAgOiAnJyksXG4gICAgICBiZGlzdF93aGVlbDoge1xuICAgICAgICB1bml2ZXJzYWw6IHRydWUsXG4gICAgICB9LFxuICAgICAgcHJvamVjdF91cmxzOiB7XG4gICAgICAgIFNvdXJjZTogdGhpcy5tZXRhZGF0YS5yZXBvc2l0b3J5LnVybCxcbiAgICAgIH0sXG4gICAgICBwYWNrYWdlX2RpcjogeyAnJzogJ3NyYycgfSxcbiAgICAgIHBhY2thZ2VzOiBtb2R1bGVzLm1hcCgobSkgPT4gbS5weXRob25OYW1lKSxcbiAgICAgIHBhY2thZ2VfZGF0YTogcGFja2FnZURhdGEsXG4gICAgICBweXRob25fcmVxdWlyZXM6ICc+PTMuNicsXG4gICAgICBpbnN0YWxsX3JlcXVpcmVzOiBbXG4gICAgICAgIGBqc2lpJHt0b1B5dGhvblZlcnNpb25SYW5nZShgXiR7anNpaVZlcnNpb25TaW1wbGV9YCl9YCxcbiAgICAgICAgJ3B1YmxpY2F0aW9uPj0wLjAuMycsXG4gICAgICBdXG4gICAgICAgIC5jb25jYXQoZGVwZW5kZW5jaWVzKVxuICAgICAgICAuc29ydCgpLFxuICAgICAgY2xhc3NpZmllcnM6IFtcbiAgICAgICAgJ0ludGVuZGVkIEF1ZGllbmNlIDo6IERldmVsb3BlcnMnLFxuICAgICAgICAnT3BlcmF0aW5nIFN5c3RlbSA6OiBPUyBJbmRlcGVuZGVudCcsXG4gICAgICAgICdQcm9ncmFtbWluZyBMYW5ndWFnZSA6OiBKYXZhU2NyaXB0JyxcbiAgICAgICAgJ1Byb2dyYW1taW5nIExhbmd1YWdlIDo6IFB5dGhvbiA6OiAzIDo6IE9ubHknLFxuICAgICAgICAnUHJvZ3JhbW1pbmcgTGFuZ3VhZ2UgOjogUHl0aG9uIDo6IDMuNicsXG4gICAgICAgICdQcm9ncmFtbWluZyBMYW5ndWFnZSA6OiBQeXRob24gOjogMy43JyxcbiAgICAgICAgJ1Byb2dyYW1taW5nIExhbmd1YWdlIDo6IFB5dGhvbiA6OiAzLjgnLFxuICAgICAgICAnUHJvZ3JhbW1pbmcgTGFuZ3VhZ2UgOjogUHl0aG9uIDo6IDMuOScsXG4gICAgICAgICdUeXBpbmcgOjogVHlwZWQnLFxuICAgICAgXSxcbiAgICAgIHNjcmlwdHMsXG4gICAgfTtcblxuICAgIHN3aXRjaCAodGhpcy5tZXRhZGF0YS5kb2NzPy5zdGFiaWxpdHkpIHtcbiAgICAgIGNhc2Ugc3BlYy5TdGFiaWxpdHkuRXhwZXJpbWVudGFsOlxuICAgICAgICBzZXR1cEt3YXJncy5jbGFzc2lmaWVycy5wdXNoKCdEZXZlbG9wbWVudCBTdGF0dXMgOjogNCAtIEJldGEnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHNwZWMuU3RhYmlsaXR5LlN0YWJsZTpcbiAgICAgICAgc2V0dXBLd2FyZ3MuY2xhc3NpZmllcnMucHVzaChcbiAgICAgICAgICAnRGV2ZWxvcG1lbnQgU3RhdHVzIDo6IDUgLSBQcm9kdWN0aW9uL1N0YWJsZScsXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzcGVjLlN0YWJpbGl0eS5EZXByZWNhdGVkOlxuICAgICAgICBzZXR1cEt3YXJncy5jbGFzc2lmaWVycy5wdXNoKCdEZXZlbG9wbWVudCBTdGF0dXMgOjogNyAtIEluYWN0aXZlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIE5vICdEZXZlbG9wbWVudCBTdGF0dXMnIHRyb3ZlIGNsYXNzaWZpZXIgZm9yIHlvdSFcbiAgICB9XG5cbiAgICBpZiAoc3BkeExpY2Vuc2VMaXN0W3RoaXMubWV0YWRhdGEubGljZW5zZV0/Lm9zaUFwcHJvdmVkKSB7XG4gICAgICBzZXR1cEt3YXJncy5jbGFzc2lmaWVycy5wdXNoKCdMaWNlbnNlIDo6IE9TSSBBcHByb3ZlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZGl0aW9uYWxDbGFzc2lmaWVycyA9IHRoaXMubWV0YWRhdGEudGFyZ2V0cz8ucHl0aG9uPy5jbGFzc2lmaWVycztcbiAgICBpZiAoYWRkaXRpb25hbENsYXNzaWZpZXJzICE9IG51bGwpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhZGRpdGlvbmFsQ2xhc3NpZmllcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVGhlIFwianNpaS50YXJnZXRzLnB5dGhvbi5jbGFzc2lmaWVyc1wiIHZhbHVlIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBpZiBwcm92aWRlZCwgYnV0IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBhZGRpdGlvbmFsQ2xhc3NpZmllcnMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICApfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBXZSBkaXNjb3VyYWdlIHVzaW5nIHRob3NlIHNpbmNlIHdlIGF1dG9tYXRpY2FsbHkgc2V0IGEgdmFsdWUgZm9yIHRoZW1cbiAgICAgIGZvciAobGV0IGNsYXNzaWZpZXIgb2YgYWRkaXRpb25hbENsYXNzaWZpZXJzLnNvcnQoKSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBcImpzaWkudGFyZ2V0cy5weXRob24uY2xhc3NpZmllcnNcIiB2YWx1ZSBjYW4gb25seSBjb250YWluIHN0cmluZ3MsIGJ1dCBmb3VuZCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBjbGFzc2lmaWVyLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UnbGwgc3BsaXQgb24gYDo6YCBhbmQgcmUtam9pbiBsYXRlciBzbyBjbGFzc2lmaWVycyBhcmUgXCJub3JtYWxpemVkXCIgdG8gYSBzdGFuZGFyZCBzcGFjaW5nXG4gICAgICAgIGNvbnN0IHBhcnRzID0gY2xhc3NpZmllci5zcGxpdCgnOjonKS5tYXAoKHBhcnQpID0+IHBhcnQudHJpbSgpKTtcbiAgICAgICAgY29uc3QgcmVzZXJ2ZWRDbGFzc2lmaWVycyA9IFtcbiAgICAgICAgICAnRGV2ZWxvcG1lbnQgU3RhdHVzJyxcbiAgICAgICAgICAnTGljZW5zZScsXG4gICAgICAgICAgJ09wZXJhdGluZyBTeXN0ZW0nLFxuICAgICAgICAgICdUeXBpbmcnLFxuICAgICAgICBdO1xuICAgICAgICBpZiAocmVzZXJ2ZWRDbGFzc2lmaWVycy5pbmNsdWRlcyhwYXJ0c1swXSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYENsYXNzaWZpZXJzIHN0YXJ0aW5nIHdpdGggJHtyZXNlcnZlZENsYXNzaWZpZXJzXG4gICAgICAgICAgICAgIC5tYXAoKHgpID0+IGBcIiR7eH0gOjpcImApXG4gICAgICAgICAgICAgIC5qb2luKFxuICAgICAgICAgICAgICAgICcsICcsXG4gICAgICAgICAgICAgICl9IGFyZSBhdXRvbWF0aWNhbGx5IHNldCBhbmQgc2hvdWxkIG5vdCBiZSBtYW51YWxseSBjb25maWd1cmVkYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzaWZpZXIgPSBwYXJ0cy5qb2luKCcgOjogJyk7XG4gICAgICAgIGlmIChzZXR1cEt3YXJncy5jbGFzc2lmaWVycy5pbmNsdWRlcyhjbGFzc2lmaWVyKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNldHVwS3dhcmdzLmNsYXNzaWZpZXJzLnB1c2goY2xhc3NpZmllcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UgTmVlZCBhIHNldHVwLnB5IHRvIG1ha2UgdGhpcyBQYWNrYWdlLCBhY3R1YWxseSBhIFBhY2thZ2UuXG4gICAgY29kZS5vcGVuRmlsZSgnc2V0dXAucHknKTtcbiAgICBjb2RlLmxpbmUoJ2ltcG9ydCBqc29uJyk7XG4gICAgY29kZS5saW5lKCdpbXBvcnQgc2V0dXB0b29scycpO1xuICAgIGNvZGUubGluZSgpO1xuICAgIGNvZGUubGluZSgna3dhcmdzID0ganNvbi5sb2FkcygnKTtcbiAgICBjb2RlLmxpbmUoJyAgICBcIlwiXCInKTtcbiAgICBjb2RlLmxpbmUoSlNPTi5zdHJpbmdpZnkoc2V0dXBLd2FyZ3MsIG51bGwsIDQpKTtcbiAgICBjb2RlLmxpbmUoJ1wiXCJcIicpO1xuICAgIGNvZGUubGluZSgnKScpO1xuICAgIGNvZGUubGluZSgpO1xuICAgIGNvZGUub3BlbkJsb2NrKCd3aXRoIG9wZW4oXCJSRUFETUUubWRcIiwgZW5jb2Rpbmc9XCJ1dGY4XCIpIGFzIGZwJyk7XG4gICAgY29kZS5saW5lKCdrd2FyZ3NbXCJsb25nX2Rlc2NyaXB0aW9uXCJdID0gZnAucmVhZCgpJyk7XG4gICAgY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5saW5lKCk7XG4gICAgY29kZS5saW5lKCdzZXR1cHRvb2xzLnNldHVwKCoqa3dhcmdzKScpO1xuICAgIGNvZGUuY2xvc2VGaWxlKCdzZXR1cC5weScpO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSdyZSBnb29kIGNpdGl6ZW5zLCB3ZSdyZSBnb2luZyB0byBnbyBhaGVhZCBhbmQgc3VwcG9ydCBweXByb2plY3QudG9tbFxuICAgIC8vIGFzIHdlbGwuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgZWFzaWVyIHRvIGp1c3QgdXNlIGEgVE9NTCBsaWJyYXJ5IHRvIHdyaXRlIHRoaXMgb3V0LlxuICAgIGNvZGUub3BlbkZpbGUoJ3B5cHJvamVjdC50b21sJyk7XG4gICAgY29kZS5saW5lKCdbYnVpbGQtc3lzdGVtXScpO1xuICAgIGNvbnN0IGJ1aWxkVG9vbHMgPSBmc1xuICAgICAgLnJlYWRGaWxlU3luYyhyZXF1aXJlbWVudHNGaWxlLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAubWFwKChsaW5lKSA9PiAvXlxccyooLispXFxzKiNcXHMqYnVpbGQtc3lzdGVtXFxzKiQvLmV4ZWMobGluZSk/LlsxXT8udHJpbSgpKVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKGJ1aWxkVG9vbHMsIGVudHJ5KSA9PiAoZW50cnkgPyBbLi4uYnVpbGRUb29scywgZW50cnldIDogYnVpbGRUb29scyksXG4gICAgICAgIG5ldyBBcnJheTxzdHJpbmc+KCksXG4gICAgICApO1xuICAgIGNvZGUubGluZShgcmVxdWlyZXMgPSBbJHtidWlsZFRvb2xzLm1hcCgoeCkgPT4gYFwiJHt4fVwiYCkuam9pbignLCAnKX1dYCk7XG4gICAgY29kZS5saW5lKCdidWlsZC1iYWNrZW5kID0gXCJzZXR1cHRvb2xzLmJ1aWxkX21ldGFcIicpO1xuICAgIGNvZGUuY2xvc2VGaWxlKCdweXByb2plY3QudG9tbCcpO1xuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHdyaXRlIG91dCBhIE1BTklGRVNULmluIHRvIGVuc3VyZSB0aGF0IGFsbCBvZiBvdXIgcmVxdWlyZWRcbiAgICAvLyBmaWxlcyBhcmUgaW5jbHVkZWQuXG4gICAgY29kZS5vcGVuRmlsZSgnTUFOSUZFU1QuaW4nKTtcbiAgICBjb2RlLmxpbmUoJ2luY2x1ZGUgcHlwcm9qZWN0LnRvbWwnKTtcbiAgICBjb2RlLmNsb3NlRmlsZSgnTUFOSUZFU1QuaW4nKTtcbiAgfVxufVxuXG50eXBlIEZpbmRNb2R1bGVDYWxsYmFjayA9IChmcW46IHN0cmluZykgPT4gc3BlYy5Bc3NlbWJseUNvbmZpZ3VyYXRpb247XG50eXBlIEZpbmRUeXBlQ2FsbGJhY2sgPSAoZnFuOiBzdHJpbmcpID0+IHNwZWMuVHlwZTtcblxuY2xhc3MgVHlwZVJlc29sdmVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSB0eXBlczogTWFwPHN0cmluZywgUHl0aG9uVHlwZT47XG4gIHByaXZhdGUgcmVhZG9ubHkgYm91bmRUbz86IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBib3VuZFJlITogUmVnRXhwO1xuICBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZU5hbWU/OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlUmUhOiBSZWdFeHA7XG4gIHByaXZhdGUgcmVhZG9ubHkgZmluZE1vZHVsZTogRmluZE1vZHVsZUNhbGxiYWNrO1xuICBwcml2YXRlIHJlYWRvbmx5IGZpbmRUeXBlOiBGaW5kVHlwZUNhbGxiYWNrO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICB0eXBlczogTWFwPHN0cmluZywgUHl0aG9uVHlwZT4sXG4gICAgZmluZE1vZHVsZTogRmluZE1vZHVsZUNhbGxiYWNrLFxuICAgIGZpbmRUeXBlOiBGaW5kVHlwZUNhbGxiYWNrLFxuICAgIGJvdW5kVG8/OiBzdHJpbmcsXG4gICAgbW9kdWxlTmFtZT86IHN0cmluZyxcbiAgKSB7XG4gICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgIHRoaXMuZmluZE1vZHVsZSA9IGZpbmRNb2R1bGU7XG4gICAgdGhpcy5maW5kVHlwZSA9IGZpbmRUeXBlO1xuICAgIHRoaXMubW9kdWxlTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgdGhpcy5ib3VuZFRvID0gYm91bmRUbyAhPT0gdW5kZWZpbmVkID8gdGhpcy50b1B5dGhvbkZRTihib3VuZFRvKSA6IGJvdW5kVG87XG5cbiAgICBpZiAodGhpcy5tb2R1bGVOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubW9kdWxlUmUgPSBuZXcgUmVnRXhwKFxuICAgICAgICBgXigke2VzY2FwZVN0cmluZ1JlZ2V4cCh0aGlzLm1vZHVsZU5hbWUpfSlcXFxcLiguKykkYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYm91bmRUbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmJvdW5kUmUgPSBuZXcgUmVnRXhwKFxuICAgICAgICBgXigke2VzY2FwZVN0cmluZ1JlZ2V4cCh0aGlzLmJvdW5kVG8pfSlcXFxcLiguKykkYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGJpbmQoZnFuOiBzdHJpbmcsIG1vZHVsZU5hbWU/OiBzdHJpbmcpOiBUeXBlUmVzb2x2ZXIge1xuICAgIHJldHVybiBuZXcgVHlwZVJlc29sdmVyKFxuICAgICAgdGhpcy50eXBlcyxcbiAgICAgIHRoaXMuZmluZE1vZHVsZSxcbiAgICAgIHRoaXMuZmluZFR5cGUsXG4gICAgICBmcW4sXG4gICAgICBtb2R1bGVOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJy4nKVxuICAgICAgICAgID8gYCR7dGhpcy5tb2R1bGVOYW1lfSR7bW9kdWxlTmFtZX1gXG4gICAgICAgICAgOiBtb2R1bGVOYW1lXG4gICAgICAgIDogdGhpcy5tb2R1bGVOYW1lLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgaXNJbk1vZHVsZSh0eXBlUmVmOiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZSB8IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHB5dGhvblR5cGUgPVxuICAgICAgdHlwZW9mIHR5cGVSZWYgIT09ICdzdHJpbmcnID8gdGhpcy50b1B5dGhvbkZRTih0eXBlUmVmLmZxbikgOiB0eXBlUmVmO1xuICAgIHJldHVybiB0aGlzLm1vZHVsZVJlLnRlc3QocHl0aG9uVHlwZSk7XG4gIH1cblxuICBwdWJsaWMgaXNJbk5hbWVzcGFjZSh0eXBlUmVmOiBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZSB8IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHB5dGhvblR5cGUgPVxuICAgICAgdHlwZW9mIHR5cGVSZWYgIT09ICdzdHJpbmcnID8gdGhpcy50b1B5dGhvbkZRTih0eXBlUmVmLmZxbikgOiB0eXBlUmVmO1xuICAgIHJldHVybiB0aGlzLmJvdW5kUmUudGVzdChweXRob25UeXBlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQYXJlbnQodHlwZVJlZjogc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2UgfCBzdHJpbmcpOiBQeXRob25UeXBlIHtcbiAgICBjb25zdCBmcW4gPSB0eXBlb2YgdHlwZVJlZiAhPT0gJ3N0cmluZycgPyB0eXBlUmVmLmZxbiA6IHR5cGVSZWY7XG4gICAgY29uc3QgbWF0Y2hlcyA9IC9eKC4rKVxcLlteLl0rJC8uZXhlYyhmcW4pO1xuICAgIGlmIChtYXRjaGVzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkobWF0Y2hlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBGUU46ICR7ZnFufWApO1xuICAgIH1cbiAgICBjb25zdCBbLCBwYXJlbnRGUU5dID0gbWF0Y2hlcztcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnR5cGVzLmdldChwYXJlbnRGUU4pO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhcmVudDogICR7cGFyZW50RlFOfWApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGVmaW5pbmdQeXRob25Nb2R1bGUoXG4gICAgdHlwZVJlZjogc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2UgfCBzdHJpbmcsXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgZnFuID0gdHlwZW9mIHR5cGVSZWYgIT09ICdzdHJpbmcnID8gdHlwZVJlZi5mcW4gOiB0eXBlUmVmO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMudHlwZXMuZ2V0KGZxbik7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBsZXQgbW9kID0gcGFyZW50O1xuICAgICAgd2hpbGUgKCEobW9kIGluc3RhbmNlb2YgUHl0aG9uTW9kdWxlKSkge1xuICAgICAgICBtb2QgPSB0aGlzLmdldFBhcmVudChtb2QuZnFuISk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kLnB5dGhvbk5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2hlcyA9IC9eKFteLl0rKVxcLi8uZXhlYyhmcW4pO1xuICAgIGlmIChtYXRjaGVzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkobWF0Y2hlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBGUU46ICR7ZnFufWApO1xuICAgIH1cbiAgICBjb25zdCBbLCBhc3NtXSA9IG1hdGNoZXM7XG4gICAgcmV0dXJuIHRoaXMuZmluZE1vZHVsZShhc3NtKS50YXJnZXRzIS5weXRob24hLm1vZHVsZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKHR5cGVSZWY6IHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlKTogUHl0aG9uVHlwZSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZXMuZ2V0KHR5cGVSZWYuZnFuKTtcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGxvY2F0ZSB0eXBlOiBcIiR7dHlwZVJlZi5mcW59XCJgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHB1YmxpYyBkZXJlZmVyZW5jZSh0eXBlUmVmOiBzdHJpbmcgfCBzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZSk6IHNwZWMuVHlwZSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlUmVmICE9PSAnc3RyaW5nJykge1xuICAgICAgdHlwZVJlZiA9IHR5cGVSZWYuZnFuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5kVHlwZSh0eXBlUmVmKTtcbiAgfVxuXG4gIHByaXZhdGUgdG9QeXRob25GUU4oZnFuOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IFthc3NlbWJseU5hbWUsIC4uLnF1YWxpZmllZElkZW50aWZpZXJzXSA9IGZxbi5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGZxblBhcnRzOiBzdHJpbmdbXSA9IFtcbiAgICAgIHRoaXMuZmluZE1vZHVsZShhc3NlbWJseU5hbWUpLnRhcmdldHMhLnB5dGhvbiEubW9kdWxlLFxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcXVhbGlmaWVkSWRlbnRpZmllcnMpIHtcbiAgICAgIGZxblBhcnRzLnB1c2godG9QeXRob25JZGVudGlmaWVyKHBhcnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnFuUGFydHMuam9pbignLicpO1xuICB9XG59XG5cbmNsYXNzIFB5dGhvbkdlbmVyYXRvciBleHRlbmRzIEdlbmVyYXRvciB7XG4gIHByaXZhdGUgcGFja2FnZSE6IFBhY2thZ2U7XG4gIHByaXZhdGUgcm9vdE1vZHVsZT86IFB5dGhvbk1vZHVsZTtcbiAgcHJpdmF0ZSByZWFkb25seSB0eXBlczogTWFwPHN0cmluZywgUHl0aG9uVHlwZT47XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcm9zZXR0YTogUm9zZXR0YSxcbiAgICBvcHRpb25zOiBHZW5lcmF0b3JPcHRpb25zID0ge30sXG4gICkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb2RlLm9wZW5CbG9ja0Zvcm1hdHRlciA9IChzKSA9PiBgJHtzfTpgO1xuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrRm9ybWF0dGVyID0gKF9zKSA9PiBmYWxzZTtcblxuICAgIHRoaXMudHlwZXMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBwdWJsaWMgZW1pdERvY1N0cmluZyhcbiAgICBjb2RlOiBDb2RlTWFrZXIsXG4gICAgYXBpTG9jYXRpb246IEFwaUxvY2F0aW9uLFxuICAgIGRvY3M6IHNwZWMuRG9jcyB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiB7XG4gICAgICBhcmd1bWVudHM/OiBEb2N1bWVudGFibGVBcmd1bWVudFtdO1xuICAgICAgZG9jdW1lbnRhYmxlSXRlbT86IHN0cmluZztcbiAgICAgIHRyYWlsaW5nTmV3TGluZT86IGJvb2xlYW47XG4gICAgfSA9IHt9LFxuICApIHtcbiAgICBpZiAoKCFkb2NzIHx8IE9iamVjdC5rZXlzKGRvY3MpLmxlbmd0aCA9PT0gMCkgJiYgIW9wdGlvbnMuYXJndW1lbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZG9jcykge1xuICAgICAgZG9jcyA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGlmIChkb2NzLnN1bW1hcnkpIHtcbiAgICAgIGxpbmVzLnB1c2gobWQycnN0KHJlbmRlclN1bW1hcnkoZG9jcykpKTtcbiAgICAgIGJyaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicmsoKSB7XG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMCAmJiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJsb2NrKGhlYWRpbmc6IHN0cmluZywgY29udGVudDogc3RyaW5nLCBkb0JyayA9IHRydWUpIHtcbiAgICAgIGlmIChkb0Jyaykge1xuICAgICAgICBicmsoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRMaW5lcyA9IG1kMnJzdChjb250ZW50KS5zcGxpdCgnXFxuJyk7XG4gICAgICBpZiAoY29udGVudExpbmVzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGxpbmVzLnB1c2goYDoke2hlYWRpbmd9OiAke2NvbnRlbnRMaW5lcy5qb2luKCcnKX1gLnRyaW0oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lcy5wdXNoKGA6JHtoZWFkaW5nfTpgKTtcbiAgICAgICAgYnJrKCk7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBjb250ZW50TGluZXMpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRvQnJrKSB7XG4gICAgICAgIGJyaygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkb2NzLnJlbWFya3MpIHtcbiAgICAgIGJyaygpO1xuICAgICAgbGluZXMucHVzaChcbiAgICAgICAgLi4ubWQycnN0KHRoaXMuY29udmVydE1hcmtkb3duKGRvY3MucmVtYXJrcyA/PyAnJywgYXBpTG9jYXRpb24pKS5zcGxpdChcbiAgICAgICAgICAnXFxuJyxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICBicmsoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hcmd1bWVudHM/Lmxlbmd0aCA/PyAwID4gMCkge1xuICAgICAgYnJrKCk7XG4gICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIG9wdGlvbnMuYXJndW1lbnRzISkge1xuICAgICAgICAvLyBBZGQgYSBsaW5lIGZvciBldmVyeSBhcmd1bWVudC4gRXZlbiBpZiB0aGVyZSBpcyBubyBkZXNjcmlwdGlvbiwgd2UgbmVlZFxuICAgICAgICAvLyB0aGUgZG9jc3RyaW5nIHNvIHRoYXQgdGhlIFNwaGlueCBleHRlbnNpb24gY2FuIGFkZCB0aGUgdHlwZSBhbm5vdGF0aW9ucy5cbiAgICAgICAgbGluZXMucHVzaChcbiAgICAgICAgICBgOnBhcmFtICR7dG9QeXRob25QYXJhbWV0ZXJOYW1lKHBhcmFtLm5hbWUpfTogJHtvbmVsaW5lRGVzY3JpcHRpb24oXG4gICAgICAgICAgICBwYXJhbS5kb2NzLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyaygpO1xuICAgIH1cblxuICAgIGlmIChkb2NzLmRlZmF1bHQpIHtcbiAgICAgIGJsb2NrKCdkZWZhdWx0JywgZG9jcy5kZWZhdWx0KTtcbiAgICB9XG4gICAgaWYgKGRvY3MucmV0dXJucykge1xuICAgICAgYmxvY2soJ3JldHVybicsIGRvY3MucmV0dXJucyk7XG4gICAgfVxuICAgIGlmIChkb2NzLmRlcHJlY2F0ZWQpIHtcbiAgICAgIGJsb2NrKCdkZXByZWNhdGVkJywgZG9jcy5kZXByZWNhdGVkKTtcbiAgICB9XG4gICAgaWYgKGRvY3Muc2VlKSB7XG4gICAgICBibG9jaygnc2VlJywgZG9jcy5zZWUsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGRvY3Muc3RhYmlsaXR5ICYmIHNob3VsZE1lbnRpb25TdGFiaWxpdHkoZG9jcy5zdGFiaWxpdHkpKSB7XG4gICAgICBibG9jaygnc3RhYmlsaXR5JywgZG9jcy5zdGFiaWxpdHksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGRvY3Muc3ViY2xhc3NhYmxlKSB7XG4gICAgICBibG9jaygnc3ViY2xhc3NhYmxlJywgJ1llcycpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGRvY3MuY3VzdG9tID8/IHt9KSkge1xuICAgICAgYmxvY2soaywgdiwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChkb2NzLmV4YW1wbGUpIHtcbiAgICAgIGJyaygpO1xuICAgICAgbGluZXMucHVzaCgnRXhhbXBsZTo6Jyk7XG4gICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgIGNvbnN0IGV4YW1wbGVUZXh0ID0gdGhpcy5jb252ZXJ0RXhhbXBsZShkb2NzLmV4YW1wbGUsIGFwaUxvY2F0aW9uKTtcblxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGV4YW1wbGVUZXh0LnNwbGl0KCdcXG4nKSkge1xuICAgICAgICBsaW5lcy5wdXNoKGAgICAgJHtsaW5lfWApO1xuICAgICAgfVxuICAgICAgYnJrKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGxpbmVzLmxlbmd0aCA+IDAgJiYgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICBsaW5lcy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29kZS5saW5lKGAke0RPQ1NUUklOR19RVU9URVN9JHtsaW5lc1swXX0ke0RPQ1NUUklOR19RVU9URVN9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUubGluZShgJHtET0NTVFJJTkdfUVVPVEVTfSR7bGluZXNbMF19YCk7XG4gICAgICBsaW5lcy5zcGxpY2UoMCwgMSk7XG5cbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBjb2RlLmxpbmUobGluZSk7XG4gICAgICB9XG5cbiAgICAgIGNvZGUubGluZShET0NTVFJJTkdfUVVPVEVTKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJhaWxpbmdOZXdMaW5lKSB7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29udmVydEV4YW1wbGUoZXhhbXBsZTogc3RyaW5nLCBhcGlMb2M6IEFwaUxvY2F0aW9uKTogc3RyaW5nIHtcbiAgICBjb25zdCB0cmFuc2xhdGVkID0gdGhpcy5yb3NldHRhLnRyYW5zbGF0ZUV4YW1wbGUoXG4gICAgICBhcGlMb2MsXG4gICAgICBleGFtcGxlLFxuICAgICAgVGFyZ2V0TGFuZ3VhZ2UuUFlUSE9OLFxuICAgICAgZW5mb3JjZXNTdHJpY3RNb2RlKHRoaXMuYXNzZW1ibHkpLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMucHJlZml4RGlzY2xhaW1lcih0cmFuc2xhdGVkKTtcbiAgfVxuXG4gIHB1YmxpYyBjb252ZXJ0TWFya2Rvd24obWFya2Rvd246IHN0cmluZywgYXBpTG9jOiBBcGlMb2NhdGlvbik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucm9zZXR0YS50cmFuc2xhdGVTbmlwcGV0c0luTWFya2Rvd24oXG4gICAgICBhcGlMb2MsXG4gICAgICBtYXJrZG93bixcbiAgICAgIFRhcmdldExhbmd1YWdlLlBZVEhPTixcbiAgICAgIGVuZm9yY2VzU3RyaWN0TW9kZSh0aGlzLmFzc2VtYmx5KSxcbiAgICAgICh0cmFucykgPT4gKHtcbiAgICAgICAgbGFuZ3VhZ2U6IHRyYW5zLmxhbmd1YWdlLFxuICAgICAgICBzb3VyY2U6IHRoaXMucHJlZml4RGlzY2xhaW1lcih0cmFucyksXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVmaXhEaXNjbGFpbWVyKHRyYW5zbGF0ZWQ6IFRyYW5zbGF0aW9uKSB7XG4gICAgaWYgKCF0cmFuc2xhdGVkLmRpZENvbXBpbGUgJiYgSU5DT01QTEVURV9ESVNDTEFJTUVSX05PTkNPTVBJTElORykge1xuICAgICAgcmV0dXJuIGAjICR7SU5DT01QTEVURV9ESVNDTEFJTUVSX05PTkNPTVBJTElOR31cXG4ke3RyYW5zbGF0ZWQuc291cmNlfWA7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2xhdGVkLnNvdXJjZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQeXRob25UeXBlKGZxbjogc3RyaW5nKTogUHl0aG9uVHlwZSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZXMuZ2V0KGZxbik7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2NhdGUgdHlwZTogXCIke2Zxbn1cImApO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEFzc2VtYmx5T3V0cHV0RGlyKGFzc206IHNwZWMuQXNzZW1ibHkpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKFxuICAgICAgJ3NyYycsXG4gICAgICBweXRob25Nb2R1bGVOYW1lVG9GaWxlbmFtZSh0aGlzLmdldEFzc2VtYmx5TW9kdWxlTmFtZShhc3NtKSksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJlZ2luQXNzZW1ibHkoYXNzbTogc3BlYy5Bc3NlbWJseSwgX2ZpbmdlcnByaW50OiBib29sZWFuKSB7XG4gICAgdGhpcy5wYWNrYWdlID0gbmV3IFBhY2thZ2UoXG4gICAgICBhc3NtLnRhcmdldHMhLnB5dGhvbiEuZGlzdE5hbWUsXG4gICAgICB0b1JlbGVhc2VWZXJzaW9uKGFzc20udmVyc2lvbiwgVGFyZ2V0TmFtZS5QWVRIT04pLFxuICAgICAgYXNzbSxcbiAgICApO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgJzxwYWNrYWdlbmFtZT4uX2pzaWknIG1vZHVsZSBmb3IgdGhpcyBhc3NlbWJseVxuICAgIGNvbnN0IGFzc2VtYmx5TW9kdWxlID0gbmV3IFB5dGhvbk1vZHVsZShcbiAgICAgIHRoaXMuZ2V0QXNzZW1ibHlNb2R1bGVOYW1lKGFzc20pLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAge1xuICAgICAgICBhc3NlbWJseTogYXNzbSxcbiAgICAgICAgYXNzZW1ibHlGaWxlbmFtZTogdGhpcy5nZXRBc3NlbWJseUZpbGVOYW1lKCksXG4gICAgICAgIGxvYWRBc3NlbWJseTogdHJ1ZSxcbiAgICAgICAgcGFja2FnZTogdGhpcy5wYWNrYWdlLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5wYWNrYWdlLmFkZE1vZHVsZShhc3NlbWJseU1vZHVsZSk7XG4gICAgdGhpcy5wYWNrYWdlLmFkZERhdGEoYXNzZW1ibHlNb2R1bGUsIHRoaXMuZ2V0QXNzZW1ibHlGaWxlTmFtZSgpLCB1bmRlZmluZWQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRW5kQXNzZW1ibHkoYXNzbTogc3BlYy5Bc3NlbWJseSwgX2ZpbmdlcnByaW50OiBib29sZWFuKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgVHlwZVJlc29sdmVyKFxuICAgICAgdGhpcy50eXBlcyxcbiAgICAgIChmcW46IHN0cmluZykgPT4gdGhpcy5maW5kTW9kdWxlKGZxbiksXG4gICAgICAoZnFuOiBzdHJpbmcpID0+IHRoaXMuZmluZFR5cGUoZnFuKSxcbiAgICApO1xuICAgIHRoaXMucGFja2FnZS53cml0ZSh0aGlzLmNvZGUsIHtcbiAgICAgIGFzc2VtYmx5OiBhc3NtLFxuICAgICAgZW1pdHRlZFR5cGVzOiBuZXcgU2V0KCksXG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1Ym1vZHVsZTogYXNzbS5uYW1lLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgYmUgY2FsbGVkIGZvciBhc3NlbWJseSByb290LCBuYW1lc3BhY2VzIGFuZCBzdWJtb2R1bGVzIChhbnl0aGluZyB0aGF0IGNvbnRhaW5zIG90aGVyIHR5cGVzLCBiYXNlZCBvbiBpdHMgRlFOKVxuICAgKi9cbiAgcHJvdGVjdGVkIG9uQmVnaW5OYW1lc3BhY2UobnM6IHN0cmluZykge1xuICAgIC8vICducycgY29udGFpbnMgc29tZXRoaW5nIGxpa2UgJ0BzY29wZS9qc2lpLWNhbGMtYmFzZS1vZi1iYXNlJ1xuICAgIGNvbnN0IHN1Ym1vZHVsZUxpa2UgPVxuICAgICAgbnMgPT09IHRoaXMuYXNzZW1ibHkubmFtZVxuICAgICAgICA/IHRoaXMuYXNzZW1ibHlcbiAgICAgICAgOiB0aGlzLmFzc2VtYmx5LnN1Ym1vZHVsZXM/Lltuc107XG5cbiAgICBjb25zdCByZWFkbWVMb2NhdGlvbjogQXBpTG9jYXRpb24gPSB7IGFwaTogJ21vZHVsZVJlYWRtZScsIG1vZHVsZUZxbjogbnMgfTtcblxuICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBQeXRob25Nb2R1bGUodG9QYWNrYWdlTmFtZShucywgdGhpcy5hc3NlbWJseSksIG5zLCB7XG4gICAgICBhc3NlbWJseTogdGhpcy5hc3NlbWJseSxcbiAgICAgIGFzc2VtYmx5RmlsZW5hbWU6IHRoaXMuZ2V0QXNzZW1ibHlGaWxlTmFtZSgpLFxuICAgICAgcGFja2FnZTogdGhpcy5wYWNrYWdlLFxuICAgICAgbW9kdWxlRG9jdW1lbnRhdGlvbjogc3VibW9kdWxlTGlrZT8ucmVhZG1lXG4gICAgICAgID8gdGhpcy5jb252ZXJ0TWFya2Rvd24oXG4gICAgICAgICAgICBzdWJtb2R1bGVMaWtlLnJlYWRtZT8ubWFya2Rvd24sXG4gICAgICAgICAgICByZWFkbWVMb2NhdGlvbixcbiAgICAgICAgICApLnRyaW0oKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9KTtcblxuICAgIHRoaXMucGFja2FnZS5hZGRNb2R1bGUobW9kdWxlKTtcbiAgICB0aGlzLnR5cGVzLnNldChucywgbW9kdWxlKTtcbiAgICBpZiAobnMgPT09IHRoaXMuYXNzZW1ibHkubmFtZSkge1xuICAgICAgLy8gVGhpcyBhcHBsaWVzIHJlY3Vyc2l2ZWx5IHRvIHN1Ym1vZHVsZXMsIHNvIG5vIG5lZWQgdG8gZHVwbGljYXRlIVxuICAgICAgdGhpcy5wYWNrYWdlLmFkZERhdGEobW9kdWxlLCAncHkudHlwZWQnLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKG5zID09PSB0aGlzLmFzc2VtYmx5Lm5hbWUpIHtcbiAgICAgIHRoaXMucm9vdE1vZHVsZSA9IG1vZHVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290TW9kdWxlIS5hZGRQeXRob25Nb2R1bGUobW9kdWxlKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25FbmROYW1lc3BhY2UobnM6IHN0cmluZykge1xuICAgIGlmIChucyA9PT0gdGhpcy5hc3NlbWJseS5uYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5yb290TW9kdWxlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJlZ2luQ2xhc3MoY2xzOiBzcGVjLkNsYXNzVHlwZSwgYWJzdHJhY3Q6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBrbGFzcyA9IG5ldyBDbGFzcyhcbiAgICAgIHRoaXMsXG4gICAgICB0b1B5dGhvbklkZW50aWZpZXIoY2xzLm5hbWUpLFxuICAgICAgY2xzLFxuICAgICAgY2xzLmZxbixcbiAgICAgIHtcbiAgICAgICAgYWJzdHJhY3QsXG4gICAgICAgIGJhc2VzOiBjbHMuYmFzZSA/IFt0aGlzLmZpbmRUeXBlKGNscy5iYXNlKV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGludGVyZmFjZXM6IGNscy5pbnRlcmZhY2VzPy5tYXAoKGJhc2UpID0+IHRoaXMuZmluZFR5cGUoYmFzZSkpLFxuICAgICAgICBhYnN0cmFjdEJhc2VzOiBhYnN0cmFjdCA/IHRoaXMuZ2V0QWJzdHJhY3RCYXNlcyhjbHMpIDogW10sXG4gICAgICB9LFxuICAgICAgY2xzLmRvY3MsXG4gICAgKTtcblxuICAgIGlmIChjbHMuaW5pdGlhbGl6ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgeyBwYXJhbWV0ZXJzID0gW10gfSA9IGNscy5pbml0aWFsaXplcjtcblxuICAgICAga2xhc3MuYWRkTWVtYmVyKFxuICAgICAgICBuZXcgSW5pdGlhbGl6ZXIoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAnX19pbml0X18nLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBjbHMuaW5pdGlhbGl6ZXIuZG9jcyxcbiAgICAgICAgICBmYWxzZSwgLy8gTmV2ZXIgc3RhdGljXG4gICAgICAgICAgeyBsaWZ0ZWRQcm9wOiB0aGlzLmdldGxpZnRlZFByb3AoY2xzLmluaXRpYWxpemVyKSwgcGFyZW50OiBjbHMgfSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRQeXRob25UeXBlKGtsYXNzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblN0YXRpY01ldGhvZChjbHM6IHNwZWMuQ2xhc3NUeXBlLCBtZXRob2Q6IHNwZWMuTWV0aG9kKSB7XG4gICAgY29uc3QgeyBwYXJhbWV0ZXJzID0gW10gfSA9IG1ldGhvZDtcblxuICAgIHRoaXMuZ2V0UHl0aG9uVHlwZShjbHMuZnFuKS5hZGRNZW1iZXIoXG4gICAgICBuZXcgU3RhdGljTWV0aG9kKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0b1B5dGhvbk1ldGhvZE5hbWUobWV0aG9kLm5hbWUpLFxuICAgICAgICBtZXRob2QubmFtZSxcbiAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgbWV0aG9kLnJldHVybnMsXG4gICAgICAgIG1ldGhvZC5kb2NzLFxuICAgICAgICB0cnVlLCAvLyBBbHdheXMgc3RhdGljXG4gICAgICAgIHtcbiAgICAgICAgICBhYnN0cmFjdDogbWV0aG9kLmFic3RyYWN0LFxuICAgICAgICAgIGxpZnRlZFByb3A6IHRoaXMuZ2V0bGlmdGVkUHJvcChtZXRob2QpLFxuICAgICAgICAgIHBhcmVudDogY2xzLFxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uU3RhdGljUHJvcGVydHkoY2xzOiBzcGVjLkNsYXNzVHlwZSwgcHJvcDogc3BlYy5Qcm9wZXJ0eSkge1xuICAgIHRoaXMuZ2V0UHl0aG9uVHlwZShjbHMuZnFuKS5hZGRNZW1iZXIoXG4gICAgICBuZXcgU3RhdGljUHJvcGVydHkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvUHl0aG9uUHJvcGVydHlOYW1lKHByb3AubmFtZSwgcHJvcC5jb25zdCksXG4gICAgICAgIHByb3AubmFtZSxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgcHJvcC5kb2NzLFxuICAgICAgICB7XG4gICAgICAgICAgYWJzdHJhY3Q6IHByb3AuYWJzdHJhY3QsXG4gICAgICAgICAgaW1tdXRhYmxlOiBwcm9wLmltbXV0YWJsZSxcbiAgICAgICAgICBpc1N0YXRpYzogcHJvcC5zdGF0aWMsXG4gICAgICAgICAgcGFyZW50OiBjbHMsXG4gICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZXRob2QoY2xzOiBzcGVjLkNsYXNzVHlwZSwgbWV0aG9kOiBzcGVjLk1ldGhvZCkge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVycyA9IFtdIH0gPSBtZXRob2Q7XG5cbiAgICBpZiAobWV0aG9kLmFzeW5jKSB7XG4gICAgICB0aGlzLmdldFB5dGhvblR5cGUoY2xzLmZxbikuYWRkTWVtYmVyKFxuICAgICAgICBuZXcgQXN5bmNNZXRob2QoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0b1B5dGhvbk1ldGhvZE5hbWUobWV0aG9kLm5hbWUsIG1ldGhvZC5wcm90ZWN0ZWQpLFxuICAgICAgICAgIG1ldGhvZC5uYW1lLFxuICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgbWV0aG9kLnJldHVybnMsXG4gICAgICAgICAgbWV0aG9kLmRvY3MsXG4gICAgICAgICAgISFtZXRob2Quc3RhdGljLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFic3RyYWN0OiBtZXRob2QuYWJzdHJhY3QsXG4gICAgICAgICAgICBsaWZ0ZWRQcm9wOiB0aGlzLmdldGxpZnRlZFByb3AobWV0aG9kKSxcbiAgICAgICAgICAgIHBhcmVudDogY2xzLFxuICAgICAgICAgIH0sXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldFB5dGhvblR5cGUoY2xzLmZxbikuYWRkTWVtYmVyKFxuICAgICAgICBuZXcgTWV0aG9kKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdG9QeXRob25NZXRob2ROYW1lKG1ldGhvZC5uYW1lLCBtZXRob2QucHJvdGVjdGVkKSxcbiAgICAgICAgICBtZXRob2QubmFtZSxcbiAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgIG1ldGhvZC5yZXR1cm5zLFxuICAgICAgICAgIG1ldGhvZC5kb2NzLFxuICAgICAgICAgICEhbWV0aG9kLnN0YXRpYyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhYnN0cmFjdDogbWV0aG9kLmFic3RyYWN0LFxuICAgICAgICAgICAgbGlmdGVkUHJvcDogdGhpcy5nZXRsaWZ0ZWRQcm9wKG1ldGhvZCksXG4gICAgICAgICAgICBwYXJlbnQ6IGNscyxcbiAgICAgICAgICB9LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25Qcm9wZXJ0eShjbHM6IHNwZWMuQ2xhc3NUeXBlLCBwcm9wOiBzcGVjLlByb3BlcnR5KSB7XG4gICAgdGhpcy5nZXRQeXRob25UeXBlKGNscy5mcW4pLmFkZE1lbWJlcihcbiAgICAgIG5ldyBQcm9wZXJ0eShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdG9QeXRob25Qcm9wZXJ0eU5hbWUocHJvcC5uYW1lLCBwcm9wLmNvbnN0LCBwcm9wLnByb3RlY3RlZCksXG4gICAgICAgIHByb3AubmFtZSxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgcHJvcC5kb2NzLFxuICAgICAgICB7XG4gICAgICAgICAgYWJzdHJhY3Q6IHByb3AuYWJzdHJhY3QsXG4gICAgICAgICAgaW1tdXRhYmxlOiBwcm9wLmltbXV0YWJsZSxcbiAgICAgICAgICBpc1N0YXRpYzogcHJvcC5zdGF0aWMsXG4gICAgICAgICAgcGFyZW50OiBjbHMsXG4gICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25VbmlvblByb3BlcnR5KFxuICAgIGNsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgcHJvcDogc3BlYy5Qcm9wZXJ0eSxcbiAgICBfdW5pb246IHNwZWMuVW5pb25UeXBlUmVmZXJlbmNlLFxuICApIHtcbiAgICB0aGlzLm9uUHJvcGVydHkoY2xzLCBwcm9wKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJlZ2luSW50ZXJmYWNlKGlmYzogc3BlYy5JbnRlcmZhY2VUeXBlKSB7XG4gICAgbGV0IGlmYWNlOiBJbnRlcmZhY2UgfCBTdHJ1Y3Q7XG5cbiAgICBpZiAoaWZjLmRhdGF0eXBlKSB7XG4gICAgICBpZmFjZSA9IG5ldyBTdHJ1Y3QoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvUHl0aG9uSWRlbnRpZmllcihpZmMubmFtZSksXG4gICAgICAgIGlmYyxcbiAgICAgICAgaWZjLmZxbixcbiAgICAgICAgeyBiYXNlczogaWZjLmludGVyZmFjZXM/Lm1hcCgoYmFzZSkgPT4gdGhpcy5maW5kVHlwZShiYXNlKSkgfSxcbiAgICAgICAgaWZjLmRvY3MsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZmFjZSA9IG5ldyBJbnRlcmZhY2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvUHl0aG9uSWRlbnRpZmllcihpZmMubmFtZSksXG4gICAgICAgIGlmYyxcbiAgICAgICAgaWZjLmZxbixcbiAgICAgICAgeyBiYXNlczogaWZjLmludGVyZmFjZXM/Lm1hcCgoYmFzZSkgPT4gdGhpcy5maW5kVHlwZShiYXNlKSkgfSxcbiAgICAgICAgaWZjLmRvY3MsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuYWRkUHl0aG9uVHlwZShpZmFjZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25FbmRJbnRlcmZhY2UoX2lmYzogc3BlYy5JbnRlcmZhY2VUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uSW50ZXJmYWNlTWV0aG9kKGlmYzogc3BlYy5JbnRlcmZhY2VUeXBlLCBtZXRob2Q6IHNwZWMuTWV0aG9kKSB7XG4gICAgY29uc3QgeyBwYXJhbWV0ZXJzID0gW10gfSA9IG1ldGhvZDtcblxuICAgIHRoaXMuZ2V0UHl0aG9uVHlwZShpZmMuZnFuKS5hZGRNZW1iZXIoXG4gICAgICBuZXcgSW50ZXJmYWNlTWV0aG9kKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0b1B5dGhvbk1ldGhvZE5hbWUobWV0aG9kLm5hbWUsIG1ldGhvZC5wcm90ZWN0ZWQpLFxuICAgICAgICBtZXRob2QubmFtZSxcbiAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgbWV0aG9kLnJldHVybnMsXG4gICAgICAgIG1ldGhvZC5kb2NzLFxuICAgICAgICAhIW1ldGhvZC5zdGF0aWMsXG4gICAgICAgIHsgbGlmdGVkUHJvcDogdGhpcy5nZXRsaWZ0ZWRQcm9wKG1ldGhvZCksIHBhcmVudDogaWZjIH0sXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25JbnRlcmZhY2VQcm9wZXJ0eShpZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSwgcHJvcDogc3BlYy5Qcm9wZXJ0eSkge1xuICAgIGxldCBpZmFjZVByb3BlcnR5OiBJbnRlcmZhY2VQcm9wZXJ0eSB8IFN0cnVjdEZpZWxkO1xuXG4gICAgaWYgKGlmYy5kYXRhdHlwZSkge1xuICAgICAgaWZhY2VQcm9wZXJ0eSA9IG5ldyBTdHJ1Y3RGaWVsZCh0aGlzLCBwcm9wLCBpZmMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZmFjZVByb3BlcnR5ID0gbmV3IEludGVyZmFjZVByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICB0b1B5dGhvblByb3BlcnR5TmFtZShwcm9wLm5hbWUsIHByb3AuY29uc3QsIHByb3AucHJvdGVjdGVkKSxcbiAgICAgICAgcHJvcC5uYW1lLFxuICAgICAgICBwcm9wLFxuICAgICAgICBwcm9wLmRvY3MsXG4gICAgICAgIHsgaW1tdXRhYmxlOiBwcm9wLmltbXV0YWJsZSwgaXNTdGF0aWM6IHByb3Auc3RhdGljLCBwYXJlbnQ6IGlmYyB9LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmdldFB5dGhvblR5cGUoaWZjLmZxbikuYWRkTWVtYmVyKGlmYWNlUHJvcGVydHkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQmVnaW5FbnVtKGVubTogc3BlYy5FbnVtVHlwZSkge1xuICAgIHRoaXMuYWRkUHl0aG9uVHlwZShcbiAgICAgIG5ldyBFbnVtKHRoaXMsIHRvUHl0aG9uSWRlbnRpZmllcihlbm0ubmFtZSksIGVubSwgZW5tLmZxbiwge30sIGVubS5kb2NzKSxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRW51bU1lbWJlcihlbm06IHNwZWMuRW51bVR5cGUsIG1lbWJlcjogc3BlYy5FbnVtTWVtYmVyKSB7XG4gICAgdGhpcy5nZXRQeXRob25UeXBlKGVubS5mcW4pLmFkZE1lbWJlcihcbiAgICAgIG5ldyBFbnVtTWVtYmVyKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0b1B5dGhvbklkZW50aWZpZXIobWVtYmVyLm5hbWUpLFxuICAgICAgICBtZW1iZXIubmFtZSxcbiAgICAgICAgbWVtYmVyLmRvY3MsXG4gICAgICAgIGVubSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkludGVyZmFjZU1ldGhvZE92ZXJsb2FkKFxuICAgIF9pZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSxcbiAgICBfb3ZlcmxvYWQ6IHNwZWMuTWV0aG9kLFxuICAgIF9vcmlnaW5hbE1ldGhvZDogc3BlYy5NZXRob2QsXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIFR5cGU6IEludGVyZmFjZU1ldGhvZE92ZXJsb2FkJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZXRob2RPdmVybG9hZChcbiAgICBfY2xzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBfb3ZlcmxvYWQ6IHNwZWMuTWV0aG9kLFxuICAgIF9vcmlnaW5hbE1ldGhvZDogc3BlYy5NZXRob2QsXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIFR5cGU6IE1ldGhvZE92ZXJsb2FkJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25TdGF0aWNNZXRob2RPdmVybG9hZChcbiAgICBfY2xzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBfb3ZlcmxvYWQ6IHNwZWMuTWV0aG9kLFxuICAgIF9vcmlnaW5hbE1ldGhvZDogc3BlYy5NZXRob2QsXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIFR5cGU6IFN0YXRpY01ldGhvZE92ZXJsb2FkJyk7XG4gIH1cblxuICBwcml2YXRlIGdldEFzc2VtYmx5TW9kdWxlTmFtZShhc3NtOiBzcGVjLkFzc2VtYmx5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7YXNzbS50YXJnZXRzIS5weXRob24hLm1vZHVsZX0uX2pzaWlgO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQYXJlbnRGUU4oZnFuOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG0gPSAvXiguKylcXC5bXi5dKyQvLmV4ZWMoZnFuKTtcblxuICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGRldGVybWluZSBwYXJlbnQgRlFOIG9mOiAke2Zxbn1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbVsxXTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGFyZW50KGZxbjogc3RyaW5nKTogUHl0aG9uVHlwZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHl0aG9uVHlwZSh0aGlzLmdldFBhcmVudEZRTihmcW4pKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkUHl0aG9uVHlwZSh0eXBlOiBQeXRob25UeXBlKSB7XG4gICAgaWYgKHR5cGUuZnFuID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBhIFB5dGhvbiB0eXBlIHdpdGhvdXQgYSBGUU4uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRQYXJlbnQodHlwZS5mcW4pLmFkZE1lbWJlcih0eXBlKTtcbiAgICB0aGlzLnR5cGVzLnNldCh0eXBlLmZxbiwgdHlwZSk7XG4gIH1cblxuICBwcml2YXRlIGdldGxpZnRlZFByb3AoXG4gICAgbWV0aG9kOiBzcGVjLk1ldGhvZCB8IHNwZWMuSW5pdGlhbGl6ZXIsXG4gICk6IHNwZWMuSW50ZXJmYWNlVHlwZSB8IHVuZGVmaW5lZCB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIHBhcmFtZXRlcnMgdG8gdGhpcyBtZXRob2QsIGFuZCBpZiB0aGUgbGFzdCBwYXJhbWV0ZXIncyB0eXBlIGlzXG4gICAgLy8gYSBkYXRhdHlwZSBpbnRlcmZhY2UsIHRoZW4gd2Ugd2FudCB0byBsaWZ0IHRoZSBtZW1iZXJzIG9mIHRoYXQgbGFzdCBwYXJhbXRlclxuICAgIC8vIGFzIGtleXdvcmQgYXJndW1lbnRzIHRvIHRoaXMgZnVuY3Rpb24uXG4gICAgaWYgKG1ldGhvZC5wYXJhbWV0ZXJzPy5sZW5ndGggPz8gMCA+PSAxKSB7XG4gICAgICBjb25zdCBsYXN0UGFyYW1ldGVyID0gbWV0aG9kLnBhcmFtZXRlcnMhLnNsaWNlKC0xKVswXTtcbiAgICAgIGlmIChcbiAgICAgICAgIWxhc3RQYXJhbWV0ZXIudmFyaWFkaWMgJiZcbiAgICAgICAgc3BlYy5pc05hbWVkVHlwZVJlZmVyZW5jZShsYXN0UGFyYW1ldGVyLnR5cGUpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbGFzdFBhcmFtZXRlclR5cGUgPSB0aGlzLmZpbmRUeXBlKGxhc3RQYXJhbWV0ZXIudHlwZS5mcW4pO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3BlYy5pc0ludGVyZmFjZVR5cGUobGFzdFBhcmFtZXRlclR5cGUpICYmXG4gICAgICAgICAgbGFzdFBhcmFtZXRlclR5cGUuZGF0YXR5cGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGxhc3RQYXJhbWV0ZXJUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QWJzdHJhY3RCYXNlcyhjbHM6IHNwZWMuQ2xhc3NUeXBlKTogc3BlYy5DbGFzc1R5cGVbXSB7XG4gICAgY29uc3QgYWJzdHJhY3RCYXNlczogc3BlYy5DbGFzc1R5cGVbXSA9IFtdO1xuXG4gICAgaWYgKGNscy5iYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLmZpbmRUeXBlKGNscy5iYXNlKTtcblxuICAgICAgaWYgKCFzcGVjLmlzQ2xhc3NUeXBlKGJhc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsYXNzIGluaGVyaXRlbmNlIHRoYXQgaXNuJ3QgYSBjbGFzcz9cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYXNlLmFic3RyYWN0KSB7XG4gICAgICAgIGFic3RyYWN0QmFzZXMucHVzaChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWJzdHJhY3RCYXNlcztcbiAgfVxufVxuXG4vKipcbiAqIFBvc2l0aW9uYWwgYXJndW1lbnQgb3Iga2V5d29yZCBwYXJhbWV0ZXJcbiAqL1xuaW50ZXJmYWNlIERvY3VtZW50YWJsZUFyZ3VtZW50IHtcbiAgbmFtZTogc3RyaW5nO1xuICBkZWZpbmluZ1R5cGU6IHNwZWMuVHlwZTtcbiAgZG9jcz86IHNwZWMuRG9jcztcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBvbmUtbGluZSBkZXNjcmlwdGlvbiBvZiB0aGUgZ2l2ZW4gZG9jcywgdXNlZCBmb3IgbWV0aG9kIGFyZ3VtZW50cyBhbmQgaW5saW5lZCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG9uZWxpbmVEZXNjcmlwdGlvbihkb2NzOiBzcGVjLkRvY3MgfCB1bmRlZmluZWQpIHtcbiAgLy8gT25seSBjb25zaWRlciBhIHN1YnNldCBvZiBmaWVsZHMgaGVyZSwgd2UgZG9uJ3QgaGF2ZSBhIGxvdCBvZiBmb3JtYXR0aW5nIHNwYWNlXG4gIGlmICghZG9jcyB8fCBPYmplY3Qua2V5cyhkb2NzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJy0nO1xuICB9XG5cbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgaWYgKGRvY3Muc3VtbWFyeSkge1xuICAgIHBhcnRzLnB1c2gobWQycnN0KHJlbmRlclN1bW1hcnkoZG9jcykpKTtcbiAgfVxuICBpZiAoZG9jcy5yZW1hcmtzKSB7XG4gICAgcGFydHMucHVzaChtZDJyc3QoZG9jcy5yZW1hcmtzKSk7XG4gIH1cbiAgaWYgKGRvY3MuZGVmYXVsdCkge1xuICAgIHBhcnRzLnB1c2goYERlZmF1bHQ6ICR7bWQycnN0KGRvY3MuZGVmYXVsdCl9YCk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJyAnKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZE1lbnRpb25TdGFiaWxpdHkoczogc3BlYy5TdGFiaWxpdHkpIHtcbiAgLy8gRG9uJ3QgcmVuZGVyIFwic3RhYmxlXCIgb3IgXCJleHRlcm5hbFwiLCB0aG9zZSBhcmUgYm90aCBzdGFibGUgYnkgaW1wbGljYXRpb24uXG4gIHJldHVybiBzID09PSBzcGVjLlN0YWJpbGl0eS5EZXByZWNhdGVkIHx8IHMgPT09IHNwZWMuU3RhYmlsaXR5LkV4cGVyaW1lbnRhbDtcbn1cblxuZnVuY3Rpb24gaXNTdHJ1Y3QoXG4gIHR5cGVTeXN0ZW06IHJlZmxlY3QuVHlwZVN5c3RlbSxcbiAgcmVmOiBzcGVjLlR5cGVSZWZlcmVuY2UsXG4pOiBib29sZWFuIHtcbiAgaWYgKCFzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHJlZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVTeXN0ZW0udHJ5RmluZEZxbihyZWYuZnFuKTtcbiAgcmV0dXJuICEhKHR5cGU/LmlzSW50ZXJmYWNlVHlwZSgpICYmIHR5cGU/LmlzRGF0YVR5cGUoKSk7XG59XG5cbi8qKlxuICogQXBwZW5kcyBgX2AgYXQgdGhlIGVuZCBvZiBgbmFtZWAgdW50aWwgaXQgbm8gbG9uZ2VyIGNvbmZsaWN0cyB3aXRoIGFueSBvZiB0aGVcbiAqIGVudHJpZXMgaW4gYGluVXNlYC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAgdGhlIG5hbWUgdG8gYmUgc2x1Z2lmaWVkLlxuICogQHBhcmFtIGluVXNlIHRoZSBuYW1lcyB0aGF0IGFyZSBhbHJlYWR5IGJlaW5nIHVzZWQuXG4gKlxuICogQHJldHVybnMgdGhlIHNsdWdpZmllZCBuYW1lLlxuICovXG5mdW5jdGlvbiBzbHVnaWZ5QXNOZWVkZWQobmFtZTogc3RyaW5nLCBpblVzZTogcmVhZG9ubHkgc3RyaW5nW10pOiBzdHJpbmcge1xuICBjb25zdCBpblVzZVNldCA9IG5ldyBTZXQoaW5Vc2UpO1xuICB3aGlsZSAoaW5Vc2VTZXQuaGFzKG5hbWUpKSB7XG4gICAgbmFtZSA9IGAke25hbWV9X2A7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBCRUhPTEQ6IEhlbHBlcnMgdG8gb3V0cHV0IGNvZGUgdGhhdCBsb29rcyBsaWtlIHdoYXQgQmxhY2sgd291bGQgZm9ybWF0IGludG8uLi5cbi8vXG4vLyBAc2VlIGh0dHBzOi8vYmxhY2sucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL3RoZV9ibGFja19jb2RlX3N0eWxlLmh0bWxcblxuY29uc3QgVEFSR0VUX0xJTkVfTEVOR1RIID0gODg7XG5cbmZ1bmN0aW9uIG9wZW5TaWduYXR1cmUoXG4gIGNvZGU6IENvZGVNYWtlcixcbiAga2V5d29yZDogJ2NsYXNzJyxcbiAgbmFtZTogc3RyaW5nLFxuICBwYXJhbXM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuKTogdm9pZDtcbmZ1bmN0aW9uIG9wZW5TaWduYXR1cmUoXG4gIGNvZGU6IENvZGVNYWtlcixcbiAga2V5d29yZDogJ2RlZicsXG4gIG5hbWU6IHN0cmluZyxcbiAgcGFyYW1zOiByZWFkb25seSBzdHJpbmdbXSxcbiAgdHJhaWxpbmdDb21tYTogYm9vbGVhbixcbiAgcmV0dXJuVHlwZTogc3RyaW5nLFxuKTogdm9pZDtcbmZ1bmN0aW9uIG9wZW5TaWduYXR1cmUoXG4gIGNvZGU6IENvZGVNYWtlcixcbiAga2V5d29yZDogJ2NsYXNzJyB8ICdkZWYnLFxuICBuYW1lOiBzdHJpbmcsXG4gIHBhcmFtczogcmVhZG9ubHkgc3RyaW5nW10sXG4gIHRyYWlsaW5nQ29tbWEgPSBmYWxzZSxcbiAgcmV0dXJuVHlwZT86IHN0cmluZyxcbikge1xuICBjb25zdCBwcmVmaXggPSBgJHtrZXl3b3JkfSAke25hbWV9YDtcbiAgY29uc3Qgc3VmZml4ID0gcmV0dXJuVHlwZSA/IGAgLT4gJHtyZXR1cm5UeXBlfWAgOiAnJztcbiAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICBjb2RlLm9wZW5CbG9jayhgJHtwcmVmaXh9JHtyZXR1cm5UeXBlID8gJygpJyA6ICcnfSR7c3VmZml4fWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGpvaW4gPSAnLCAnO1xuICBjb25zdCB7IGVsZW1lbnRzU2l6ZSwgam9pblNpemUgfSA9IHRvdGFsU2l6ZU9mKHBhcmFtcywgam9pbik7XG5cbiAgY29uc3QgaGFzQ29tbWVudHMgPSAhcGFyYW1zLnNvbWUoKHBhcmFtKSA9PiAvIyAuKyQvLmV4ZWMocGFyYW0pKTtcblxuICBpZiAoXG4gICAgaGFzQ29tbWVudHMgJiZcbiAgICBUQVJHRVRfTElORV9MRU5HVEggPlxuICAgICAgY29kZS5jdXJyZW50SW5kZW50TGVuZ3RoICtcbiAgICAgICAgcHJlZml4Lmxlbmd0aCArXG4gICAgICAgIGVsZW1lbnRzU2l6ZSArXG4gICAgICAgIGpvaW5TaXplICtcbiAgICAgICAgc3VmZml4Lmxlbmd0aCArXG4gICAgICAgIDJcbiAgKSB7XG4gICAgY29kZS5vcGVuQmxvY2soYCR7cHJlZml4fSgke3BhcmFtcy5qb2luKGpvaW4pfSkke3N1ZmZpeH1gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb2RlLmluZGVudChgJHtwcmVmaXh9KGApO1xuICBpZiAoXG4gICAgIWhhc0NvbW1lbnRzICYmXG4gICAgVEFSR0VUX0xJTkVfTEVOR1RIID5cbiAgICAgIGNvZGUuY3VycmVudEluZGVudExlbmd0aCArXG4gICAgICAgIGVsZW1lbnRzU2l6ZSArXG4gICAgICAgIGpvaW5TaXplICtcbiAgICAgICAgKHRyYWlsaW5nQ29tbWEgPyAxIDogMClcbiAgKSB7XG4gICAgY29kZS5saW5lKGAke3BhcmFtcy5qb2luKGpvaW4pfSR7dHJhaWxpbmdDb21tYSA/ICcsJyA6ICcnfWApO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgcGFyYW1zKSB7XG4gICAgICBjb2RlLmxpbmUocGFyYW0ucmVwbGFjZSgvKFxccyojIC4rKT8kLywgJywkMScpKTtcbiAgICB9XG4gIH1cbiAgY29kZS51bmluZGVudChmYWxzZSk7XG4gIGNvZGUub3BlbkJsb2NrKGApJHtzdWZmaXh9YCk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkNhbGxSZXN1bHQoXG4gIGNvZGU6IENvZGVNYWtlcixcbiAgdmFyaWFibGU6IHN0cmluZyxcbiAgZnVuY3Q6IHN0cmluZyxcbiAgcGFyYW1zOiByZWFkb25seSBzdHJpbmdbXSxcbikge1xuICBjb25zdCBwcmVmaXggPSBgJHt2YXJpYWJsZX0gPSAke2Z1bmN0fShgO1xuICBjb25zdCBzdWZmaXggPSAnKSc7XG5cbiAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICBjb2RlLmxpbmUoYCR7cHJlZml4fSR7c3VmZml4fWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGpvaW4gPSAnLCAnO1xuICBjb25zdCB7IGVsZW1lbnRzU2l6ZSwgam9pblNpemUgfSA9IHRvdGFsU2l6ZU9mKHBhcmFtcywgam9pbik7XG5cbiAgaWYgKFxuICAgIFRBUkdFVF9MSU5FX0xFTkdUSCA+XG4gICAgY29kZS5jdXJyZW50SW5kZW50TGVuZ3RoICtcbiAgICAgIHByZWZpeC5sZW5ndGggK1xuICAgICAgZWxlbWVudHNTaXplICtcbiAgICAgIGpvaW5TaXplICtcbiAgICAgIHN1ZmZpeC5sZW5ndGhcbiAgKSB7XG4gICAgY29kZS5saW5lKGAke3ByZWZpeH0ke3BhcmFtcy5qb2luKGpvaW4pfSR7c3VmZml4fWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvZGUuaW5kZW50KHByZWZpeCk7XG4gIGlmIChUQVJHRVRfTElORV9MRU5HVEggPiBjb2RlLmN1cnJlbnRJbmRlbnRMZW5ndGggKyBlbGVtZW50c1NpemUgKyBqb2luU2l6ZSkge1xuICAgIGNvZGUubGluZShwYXJhbXMuam9pbihqb2luKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXMpIHtcbiAgICAgIGNvZGUubGluZShgJHtwYXJhbX0sYCk7XG4gICAgfVxuICB9XG4gIGNvZGUudW5pbmRlbnQoc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gYXNzaWduRGljdGlvbmFyeShcbiAgY29kZTogQ29kZU1ha2VyLFxuICB2YXJpYWJsZTogc3RyaW5nLFxuICBlbGVtZW50czogcmVhZG9ubHkgc3RyaW5nW10sXG4gIHRyYWlsaW5nPzogc3RyaW5nLFxuICBjb21wYWN0ID0gZmFsc2UsXG4pOiB2b2lkIHtcbiAgY29uc3Qgc3BhY2UgPSBjb21wYWN0ID8gJycgOiAnICc7XG5cbiAgY29uc3QgcHJlZml4ID0gYCR7dmFyaWFibGV9JHtzcGFjZX09JHtzcGFjZX17YDtcbiAgY29uc3Qgc3VmZml4ID0gYH0ke3RyYWlsaW5nID8/ICcnfWA7XG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvZGUubGluZShgJHtwcmVmaXh9JHtzdWZmaXh9YCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbXBhY3QpIHtcbiAgICBjb25zdCBqb2luID0gJywgJztcbiAgICBjb25zdCB7IGVsZW1lbnRzU2l6ZSwgam9pblNpemUgfSA9IHRvdGFsU2l6ZU9mKGVsZW1lbnRzLCBqb2luKTtcbiAgICBpZiAoXG4gICAgICBUQVJHRVRfTElORV9MRU5HVEggPlxuICAgICAgcHJlZml4Lmxlbmd0aCArXG4gICAgICAgIGNvZGUuY3VycmVudEluZGVudExlbmd0aCArXG4gICAgICAgIGVsZW1lbnRzU2l6ZSArXG4gICAgICAgIGpvaW5TaXplICtcbiAgICAgICAgc3VmZml4Lmxlbmd0aFxuICAgICkge1xuICAgICAgY29kZS5saW5lKGAke3ByZWZpeH0ke2VsZW1lbnRzLmpvaW4oam9pbil9JHtzdWZmaXh9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgY29kZS5pbmRlbnQocHJlZml4KTtcbiAgZm9yIChjb25zdCBlbHQgb2YgZWxlbWVudHMpIHtcbiAgICBjb2RlLmxpbmUoYCR7ZWx0fSxgKTtcbiAgfVxuICBjb2RlLnVuaW5kZW50KHN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIGVtaXRMaXN0KFxuICBjb2RlOiBDb2RlTWFrZXIsXG4gIHByZWZpeDogc3RyaW5nLFxuICBlbGVtZW50czogcmVhZG9ubHkgc3RyaW5nW10sXG4gIHN1ZmZpeDogc3RyaW5nLFxuICBvcHRzPzogeyBpZk11bHRpOiBbc3RyaW5nLCBzdHJpbmddIH0sXG4pIHtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvZGUubGluZShgJHtwcmVmaXh9JHtzdWZmaXh9YCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgam9pbiA9ICcsICc7XG4gIGNvbnN0IHsgZWxlbWVudHNTaXplLCBqb2luU2l6ZSB9ID0gdG90YWxTaXplT2YoZWxlbWVudHMsIGpvaW4pO1xuICBpZiAoXG4gICAgVEFSR0VUX0xJTkVfTEVOR1RIID5cbiAgICBjb2RlLmN1cnJlbnRJbmRlbnRMZW5ndGggK1xuICAgICAgcHJlZml4Lmxlbmd0aCArXG4gICAgICBlbGVtZW50c1NpemUgK1xuICAgICAgam9pblNpemUgK1xuICAgICAgc3VmZml4Lmxlbmd0aFxuICApIHtcbiAgICBjb2RlLmxpbmUoYCR7cHJlZml4fSR7ZWxlbWVudHMuam9pbihqb2luKX0ke3N1ZmZpeH1gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBbYmVmb3JlLCBhZnRlcl0gPSBvcHRzPy5pZk11bHRpID8/IFsnJywgJyddO1xuXG4gIGNvZGUuaW5kZW50KGAke3ByZWZpeH0ke2JlZm9yZX1gKTtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvZGUubGluZShlbGVtZW50c1swXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKFxuICAgICAgVEFSR0VUX0xJTkVfTEVOR1RIID5cbiAgICAgIGNvZGUuY3VycmVudEluZGVudExlbmd0aCArIGVsZW1lbnRzU2l6ZSArIGpvaW5TaXplXG4gICAgKSB7XG4gICAgICBjb2RlLmxpbmUoZWxlbWVudHMuam9pbihqb2luKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgZWx0IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvZGUubGluZShgJHtlbHR9LGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb2RlLnVuaW5kZW50KGAke2FmdGVyfSR7c3VmZml4fWApO1xufVxuXG5mdW5jdGlvbiB0b3RhbFNpemVPZihzdHJpbmdzOiByZWFkb25seSBzdHJpbmdbXSwgam9pbjogc3RyaW5nKSB7XG4gIHJldHVybiB7XG4gICAgZWxlbWVudHNTaXplOiBzdHJpbmdzXG4gICAgICAubWFwKChzdHIpID0+IHN0ci5sZW5ndGgpXG4gICAgICAucmVkdWNlKChhY2MsIGVsdCkgPT4gYWNjICsgZWx0LCAwKSxcbiAgICBqb2luU2l6ZTogc3RyaW5ncy5sZW5ndGggPiAxID8gam9pbi5sZW5ndGggKiAoc3RyaW5ncy5sZW5ndGggLSAxKSA6IDAsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5lc3RlZENvbnRleHQoXG4gIGNvbnRleHQ6IEVtaXRDb250ZXh0LFxuICBmcW46IHN0cmluZyB8IHVuZGVmaW5lZCxcbik6IEVtaXRDb250ZXh0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5jb250ZXh0LFxuICAgIHN1cnJvdW5kaW5nVHlwZUZxbnM6XG4gICAgICBmcW4gIT0gbnVsbFxuICAgICAgICA/IFsuLi4oY29udGV4dC5zdXJyb3VuZGluZ1R5cGVGcW5zID8/IFtdKSwgZnFuXVxuICAgICAgICA6IGNvbnRleHQuc3Vycm91bmRpbmdUeXBlRnFucyxcbiAgfTtcbn1cblxuY29uc3QgaXNEZXByZWNhdGVkID0gKHg6IFB5dGhvbkJhc2UpID0+IHguZG9jcz8uZGVwcmVjYXRlZCAhPT0gdW5kZWZpbmVkO1xuIl19