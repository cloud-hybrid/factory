"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateAllNpmIgnores = exports.findJsiiModules = void 0;
const spec = require("@jsii/spec");
const fs = require("fs-extra");
const path = require("path");
const logging = require("../lib/logging");
const packaging_1 = require("./packaging");
const toposort_1 = require("./toposort");
const util_1 = require("./util");
/**
 * Find all modules that need to be packagerd
 *
 * If the input list is empty, include the current directory.
 *
 * The result is topologically sorted.
 */
async function findJsiiModules(directories, recurse) {
    const ret = [];
    const visited = new Set();
    const toVisit = directories.length > 0 ? directories : ['.'];
    await Promise.all(toVisit.map((dir) => visitPackage(dir, true)));
    return toposort_1.topologicalSort(ret, (m) => m.name, (m) => m.dependencyNames);
    async function visitPackage(dir, isRoot) {
        var _a, _b, _c, _d, _e;
        const realPath = await fs.realpath(dir);
        if (visited.has(realPath)) {
            return;
        } // Already visited
        visited.add(realPath);
        const pkg = await fs.readJson(path.join(realPath, 'package.json'));
        if (!((_a = pkg.jsii) === null || _a === void 0 ? void 0 : _a.outdir) || !((_b = pkg.jsii) === null || _b === void 0 ? void 0 : _b.targets)) {
            if (isRoot) {
                throw new Error(`Invalid "jsii" section in ${realPath}. Expecting "outdir" and "targets"`);
            }
            else {
                return; // just move on, this is not a jsii package
            }
        }
        if (!pkg.name) {
            throw new Error(`package.json does not have a 'name' field: ${JSON.stringify(pkg, undefined, 2)}`);
        }
        const dependencyNames = [
            ...Object.keys((_c = pkg.dependencies) !== null && _c !== void 0 ? _c : {}),
            ...Object.keys((_d = pkg.peerDependencies) !== null && _d !== void 0 ? _d : {}),
            ...Object.keys((_e = pkg.devDependencies) !== null && _e !== void 0 ? _e : {}),
        ];
        // if --recurse is set, find dependency dirs and build them.
        if (recurse) {
            await Promise.all(dependencyNames.flatMap(async (dep) => {
                if (util_1.isBuiltinModule(dep)) {
                    return [];
                }
                try {
                    const depDir = await util_1.findDependencyDirectory(dep, realPath);
                    return [await visitPackage(depDir, false)];
                }
                catch (e) {
                    // Some modules like `@types/node` cannot be require()d, but we also don't need them.
                    if (!['MODULE_NOT_FOUND', 'ERR_PACKAGE_PATH_NOT_EXPORTED'].includes(e.code)) {
                        throw e;
                    }
                    return [];
                }
            }));
        }
        // outdir is either by package.json/jsii.outdir (relative to package root) or via command line (relative to cwd)
        const outputDirectory = pkg.jsii.outdir && path.resolve(realPath, pkg.jsii.outdir);
        const targets = [...Object.keys(pkg.jsii.targets), 'js']; // "js" is an implicit target.
        ret.push(new packaging_1.JsiiModule({
            name: pkg.name,
            moduleDirectory: realPath,
            defaultOutputDirectory: outputDirectory,
            availableTargets: targets,
            dependencyNames,
        }));
    }
}
exports.findJsiiModules = findJsiiModules;
async function updateAllNpmIgnores(packages) {
    await Promise.all(packages.map((pkg) => updateNpmIgnore(pkg.moduleDirectory, pkg.outputDirectory)));
}
exports.updateAllNpmIgnores = updateAllNpmIgnores;
async function updateNpmIgnore(packageDir, excludeOutdir) {
    const npmIgnorePath = path.join(packageDir, '.npmignore');
    let lines = new Array();
    let modified = false;
    if (await fs.pathExists(npmIgnorePath)) {
        lines = (await fs.readFile(npmIgnorePath)).toString().split('\n');
    }
    // if this is a fresh .npmignore, we can be a bit more opinionated
    // otherwise, we add just add stuff that's critical
    if (lines.length === 0) {
        excludePattern('Exclude typescript source and config', '*.ts', 'tsconfig.json');
        includePattern('Include javascript files and typescript declarations', '*.js', '*.d.ts');
    }
    if (excludeOutdir) {
        excludePattern('Exclude jsii outdir', path.relative(packageDir, excludeOutdir));
    }
    includePattern('Include .jsii', spec.SPEC_FILE_NAME);
    if (modified) {
        await fs.writeFile(npmIgnorePath, `${lines.join('\n')}\n`);
        logging.info('Updated .npmignore');
    }
    function includePattern(comment, ...patterns) {
        excludePattern(comment, ...patterns.map((p) => `!${p}`));
    }
    function excludePattern(comment, ...patterns) {
        let first = true;
        for (const pattern of patterns) {
            if (lines.includes(pattern)) {
                return; // already in .npmignore
            }
            modified = true;
            if (first) {
                lines.push('');
                lines.push(`# ${comment}`);
                first = false;
            }
            lines.push(pattern);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnBtLW1vZHVsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJucG0tbW9kdWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBbUM7QUFDbkMsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUU3QiwwQ0FBMEM7QUFDMUMsMkNBQXlDO0FBQ3pDLHlDQUF5RDtBQUN6RCxpQ0FBa0U7QUFFbEU7Ozs7OztHQU1HO0FBQ0ksS0FBSyxVQUFVLGVBQWUsQ0FDbkMsV0FBOEIsRUFDOUIsT0FBZ0I7SUFFaEIsTUFBTSxHQUFHLEdBQWlCLEVBQUUsQ0FBQztJQUM3QixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO0lBRWxDLE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDN0QsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRWpFLE9BQU8sMEJBQWUsQ0FDcEIsR0FBRyxFQUNILENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUNiLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUN6QixDQUFDO0lBRUYsS0FBSyxVQUFVLFlBQVksQ0FBQyxHQUFXLEVBQUUsTUFBZTs7UUFDdEQsTUFBTSxRQUFRLEdBQUcsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hDLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUN6QixPQUFPO1NBQ1IsQ0FBQyxrQkFBa0I7UUFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUV0QixNQUFNLEdBQUcsR0FBRyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUNuRSxJQUFJLFFBQUMsR0FBRyxDQUFDLElBQUksMENBQUUsTUFBTSxDQUFBLElBQUksUUFBQyxHQUFHLENBQUMsSUFBSSwwQ0FBRSxPQUFPLENBQUEsRUFBRTtZQUMzQyxJQUFJLE1BQU0sRUFBRTtnQkFDVixNQUFNLElBQUksS0FBSyxDQUNiLDZCQUE2QixRQUFRLG9DQUFvQyxDQUMxRSxDQUFDO2FBQ0g7aUJBQU07Z0JBQ0wsT0FBTyxDQUFDLDJDQUEyQzthQUNwRDtTQUNGO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUNiLDhDQUE4QyxJQUFJLENBQUMsU0FBUyxDQUMxRCxHQUFHLEVBQ0gsU0FBUyxFQUNULENBQUMsQ0FDRixFQUFFLENBQ0osQ0FBQztTQUNIO1FBRUQsTUFBTSxlQUFlLEdBQUc7WUFDdEIsR0FBRyxNQUFNLENBQUMsSUFBSSxPQUFDLEdBQUcsQ0FBQyxZQUFZLG1DQUFJLEVBQUUsQ0FBQztZQUN0QyxHQUFHLE1BQU0sQ0FBQyxJQUFJLE9BQUMsR0FBRyxDQUFDLGdCQUFnQixtQ0FBSSxFQUFFLENBQUM7WUFDMUMsR0FBRyxNQUFNLENBQUMsSUFBSSxPQUFDLEdBQUcsQ0FBQyxlQUFlLG1DQUFJLEVBQUUsQ0FBQztTQUMxQyxDQUFDO1FBRUYsNERBQTREO1FBQzVELElBQUksT0FBTyxFQUFFO1lBQ1gsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUNmLGVBQWUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFO2dCQUNwQyxJQUFJLHNCQUFlLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ3hCLE9BQU8sRUFBRSxDQUFDO2lCQUNYO2dCQUVELElBQUk7b0JBQ0YsTUFBTSxNQUFNLEdBQUcsTUFBTSw4QkFBdUIsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7b0JBQzVELE9BQU8sQ0FBQyxNQUFNLFlBQVksQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDNUM7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1YscUZBQXFGO29CQUNyRixJQUNFLENBQUMsQ0FBQyxrQkFBa0IsRUFBRSwrQkFBK0IsQ0FBQyxDQUFDLFFBQVEsQ0FDN0QsQ0FBQyxDQUFDLElBQUksQ0FDUCxFQUNEO3dCQUNBLE1BQU0sQ0FBQyxDQUFDO3FCQUNUO29CQUNELE9BQU8sRUFBRSxDQUFDO2lCQUNYO1lBQ0gsQ0FBQyxDQUFDLENBQ0gsQ0FBQztTQUNIO1FBRUQsZ0hBQWdIO1FBQ2hILE1BQU0sZUFBZSxHQUNuQixHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdELE1BQU0sT0FBTyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyw4QkFBOEI7UUFFeEYsR0FBRyxDQUFDLElBQUksQ0FDTixJQUFJLHNCQUFVLENBQUM7WUFDYixJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUk7WUFDZCxlQUFlLEVBQUUsUUFBUTtZQUN6QixzQkFBc0IsRUFBRSxlQUFlO1lBQ3ZDLGdCQUFnQixFQUFFLE9BQU87WUFDekIsZUFBZTtTQUNoQixDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDO0FBM0ZELDBDQTJGQztBQUVNLEtBQUssVUFBVSxtQkFBbUIsQ0FDdkMsUUFBc0I7SUFFdEIsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUNmLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUNuQixlQUFlLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxHQUFHLENBQUMsZUFBZSxDQUFDLENBQzFELENBQ0YsQ0FBQztBQUNKLENBQUM7QUFSRCxrREFRQztBQUVELEtBQUssVUFBVSxlQUFlLENBQzVCLFVBQWtCLEVBQ2xCLGFBQWlDO0lBRWpDLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQzFELElBQUksS0FBSyxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7SUFDaEMsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLElBQUksTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1FBQ3RDLEtBQUssR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNuRTtJQUVELGtFQUFrRTtJQUNsRSxtREFBbUQ7SUFDbkQsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN0QixjQUFjLENBQ1osc0NBQXNDLEVBQ3RDLE1BQU0sRUFDTixlQUFlLENBQ2hCLENBQUM7UUFDRixjQUFjLENBQ1osc0RBQXNELEVBQ3RELE1BQU0sRUFDTixRQUFRLENBQ1QsQ0FBQztLQUNIO0lBRUQsSUFBSSxhQUFhLEVBQUU7UUFDakIsY0FBYyxDQUNaLHFCQUFxQixFQUNyQixJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxhQUFhLENBQUMsQ0FDekMsQ0FBQztLQUNIO0lBRUQsY0FBYyxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7SUFFckQsSUFBSSxRQUFRLEVBQUU7UUFDWixNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0QsT0FBTyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0tBQ3BDO0lBRUQsU0FBUyxjQUFjLENBQUMsT0FBZSxFQUFFLEdBQUcsUUFBa0I7UUFDNUQsY0FBYyxDQUFDLE9BQU8sRUFBRSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRCxTQUFTLGNBQWMsQ0FBQyxPQUFlLEVBQUUsR0FBRyxRQUFrQjtRQUM1RCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDakIsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUU7WUFDOUIsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUMzQixPQUFPLENBQUMsd0JBQXdCO2FBQ2pDO1lBRUQsUUFBUSxHQUFHLElBQUksQ0FBQztZQUVoQixJQUFJLEtBQUssRUFBRTtnQkFDVCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNmLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2dCQUMzQixLQUFLLEdBQUcsS0FBSyxDQUFDO2FBQ2Y7WUFFRCxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3JCO0lBQ0gsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzcGVjIGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICcuLi9saWIvbG9nZ2luZyc7XG5pbXBvcnQgeyBKc2lpTW9kdWxlIH0gZnJvbSAnLi9wYWNrYWdpbmcnO1xuaW1wb3J0IHsgdG9wb2xvZ2ljYWxTb3J0LCBUb3Bvc29ydGVkIH0gZnJvbSAnLi90b3Bvc29ydCc7XG5pbXBvcnQgeyBmaW5kRGVwZW5kZW5jeURpcmVjdG9yeSwgaXNCdWlsdGluTW9kdWxlIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBGaW5kIGFsbCBtb2R1bGVzIHRoYXQgbmVlZCB0byBiZSBwYWNrYWdlcmRcbiAqXG4gKiBJZiB0aGUgaW5wdXQgbGlzdCBpcyBlbXB0eSwgaW5jbHVkZSB0aGUgY3VycmVudCBkaXJlY3RvcnkuXG4gKlxuICogVGhlIHJlc3VsdCBpcyB0b3BvbG9naWNhbGx5IHNvcnRlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbmRKc2lpTW9kdWxlcyhcbiAgZGlyZWN0b3JpZXM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICByZWN1cnNlOiBib29sZWFuLFxuKTogUHJvbWlzZTxUb3Bvc29ydGVkPEpzaWlNb2R1bGU+PiB7XG4gIGNvbnN0IHJldDogSnNpaU1vZHVsZVtdID0gW107XG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBjb25zdCB0b1Zpc2l0ID0gZGlyZWN0b3JpZXMubGVuZ3RoID4gMCA/IGRpcmVjdG9yaWVzIDogWycuJ107XG4gIGF3YWl0IFByb21pc2UuYWxsKHRvVmlzaXQubWFwKChkaXIpID0+IHZpc2l0UGFja2FnZShkaXIsIHRydWUpKSk7XG5cbiAgcmV0dXJuIHRvcG9sb2dpY2FsU29ydChcbiAgICByZXQsXG4gICAgKG0pID0+IG0ubmFtZSxcbiAgICAobSkgPT4gbS5kZXBlbmRlbmN5TmFtZXMsXG4gICk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gdmlzaXRQYWNrYWdlKGRpcjogc3RyaW5nLCBpc1Jvb3Q6IGJvb2xlYW4pIHtcbiAgICBjb25zdCByZWFsUGF0aCA9IGF3YWl0IGZzLnJlYWxwYXRoKGRpcik7XG4gICAgaWYgKHZpc2l0ZWQuaGFzKHJlYWxQYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQWxyZWFkeSB2aXNpdGVkXG4gICAgdmlzaXRlZC5hZGQocmVhbFBhdGgpO1xuXG4gICAgY29uc3QgcGtnID0gYXdhaXQgZnMucmVhZEpzb24ocGF0aC5qb2luKHJlYWxQYXRoLCAncGFja2FnZS5qc29uJykpO1xuICAgIGlmICghcGtnLmpzaWk/Lm91dGRpciB8fCAhcGtnLmpzaWk/LnRhcmdldHMpIHtcbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIFwianNpaVwiIHNlY3Rpb24gaW4gJHtyZWFsUGF0aH0uIEV4cGVjdGluZyBcIm91dGRpclwiIGFuZCBcInRhcmdldHNcImAsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47IC8vIGp1c3QgbW92ZSBvbiwgdGhpcyBpcyBub3QgYSBqc2lpIHBhY2thZ2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBrZy5uYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBwYWNrYWdlLmpzb24gZG9lcyBub3QgaGF2ZSBhICduYW1lJyBmaWVsZDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBwa2csXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIDIsXG4gICAgICAgICl9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVwZW5kZW5jeU5hbWVzID0gW1xuICAgICAgLi4uT2JqZWN0LmtleXMocGtnLmRlcGVuZGVuY2llcyA/PyB7fSksXG4gICAgICAuLi5PYmplY3Qua2V5cyhwa2cucGVlckRlcGVuZGVuY2llcyA/PyB7fSksXG4gICAgICAuLi5PYmplY3Qua2V5cyhwa2cuZGV2RGVwZW5kZW5jaWVzID8/IHt9KSxcbiAgICBdO1xuXG4gICAgLy8gaWYgLS1yZWN1cnNlIGlzIHNldCwgZmluZCBkZXBlbmRlbmN5IGRpcnMgYW5kIGJ1aWxkIHRoZW0uXG4gICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBkZXBlbmRlbmN5TmFtZXMuZmxhdE1hcChhc3luYyAoZGVwKSA9PiB7XG4gICAgICAgICAgaWYgKGlzQnVpbHRpbk1vZHVsZShkZXApKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlcERpciA9IGF3YWl0IGZpbmREZXBlbmRlbmN5RGlyZWN0b3J5KGRlcCwgcmVhbFBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIFthd2FpdCB2aXNpdFBhY2thZ2UoZGVwRGlyLCBmYWxzZSldO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgbW9kdWxlcyBsaWtlIGBAdHlwZXMvbm9kZWAgY2Fubm90IGJlIHJlcXVpcmUoKWQsIGJ1dCB3ZSBhbHNvIGRvbid0IG5lZWQgdGhlbS5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIVsnTU9EVUxFX05PVF9GT1VORCcsICdFUlJfUEFDS0FHRV9QQVRIX05PVF9FWFBPUlRFRCddLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgIGUuY29kZSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gb3V0ZGlyIGlzIGVpdGhlciBieSBwYWNrYWdlLmpzb24vanNpaS5vdXRkaXIgKHJlbGF0aXZlIHRvIHBhY2thZ2Ugcm9vdCkgb3IgdmlhIGNvbW1hbmQgbGluZSAocmVsYXRpdmUgdG8gY3dkKVxuICAgIGNvbnN0IG91dHB1dERpcmVjdG9yeSA9XG4gICAgICBwa2cuanNpaS5vdXRkaXIgJiYgcGF0aC5yZXNvbHZlKHJlYWxQYXRoLCBwa2cuanNpaS5vdXRkaXIpO1xuICAgIGNvbnN0IHRhcmdldHMgPSBbLi4uT2JqZWN0LmtleXMocGtnLmpzaWkudGFyZ2V0cyksICdqcyddOyAvLyBcImpzXCIgaXMgYW4gaW1wbGljaXQgdGFyZ2V0LlxuXG4gICAgcmV0LnB1c2goXG4gICAgICBuZXcgSnNpaU1vZHVsZSh7XG4gICAgICAgIG5hbWU6IHBrZy5uYW1lLFxuICAgICAgICBtb2R1bGVEaXJlY3Rvcnk6IHJlYWxQYXRoLFxuICAgICAgICBkZWZhdWx0T3V0cHV0RGlyZWN0b3J5OiBvdXRwdXREaXJlY3RvcnksXG4gICAgICAgIGF2YWlsYWJsZVRhcmdldHM6IHRhcmdldHMsXG4gICAgICAgIGRlcGVuZGVuY3lOYW1lcyxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFsbE5wbUlnbm9yZXMoXG4gIHBhY2thZ2VzOiBKc2lpTW9kdWxlW10sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgcGFja2FnZXMubWFwKChwa2cpID0+XG4gICAgICB1cGRhdGVOcG1JZ25vcmUocGtnLm1vZHVsZURpcmVjdG9yeSwgcGtnLm91dHB1dERpcmVjdG9yeSksXG4gICAgKSxcbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlTnBtSWdub3JlKFxuICBwYWNrYWdlRGlyOiBzdHJpbmcsXG4gIGV4Y2x1ZGVPdXRkaXI6IHN0cmluZyB8IHVuZGVmaW5lZCxcbikge1xuICBjb25zdCBucG1JZ25vcmVQYXRoID0gcGF0aC5qb2luKHBhY2thZ2VEaXIsICcubnBtaWdub3JlJyk7XG4gIGxldCBsaW5lcyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhucG1JZ25vcmVQYXRoKSkge1xuICAgIGxpbmVzID0gKGF3YWl0IGZzLnJlYWRGaWxlKG5wbUlnbm9yZVBhdGgpKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBmcmVzaCAubnBtaWdub3JlLCB3ZSBjYW4gYmUgYSBiaXQgbW9yZSBvcGluaW9uYXRlZFxuICAvLyBvdGhlcndpc2UsIHdlIGFkZCBqdXN0IGFkZCBzdHVmZiB0aGF0J3MgY3JpdGljYWxcbiAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGV4Y2x1ZGVQYXR0ZXJuKFxuICAgICAgJ0V4Y2x1ZGUgdHlwZXNjcmlwdCBzb3VyY2UgYW5kIGNvbmZpZycsXG4gICAgICAnKi50cycsXG4gICAgICAndHNjb25maWcuanNvbicsXG4gICAgKTtcbiAgICBpbmNsdWRlUGF0dGVybihcbiAgICAgICdJbmNsdWRlIGphdmFzY3JpcHQgZmlsZXMgYW5kIHR5cGVzY3JpcHQgZGVjbGFyYXRpb25zJyxcbiAgICAgICcqLmpzJyxcbiAgICAgICcqLmQudHMnLFxuICAgICk7XG4gIH1cblxuICBpZiAoZXhjbHVkZU91dGRpcikge1xuICAgIGV4Y2x1ZGVQYXR0ZXJuKFxuICAgICAgJ0V4Y2x1ZGUganNpaSBvdXRkaXInLFxuICAgICAgcGF0aC5yZWxhdGl2ZShwYWNrYWdlRGlyLCBleGNsdWRlT3V0ZGlyKSxcbiAgICApO1xuICB9XG5cbiAgaW5jbHVkZVBhdHRlcm4oJ0luY2x1ZGUgLmpzaWknLCBzcGVjLlNQRUNfRklMRV9OQU1FKTtcblxuICBpZiAobW9kaWZpZWQpIHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUobnBtSWdub3JlUGF0aCwgYCR7bGluZXMuam9pbignXFxuJyl9XFxuYCk7XG4gICAgbG9nZ2luZy5pbmZvKCdVcGRhdGVkIC5ucG1pZ25vcmUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGVQYXR0ZXJuKGNvbW1lbnQ6IHN0cmluZywgLi4ucGF0dGVybnM6IHN0cmluZ1tdKSB7XG4gICAgZXhjbHVkZVBhdHRlcm4oY29tbWVudCwgLi4ucGF0dGVybnMubWFwKChwKSA9PiBgISR7cH1gKSk7XG4gIH1cblxuICBmdW5jdGlvbiBleGNsdWRlUGF0dGVybihjb21tZW50OiBzdHJpbmcsIC4uLnBhdHRlcm5zOiBzdHJpbmdbXSkge1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICBpZiAobGluZXMuaW5jbHVkZXMocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IGluIC5ucG1pZ25vcmVcbiAgICAgIH1cblxuICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgIGxpbmVzLnB1c2goYCMgJHtjb21tZW50fWApO1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsaW5lcy5wdXNoKHBhdHRlcm4pO1xuICAgIH1cbiAgfVxufVxuIl19