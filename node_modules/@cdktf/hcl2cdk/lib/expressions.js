"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findUsedReferences = exports.extractDynamicBlocks = exports.referencesToAst = exports.referenceToAst = exports.constructAst = exports.variableName = exports.referenceToVariableName = exports.extractReferencesFromExpression = void 0;
const t = __importStar(require("@babel/types"));
const reserved_words_1 = __importDefault(require("reserved-words"));
const utils_1 = require("./utils");
const provider_generator_1 = require("@cdktf/provider-generator");
const PROPERTY_ACCESS_REGEX = /\[.*\]/;
const DOLLAR_REGEX = /\$/g;
function extractReferencesFromExpression(input, nodeIds, scopedIds = [] // dynamics introduce new scoped variables that are not the globally accessible ids
) {
    const isDoubleParanthesis = input.startsWith("${{");
    if (!input.startsWith("${")) {
        return [];
    }
    const start = isDoubleParanthesis ? 3 : 2;
    const end = isDoubleParanthesis ? input.length - 2 : input.length - 1;
    let expressionString = input.substring(start, end);
    if (expressionString.includes("for") &&
        expressionString.includes("in") &&
        expressionString.includes(":")) {
        // for name, user in var.users : user.role => name...
        // We just want the var.users part (that could be an expression)
        expressionString = expressionString.substring(expressionString.indexOf("in") + 2, expressionString.indexOf(":"));
    }
    const lines = expressionString
        .split("\n")
        .map((line) => {
        const commentStart = line.indexOf("#");
        const lineWithoutComment = commentStart !== -1 ? line.substring(0, commentStart - 1) : line;
        return lineWithoutComment.trim();
    })
        .filter((line) => line !== "");
    const delimiters = [
        "(",
        ",",
        ")",
        ".*",
        PROPERTY_ACCESS_REGEX,
        " ",
        "!",
        "*",
        "/",
        "%",
        ">",
        "<",
        "=",
        "&&",
        "||",
        "?",
        // There can be nested terraform expression strings
        "${",
        "}",
    ];
    let possibleVariableSpots = lines;
    delimiters.forEach((delimiter) => {
        possibleVariableSpots = possibleVariableSpots.reduce((carry, str) => [...carry, ...str.split(delimiter)], []);
    });
    return possibleVariableSpots.reduce((carry, spot) => {
        // no reference
        if (!spot.includes(".") || // just a literal
            spot.startsWith(".") || // dangling property access
            spot.endsWith("...") || // spread (likely in for loop)
            spot.startsWith("count.") || // count variable
            spot.startsWith("each.") || // each variable
            // https://www.terraform.io/docs/language/expressions/references.html#filesystem-and-workspace-info
            spot.startsWith("path.module") ||
            spot.startsWith("path.root") ||
            spot.startsWith("path.cwd") ||
            spot.startsWith("terraform.workspace")) {
            return carry;
        }
        const referenceParts = spot.split(".");
        const corespondingNodeId = [...nodeIds, ...scopedIds].find((id) => {
            const parts = id.split(".");
            const matchesFirst = parts[0] === referenceParts[0];
            const matchesFirstTwo = matchesFirst && (parts[1] === referenceParts[1] || parts.length === 1);
            return (matchesFirstTwo &&
                (parts[0] === "data" ? parts[2] === referenceParts[2] : true));
        });
        if (!corespondingNodeId) {
            // This is most likely a false positive, so we just ignore it
            // We include the log below to help debugging
            console.error(`Found a reference that is unknown: ${input} has reference "${spot}". The id was not found in ${JSON.stringify(nodeIds)} with temporary values ${JSON.stringify(scopedIds)}.
        Please leave a comment at https://cdk.tf/bugs/convert-expressions if you run into this issue.`);
            return carry;
        }
        if (scopedIds.includes(corespondingNodeId)) {
            return carry;
        }
        const spotParts = spot.split(".");
        let isThereANumericAccessor = false;
        const referenceSpotParts = spotParts.filter((part) => {
            if (!Number.isNaN(parseInt(part, 10))) {
                isThereANumericAccessor = true;
                return false;
            }
            return !isThereANumericAccessor;
        });
        const fullReference = isThereANumericAccessor
            ? referenceSpotParts.slice(0, 2).join(".")
            : spot;
        // we know we are at closer to the end than the last reference we found
        // this helps us find duplicate referencees
        const position = carry.length ? carry[carry.length - 1].end : 0;
        const start = input.indexOf(fullReference, position);
        const end = start + fullReference.length;
        const isVariable = spot.startsWith("var.");
        const useFqn = 
        // Can not use FQN on vars
        !isVariable &&
            // Can not use FQN on locals
            !spot.startsWith("local.") &&
            // If the following character is
            (input.substr(end + 1, 1) === "*" || // a * (splat) we need to use the FQN
                input.substr(end, 1) === "[" || // a property access
                isThereANumericAccessor || // a numeric access
                fullReference.split(".").length < 3);
        const ref = {
            start,
            end,
            referencee: {
                id: corespondingNodeId,
                full: fullReference,
            },
            useFqn,
            isVariable,
        };
        return [...carry, ref];
    }, []);
}
exports.extractReferencesFromExpression = extractReferencesFromExpression;
function referenceToVariableName(scope, ref) {
    const parts = ref.referencee.full.split(".");
    const resource = parts[0] === "data" ? `${parts[0]}.${parts[1]}` : parts[0];
    const name = parts[0] === "data" ? parts[2] : parts[1];
    return variableName(scope, resource, name);
}
exports.referenceToVariableName = referenceToVariableName;
function validVarName(name) {
    if (reserved_words_1.default.check(name)) {
        return `${name}Var`;
    }
    if (!Number.isNaN(parseInt(name[0], 10))) {
        return `d${name}`;
    }
    return name;
}
function variableName(scope, resource, name) {
    // name collision, we need to prefix the name
    if (scope.variables[name]) {
        if (resource === scope.variables[name].resource) {
            return scope.variables[name].variableName;
        }
        // we only cache one per name
        return validVarName(utils_1.camelCase([resource, name].join("_")));
    }
    const variableName = validVarName(utils_1.camelCase(["var", "local", "module"].includes(resource)
        ? name
        : [resource, name].join("_")));
    scope.variables[name] = { variableName, resource };
    return variableName;
}
exports.variableName = variableName;
function constructAst(type, isModuleImport) {
    if (isModuleImport) {
        return t.memberExpression(t.identifier(type), t.identifier(type));
    }
    // resources or data sources
    if (!type.includes("./") && type.includes(".")) {
        const parts = type.split(".");
        if (parts[0] === "data") {
            const [, provider, resource] = parts;
            const namespace = provider_generator_1.getResourceNamespace(provider, resource);
            if (namespace) {
                return t.memberExpression(t.memberExpression(t.identifier(provider), // e.g. aws
                t.identifier(namespace.name) // e.g. EC2
                ), t.identifier(utils_1.pascalCase(`data_${provider}_${resource}`)) // e.g. DataAwsInstance
                );
            }
            return t.memberExpression(t.identifier(provider), // e.g. aws
            t.identifier(utils_1.pascalCase(`data_${provider}_${resource}`)) // e.g. DataAwsNatGateway
            );
        }
        const [provider, resource] = parts;
        const namespace = provider_generator_1.getResourceNamespace(provider, resource);
        if (namespace) {
            return t.memberExpression(t.memberExpression(t.identifier(provider), // e.g. aws
            t.identifier(namespace.name) // e.g. EC2
            ), t.identifier(utils_1.pascalCase(resource)) // e.g. Instance
            );
        }
        return t.memberExpression(t.identifier(provider), // e.g. google
        t.identifier(utils_1.pascalCase(resource)) // e.g. BigQueryTable
        );
    }
    return t.identifier(utils_1.pascalCase(type));
}
exports.constructAst = constructAst;
function referenceToAst(scope, ref) {
    const [resource, , ...selector] = ref.referencee.full.split(".");
    const variableReference = t.identifier(utils_1.camelCase(referenceToVariableName(scope, ref)));
    if (resource === "data") {
        selector.shift(); // remove the data part so that the name is not used in the selector
    }
    const accessor = selector.reduce((carry, member, index) => t.memberExpression(carry, t.identifier(index === 0 && resource === "module"
        ? utils_1.camelCase(member + "Output")
        : utils_1.camelCase(member))), variableReference);
    if (ref.useFqn) {
        return t.memberExpression(accessor, t.identifier("fqn"));
    }
    if (ref.isVariable) {
        return t.memberExpression(accessor, t.identifier("value"));
    }
    return accessor;
}
exports.referenceToAst = referenceToAst;
function referencesToAst(scope, input, refs, scopedIds = [] // dynamics introduce new scoped variables that are not the globally accessible ids
) {
    if (refs.length === 0) {
        return t.stringLiteral(input);
    }
    const refAsts = refs
        .sort((a, b) => a.start - b.start)
        .filter((ref) => !scopedIds.includes(ref.referencee.id))
        .map((ref) => ({ ref, ast: referenceToAst(scope, ref) }));
    if (refAsts.length === 1 &&
        refAsts[0].ref.start === "${".length &&
        refAsts[0].ref.end === input.length - "}".length &&
        !refAsts[0].ref.useFqn) {
        return refAsts[0].ast;
    }
    // string parts in the template string
    const quasis = [];
    // dynamic values in the template string
    const expressions = [];
    let lastEnd = 0;
    refAsts.forEach(({ ref, ast }) => {
        // leading quasi
        if (ref.start !== lastEnd) {
            quasis.push(t.templateElement({
                raw: input.substring(lastEnd, ref.start).replace(DOLLAR_REGEX, "\\$"),
            }));
        }
        expressions.push(ast);
        lastEnd = ref.end;
    });
    // trailing quasi
    quasis.push(t.templateElement({
        raw: input
            .substring(lastEnd, input.length)
            .replace(DOLLAR_REGEX, "\\$"),
    }, true));
    return t.templateLiteral(quasis, expressions);
}
exports.referencesToAst = referencesToAst;
exports.extractDynamicBlocks = (config, path = "") => {
    if (typeof config !== "object") {
        return [];
    }
    if (!config) {
        return [];
    }
    if (Array.isArray(config)) {
        return config.reduce((carry, item, index) => [
            ...carry,
            ...exports.extractDynamicBlocks(item, `${path}.${index}`),
        ], []);
    }
    if ("dynamic" in config) {
        const dynamic = config.dynamic;
        const scopedVar = Object.keys(dynamic)[0];
        const { for_each, content } = dynamic[scopedVar][0];
        return [
            {
                path: `${path}.${scopedVar}`,
                for_each,
                content,
                scopedVar,
            },
        ];
    }
    return Object.entries(config).reduce((carry, [key, value]) => {
        return [...carry, ...exports.extractDynamicBlocks(value, `${path}.${key}`)];
    }, []);
};
function findUsedReferences(nodeIds, item) {
    if (typeof item === "string") {
        return extractReferencesFromExpression(item, nodeIds, []);
    }
    if (typeof item !== "object" || item === null || item === undefined) {
        return [];
    }
    if (Array.isArray(item)) {
        return item.reduce((carry, i) => [...carry, ...findUsedReferences(nodeIds, i)], []);
    }
    if (item && "dynamic" in item) {
        const dyn = item["dynamic"];
        const { for_each, ...others } = dyn;
        const dynamicRef = Object.keys(others)[0];
        return findUsedReferences([...nodeIds, dynamicRef], dyn);
    }
    return Object.values(item).reduce((carry, i) => [...carry, ...findUsedReferences(nodeIds, i)], []);
}
exports.findUsedReferences = findUsedReferences;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJleHByZXNzaW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0RBQWtDO0FBQ2xDLG9FQUEyQztBQUMzQyxtQ0FBZ0Q7QUFFaEQsa0VBQWlFO0FBVWpFLE1BQU0scUJBQXFCLEdBQUcsUUFBUSxDQUFDO0FBQ3ZDLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQztBQUUzQixTQUFnQiwrQkFBK0IsQ0FDN0MsS0FBYSxFQUNiLE9BQTBCLEVBQzFCLFlBQStCLEVBQUUsQ0FBQyxtRkFBbUY7O0lBRXJILE1BQU0sbUJBQW1CLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUMzQixPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsTUFBTSxLQUFLLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sR0FBRyxHQUFHLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDdEUsSUFBSSxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUVuRCxJQUNFLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7UUFDaEMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztRQUMvQixnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQzlCO1FBQ0EscURBQXFEO1FBQ3JELGdFQUFnRTtRQUNoRSxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFTLENBQzNDLGdCQUFn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QyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQyxPQUFPLGtCQUFrQixDQUFDLENBQUMsR0FBRyxPQUFPLEVBQUUsVUFBVSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FDMUQ7SUFDRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBMkIsQ0FBQyxDQUFDLE1BQU0sQ0FDdEQsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxFQUFFLEdBQUcsa0JBQWtCLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQzNELEVBQUUsQ0FDSCxDQUFDO0FBQ0osQ0FBQztBQTdCRCxnREE2QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0IGZyb20gXCJAYmFiZWwvdHlwZXNcIjtcbmltcG9ydCByZXNlcnZlZFdvcmRzIGZyb20gXCJyZXNlcnZlZC13b3Jkc1wiO1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBwYXNjYWxDYXNlIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IFRlcnJhZm9ybVJlc291cmNlQmxvY2ssIFNjb3BlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGdldFJlc291cmNlTmFtZXNwYWNlIH0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1nZW5lcmF0b3JcIjtcblxuZXhwb3J0IHR5cGUgUmVmZXJlbmNlID0ge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgcmVmZXJlbmNlZTogeyBpZDogc3RyaW5nOyBmdWxsOiBzdHJpbmcgfTsgLy8gaWRlbnRpZmllciBmb3IgcmVzb3VyY2VcbiAgdXNlRnFuPzogYm9vbGVhbjtcbiAgaXNWYXJpYWJsZT86IGJvb2xlYW47XG59O1xuXG5jb25zdCBQUk9QRVJUWV9BQ0NFU1NfUkVHRVggPSAvXFxbLipcXF0vO1xuY29uc3QgRE9MTEFSX1JFR0VYID0gL1xcJC9nO1xuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFJlZmVyZW5jZXNGcm9tRXhwcmVzc2lvbihcbiAgaW5wdXQ6IHN0cmluZyxcbiAgbm9kZUlkczogcmVhZG9ubHkgc3RyaW5nW10sXG4gIHNjb3BlZElkczogcmVhZG9ubHkgc3RyaW5nW10gPSBbXSAvLyBkeW5hbWljcyBpbnRyb2R1Y2UgbmV3IHNjb3BlZCB2YXJpYWJsZXMgdGhhdCBhcmUgbm90IHRoZSBnbG9iYWxseSBhY2Nlc3NpYmxlIGlkc1xuKTogUmVmZXJlbmNlW10ge1xuICBjb25zdCBpc0RvdWJsZVBhcmFudGhlc2lzID0gaW5wdXQuc3RhcnRzV2l0aChcIiR7e1wiKTtcbiAgaWYgKCFpbnB1dC5zdGFydHNXaXRoKFwiJHtcIikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBzdGFydCA9IGlzRG91YmxlUGFyYW50aGVzaXMgPyAzIDogMjtcbiAgY29uc3QgZW5kID0gaXNEb3VibGVQYXJhbnRoZXNpcyA/IGlucHV0Lmxlbmd0aCAtIDIgOiBpbnB1dC5sZW5ndGggLSAxO1xuICBsZXQgZXhwcmVzc2lvblN0cmluZyA9IGlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcblxuICBpZiAoXG4gICAgZXhwcmVzc2lvblN0cmluZy5pbmNsdWRlcyhcImZvclwiKSAmJlxuICAgIGV4cHJlc3Npb25TdHJpbmcuaW5jbHVkZXMoXCJpblwiKSAmJlxuICAgIGV4cHJlc3Npb25TdHJpbmcuaW5jbHVkZXMoXCI6XCIpXG4gICkge1xuICAgIC8vIGZvciBuYW1lLCB1c2VyIGluIHZhci51c2VycyA6IHVzZXIucm9sZSA9PiBuYW1lLi4uXG4gICAgLy8gV2UganVzdCB3YW50IHRoZSB2YXIudXNlcnMgcGFydCAodGhhdCBjb3VsZCBiZSBhbiBleHByZXNzaW9uKVxuICAgIGV4cHJlc3Npb25TdHJpbmcgPSBleHByZXNzaW9uU3RyaW5nLnN1YnN0cmluZyhcbiAgICAgIGV4cHJlc3Npb25TdHJpbmcuaW5kZXhPZihcImluXCIpICsgMixcbiAgICAgIGV4cHJlc3Npb25TdHJpbmcuaW5kZXhPZihcIjpcIilcbiAgICApO1xuICB9XG4gIGNvbnN0IGxpbmVzID0gZXhwcmVzc2lvblN0cmluZ1xuICAgIC5zcGxpdChcIlxcblwiKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGNvbW1lbnRTdGFydCA9IGxpbmUuaW5kZXhPZihcIiNcIik7XG4gICAgICBjb25zdCBsaW5lV2l0aG91dENvbW1lbnQgPVxuICAgICAgICBjb21tZW50U3RhcnQgIT09IC0xID8gbGluZS5zdWJzdHJpbmcoMCwgY29tbWVudFN0YXJ0IC0gMSkgOiBsaW5lO1xuXG4gICAgICByZXR1cm4gbGluZVdpdGhvdXRDb21tZW50LnRyaW0oKTtcbiAgICB9KVxuICAgIC5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpO1xuXG4gIGNvbnN0IGRlbGltaXRlcnMgPSBbXG4gICAgXCIoXCIsXG4gICAgXCIsXCIsXG4gICAgXCIpXCIsXG4gICAgXCIuKlwiLFxuICAgIFBST1BFUlRZX0FDQ0VTU19SRUdFWCxcbiAgICBcIiBcIixcbiAgICBcIiFcIixcbiAgICBcIipcIixcbiAgICBcIi9cIixcbiAgICBcIiVcIixcbiAgICBcIj5cIixcbiAgICBcIjxcIixcbiAgICBcIj1cIixcbiAgICBcIiYmXCIsXG4gICAgXCJ8fFwiLFxuICAgIFwiP1wiLFxuICAgIC8vIFRoZXJlIGNhbiBiZSBuZXN0ZWQgdGVycmFmb3JtIGV4cHJlc3Npb24gc3RyaW5nc1xuICAgIFwiJHtcIixcbiAgICBcIn1cIixcbiAgXTtcblxuICBsZXQgcG9zc2libGVWYXJpYWJsZVNwb3RzID0gbGluZXM7XG5cbiAgZGVsaW1pdGVycy5mb3JFYWNoKChkZWxpbWl0ZXIpID0+IHtcbiAgICBwb3NzaWJsZVZhcmlhYmxlU3BvdHMgPSBwb3NzaWJsZVZhcmlhYmxlU3BvdHMucmVkdWNlKFxuICAgICAgKGNhcnJ5LCBzdHIpID0+IFsuLi5jYXJyeSwgLi4uc3RyLnNwbGl0KGRlbGltaXRlcildLFxuICAgICAgW10gYXMgc3RyaW5nW11cbiAgICApO1xuICB9KTtcblxuICByZXR1cm4gcG9zc2libGVWYXJpYWJsZVNwb3RzLnJlZHVjZSgoY2FycnksIHNwb3QpID0+IHtcbiAgICAvLyBubyByZWZlcmVuY2VcbiAgICBpZiAoXG4gICAgICAhc3BvdC5pbmNsdWRlcyhcIi5cIikgfHwgLy8ganVzdCBhIGxpdGVyYWxcbiAgICAgIHNwb3Quc3RhcnRzV2l0aChcIi5cIikgfHwgLy8gZGFuZ2xpbmcgcHJvcGVydHkgYWNjZXNzXG4gICAgICBzcG90LmVuZHNXaXRoKFwiLi4uXCIpIHx8IC8vIHNwcmVhZCAobGlrZWx5IGluIGZvciBsb29wKVxuICAgICAgc3BvdC5zdGFydHNXaXRoKFwiY291bnQuXCIpIHx8IC8vIGNvdW50IHZhcmlhYmxlXG4gICAgICBzcG90LnN0YXJ0c1dpdGgoXCJlYWNoLlwiKSB8fCAvLyBlYWNoIHZhcmlhYmxlXG4gICAgICAvLyBodHRwczovL3d3dy50ZXJyYWZvcm0uaW8vZG9jcy9sYW5ndWFnZS9leHByZXNzaW9ucy9yZWZlcmVuY2VzLmh0bWwjZmlsZXN5c3RlbS1hbmQtd29ya3NwYWNlLWluZm9cbiAgICAgIHNwb3Quc3RhcnRzV2l0aChcInBhdGgubW9kdWxlXCIpIHx8XG4gICAgICBzcG90LnN0YXJ0c1dpdGgoXCJwYXRoLnJvb3RcIikgfHxcbiAgICAgIHNwb3Quc3RhcnRzV2l0aChcInBhdGguY3dkXCIpIHx8XG4gICAgICBzcG90LnN0YXJ0c1dpdGgoXCJ0ZXJyYWZvcm0ud29ya3NwYWNlXCIpXG4gICAgKSB7XG4gICAgICByZXR1cm4gY2Fycnk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVmZXJlbmNlUGFydHMgPSBzcG90LnNwbGl0KFwiLlwiKTtcblxuICAgIGNvbnN0IGNvcmVzcG9uZGluZ05vZGVJZCA9IFsuLi5ub2RlSWRzLCAuLi5zY29wZWRJZHNdLmZpbmQoKGlkKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGlkLnNwbGl0KFwiLlwiKTtcbiAgICAgIGNvbnN0IG1hdGNoZXNGaXJzdCA9IHBhcnRzWzBdID09PSByZWZlcmVuY2VQYXJ0c1swXTtcbiAgICAgIGNvbnN0IG1hdGNoZXNGaXJzdFR3byA9XG4gICAgICAgIG1hdGNoZXNGaXJzdCAmJiAocGFydHNbMV0gPT09IHJlZmVyZW5jZVBhcnRzWzFdIHx8IHBhcnRzLmxlbmd0aCA9PT0gMSk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIG1hdGNoZXNGaXJzdFR3byAmJlxuICAgICAgICAocGFydHNbMF0gPT09IFwiZGF0YVwiID8gcGFydHNbMl0gPT09IHJlZmVyZW5jZVBhcnRzWzJdIDogdHJ1ZSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWNvcmVzcG9uZGluZ05vZGVJZCkge1xuICAgICAgLy8gVGhpcyBpcyBtb3N0IGxpa2VseSBhIGZhbHNlIHBvc2l0aXZlLCBzbyB3ZSBqdXN0IGlnbm9yZSBpdFxuICAgICAgLy8gV2UgaW5jbHVkZSB0aGUgbG9nIGJlbG93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRm91bmQgYSByZWZlcmVuY2UgdGhhdCBpcyB1bmtub3duOiAke2lucHV0fSBoYXMgcmVmZXJlbmNlIFwiJHtzcG90fVwiLiBUaGUgaWQgd2FzIG5vdCBmb3VuZCBpbiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIG5vZGVJZHNcbiAgICAgICAgKX0gd2l0aCB0ZW1wb3JhcnkgdmFsdWVzICR7SlNPTi5zdHJpbmdpZnkoc2NvcGVkSWRzKX0uXG4gICAgICAgIFBsZWFzZSBsZWF2ZSBhIGNvbW1lbnQgYXQgaHR0cHM6Ly9jZGsudGYvYnVncy9jb252ZXJ0LWV4cHJlc3Npb25zIGlmIHlvdSBydW4gaW50byB0aGlzIGlzc3VlLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlZElkcy5pbmNsdWRlcyhjb3Jlc3BvbmRpbmdOb2RlSWQpKSB7XG4gICAgICByZXR1cm4gY2Fycnk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3BvdFBhcnRzID0gc3BvdC5zcGxpdChcIi5cIik7XG4gICAgbGV0IGlzVGhlcmVBTnVtZXJpY0FjY2Vzc29yID0gZmFsc2U7XG4gICAgY29uc3QgcmVmZXJlbmNlU3BvdFBhcnRzID0gc3BvdFBhcnRzLmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VJbnQocGFydCwgMTApKSkge1xuICAgICAgICBpc1RoZXJlQU51bWVyaWNBY2Nlc3NvciA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFpc1RoZXJlQU51bWVyaWNBY2Nlc3NvcjtcbiAgICB9KTtcbiAgICBjb25zdCBmdWxsUmVmZXJlbmNlID0gaXNUaGVyZUFOdW1lcmljQWNjZXNzb3JcbiAgICAgID8gcmVmZXJlbmNlU3BvdFBhcnRzLnNsaWNlKDAsIDIpLmpvaW4oXCIuXCIpXG4gICAgICA6IHNwb3Q7XG5cbiAgICAvLyB3ZSBrbm93IHdlIGFyZSBhdCBjbG9zZXIgdG8gdGhlIGVuZCB0aGFuIHRoZSBsYXN0IHJlZmVyZW5jZSB3ZSBmb3VuZFxuICAgIC8vIHRoaXMgaGVscHMgdXMgZmluZCBkdXBsaWNhdGUgcmVmZXJlbmNlZXNcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNhcnJ5Lmxlbmd0aCA/IGNhcnJ5W2NhcnJ5Lmxlbmd0aCAtIDFdLmVuZCA6IDA7XG4gICAgY29uc3Qgc3RhcnQgPSBpbnB1dC5pbmRleE9mKGZ1bGxSZWZlcmVuY2UsIHBvc2l0aW9uKTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGZ1bGxSZWZlcmVuY2UubGVuZ3RoO1xuXG4gICAgY29uc3QgaXNWYXJpYWJsZSA9IHNwb3Quc3RhcnRzV2l0aChcInZhci5cIik7XG4gICAgY29uc3QgdXNlRnFuID1cbiAgICAgIC8vIENhbiBub3QgdXNlIEZRTiBvbiB2YXJzXG4gICAgICAhaXNWYXJpYWJsZSAmJlxuICAgICAgLy8gQ2FuIG5vdCB1c2UgRlFOIG9uIGxvY2Fsc1xuICAgICAgIXNwb3Quc3RhcnRzV2l0aChcImxvY2FsLlwiKSAmJlxuICAgICAgLy8gSWYgdGhlIGZvbGxvd2luZyBjaGFyYWN0ZXIgaXNcbiAgICAgIChpbnB1dC5zdWJzdHIoZW5kICsgMSwgMSkgPT09IFwiKlwiIHx8IC8vIGEgKiAoc3BsYXQpIHdlIG5lZWQgdG8gdXNlIHRoZSBGUU5cbiAgICAgICAgaW5wdXQuc3Vic3RyKGVuZCwgMSkgPT09IFwiW1wiIHx8IC8vIGEgcHJvcGVydHkgYWNjZXNzXG4gICAgICAgIGlzVGhlcmVBTnVtZXJpY0FjY2Vzc29yIHx8IC8vIGEgbnVtZXJpYyBhY2Nlc3NcbiAgICAgICAgZnVsbFJlZmVyZW5jZS5zcGxpdChcIi5cIikubGVuZ3RoIDwgMyk7XG5cbiAgICBjb25zdCByZWY6IFJlZmVyZW5jZSA9IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgcmVmZXJlbmNlZToge1xuICAgICAgICBpZDogY29yZXNwb25kaW5nTm9kZUlkLFxuICAgICAgICBmdWxsOiBmdWxsUmVmZXJlbmNlLFxuICAgICAgfSxcbiAgICAgIHVzZUZxbixcbiAgICAgIGlzVmFyaWFibGUsXG4gICAgfTtcbiAgICByZXR1cm4gWy4uLmNhcnJ5LCByZWZdO1xuICB9LCBbXSBhcyBSZWZlcmVuY2VbXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZlcmVuY2VUb1ZhcmlhYmxlTmFtZShzY29wZTogU2NvcGUsIHJlZjogUmVmZXJlbmNlKTogc3RyaW5nIHtcbiAgY29uc3QgcGFydHMgPSByZWYucmVmZXJlbmNlZS5mdWxsLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgcmVzb3VyY2UgPSBwYXJ0c1swXSA9PT0gXCJkYXRhXCIgPyBgJHtwYXJ0c1swXX0uJHtwYXJ0c1sxXX1gIDogcGFydHNbMF07XG4gIGNvbnN0IG5hbWUgPSBwYXJ0c1swXSA9PT0gXCJkYXRhXCIgPyBwYXJ0c1syXSA6IHBhcnRzWzFdO1xuICByZXR1cm4gdmFyaWFibGVOYW1lKHNjb3BlLCByZXNvdXJjZSwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkVmFyTmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgaWYgKHJlc2VydmVkV29yZHMuY2hlY2sobmFtZSkpIHtcbiAgICByZXR1cm4gYCR7bmFtZX1WYXJgO1xuICB9XG5cbiAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmFtZVswXSwgMTApKSkge1xuICAgIHJldHVybiBgZCR7bmFtZX1gO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZU5hbWUoXG4gIHNjb3BlOiBTY29wZSxcbiAgcmVzb3VyY2U6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nXG4pOiBzdHJpbmcge1xuICAvLyBuYW1lIGNvbGxpc2lvbiwgd2UgbmVlZCB0byBwcmVmaXggdGhlIG5hbWVcbiAgaWYgKHNjb3BlLnZhcmlhYmxlc1tuYW1lXSkge1xuICAgIGlmIChyZXNvdXJjZSA9PT0gc2NvcGUudmFyaWFibGVzW25hbWVdLnJlc291cmNlKSB7XG4gICAgICByZXR1cm4gc2NvcGUudmFyaWFibGVzW25hbWVdLnZhcmlhYmxlTmFtZTtcbiAgICB9XG5cbiAgICAvLyB3ZSBvbmx5IGNhY2hlIG9uZSBwZXIgbmFtZVxuICAgIHJldHVybiB2YWxpZFZhck5hbWUoY2FtZWxDYXNlKFtyZXNvdXJjZSwgbmFtZV0uam9pbihcIl9cIikpKTtcbiAgfVxuXG4gIGNvbnN0IHZhcmlhYmxlTmFtZSA9IHZhbGlkVmFyTmFtZShcbiAgICBjYW1lbENhc2UoXG4gICAgICBbXCJ2YXJcIiwgXCJsb2NhbFwiLCBcIm1vZHVsZVwiXS5pbmNsdWRlcyhyZXNvdXJjZSlcbiAgICAgICAgPyBuYW1lXG4gICAgICAgIDogW3Jlc291cmNlLCBuYW1lXS5qb2luKFwiX1wiKVxuICAgIClcbiAgKTtcblxuICBzY29wZS52YXJpYWJsZXNbbmFtZV0gPSB7IHZhcmlhYmxlTmFtZSwgcmVzb3VyY2UgfTtcbiAgcmV0dXJuIHZhcmlhYmxlTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdEFzdCh0eXBlOiBzdHJpbmcsIGlzTW9kdWxlSW1wb3J0OiBib29sZWFuKSB7XG4gIGlmIChpc01vZHVsZUltcG9ydCkge1xuICAgIHJldHVybiB0Lm1lbWJlckV4cHJlc3Npb24odC5pZGVudGlmaWVyKHR5cGUpLCB0LmlkZW50aWZpZXIodHlwZSkpO1xuICB9XG5cbiAgLy8gcmVzb3VyY2VzIG9yIGRhdGEgc291cmNlc1xuICBpZiAoIXR5cGUuaW5jbHVkZXMoXCIuL1wiKSAmJiB0eXBlLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgIGNvbnN0IHBhcnRzID0gdHlwZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKHBhcnRzWzBdID09PSBcImRhdGFcIikge1xuICAgICAgY29uc3QgWywgcHJvdmlkZXIsIHJlc291cmNlXSA9IHBhcnRzO1xuICAgICAgY29uc3QgbmFtZXNwYWNlID0gZ2V0UmVzb3VyY2VOYW1lc3BhY2UocHJvdmlkZXIsIHJlc291cmNlKTtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICB0LmlkZW50aWZpZXIocHJvdmlkZXIpLCAvLyBlLmcuIGF3c1xuICAgICAgICAgICAgdC5pZGVudGlmaWVyKG5hbWVzcGFjZS5uYW1lKSAvLyBlLmcuIEVDMlxuICAgICAgICAgICksXG4gICAgICAgICAgdC5pZGVudGlmaWVyKHBhc2NhbENhc2UoYGRhdGFfJHtwcm92aWRlcn1fJHtyZXNvdXJjZX1gKSkgLy8gZS5nLiBEYXRhQXdzSW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgdC5pZGVudGlmaWVyKHByb3ZpZGVyKSwgLy8gZS5nLiBhd3NcbiAgICAgICAgdC5pZGVudGlmaWVyKHBhc2NhbENhc2UoYGRhdGFfJHtwcm92aWRlcn1fJHtyZXNvdXJjZX1gKSkgLy8gZS5nLiBEYXRhQXdzTmF0R2F0ZXdheVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBbcHJvdmlkZXIsIHJlc291cmNlXSA9IHBhcnRzO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IGdldFJlc291cmNlTmFtZXNwYWNlKHByb3ZpZGVyLCByZXNvdXJjZSk7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgcmV0dXJuIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgIHQuaWRlbnRpZmllcihwcm92aWRlciksIC8vIGUuZy4gYXdzXG4gICAgICAgICAgdC5pZGVudGlmaWVyKG5hbWVzcGFjZS5uYW1lKSAvLyBlLmcuIEVDMlxuICAgICAgICApLFxuICAgICAgICB0LmlkZW50aWZpZXIocGFzY2FsQ2FzZShyZXNvdXJjZSkpIC8vIGUuZy4gSW5zdGFuY2VcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICB0LmlkZW50aWZpZXIocHJvdmlkZXIpLCAvLyBlLmcuIGdvb2dsZVxuICAgICAgdC5pZGVudGlmaWVyKHBhc2NhbENhc2UocmVzb3VyY2UpKSAvLyBlLmcuIEJpZ1F1ZXJ5VGFibGVcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHQuaWRlbnRpZmllcihwYXNjYWxDYXNlKHR5cGUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmVyZW5jZVRvQXN0KHNjb3BlOiBTY29wZSwgcmVmOiBSZWZlcmVuY2UpIHtcbiAgY29uc3QgW3Jlc291cmNlLCAsIC4uLnNlbGVjdG9yXSA9IHJlZi5yZWZlcmVuY2VlLmZ1bGwuc3BsaXQoXCIuXCIpO1xuXG4gIGNvbnN0IHZhcmlhYmxlUmVmZXJlbmNlID0gdC5pZGVudGlmaWVyKFxuICAgIGNhbWVsQ2FzZShyZWZlcmVuY2VUb1ZhcmlhYmxlTmFtZShzY29wZSwgcmVmKSlcbiAgKTtcblxuICBpZiAocmVzb3VyY2UgPT09IFwiZGF0YVwiKSB7XG4gICAgc2VsZWN0b3Iuc2hpZnQoKTsgLy8gcmVtb3ZlIHRoZSBkYXRhIHBhcnQgc28gdGhhdCB0aGUgbmFtZSBpcyBub3QgdXNlZCBpbiB0aGUgc2VsZWN0b3JcbiAgfVxuXG4gIGNvbnN0IGFjY2Vzc29yID0gc2VsZWN0b3IucmVkdWNlKFxuICAgIChjYXJyeSwgbWVtYmVyLCBpbmRleCkgPT5cbiAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgY2FycnksXG4gICAgICAgIHQuaWRlbnRpZmllcihcbiAgICAgICAgICBpbmRleCA9PT0gMCAmJiByZXNvdXJjZSA9PT0gXCJtb2R1bGVcIlxuICAgICAgICAgICAgPyBjYW1lbENhc2UobWVtYmVyICsgXCJPdXRwdXRcIilcbiAgICAgICAgICAgIDogY2FtZWxDYXNlKG1lbWJlcilcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICB2YXJpYWJsZVJlZmVyZW5jZSBhcyB0LkV4cHJlc3Npb25cbiAgKTtcblxuICBpZiAocmVmLnVzZUZxbikge1xuICAgIHJldHVybiB0Lm1lbWJlckV4cHJlc3Npb24oYWNjZXNzb3IsIHQuaWRlbnRpZmllcihcImZxblwiKSk7XG4gIH1cblxuICBpZiAocmVmLmlzVmFyaWFibGUpIHtcbiAgICByZXR1cm4gdC5tZW1iZXJFeHByZXNzaW9uKGFjY2Vzc29yLCB0LmlkZW50aWZpZXIoXCJ2YWx1ZVwiKSk7XG4gIH1cbiAgcmV0dXJuIGFjY2Vzc29yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVmZXJlbmNlc1RvQXN0KFxuICBzY29wZTogU2NvcGUsXG4gIGlucHV0OiBzdHJpbmcsXG4gIHJlZnM6IFJlZmVyZW5jZVtdLFxuICBzY29wZWRJZHM6IHJlYWRvbmx5IHN0cmluZ1tdID0gW10gLy8gZHluYW1pY3MgaW50cm9kdWNlIG5ldyBzY29wZWQgdmFyaWFibGVzIHRoYXQgYXJlIG5vdCB0aGUgZ2xvYmFsbHkgYWNjZXNzaWJsZSBpZHNcbik6IHQuRXhwcmVzc2lvbiB7XG4gIGlmIChyZWZzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0LnN0cmluZ0xpdGVyYWwoaW5wdXQpO1xuICB9XG5cbiAgY29uc3QgcmVmQXN0cyA9IHJlZnNcbiAgICAuc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpXG4gICAgLmZpbHRlcigocmVmKSA9PiAhc2NvcGVkSWRzLmluY2x1ZGVzKHJlZi5yZWZlcmVuY2VlLmlkKSlcbiAgICAubWFwKChyZWYpID0+ICh7IHJlZiwgYXN0OiByZWZlcmVuY2VUb0FzdChzY29wZSwgcmVmKSB9KSk7XG5cbiAgaWYgKFxuICAgIHJlZkFzdHMubGVuZ3RoID09PSAxICYmXG4gICAgcmVmQXN0c1swXS5yZWYuc3RhcnQgPT09IFwiJHtcIi5sZW5ndGggJiZcbiAgICByZWZBc3RzWzBdLnJlZi5lbmQgPT09IGlucHV0Lmxlbmd0aCAtIFwifVwiLmxlbmd0aCAmJlxuICAgICFyZWZBc3RzWzBdLnJlZi51c2VGcW5cbiAgKSB7XG4gICAgcmV0dXJuIHJlZkFzdHNbMF0uYXN0O1xuICB9XG5cbiAgLy8gc3RyaW5nIHBhcnRzIGluIHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAgY29uc3QgcXVhc2lzOiB0LlRlbXBsYXRlRWxlbWVudFtdID0gW107XG4gIC8vIGR5bmFtaWMgdmFsdWVzIGluIHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAgY29uc3QgZXhwcmVzc2lvbnM6IHQuRXhwcmVzc2lvbltdID0gW107XG5cbiAgbGV0IGxhc3RFbmQgPSAwO1xuXG4gIHJlZkFzdHMuZm9yRWFjaCgoeyByZWYsIGFzdCB9KSA9PiB7XG4gICAgLy8gbGVhZGluZyBxdWFzaVxuICAgIGlmIChyZWYuc3RhcnQgIT09IGxhc3RFbmQpIHtcbiAgICAgIHF1YXNpcy5wdXNoKFxuICAgICAgICB0LnRlbXBsYXRlRWxlbWVudCh7XG4gICAgICAgICAgcmF3OiBpbnB1dC5zdWJzdHJpbmcobGFzdEVuZCwgcmVmLnN0YXJ0KS5yZXBsYWNlKERPTExBUl9SRUdFWCwgXCJcXFxcJFwiKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZXhwcmVzc2lvbnMucHVzaChhc3QpO1xuXG4gICAgbGFzdEVuZCA9IHJlZi5lbmQ7XG4gIH0pO1xuXG4gIC8vIHRyYWlsaW5nIHF1YXNpXG4gIHF1YXNpcy5wdXNoKFxuICAgIHQudGVtcGxhdGVFbGVtZW50KFxuICAgICAge1xuICAgICAgICByYXc6IGlucHV0XG4gICAgICAgICAgLnN1YnN0cmluZyhsYXN0RW5kLCBpbnB1dC5sZW5ndGgpXG4gICAgICAgICAgLnJlcGxhY2UoRE9MTEFSX1JFR0VYLCBcIlxcXFwkXCIpLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApXG4gICk7XG5cbiAgcmV0dXJuIHQudGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpO1xufVxuXG5leHBvcnQgdHlwZSBEeW5hbWljQmxvY2sgPSB7XG4gIHBhdGg6IHN0cmluZztcbiAgZm9yX2VhY2g6IHN0cmluZztcbiAgY29udGVudDogVGVycmFmb3JtUmVzb3VyY2VCbG9jaztcbiAgc2NvcGVkVmFyOiBzdHJpbmc7XG59O1xuZXhwb3J0IGNvbnN0IGV4dHJhY3REeW5hbWljQmxvY2tzID0gKFxuICBjb25maWc6IFRlcnJhZm9ybVJlc291cmNlQmxvY2ssXG4gIHBhdGggPSBcIlwiXG4pOiBEeW5hbWljQmxvY2tbXSA9PiB7XG4gIGlmICh0eXBlb2YgY29uZmlnICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5yZWR1Y2UoXG4gICAgICAoY2FycnksIGl0ZW0sIGluZGV4KSA9PiBbXG4gICAgICAgIC4uLmNhcnJ5LFxuICAgICAgICAuLi5leHRyYWN0RHluYW1pY0Jsb2NrcyhpdGVtLCBgJHtwYXRofS4ke2luZGV4fWApLFxuICAgICAgXSxcbiAgICAgIFtdXG4gICAgKTtcbiAgfVxuXG4gIGlmIChcImR5bmFtaWNcIiBpbiBjb25maWcpIHtcbiAgICBjb25zdCBkeW5hbWljID0gKGNvbmZpZyBhcyBhbnkpLmR5bmFtaWM7XG4gICAgY29uc3Qgc2NvcGVkVmFyID0gT2JqZWN0LmtleXMoZHluYW1pYylbMF07XG4gICAgY29uc3QgeyBmb3JfZWFjaCwgY29udGVudCB9ID0gZHluYW1pY1tzY29wZWRWYXJdWzBdO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgcGF0aDogYCR7cGF0aH0uJHtzY29wZWRWYXJ9YCxcbiAgICAgICAgZm9yX2VhY2gsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIHNjb3BlZFZhcixcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhjb25maWcpLnJlZHVjZSgoY2FycnksIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIHJldHVybiBbLi4uY2FycnksIC4uLmV4dHJhY3REeW5hbWljQmxvY2tzKHZhbHVlIGFzIGFueSwgYCR7cGF0aH0uJHtrZXl9YCldO1xuICB9LCBbXSBhcyBEeW5hbWljQmxvY2tbXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFVzZWRSZWZlcmVuY2VzKFxuICBub2RlSWRzOiBzdHJpbmdbXSxcbiAgaXRlbTogVGVycmFmb3JtUmVzb3VyY2VCbG9ja1xuKTogUmVmZXJlbmNlW10ge1xuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXh0cmFjdFJlZmVyZW5jZXNGcm9tRXhwcmVzc2lvbihpdGVtLCBub2RlSWRzLCBbXSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGl0ZW0gIT09IFwib2JqZWN0XCIgfHwgaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIHJldHVybiBpdGVtLnJlZHVjZShcbiAgICAgIChjYXJyeSwgaSkgPT4gWy4uLmNhcnJ5LCAuLi5maW5kVXNlZFJlZmVyZW5jZXMobm9kZUlkcywgaSldLFxuICAgICAgW11cbiAgICApO1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgXCJkeW5hbWljXCIgaW4gaXRlbSkge1xuICAgIGNvbnN0IGR5biA9IChpdGVtIGFzIGFueSlbXCJkeW5hbWljXCJdO1xuICAgIGNvbnN0IHsgZm9yX2VhY2gsIC4uLm90aGVycyB9ID0gZHluO1xuICAgIGNvbnN0IGR5bmFtaWNSZWYgPSBPYmplY3Qua2V5cyhvdGhlcnMpWzBdO1xuICAgIHJldHVybiBmaW5kVXNlZFJlZmVyZW5jZXMoWy4uLm5vZGVJZHMsIGR5bmFtaWNSZWZdLCBkeW4pO1xuICB9XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGl0ZW0gYXMgUmVjb3JkPHN0cmluZywgYW55PikucmVkdWNlKFxuICAgIChjYXJyeSwgaSkgPT4gWy4uLmNhcnJ5LCAuLi5maW5kVXNlZFJlZmVyZW5jZXMobm9kZUlkcywgaSldLFxuICAgIFtdXG4gICk7XG59XG4iXX0=