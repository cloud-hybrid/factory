"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _interfaces;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterfaceType = void 0;
const method_1 = require("./method");
const property_1 = require("./property");
const reference_type_1 = require("./reference-type");
const util_1 = require("./util");
class InterfaceType extends reference_type_1.ReferenceType {
    constructor(system, assembly, spec) {
        super(system, assembly, spec);
        this.system = system;
        this.assembly = assembly;
        this.spec = spec;
        /** Caches the result of `getInterfaces`. */
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _interfaces.set(this, new Map());
    }
    /**
     * True if this interface only contains properties. Different backends might
     * have idiomatic ways to allow defining concrete instances such interfaces.
     * For example, in Java, the generator will produce a PoJo and a builder
     * which will allow users to create a concrete object with data which
     * adheres to this interface.
     */
    get datatype() {
        return this.isDataType();
    }
    /**
     * Lists all interfaces this interface extends.
     * @param inherited include all interfaces implemented by all super interfaces (default: false)
     */
    getInterfaces(inherited = false) {
        if (!this.spec.interfaces) {
            return [];
        }
        if (__classPrivateFieldGet(this, _interfaces).has(inherited)) {
            return Array.from(__classPrivateFieldGet(this, _interfaces).get(inherited));
        }
        const result = new Set();
        for (const iface of this.spec.interfaces) {
            const ifaceType = this.system.findInterface(iface);
            if (!result.has(ifaceType) && inherited) {
                ifaceType.getInterfaces(inherited).forEach((i) => result.add(i));
            }
            result.add(ifaceType);
        }
        __classPrivateFieldGet(this, _interfaces).set(inherited, Array.from(result));
        // Returning a copy of the array, distinct from the one we memoized, for safety.
        return Array.from(result);
    }
    /**
     * Lists all properties in this class.
     * @param inherited include all properties inherited from base classes (default: false)
     */
    getProperties(inherited = false) {
        return this._getProperties(inherited, this);
    }
    /**
     * List all methods in this class.
     * @param inherited include all methods inherited from base classes (default: false)
     */
    getMethods(inherited = false) {
        return this._getMethods(inherited, this);
    }
    isDataType() {
        return !!this.spec.datatype;
    }
    isInterfaceType() {
        return true;
    }
    _getProperties(inherited, parentType) {
        var _a;
        const base = {};
        if (inherited) {
            for (const parent of this.getInterfaces()) {
                Object.assign(base, parent._getProperties(inherited, parentType));
            }
        }
        return Object.assign(base, util_1.indexBy(((_a = this.spec.properties) !== null && _a !== void 0 ? _a : []).map((p) => new property_1.Property(this.system, this.assembly, parentType, this, p)), (p) => p.name));
    }
    _getMethods(inherited, parentType) {
        var _a;
        const base = {};
        if (inherited) {
            for (const parent of this.getInterfaces()) {
                Object.assign(base, parent._getMethods(inherited, parentType));
            }
        }
        return Object.assign(base, util_1.indexBy(((_a = this.spec.methods) !== null && _a !== void 0 ? _a : []).map((m) => new method_1.Method(this.system, this.assembly, parentType, this, m)), (m) => m.name));
    }
}
exports.InterfaceType = InterfaceType;
_interfaces = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJmYWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW50ZXJmYWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFHQSxxQ0FBa0M7QUFDbEMseUNBQXNDO0FBQ3RDLHFEQUFpRDtBQUVqRCxpQ0FBaUM7QUFFakMsTUFBYSxhQUFjLFNBQVEsOEJBQWE7SUFLOUMsWUFDUyxNQUFrQixFQUNsQixRQUFrQixFQUNULElBQXdCO1FBRXhDLEtBQUssQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBSnZCLFdBQU0sR0FBTixNQUFNLENBQVk7UUFDbEIsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNULFNBQUksR0FBSixJQUFJLENBQW9CO1FBUDFDLDRDQUE0QztRQUM1Qyw0RUFBNEU7UUFDNUUsc0JBQXVCLElBQUksR0FBRyxFQUFxQyxFQUFDO0lBUXBFLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxJQUFXLFFBQVE7UUFDakIsT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGFBQWEsQ0FBQyxTQUFTLEdBQUcsS0FBSztRQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDekIsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELElBQUksMENBQWlCLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNuQyxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsMENBQWlCLEdBQUcsQ0FBQyxTQUFTLENBQUUsQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLEVBQWlCLENBQUM7UUFDeEMsS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUN4QyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZ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b250ZW50IjpbImltcG9ydCAqIGFzIGpzaWkgZnJvbSAnQGpzaWkvc3BlYyc7XG5cbmltcG9ydCB7IEFzc2VtYmx5IH0gZnJvbSAnLi9hc3NlbWJseSc7XG5pbXBvcnQgeyBNZXRob2QgfSBmcm9tICcuL21ldGhvZCc7XG5pbXBvcnQgeyBQcm9wZXJ0eSB9IGZyb20gJy4vcHJvcGVydHknO1xuaW1wb3J0IHsgUmVmZXJlbmNlVHlwZSB9IGZyb20gJy4vcmVmZXJlbmNlLXR5cGUnO1xuaW1wb3J0IHsgVHlwZVN5c3RlbSB9IGZyb20gJy4vdHlwZS1zeXN0ZW0nO1xuaW1wb3J0IHsgaW5kZXhCeSB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBJbnRlcmZhY2VUeXBlIGV4dGVuZHMgUmVmZXJlbmNlVHlwZSB7XG4gIC8qKiBDYWNoZXMgdGhlIHJlc3VsdCBvZiBgZ2V0SW50ZXJmYWNlc2AuICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbWVtYmVyLWFjY2Vzc2liaWxpdHlcbiAgcmVhZG9ubHkgI2ludGVyZmFjZXMgPSBuZXcgTWFwPGJvb2xlYW4sIHJlYWRvbmx5IEludGVyZmFjZVR5cGVbXT4oKTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHN5c3RlbTogVHlwZVN5c3RlbSxcbiAgICBwdWJsaWMgYXNzZW1ibHk6IEFzc2VtYmx5LFxuICAgIHB1YmxpYyByZWFkb25seSBzcGVjOiBqc2lpLkludGVyZmFjZVR5cGUsXG4gICkge1xuICAgIHN1cGVyKHN5c3RlbSwgYXNzZW1ibHksIHNwZWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhpcyBpbnRlcmZhY2Ugb25seSBjb250YWlucyBwcm9wZXJ0aWVzLiBEaWZmZXJlbnQgYmFja2VuZHMgbWlnaHRcbiAgICogaGF2ZSBpZGlvbWF0aWMgd2F5cyB0byBhbGxvdyBkZWZpbmluZyBjb25jcmV0ZSBpbnN0YW5jZXMgc3VjaCBpbnRlcmZhY2VzLlxuICAgKiBGb3IgZXhhbXBsZSwgaW4gSmF2YSwgdGhlIGdlbmVyYXRvciB3aWxsIHByb2R1Y2UgYSBQb0pvIGFuZCBhIGJ1aWxkZXJcbiAgICogd2hpY2ggd2lsbCBhbGxvdyB1c2VycyB0byBjcmVhdGUgYSBjb25jcmV0ZSBvYmplY3Qgd2l0aCBkYXRhIHdoaWNoXG4gICAqIGFkaGVyZXMgdG8gdGhpcyBpbnRlcmZhY2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRhdGF0eXBlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRGF0YVR5cGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgaW50ZXJmYWNlcyB0aGlzIGludGVyZmFjZSBleHRlbmRzLlxuICAgKiBAcGFyYW0gaW5oZXJpdGVkIGluY2x1ZGUgYWxsIGludGVyZmFjZXMgaW1wbGVtZW50ZWQgYnkgYWxsIHN1cGVyIGludGVyZmFjZXMgKGRlZmF1bHQ6IGZhbHNlKVxuICAgKi9cbiAgcHVibGljIGdldEludGVyZmFjZXMoaW5oZXJpdGVkID0gZmFsc2UpOiBJbnRlcmZhY2VUeXBlW10ge1xuICAgIGlmICghdGhpcy5zcGVjLmludGVyZmFjZXMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jaW50ZXJmYWNlcy5oYXMoaW5oZXJpdGVkKSkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jaW50ZXJmYWNlcy5nZXQoaW5oZXJpdGVkKSEpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SW50ZXJmYWNlVHlwZT4oKTtcbiAgICBmb3IgKGNvbnN0IGlmYWNlIG9mIHRoaXMuc3BlYy5pbnRlcmZhY2VzKSB7XG4gICAgICBjb25zdCBpZmFjZVR5cGUgPSB0aGlzLnN5c3RlbS5maW5kSW50ZXJmYWNlKGlmYWNlKTtcbiAgICAgIGlmICghcmVzdWx0LmhhcyhpZmFjZVR5cGUpICYmIGluaGVyaXRlZCkge1xuICAgICAgICBpZmFjZVR5cGUuZ2V0SW50ZXJmYWNlcyhpbmhlcml0ZWQpLmZvckVhY2goKGkpID0+IHJlc3VsdC5hZGQoaSkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmFkZChpZmFjZVR5cGUpO1xuICAgIH1cbiAgICB0aGlzLiNpbnRlcmZhY2VzLnNldChpbmhlcml0ZWQsIEFycmF5LmZyb20ocmVzdWx0KSk7XG4gICAgLy8gUmV0dXJuaW5nIGEgY29weSBvZiB0aGUgYXJyYXksIGRpc3RpbmN0IGZyb20gdGhlIG9uZSB3ZSBtZW1vaXplZCwgZm9yIHNhZmV0eS5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBwcm9wZXJ0aWVzIGluIHRoaXMgY2xhc3MuXG4gICAqIEBwYXJhbSBpbmhlcml0ZWQgaW5jbHVkZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBiYXNlIGNsYXNzZXMgKGRlZmF1bHQ6IGZhbHNlKVxuICAgKi9cbiAgcHVibGljIGdldFByb3BlcnRpZXMoaW5oZXJpdGVkID0gZmFsc2UpOiB7IFtuYW1lOiBzdHJpbmddOiBQcm9wZXJ0eSB9IHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcGVydGllcyhpbmhlcml0ZWQsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYWxsIG1ldGhvZHMgaW4gdGhpcyBjbGFzcy5cbiAgICogQHBhcmFtIGluaGVyaXRlZCBpbmNsdWRlIGFsbCBtZXRob2RzIGluaGVyaXRlZCBmcm9tIGJhc2UgY2xhc3NlcyAoZGVmYXVsdDogZmFsc2UpXG4gICAqL1xuICBwdWJsaWMgZ2V0TWV0aG9kcyhpbmhlcml0ZWQgPSBmYWxzZSk6IHsgW25hbWU6IHN0cmluZ106IE1ldGhvZCB9IHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0aG9kcyhpbmhlcml0ZWQsIHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGlzRGF0YVR5cGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zcGVjLmRhdGF0eXBlO1xuICB9XG5cbiAgcHVibGljIGlzSW50ZXJmYWNlVHlwZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgX2dldFByb3BlcnRpZXMoXG4gICAgaW5oZXJpdGVkOiBib29sZWFuLFxuICAgIHBhcmVudFR5cGU6IFJlZmVyZW5jZVR5cGUsXG4gICk6IHsgW25hbWU6IHN0cmluZ106IFByb3BlcnR5IH0ge1xuICAgIGNvbnN0IGJhc2U6IHsgW25hbWU6IHN0cmluZ106IFByb3BlcnR5IH0gPSB7fTtcbiAgICBpZiAoaW5oZXJpdGVkKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiB0aGlzLmdldEludGVyZmFjZXMoKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGJhc2UsIHBhcmVudC5fZ2V0UHJvcGVydGllcyhpbmhlcml0ZWQsIHBhcmVudFR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICBiYXNlLFxuICAgICAgaW5kZXhCeShcbiAgICAgICAgKHRoaXMuc3BlYy5wcm9wZXJ0aWVzID8/IFtdKS5tYXAoXG4gICAgICAgICAgKHApID0+IG5ldyBQcm9wZXJ0eSh0aGlzLnN5c3RlbSwgdGhpcy5hc3NlbWJseSwgcGFyZW50VHlwZSwgdGhpcywgcCksXG4gICAgICAgICksXG4gICAgICAgIChwKSA9PiBwLm5hbWUsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIF9nZXRNZXRob2RzKFxuICAgIGluaGVyaXRlZDogYm9vbGVhbixcbiAgICBwYXJlbnRUeXBlOiBSZWZlcmVuY2VUeXBlLFxuICApOiB7IFtuYW1lOiBzdHJpbmddOiBNZXRob2QgfSB7XG4gICAgY29uc3QgYmFzZTogeyBbbmFtZTogc3RyaW5nXTogUHJvcGVydHkgfSA9IHt9O1xuICAgIGlmIChpbmhlcml0ZWQpIHtcbiAgICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHRoaXMuZ2V0SW50ZXJmYWNlcygpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYmFzZSwgcGFyZW50Ll9nZXRNZXRob2RzKGluaGVyaXRlZCwgcGFyZW50VHlwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIGJhc2UsXG4gICAgICBpbmRleEJ5KFxuICAgICAgICAodGhpcy5zcGVjLm1ldGhvZHMgPz8gW10pLm1hcChcbiAgICAgICAgICAobSkgPT4gbmV3IE1ldGhvZCh0aGlzLnN5c3RlbSwgdGhpcy5hc3NlbWJseSwgcGFyZW50VHlwZSwgdGhpcywgbSksXG4gICAgICAgICksXG4gICAgICAgIChtKSA9PiBtLm5hbWUsXG4gICAgICApLFxuICAgICk7XG4gIH1cbn1cbiJdfQ==