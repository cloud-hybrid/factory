"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Method = exports.INITIALIZER_NAME = void 0;
const callable_1 = require("./callable");
const optional_value_1 = require("./optional-value");
const type_member_1 = require("./type-member");
/**
 * Symbolic name for the constructor
 */
exports.INITIALIZER_NAME = '<initializer>';
class Method extends callable_1.Callable {
    constructor(system, assembly, parentType, definingType, spec) {
        super(system, assembly, parentType, spec);
        this.definingType = definingType;
        this.spec = spec;
        this.kind = type_member_1.MemberKind.Method;
    }
    static isMethod(x) {
        return x instanceof Method;
    }
    /**
     * The name of the method.
     */
    get name() {
        return this.spec.name;
    }
    get overrides() {
        if (!this.spec.overrides) {
            return undefined;
        }
        return this.system.findFqn(this.spec.overrides);
    }
    /**
     * The return type of the method (undefined if void or initializer)
     */
    get returns() {
        return new optional_value_1.OptionalValue(this.system, this.spec.returns);
    }
    /**
     * Is this method an abstract method (this means the class will also be an abstract class)
     */
    get abstract() {
        return !!this.spec.abstract;
    }
    /**
     * Is this method asyncrhonous (this means the return value is a promise)
     */
    get async() {
        return !!this.spec.async;
    }
    /**
     * Indicates if this is a static method.
     */
    get static() {
        return !!this.spec.static;
    }
}
exports.Method = Method;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0aG9kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibWV0aG9kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdBLHlDQUFzQztBQUV0QyxxREFBaUQ7QUFJakQsK0NBQXVEO0FBR3ZEOztHQUVHO0FBQ1UsUUFBQSxnQkFBZ0IsR0FBRyxlQUFlLENBQUM7QUFFaEQsTUFBYSxNQUNYLFNBQVEsbUJBQVE7SUFTaEIsWUFDRSxNQUFrQixFQUNsQixRQUFrQixFQUNsQixVQUFnQixFQUNBLFlBQWtCLEVBQ2xCLElBQWlCO1FBRWpDLEtBQUssQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUgxQixpQkFBWSxHQUFaLFlBQVksQ0FBTTtRQUNsQixTQUFJLEdBQUosSUFBSSxDQUFhO1FBUG5CLFNBQUksR0FBRyx3QkFBVSxDQUFDLE1BQU0sQ0FBQztJQVV6QyxDQUFDO0lBZE0sTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFXO1FBQ2hDLE9BQU8sQ0FBQyxZQUFZLE1BQU0sQ0FBQztJQUM3QixDQUFDO0lBY0Q7O09BRUc7SUFDSCxJQUFXLElBQUk7UUFDYixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxJQUFXLFNBQVM7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ3hCLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsT0FBTztRQUNoQixPQUFPLElBQUksOEJBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxRQUFRO1FBQ2pCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsS0FBSztRQUNkLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsTUFBTTtRQUNmLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzVCLENBQUM7Q0FDRjtBQTlERCx3QkE4REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBqc2lpIGZyb20gJ0Bqc2lpL3NwZWMnO1xuXG5pbXBvcnQgeyBBc3NlbWJseSB9IGZyb20gJy4vYXNzZW1ibHknO1xuaW1wb3J0IHsgQ2FsbGFibGUgfSBmcm9tICcuL2NhbGxhYmxlJztcbmltcG9ydCB7IERvY3VtZW50YWJsZSB9IGZyb20gJy4vZG9jcyc7XG5pbXBvcnQgeyBPcHRpb25hbFZhbHVlIH0gZnJvbSAnLi9vcHRpb25hbC12YWx1ZSc7XG5pbXBvcnQgeyBPdmVycmlkYWJsZSB9IGZyb20gJy4vb3ZlcnJpZGFibGUnO1xuaW1wb3J0IHsgU291cmNlTG9jYXRhYmxlIH0gZnJvbSAnLi9zb3VyY2UnO1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJy4vdHlwZSc7XG5pbXBvcnQgeyBNZW1iZXJLaW5kLCBUeXBlTWVtYmVyIH0gZnJvbSAnLi90eXBlLW1lbWJlcic7XG5pbXBvcnQgeyBUeXBlU3lzdGVtIH0gZnJvbSAnLi90eXBlLXN5c3RlbSc7XG5cbi8qKlxuICogU3ltYm9saWMgbmFtZSBmb3IgdGhlIGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBjb25zdCBJTklUSUFMSVpFUl9OQU1FID0gJzxpbml0aWFsaXplcj4nO1xuXG5leHBvcnQgY2xhc3MgTWV0aG9kXG4gIGV4dGVuZHMgQ2FsbGFibGVcbiAgaW1wbGVtZW50cyBEb2N1bWVudGFibGUsIE92ZXJyaWRhYmxlLCBUeXBlTWVtYmVyLCBTb3VyY2VMb2NhdGFibGVcbntcbiAgcHVibGljIHN0YXRpYyBpc01ldGhvZCh4OiBDYWxsYWJsZSk6IHggaXMgTWV0aG9kIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIE1ldGhvZDtcbiAgfVxuXG4gIHB1YmxpYyByZWFkb25seSBraW5kID0gTWVtYmVyS2luZC5NZXRob2Q7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHN5c3RlbTogVHlwZVN5c3RlbSxcbiAgICBhc3NlbWJseTogQXNzZW1ibHksXG4gICAgcGFyZW50VHlwZTogVHlwZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGVmaW5pbmdUeXBlOiBUeXBlLFxuICAgIHB1YmxpYyByZWFkb25seSBzcGVjOiBqc2lpLk1ldGhvZCxcbiAgKSB7XG4gICAgc3VwZXIoc3lzdGVtLCBhc3NlbWJseSwgcGFyZW50VHlwZSwgc3BlYyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNwZWMubmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgb3ZlcnJpZGVzKCk6IFR5cGUgfCB1bmRlZmluZWQge1xuICAgIGlmICghdGhpcy5zcGVjLm92ZXJyaWRlcykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zeXN0ZW0uZmluZEZxbih0aGlzLnNwZWMub3ZlcnJpZGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJuIHR5cGUgb2YgdGhlIG1ldGhvZCAodW5kZWZpbmVkIGlmIHZvaWQgb3IgaW5pdGlhbGl6ZXIpXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJldHVybnMoKTogT3B0aW9uYWxWYWx1ZSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25hbFZhbHVlKHRoaXMuc3lzdGVtLCB0aGlzLnNwZWMucmV0dXJucyk7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhpcyBtZXRob2QgYW4gYWJzdHJhY3QgbWV0aG9kICh0aGlzIG1lYW5zIHRoZSBjbGFzcyB3aWxsIGFsc28gYmUgYW4gYWJzdHJhY3QgY2xhc3MpXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFic3RyYWN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuc3BlYy5hYnN0cmFjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGlzIG1ldGhvZCBhc3luY3Job25vdXMgKHRoaXMgbWVhbnMgdGhlIHJldHVybiB2YWx1ZSBpcyBhIHByb21pc2UpXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFzeW5jKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuc3BlYy5hc3luYztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhpcyBpcyBhIHN0YXRpYyBtZXRob2QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YXRpYygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLnNwZWMuc3RhdGljO1xuICB9XG59XG4iXX0=