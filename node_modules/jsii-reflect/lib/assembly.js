"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assembly = void 0;
const jsii = require("@jsii/spec");
const class_1 = require("./class");
const dependency_1 = require("./dependency");
const enum_1 = require("./enum");
const interface_1 = require("./interface");
const module_like_1 = require("./module-like");
const submodule_1 = require("./submodule");
class Assembly extends module_like_1.ModuleLike {
    constructor(system, spec) {
        super(system);
        this.spec = spec;
    }
    get fqn() {
        return this.spec.name;
    }
    /**
     * The version of the spec schema
     */
    get schema() {
        return this.spec.schema;
    }
    /**
     * The version of the jsii compiler that was used to produce this Assembly.
     */
    get jsiiVersion() {
        return this.spec.jsiiVersion;
    }
    /**
     * The name of the assembly
     */
    get name() {
        return this.spec.name;
    }
    /**
     * Description of the assembly, maps to "description" from package.json
     * This is required since some package managers (like Maven) require it.
     */
    get description() {
        return this.spec.description;
    }
    /**
     * The metadata associated with the assembly, if any.
     */
    get metadata() {
        return this.spec.metadata;
    }
    /**
     * The url to the project homepage. Maps to "homepage" from package.json.
     */
    get homepage() {
        return this.spec.homepage;
    }
    /**
     * The module repository, maps to "repository" from package.json
     * This is required since some package managers (like Maven) require it.
     */
    get repository() {
        return this.spec.repository;
    }
    /**
     * The main author of this package.
     */
    get author() {
        return this.spec.author;
    }
    /**
     * Additional contributors to this package.
     */
    get contributors() {
        var _a;
        return (_a = this.spec.contributors) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * A fingerprint that can be used to determine if the specification has changed.
     */
    get fingerprint() {
        return this.spec.fingerprint;
    }
    /**
     * The version of the assembly
     */
    get version() {
        return this.spec.version;
    }
    /**
     * The SPDX name of the license this assembly is distributed on.
     */
    get license() {
        return this.spec.license;
    }
    /**
     * A map of target name to configuration, which is used when generating packages for
     * various languages.
     */
    get targets() {
        return this.spec.targets;
    }
    /**
     * Dependencies on other assemblies (with semver), the key is the JSII assembly name.
     */
    get dependencies() {
        return Object.keys(this._dependencies).map((name) => this._dependencies[name]);
    }
    findDependency(name) {
        const dep = this._dependencies[name];
        if (!dep) {
            throw new Error(`Dependency ${name} not found for assembly ${this.name}`);
        }
        return dep;
    }
    /**
     * List if bundled dependencies (these are not expected to be jsii assemblies).
     */
    get bundled() {
        var _a;
        return (_a = this.spec.bundled) !== null && _a !== void 0 ? _a : {};
    }
    /**
     * The top-level readme document for this assembly (if any).
     */
    get readme() {
        return this.spec.readme;
    }
    /**
     * Return the those submodules nested directly under the assembly
     */
    get submodules() {
        const { submodules } = this._analyzeTypes();
        return Object.entries(submodules)
            .filter(([name, _]) => name.split('.').length === 2)
            .map(([_, submodule]) => submodule);
    }
    /**
     * Return all submodules, even those transtively nested
     */
    get allSubmodules() {
        const { submodules } = this._analyzeTypes();
        return Object.values(submodules);
    }
    /**
     * All types, even those in submodules and nested submodules.
     */
    get types() {
        return Object.values(this.typeMap);
    }
    /**
     * Return all types in the current assembly/submodule and all submodules underneath
     */
    get allTypes() {
        return [...this.types, ...this.allSubmodules.flatMap((s) => s.types)];
    }
    findType(fqn) {
        const type = this.tryFindType(fqn);
        if (!type) {
            throw new Error(`Type '${fqn}' not found in assembly ${this.name}`);
        }
        return type;
    }
    /**
     * Validate an assembly after loading
     *
     * If the assembly was loaded without validation, call this to validate
     * it after all. Throws an exception if validation fails.
     */
    validate() {
        jsii.validateAssembly(this.spec);
    }
    get submoduleMap() {
        return this._analyzeTypes().submodules;
    }
    /**
     * All types in the root of the assembly
     */
    get typeMap() {
        return this._analyzeTypes().types;
    }
    get _dependencies() {
        if (!this._dependencyCache) {
            this._dependencyCache = {};
            if (this.spec.dependencies) {
                for (const name of Object.keys(this.spec.dependencies)) {
                    this._dependencyCache[name] = new dependency_1.Dependency(this.system, name, this.spec.dependencies[name]);
                }
            }
        }
        return this._dependencyCache;
    }
    _analyzeTypes() {
        var _a;
        if (!this._typeCache || !this._submoduleCache) {
            this._typeCache = {};
            const submoduleBuilders = this.discoverSubmodules();
            const ts = (_a = this.spec.types) !== null && _a !== void 0 ? _a : {};
            for (const [fqn, typeSpec] of Object.entries(ts)) {
                let type;
                switch (typeSpec.kind) {
                    case jsii.TypeKind.Class:
                        type = new class_1.ClassType(this.system, this, typeSpec);
                        break;
                    case jsii.TypeKind.Interface:
                        type = new interface_1.InterfaceType(this.system, this, typeSpec);
                        break;
                    case jsii.TypeKind.Enum:
                        type = new enum_1.EnumType(this.system, this, typeSpec);
                        break;
                    default:
                        throw new Error('Unknown type kind');
                }
                // Find containing submodule (potentially through containing nested classes,
                // which DO count as namespaces but don't count as modules)
                let submodule = typeSpec.namespace;
                while (submodule != null && `${this.spec.name}.${submodule}` in ts) {
                    submodule = ts[`${this.spec.name}.${submodule}`].namespace;
                }
                if (submodule != null) {
                    const moduleName = `${this.spec.name}.${submodule}`;
                    submoduleBuilders[moduleName].addType(type);
                }
                else {
                    this._typeCache[fqn] = type;
                }
            }
            this._submoduleCache = mapValues(submoduleBuilders, (b) => b.build());
        }
        return { types: this._typeCache, submodules: this._submoduleCache };
    }
    /**
     * Return a builder for all submodules in this assembly (so that we can
     * add types into the objects).
     */
    discoverSubmodules() {
        var _a;
        const system = this.system;
        const ret = {};
        for (const [submoduleName, submoduleSpec] of Object.entries((_a = this.spec.submodules) !== null && _a !== void 0 ? _a : {})) {
            ret[submoduleName] = new SubmoduleBuilder(system, submoduleSpec, submoduleName, ret);
        }
        return ret;
    }
}
exports.Assembly = Assembly;
/**
 * Mutable Submodule builder
 *
 * Allows adding Types before the submodule is frozen to a Submodule class.
 *
 * Takes a reference to the full map of submodule builders, so that come time
 * to translate
 */
class SubmoduleBuilder {
    constructor(system, spec, fullName, allModuleBuilders) {
        this.system = system;
        this.spec = spec;
        this.fullName = fullName;
        this.allModuleBuilders = allModuleBuilders;
        this.types = {};
    }
    /**
     * Whether this submodule is a direct child of another submodule
     */
    isChildOf(other) {
        return (this.fullName.startsWith(`${other.fullName}.`) &&
            this.fullName.split('.').length === other.fullName.split('.').length + 1);
    }
    build() {
        if (!this._built) {
            this._built = new submodule_1.Submodule(this.system, this.spec, this.fullName, mapValues(this.findSubmoduleBuilders(), (b) => b.build()), this.types);
        }
        return this._built;
    }
    /**
     * Return all the builders from the map that are nested underneath ourselves.
     */
    findSubmoduleBuilders() {
        const ret = {};
        for (const [k, child] of Object.entries(this.allModuleBuilders)) {
            if (child.isChildOf(this)) {
                ret[k] = child;
            }
        }
        return ret;
    }
    addType(type) {
        this.types[type.fqn] = type;
    }
}
function mapValues(xs, fn) {
    const ret = {};
    for (const [k, v] of Object.entries(xs)) {
        ret[k] = fn(v);
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZW1ibHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhc3NlbWJseS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBbUM7QUFFbkMsbUNBQW9DO0FBQ3BDLDZDQUEwQztBQUMxQyxpQ0FBa0M7QUFDbEMsMkNBQTRDO0FBQzVDLCtDQUEyQztBQUMzQywyQ0FBd0M7QUFJeEMsTUFBYSxRQUFTLFNBQVEsd0JBQVU7SUFLdEMsWUFBbUIsTUFBa0IsRUFBa0IsSUFBbUI7UUFDeEUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRHVDLFNBQUksR0FBSixJQUFJLENBQWU7SUFFMUUsQ0FBQztJQUVELElBQVcsR0FBRztRQUNaLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxNQUFNO1FBQ2YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUMxQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLFdBQVc7UUFDcEIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLElBQUk7UUFDYixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFXLFdBQVc7UUFDcEIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLFFBQVE7UUFDakIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUM1QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLFFBQVE7UUFDakIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUM1QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBVyxVQUFVO1FBS25CLE9BQU8sSUFBSSxDQUFDLElB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T0FBTyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO1lBQy9ELElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDekIsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQzthQUNoQjtTQUNGO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRU0sT0FBTyxDQUFDLElBQVU7UUFDdkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQzlCLENBQUM7Q0FDRjtBQUVELFNBQVMsU0FBUyxDQUNoQixFQUFxQixFQUNyQixFQUFlO0lBRWYsTUFBTSxHQUFHLEdBQXNCLEVBQUUsQ0FBQztJQUNsQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUN2QyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2hCO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMganNpaSBmcm9tICdAanNpaS9zcGVjJztcblxuaW1wb3J0IHsgQ2xhc3NUeXBlIH0gZnJvbSAnLi9jbGFzcyc7XG5pbXBvcnQgeyBEZXBlbmRlbmN5IH0gZnJvbSAnLi9kZXBlbmRlbmN5JztcbmltcG9ydCB7IEVudW1UeXBlIH0gZnJvbSAnLi9lbnVtJztcbmltcG9ydCB7IEludGVyZmFjZVR5cGUgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBNb2R1bGVMaWtlIH0gZnJvbSAnLi9tb2R1bGUtbGlrZSc7XG5pbXBvcnQgeyBTdWJtb2R1bGUgfSBmcm9tICcuL3N1Ym1vZHVsZSc7XG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi90eXBlJztcbmltcG9ydCB7IFR5cGVTeXN0ZW0gfSBmcm9tICcuL3R5cGUtc3lzdGVtJztcblxuZXhwb3J0IGNsYXNzIEFzc2VtYmx5IGV4dGVuZHMgTW9kdWxlTGlrZSB7XG4gIHByaXZhdGUgX3R5cGVDYWNoZT86IHsgW2Zxbjogc3RyaW5nXTogVHlwZSB9O1xuICBwcml2YXRlIF9zdWJtb2R1bGVDYWNoZT86IHsgW2Zxbjogc3RyaW5nXTogU3VibW9kdWxlIH07XG4gIHByaXZhdGUgX2RlcGVuZGVuY3lDYWNoZT86IHsgW25hbWU6IHN0cmluZ106IERlcGVuZGVuY3kgfTtcblxuICBwdWJsaWMgY29uc3RydWN0b3Ioc3lzdGVtOiBUeXBlU3lzdGVtLCBwdWJsaWMgcmVhZG9ubHkgc3BlYzoganNpaS5Bc3NlbWJseSkge1xuICAgIHN1cGVyKHN5c3RlbSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGZxbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNwZWMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc3BlYyBzY2hlbWFcbiAgICovXG4gIHB1YmxpYyBnZXQgc2NoZW1hKCk6IGpzaWkuU2NoZW1hVmVyc2lvbiB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5zY2hlbWE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIGpzaWkgY29tcGlsZXIgdGhhdCB3YXMgdXNlZCB0byBwcm9kdWNlIHRoaXMgQXNzZW1ibHkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGpzaWlWZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5qc2lpVmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgYXNzZW1ibHlcbiAgICovXG4gIHB1YmxpYyBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNwZWMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNjcmlwdGlvbiBvZiB0aGUgYXNzZW1ibHksIG1hcHMgdG8gXCJkZXNjcmlwdGlvblwiIGZyb20gcGFja2FnZS5qc29uXG4gICAqIFRoaXMgaXMgcmVxdWlyZWQgc2luY2Ugc29tZSBwYWNrYWdlIG1hbmFnZXJzIChsaWtlIE1hdmVuKSByZXF1aXJlIGl0LlxuICAgKi9cbiAgcHVibGljIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNwZWMuZGVzY3JpcHRpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzZW1ibHksIGlmIGFueS5cbiAgICovXG4gIHB1YmxpYyBnZXQgbWV0YWRhdGEoKTogeyByZWFkb25seSBba2V5OiBzdHJpbmddOiBhbnkgfSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5tZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdXJsIHRvIHRoZSBwcm9qZWN0IGhvbWVwYWdlLiBNYXBzIHRvIFwiaG9tZXBhZ2VcIiBmcm9tIHBhY2thZ2UuanNvbi5cbiAgICovXG4gIHB1YmxpYyBnZXQgaG9tZXBhZ2UoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zcGVjLmhvbWVwYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtb2R1bGUgcmVwb3NpdG9yeSwgbWFwcyB0byBcInJlcG9zaXRvcnlcIiBmcm9tIHBhY2thZ2UuanNvblxuICAgKiBUaGlzIGlzIHJlcXVpcmVkIHNpbmNlIHNvbWUgcGFja2FnZSBtYW5hZ2VycyAobGlrZSBNYXZlbikgcmVxdWlyZSBpdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmVwb3NpdG9yeSgpOiB7XG4gICAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHVybDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGRpcmVjdG9yeT86IHN0cmluZztcbiAgfSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5yZXBvc2l0b3J5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIGF1dGhvciBvZiB0aGlzIHBhY2thZ2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGF1dGhvcigpOiBqc2lpLlBlcnNvbiB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5hdXRob3I7XG4gIH1cblxuICAvKipcbiAgICogQWRkaXRpb25hbCBjb250cmlidXRvcnMgdG8gdGhpcyBwYWNrYWdlLlxuICAgKi9cbiAgcHVibGljIGdldCBjb250cmlidXRvcnMoKTogcmVhZG9ubHkganNpaS5QZXJzb25bXSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5jb250cmlidXRvcnMgPz8gW107XG4gIH1cblxuICAvKipcbiAgICogQSBmaW5nZXJwcmludCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgc3BlY2lmaWNhdGlvbiBoYXMgY2hhbmdlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgZmluZ2VycHJpbnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zcGVjLmZpbmdlcnByaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBhc3NlbWJseVxuICAgKi9cbiAgcHVibGljIGdldCB2ZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy52ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBTUERYIG5hbWUgb2YgdGhlIGxpY2Vuc2UgdGhpcyBhc3NlbWJseSBpcyBkaXN0cmlidXRlZCBvbi5cbiAgICovXG4gIHB1YmxpYyBnZXQgbGljZW5zZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNwZWMubGljZW5zZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1hcCBvZiB0YXJnZXQgbmFtZSB0byBjb25maWd1cmF0aW9uLCB3aGljaCBpcyB1c2VkIHdoZW4gZ2VuZXJhdGluZyBwYWNrYWdlcyBmb3JcbiAgICogdmFyaW91cyBsYW5ndWFnZXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy50YXJnZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGVuZGVuY2llcyBvbiBvdGhlciBhc3NlbWJsaWVzICh3aXRoIHNlbXZlciksIHRoZSBrZXkgaXMgdGhlIEpTSUkgYXNzZW1ibHkgbmFtZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgZGVwZW5kZW5jaWVzKCk6IHJlYWRvbmx5IERlcGVuZGVuY3lbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2RlcGVuZGVuY2llcykubWFwKFxuICAgICAgKG5hbWUpID0+IHRoaXMuX2RlcGVuZGVuY2llc1tuYW1lXSxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGZpbmREZXBlbmRlbmN5KG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGRlcCA9IHRoaXMuX2RlcGVuZGVuY2llc1tuYW1lXTtcbiAgICBpZiAoIWRlcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZXBlbmRlbmN5ICR7bmFtZX0gbm90IGZvdW5kIGZvciBhc3NlbWJseSAke3RoaXMubmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IGlmIGJ1bmRsZWQgZGVwZW5kZW5jaWVzICh0aGVzZSBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIGpzaWkgYXNzZW1ibGllcykuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGJ1bmRsZWQoKTogeyByZWFkb25seSBbbW9kdWxlOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5idW5kbGVkID8/IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AtbGV2ZWwgcmVhZG1lIGRvY3VtZW50IGZvciB0aGlzIGFzc2VtYmx5IChpZiBhbnkpLlxuICAgKi9cbiAgcHVibGljIGdldCByZWFkbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5yZWFkbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0aG9zZSBzdWJtb2R1bGVzIG5lc3RlZCBkaXJlY3RseSB1bmRlciB0aGUgYXNzZW1ibHlcbiAgICovXG4gIHB1YmxpYyBnZXQgc3VibW9kdWxlcygpOiByZWFkb25seSBTdWJtb2R1bGVbXSB7XG4gICAgY29uc3QgeyBzdWJtb2R1bGVzIH0gPSB0aGlzLl9hbmFseXplVHlwZXMoKTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc3VibW9kdWxlcylcbiAgICAgIC5maWx0ZXIoKFtuYW1lLCBfXSkgPT4gbmFtZS5zcGxpdCgnLicpLmxlbmd0aCA9PT0gMilcbiAgICAgIC5tYXAoKFtfLCBzdWJtb2R1bGVdKSA9PiBzdWJtb2R1bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgc3VibW9kdWxlcywgZXZlbiB0aG9zZSB0cmFuc3RpdmVseSBuZXN0ZWRcbiAgICovXG4gIHB1YmxpYyBnZXQgYWxsU3VibW9kdWxlcygpOiByZWFkb25seSBTdWJtb2R1bGVbXSB7XG4gICAgY29uc3QgeyBzdWJtb2R1bGVzIH0gPSB0aGlzLl9hbmFseXplVHlwZXMoKTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdWJtb2R1bGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGwgdHlwZXMsIGV2ZW4gdGhvc2UgaW4gc3VibW9kdWxlcyBhbmQgbmVzdGVkIHN1Ym1vZHVsZXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHR5cGVzKCk6IHJlYWRvbmx5IFR5cGVbXSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy50eXBlTWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHR5cGVzIGluIHRoZSBjdXJyZW50IGFzc2VtYmx5L3N1Ym1vZHVsZSBhbmQgYWxsIHN1Ym1vZHVsZXMgdW5kZXJuZWF0aFxuICAgKi9cbiAgcHVibGljIGdldCBhbGxUeXBlcygpOiByZWFkb25seSBUeXBlW10ge1xuICAgIHJldHVybiBbLi4udGhpcy50eXBlcywgLi4udGhpcy5hbGxTdWJtb2R1bGVzLmZsYXRNYXAoKHMpID0+IHMudHlwZXMpXTtcbiAgfVxuXG4gIHB1YmxpYyBmaW5kVHlwZShmcW46IHN0cmluZykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRyeUZpbmRUeXBlKGZxbik7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgJyR7ZnFufScgbm90IGZvdW5kIGluIGFzc2VtYmx5ICR7dGhpcy5uYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbiBhc3NlbWJseSBhZnRlciBsb2FkaW5nXG4gICAqXG4gICAqIElmIHRoZSBhc3NlbWJseSB3YXMgbG9hZGVkIHdpdGhvdXQgdmFsaWRhdGlvbiwgY2FsbCB0aGlzIHRvIHZhbGlkYXRlXG4gICAqIGl0IGFmdGVyIGFsbC4gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgKi9cbiAgcHVibGljIHZhbGlkYXRlKCkge1xuICAgIGpzaWkudmFsaWRhdGVBc3NlbWJseSh0aGlzLnNwZWMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCBzdWJtb2R1bGVNYXAoKTogUmVhZG9ubHk8UmVjb3JkPHN0cmluZywgU3VibW9kdWxlPj4ge1xuICAgIHJldHVybiB0aGlzLl9hbmFseXplVHlwZXMoKS5zdWJtb2R1bGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbCB0eXBlcyBpbiB0aGUgcm9vdCBvZiB0aGUgYXNzZW1ibHlcbiAgICovXG4gIHByb3RlY3RlZCBnZXQgdHlwZU1hcCgpOiBSZWFkb25seTxSZWNvcmQ8c3RyaW5nLCBUeXBlPj4ge1xuICAgIHJldHVybiB0aGlzLl9hbmFseXplVHlwZXMoKS50eXBlcztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IF9kZXBlbmRlbmNpZXMoKSB7XG4gICAgaWYgKCF0aGlzLl9kZXBlbmRlbmN5Q2FjaGUpIHtcbiAgICAgIHRoaXMuX2RlcGVuZGVuY3lDYWNoZSA9IHt9O1xuICAgICAgaWYgKHRoaXMuc3BlYy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuc3BlYy5kZXBlbmRlbmNpZXMpKSB7XG4gICAgICAgICAgdGhpcy5fZGVwZW5kZW5jeUNhY2hlW25hbWVdID0gbmV3IERlcGVuZGVuY3koXG4gICAgICAgICAgICB0aGlzLnN5c3RlbSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0aGlzLnNwZWMuZGVwZW5kZW5jaWVzW25hbWVdLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeUNhY2hlO1xuICB9XG5cbiAgcHJpdmF0ZSBfYW5hbHl6ZVR5cGVzKCkge1xuICAgIGlmICghdGhpcy5fdHlwZUNhY2hlIHx8ICF0aGlzLl9zdWJtb2R1bGVDYWNoZSkge1xuICAgICAgdGhpcy5fdHlwZUNhY2hlID0ge307XG5cbiAgICAgIGNvbnN0IHN1Ym1vZHVsZUJ1aWxkZXJzID0gdGhpcy5kaXNjb3ZlclN1Ym1vZHVsZXMoKTtcblxuICAgICAgY29uc3QgdHMgPSB0aGlzLnNwZWMudHlwZXMgPz8ge307XG4gICAgICBmb3IgKGNvbnN0IFtmcW4sIHR5cGVTcGVjXSBvZiBPYmplY3QuZW50cmllcyh0cykpIHtcbiAgICAgICAgbGV0IHR5cGU6IFR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZVNwZWMua2luZCkge1xuICAgICAgICAgIGNhc2UganNpaS5UeXBlS2luZC5DbGFzczpcbiAgICAgICAgICAgIHR5cGUgPSBuZXcgQ2xhc3NUeXBlKHRoaXMuc3lzdGVtLCB0aGlzLCB0eXBlU3BlYyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UganNpaS5UeXBlS2luZC5JbnRlcmZhY2U6XG4gICAgICAgICAgICB0eXBlID0gbmV3IEludGVyZmFjZVR5cGUodGhpcy5zeXN0ZW0sIHRoaXMsIHR5cGVTcGVjKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBqc2lpLlR5cGVLaW5kLkVudW06XG4gICAgICAgICAgICB0eXBlID0gbmV3IEVudW1UeXBlKHRoaXMuc3lzdGVtLCB0aGlzLCB0eXBlU3BlYyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSBraW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIGNvbnRhaW5pbmcgc3VibW9kdWxlIChwb3RlbnRpYWxseSB0aHJvdWdoIGNvbnRhaW5pbmcgbmVzdGVkIGNsYXNzZXMsXG4gICAgICAgIC8vIHdoaWNoIERPIGNvdW50IGFzIG5hbWVzcGFjZXMgYnV0IGRvbid0IGNvdW50IGFzIG1vZHVsZXMpXG4gICAgICAgIGxldCBzdWJtb2R1bGUgPSB0eXBlU3BlYy5uYW1lc3BhY2U7XG4gICAgICAgIHdoaWxlIChzdWJtb2R1bGUgIT0gbnVsbCAmJiBgJHt0aGlzLnNwZWMubmFtZX0uJHtzdWJtb2R1bGV9YCBpbiB0cykge1xuICAgICAgICAgIHN1Ym1vZHVsZSA9IHRzW2Ake3RoaXMuc3BlYy5uYW1lfS4ke3N1Ym1vZHVsZX1gXS5uYW1lc3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VibW9kdWxlICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGVOYW1lID0gYCR7dGhpcy5zcGVjLm5hbWV9LiR7c3VibW9kdWxlfWA7XG4gICAgICAgICAgc3VibW9kdWxlQnVpbGRlcnNbbW9kdWxlTmFtZV0uYWRkVHlwZSh0eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90eXBlQ2FjaGVbZnFuXSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3VibW9kdWxlQ2FjaGUgPSBtYXBWYWx1ZXMoc3VibW9kdWxlQnVpbGRlcnMsIChiKSA9PiBiLmJ1aWxkKCkpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlczogdGhpcy5fdHlwZUNhY2hlLCBzdWJtb2R1bGVzOiB0aGlzLl9zdWJtb2R1bGVDYWNoZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGJ1aWxkZXIgZm9yIGFsbCBzdWJtb2R1bGVzIGluIHRoaXMgYXNzZW1ibHkgKHNvIHRoYXQgd2UgY2FuXG4gICAqIGFkZCB0eXBlcyBpbnRvIHRoZSBvYmplY3RzKS5cbiAgICovXG4gIHByaXZhdGUgZGlzY292ZXJTdWJtb2R1bGVzKCk6IFJlY29yZDxzdHJpbmcsIFN1Ym1vZHVsZUJ1aWxkZXI+IHtcbiAgICBjb25zdCBzeXN0ZW0gPSB0aGlzLnN5c3RlbTtcblxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgU3VibW9kdWxlQnVpbGRlcj4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtzdWJtb2R1bGVOYW1lLCBzdWJtb2R1bGVTcGVjXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgIHRoaXMuc3BlYy5zdWJtb2R1bGVzID8/IHt9LFxuICAgICkpIHtcbiAgICAgIHJldFtzdWJtb2R1bGVOYW1lXSA9IG5ldyBTdWJtb2R1bGVCdWlsZGVyKFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHN1Ym1vZHVsZVNwZWMsXG4gICAgICAgIHN1Ym1vZHVsZU5hbWUsXG4gICAgICAgIHJldCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNdXRhYmxlIFN1Ym1vZHVsZSBidWlsZGVyXG4gKlxuICogQWxsb3dzIGFkZGluZyBUeXBlcyBiZWZvcmUgdGhlIHN1Ym1vZHVsZSBpcyBmcm96ZW4gdG8gYSBTdWJtb2R1bGUgY2xhc3MuXG4gKlxuICogVGFrZXMgYSByZWZlcmVuY2UgdG8gdGhlIGZ1bGwgbWFwIG9mIHN1Ym1vZHVsZSBidWlsZGVycywgc28gdGhhdCBjb21lIHRpbWVcbiAqIHRvIHRyYW5zbGF0ZVxuICovXG5jbGFzcyBTdWJtb2R1bGVCdWlsZGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSB0eXBlczogUmVjb3JkPHN0cmluZywgVHlwZT4gPSB7fTtcblxuICBwcml2YXRlIF9idWlsdD86IFN1Ym1vZHVsZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzeXN0ZW06IFR5cGVTeXN0ZW0sXG4gICAgcHJpdmF0ZSByZWFkb25seSBzcGVjOiBqc2lpLlN1Ym1vZHVsZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZ1bGxOYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhbGxNb2R1bGVCdWlsZGVyczogUmVjb3JkPHN0cmluZywgU3VibW9kdWxlQnVpbGRlcj4sXG4gICkge31cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHN1Ym1vZHVsZSBpcyBhIGRpcmVjdCBjaGlsZCBvZiBhbm90aGVyIHN1Ym1vZHVsZVxuICAgKi9cbiAgcHVibGljIGlzQ2hpbGRPZihvdGhlcjogU3VibW9kdWxlQnVpbGRlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmZ1bGxOYW1lLnN0YXJ0c1dpdGgoYCR7b3RoZXIuZnVsbE5hbWV9LmApICYmXG4gICAgICB0aGlzLmZ1bGxOYW1lLnNwbGl0KCcuJykubGVuZ3RoID09PSBvdGhlci5mdWxsTmFtZS5zcGxpdCgnLicpLmxlbmd0aCArIDFcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGJ1aWxkKCk6IFN1Ym1vZHVsZSB7XG4gICAgaWYgKCF0aGlzLl9idWlsdCkge1xuICAgICAgdGhpcy5fYnVpbHQgPSBuZXcgU3VibW9kdWxlKFxuICAgICAgICB0aGlzLnN5c3RlbSxcbiAgICAgICAgdGhpcy5zcGVjLFxuICAgICAgICB0aGlzLmZ1bGxOYW1lLFxuICAgICAgICBtYXBWYWx1ZXModGhpcy5maW5kU3VibW9kdWxlQnVpbGRlcnMoKSwgKGIpID0+IGIuYnVpbGQoKSksXG4gICAgICAgIHRoaXMudHlwZXMsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnVpbHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCB0aGUgYnVpbGRlcnMgZnJvbSB0aGUgbWFwIHRoYXQgYXJlIG5lc3RlZCB1bmRlcm5lYXRoIG91cnNlbHZlcy5cbiAgICovXG4gIHByaXZhdGUgZmluZFN1Ym1vZHVsZUJ1aWxkZXJzKCkge1xuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgU3VibW9kdWxlQnVpbGRlcj4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrLCBjaGlsZF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5hbGxNb2R1bGVCdWlsZGVycykpIHtcbiAgICAgIGlmIChjaGlsZC5pc0NoaWxkT2YodGhpcykpIHtcbiAgICAgICAgcmV0W2tdID0gY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBwdWJsaWMgYWRkVHlwZSh0eXBlOiBUeXBlKSB7XG4gICAgdGhpcy50eXBlc1t0eXBlLmZxbl0gPSB0eXBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcFZhbHVlczxBLCBCPihcbiAgeHM6IFJlY29yZDxzdHJpbmcsIEE+LFxuICBmbjogKHg6IEEpID0+IEIsXG4pOiBSZWNvcmQ8c3RyaW5nLCBCPiB7XG4gIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgQj4gPSB7fTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoeHMpKSB7XG4gICAgcmV0W2tdID0gZm4odik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==