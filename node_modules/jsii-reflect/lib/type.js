"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = void 0;
const _memoized_1 = require("./_memoized");
const docs_1 = require("./docs");
const source_1 = require("./source");
const type_ref_1 = require("./type-ref");
class Type {
    constructor(system, assembly, spec) {
        this.system = system;
        this.assembly = assembly;
        this.spec = spec;
    }
    toString() {
        return `${this.kind} ${this.fqn}`;
    }
    /**
     * The fully qualified name of the type (``<assembly>.<namespace>.<name>``)
     */
    get fqn() {
        return this.spec.fqn;
    }
    /**
     * The namespace of the type (``foo.bar.baz``). When undefined, the type is located at the root of the assembly
     * (it's ``fqn`` would be like ``<assembly>.<name>``). If the `namespace` corresponds to an existing type's
     * namespace-qualified (e.g: ``<namespace>.<name>``), then the current type is a nested type.
     */
    get namespace() {
        return this.spec.namespace;
    }
    /**
     * The type within which this type is nested (if any).
     */
    get nestingParent() {
        const ns = this.namespace;
        if (ns == null) {
            return undefined;
        }
        return this.assembly.tryFindType(`${this.assembly.name}.${ns}`);
    }
    /**
     * The simple name of the type (MyClass).
     */
    get name() {
        return this.spec.name;
    }
    /**
     * The kind of the type.
     */
    get kind() {
        return this.spec.kind;
    }
    get docs() {
        var _a;
        return new docs_1.Docs(this.system, this, (_a = this.spec.docs) !== null && _a !== void 0 ? _a : {});
    }
    /**
     * A type reference to this type
     */
    get reference() {
        return new type_ref_1.TypeReference(this.system, {
            fqn: this.fqn,
        });
    }
    /**
     * Determines whether this is a Class type or not.
     */
    isClassType() {
        return false;
    }
    /**
     * Determines whether this is a Data Type (that is, an interface with no methods) or not.
     */
    isDataType() {
        return false; // TODO how is this different from isInterfaceType?
    }
    /**
     * Determines whether this is an Enum type or not.
     */
    isEnumType() {
        return false;
    }
    /**
     * Determines whether this is an Interface type or not.
     */
    isInterfaceType() {
        return false;
    }
    /**
     * Determines whether this type extends a given base or not.
     *
     * @param base the candidate base type.
     */
    extends(base) {
        if (this === base) {
            return true;
        }
        if ((this.isInterfaceType() || this.isClassType()) &&
            base.isInterfaceType()) {
            return this.getInterfaces(true).some((iface) => iface === base);
        }
        if (this.isClassType() && base.isClassType()) {
            return this.getAncestors().some((clazz) => clazz === base);
        }
        return false;
    }
    /**
     * Finds all type that:
     * - extend this, if this is a ClassType
     * - implement this, if this is an InterfaceType (this includes interfaces extending this)
     *
     * As classes and interfaces are considered to extend themselves, "this" will be part of all return values when called
     * on classes and interfaces.
     *
     * The result will always be empty for types that are neither ClassType nor InterfaceType.
     */
    get allImplementations() {
        if (this.isClassType() || this.isInterfaceType()) {
            return [
                ...this.system.classes.filter((c) => c.extends(this)),
                ...this.system.interfaces.filter((i) => i.extends(this)),
            ];
        }
        return [];
    }
    /**
     * Return the location in the module
     */
    get locationInModule() {
        return this.spec.locationInModule;
    }
    /**
     * Return the location in the repository
     */
    get locationInRepository() {
        return source_1.locationInRepository(this);
    }
}
__decorate([
    _memoized_1.memoized
], Type.prototype, "nestingParent", null);
__decorate([
    _memoized_1.memoized
], Type.prototype, "allImplementations", null);
exports.Type = Type;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInR5cGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRUEsMkNBQXVDO0FBR3ZDLGlDQUE0QztBQUc1QyxxQ0FJa0I7QUFDbEIseUNBQTJDO0FBRzNDLE1BQXNCLElBQUk7SUFDeEIsWUFDa0IsTUFBa0IsRUFDbEIsUUFBa0IsRUFDbEIsSUFBZTtRQUZmLFdBQU0sR0FBTixNQUFNLENBQVk7UUFDbEIsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNsQixTQUFJLEdBQUosSUFBSSxDQUFXO0lBQzlCLENBQUM7SUFFRyxRQUFRO1FBQ2IsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsR0FBRztRQUNaLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFXLFNBQVM7UUFDbEIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7O09BRUc7SUFFSCxJQUFXLGFBQWE7UUFDdEIsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUMxQixJQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUU7WUFDZCxPQUFPLFNBQVMsQ0FBQztTQUNsQjtRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsSUFBSTtRQUNiLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxJQUFJO1FBQ2IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztJQUN4QixDQUFDO0lBRUQsSUFBVyxJQUFJOztRQUNiLE9BQU8sSUFBSSxXQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLFFBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLG1DQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsU0FBUztRQUNsQixPQUFPLElBQUksd0JBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ3BDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztTQUNkLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNJLFdBQVc7UUFDaEIsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSSxVQUFVO1FBQ2YsT0FBTyxLQUFLLENBQUMsQ0FBQyxtREFBbUQ7SUFDbkUsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVTtRQUNmLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZUFBZTtRQUNwQixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksT0FBTyxDQUFDLElBQVU7UUFDdkIsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFO1lBQ2pCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUNFLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUM5QyxJQUFJLENBQUMsZUFBZSxFQUFFLEVBQ3RCO1lBQ0EsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDO1NBQ2pFO1FBQ0QsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO1lBQzVDLE9BQU8sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDO1NBQzVEO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBRUgsSUFBVyxrQkFBa0I7UUFDM0IsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFO1lBQ2hELE9BQU87Z0JBQ0wsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3JELEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3pELENBQUM7U0FDSDtRQUNELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxnQkFBZ0I7UUFDekIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsb0JBQW9CO1FBQzdCLE9BQU8sNkJBQW9CLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztDQUNGO0FBdEhDO0lBREMsb0JBQVE7eUNBT1I7QUF5RkQ7SUFEQyxvQkFBUTs4Q0FTUjtBQXRJSCxvQkFxSkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBqc2lpIGZyb20gJ0Bqc2lpL3NwZWMnO1xuXG5pbXBvcnQgeyBtZW1vaXplZCB9IGZyb20gJy4vX21lbW9pemVkJztcbmltcG9ydCB7IEFzc2VtYmx5IH0gZnJvbSAnLi9hc3NlbWJseSc7XG5pbXBvcnQgeyBDbGFzc1R5cGUgfSBmcm9tICcuL2NsYXNzJztcbmltcG9ydCB7IERvY3MsIERvY3VtZW50YWJsZSB9IGZyb20gJy4vZG9jcyc7XG5pbXBvcnQgeyBFbnVtVHlwZSB9IGZyb20gJy4vZW51bSc7XG5pbXBvcnQgeyBJbnRlcmZhY2VUeXBlIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHtcbiAgbG9jYXRpb25JblJlcG9zaXRvcnksXG4gIFNvdXJjZUxvY2F0YWJsZSxcbiAgU291cmNlTG9jYXRpb24sXG59IGZyb20gJy4vc291cmNlJztcbmltcG9ydCB7IFR5cGVSZWZlcmVuY2UgfSBmcm9tICcuL3R5cGUtcmVmJztcbmltcG9ydCB7IFR5cGVTeXN0ZW0gfSBmcm9tICcuL3R5cGUtc3lzdGVtJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFR5cGUgaW1wbGVtZW50cyBEb2N1bWVudGFibGUsIFNvdXJjZUxvY2F0YWJsZSB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgc3lzdGVtOiBUeXBlU3lzdGVtLFxuICAgIHB1YmxpYyByZWFkb25seSBhc3NlbWJseTogQXNzZW1ibHksXG4gICAgcHVibGljIHJlYWRvbmx5IHNwZWM6IGpzaWkuVHlwZSxcbiAgKSB7fVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmtpbmR9ICR7dGhpcy5mcW59YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb2YgdGhlIHR5cGUgKGBgPGFzc2VtYmx5Pi48bmFtZXNwYWNlPi48bmFtZT5gYClcbiAgICovXG4gIHB1YmxpYyBnZXQgZnFuKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5mcW47XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWVzcGFjZSBvZiB0aGUgdHlwZSAoYGBmb28uYmFyLmJhemBgKS4gV2hlbiB1bmRlZmluZWQsIHRoZSB0eXBlIGlzIGxvY2F0ZWQgYXQgdGhlIHJvb3Qgb2YgdGhlIGFzc2VtYmx5XG4gICAqIChpdCdzIGBgZnFuYGAgd291bGQgYmUgbGlrZSBgYDxhc3NlbWJseT4uPG5hbWU+YGApLiBJZiB0aGUgYG5hbWVzcGFjZWAgY29ycmVzcG9uZHMgdG8gYW4gZXhpc3RpbmcgdHlwZSdzXG4gICAqIG5hbWVzcGFjZS1xdWFsaWZpZWQgKGUuZzogYGA8bmFtZXNwYWNlPi48bmFtZT5gYCksIHRoZW4gdGhlIGN1cnJlbnQgdHlwZSBpcyBhIG5lc3RlZCB0eXBlLlxuICAgKi9cbiAgcHVibGljIGdldCBuYW1lc3BhY2UoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zcGVjLm5hbWVzcGFjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSB3aXRoaW4gd2hpY2ggdGhpcyB0eXBlIGlzIG5lc3RlZCAoaWYgYW55KS5cbiAgICovXG4gIEBtZW1vaXplZFxuICBwdWJsaWMgZ2V0IG5lc3RpbmdQYXJlbnQoKTogVHlwZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAobnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXNzZW1ibHkudHJ5RmluZFR5cGUoYCR7dGhpcy5hc3NlbWJseS5uYW1lfS4ke25zfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzaW1wbGUgbmFtZSBvZiB0aGUgdHlwZSAoTXlDbGFzcykuXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zcGVjLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGtpbmQgb2YgdGhlIHR5cGUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGtpbmQoKToganNpaS5UeXBlS2luZCB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5raW5kO1xuICB9XG5cbiAgcHVibGljIGdldCBkb2NzKCk6IERvY3Mge1xuICAgIHJldHVybiBuZXcgRG9jcyh0aGlzLnN5c3RlbSwgdGhpcywgdGhpcy5zcGVjLmRvY3MgPz8ge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdHlwZSByZWZlcmVuY2UgdG8gdGhpcyB0eXBlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJlZmVyZW5jZSgpOiBUeXBlUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gbmV3IFR5cGVSZWZlcmVuY2UodGhpcy5zeXN0ZW0sIHtcbiAgICAgIGZxbjogdGhpcy5mcW4sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgaXMgYSBDbGFzcyB0eXBlIG9yIG5vdC5cbiAgICovXG4gIHB1YmxpYyBpc0NsYXNzVHlwZSgpOiB0aGlzIGlzIENsYXNzVHlwZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIGlzIGEgRGF0YSBUeXBlICh0aGF0IGlzLCBhbiBpbnRlcmZhY2Ugd2l0aCBubyBtZXRob2RzKSBvciBub3QuXG4gICAqL1xuICBwdWJsaWMgaXNEYXRhVHlwZSgpOiB0aGlzIGlzIEludGVyZmFjZVR5cGUge1xuICAgIHJldHVybiBmYWxzZTsgLy8gVE9ETyBob3cgaXMgdGhpcyBkaWZmZXJlbnQgZnJvbSBpc0ludGVyZmFjZVR5cGU/XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgaXMgYW4gRW51bSB0eXBlIG9yIG5vdC5cbiAgICovXG4gIHB1YmxpYyBpc0VudW1UeXBlKCk6IHRoaXMgaXMgRW51bVR5cGUge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBpcyBhbiBJbnRlcmZhY2UgdHlwZSBvciBub3QuXG4gICAqL1xuICBwdWJsaWMgaXNJbnRlcmZhY2VUeXBlKCk6IHRoaXMgaXMgSW50ZXJmYWNlVHlwZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHR5cGUgZXh0ZW5kcyBhIGdpdmVuIGJhc2Ugb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0gYmFzZSB0aGUgY2FuZGlkYXRlIGJhc2UgdHlwZS5cbiAgICovXG4gIHB1YmxpYyBleHRlbmRzKGJhc2U6IFR5cGUpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcyA9PT0gYmFzZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICh0aGlzLmlzSW50ZXJmYWNlVHlwZSgpIHx8IHRoaXMuaXNDbGFzc1R5cGUoKSkgJiZcbiAgICAgIGJhc2UuaXNJbnRlcmZhY2VUeXBlKClcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZXModHJ1ZSkuc29tZSgoaWZhY2UpID0+IGlmYWNlID09PSBiYXNlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDbGFzc1R5cGUoKSAmJiBiYXNlLmlzQ2xhc3NUeXBlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFuY2VzdG9ycygpLnNvbWUoKGNsYXp6KSA9PiBjbGF6eiA9PT0gYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgdHlwZSB0aGF0OlxuICAgKiAtIGV4dGVuZCB0aGlzLCBpZiB0aGlzIGlzIGEgQ2xhc3NUeXBlXG4gICAqIC0gaW1wbGVtZW50IHRoaXMsIGlmIHRoaXMgaXMgYW4gSW50ZXJmYWNlVHlwZSAodGhpcyBpbmNsdWRlcyBpbnRlcmZhY2VzIGV4dGVuZGluZyB0aGlzKVxuICAgKlxuICAgKiBBcyBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIGFyZSBjb25zaWRlcmVkIHRvIGV4dGVuZCB0aGVtc2VsdmVzLCBcInRoaXNcIiB3aWxsIGJlIHBhcnQgb2YgYWxsIHJldHVybiB2YWx1ZXMgd2hlbiBjYWxsZWRcbiAgICogb24gY2xhc3NlcyBhbmQgaW50ZXJmYWNlcy5cbiAgICpcbiAgICogVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBlbXB0eSBmb3IgdHlwZXMgdGhhdCBhcmUgbmVpdGhlciBDbGFzc1R5cGUgbm9yIEludGVyZmFjZVR5cGUuXG4gICAqL1xuICBAbWVtb2l6ZWRcbiAgcHVibGljIGdldCBhbGxJbXBsZW1lbnRhdGlvbnMoKTogVHlwZVtdIHtcbiAgICBpZiAodGhpcy5pc0NsYXNzVHlwZSgpIHx8IHRoaXMuaXNJbnRlcmZhY2VUeXBlKCkpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLnRoaXMuc3lzdGVtLmNsYXNzZXMuZmlsdGVyKChjKSA9PiBjLmV4dGVuZHModGhpcykpLFxuICAgICAgICAuLi50aGlzLnN5c3RlbS5pbnRlcmZhY2VzLmZpbHRlcigoaSkgPT4gaS5leHRlbmRzKHRoaXMpKSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxvY2F0aW9uIGluIHRoZSBtb2R1bGVcbiAgICovXG4gIHB1YmxpYyBnZXQgbG9jYXRpb25Jbk1vZHVsZSgpOiBTb3VyY2VMb2NhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5sb2NhdGlvbkluTW9kdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbG9jYXRpb24gaW4gdGhlIHJlcG9zaXRvcnlcbiAgICovXG4gIHB1YmxpYyBnZXQgbG9jYXRpb25JblJlcG9zaXRvcnkoKTogU291cmNlTG9jYXRpb24gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBsb2NhdGlvbkluUmVwb3NpdG9yeSh0aGlzKTtcbiAgfVxufVxuIl19