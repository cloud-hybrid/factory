"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotNetGenerator = void 0;
const spec = require("@jsii/spec");
const clone = require("clone");
const fs = require("fs-extra");
const path = require("path");
const generator_1 = require("../../generator");
const dotnetdocgenerator_1 = require("./dotnetdocgenerator");
const dotnetruntimegenerator_1 = require("./dotnetruntimegenerator");
const dotnettyperesolver_1 = require("./dotnettyperesolver");
const filegenerator_1 = require("./filegenerator");
const nameutils_1 = require("./nameutils");
/**
 * CODE GENERATOR V2
 */
class DotNetGenerator extends generator_1.Generator {
    constructor(assembliesCurrentlyBeingCompiled, rosetta) {
        super();
        this.assembliesCurrentlyBeingCompiled = assembliesCurrentlyBeingCompiled;
        this.rosetta = rosetta;
        // Flags that tracks if we have already wrote the first member of the class
        this.firstMemberWritten = false;
        this.nameutils = new nameutils_1.DotNetNameUtils();
        // Override the openBlock to get a correct C# looking code block with the curly brace after the line
        this.code.openBlock = function (text) {
            this.line(text);
            this.open('{');
        };
    }
    async load(packageRoot, assembly) {
        await super.load(packageRoot, assembly);
    }
    /**
     * Runs the generator (in-memory).
     */
    generate(fingerprint) {
        this.typeresolver = new dotnettyperesolver_1.DotNetTypeResolver(this.assembly, (fqn) => this.findModule(fqn), (fqn) => this.findType(fqn), this.assembliesCurrentlyBeingCompiled);
        this.dotnetRuntimeGenerator = new dotnetruntimegenerator_1.DotNetRuntimeGenerator(this.code, this.typeresolver);
        this.dotnetDocGenerator = new dotnetdocgenerator_1.DotNetDocGenerator(this.code, this.rosetta, this.assembly);
        this.emitAssemblyDocs();
        // We need to resolve the dependency tree
        this.typeresolver.resolveNamespacesDependencies();
        super.generate(fingerprint);
    }
    async save(outdir, tarball, { license, notice }) {
        // Generating the csproj and AssemblyInfo.cs files
        const tarballFileName = path.basename(tarball);
        const filegen = new filegenerator_1.FileGenerator(this.assembly, tarballFileName, this.code);
        filegen.generateAssemblyInfoFile();
        filegen.generateProjectFile(this.typeresolver.namespaceDependencies);
        // Calling super.save() dumps the tarball in the format name@version.jsii.tgz.
        // This is not in sync with the Old .NET generator where the name is scope-name-version.tgz.
        // Hence we are saving the files ourselves here:
        const assm = this.assembly;
        const packageId = assm.targets.dotnet.packageId;
        if (!packageId) {
            throw new Error(`The module ${assm.name} does not have a dotnet.packageId setting`);
        }
        await fs.mkdirp(path.join(outdir, packageId));
        await fs.copyFile(tarball, path.join(outdir, packageId, tarballFileName));
        // Create an anchor file for the current model
        this.generateDependencyAnchorFile();
        if (license) {
            await fs.writeFile(path.join(outdir, packageId, 'LICENSE'), license, {
                encoding: 'utf8',
            });
        }
        if (notice) {
            await fs.writeFile(path.join(outdir, packageId, 'NOTICE'), notice, {
                encoding: 'utf8',
            });
        }
        // Saving the generated code.
        return this.code.save(outdir);
    }
    /**
     * Generates the anchor file
     */
    generateDependencyAnchorFile() {
        const namespace = `${this.assembly.targets.dotnet.namespace}.Internal.DependencyResolution`;
        this.openFileIfNeeded('Anchor', namespace, false, false);
        this.code.openBlock('public sealed class Anchor');
        this.code.openBlock('public Anchor()');
        this.typeresolver.namespaceDependencies.forEach((value) => this.code.line(`new ${value.namespace}.Internal.DependencyResolution.Anchor();`));
        this.code.closeBlock();
        this.code.closeBlock();
        this.closeFileIfNeeded('Anchor', namespace, false);
    }
    /**
     * Not used as we override the save() method
     */
    getAssemblyOutputDir(mod) {
        return this.nameutils.convertPackageName(mod.name);
    }
    /**
     * Namespaces are handled implicitly by openFileIfNeeded().
     *
     * Do generate docs if this is for a submodule though.
     */
    onBeginNamespace(jsiiNs) {
        var _a;
        const submodule = (_a = this.assembly.submodules) === null || _a === void 0 ? void 0 : _a[jsiiNs];
        if (submodule) {
            const dotnetNs = this.typeresolver.resolveNamespace(this.assembly, this.assembly.name, 
            // Strip the `${assmName}.` prefix here, as the "assembly-relative" NS
            // is expected by `this.typeResolver.resovleNamespace`.
            jsiiNs.substr(this.assembly.name.length + 1));
            this.emitNamespaceDocs(dotnetNs, jsiiNs, submodule);
        }
    }
    onEndNamespace(_ns) {
        /* noop */
    }
    onBeginInterface(ifc) {
        const implementations = this.typeresolver.resolveImplementedInterfaces(ifc);
        const interfaceName = this.nameutils.convertInterfaceName(ifc);
        const namespace = this.namespaceFor(this.assembly, ifc);
        this.openFileIfNeeded(interfaceName, namespace, this.isNested(ifc));
        this.dotnetDocGenerator.emitDocs(ifc, { api: 'type', fqn: ifc.fqn });
        this.dotnetRuntimeGenerator.emitAttributesForInterface(ifc);
        if (implementations.length > 0) {
            this.code.openBlock(`public interface ${interfaceName} : ${implementations.join(', ')}`);
        }
        else {
            this.code.openBlock(`public interface ${interfaceName}`);
        }
        this.flagFirstMemberWritten(false);
    }
    onEndInterface(ifc) {
        // emit interface proxy class
        this.emitInterfaceProxy(ifc);
        const interfaceName = this.nameutils.convertInterfaceName(ifc);
        this.code.closeBlock();
        const namespace = this.namespaceFor(this.assembly, ifc);
        this.closeFileIfNeeded(interfaceName, namespace, this.isNested(ifc));
        // emit implementation class
        // TODO: If datatype then we may not need the interface proxy to be created, We could do with just the interface impl?
        if (ifc.datatype) {
            this.emitInterfaceDataType(ifc);
        }
    }
    onInterfaceMethod(ifc, method) {
        var _a;
        this.dotnetDocGenerator.emitDocs(method, {
            api: 'member',
            fqn: ifc.fqn,
            memberName: method.name,
        });
        this.dotnetRuntimeGenerator.emitAttributesForMethod(ifc, method);
        const returnType = method.returns
            ? this.typeresolver.toDotNetType(method.returns.type)
            : 'void';
        const nullable = ((_a = method.returns) === null || _a === void 0 ? void 0 : _a.optional) ? '?' : '';
        this.code.line(`${returnType}${nullable} ${this.nameutils.convertMethodName(method.name)}(${this.renderMethodParameters(method)});`);
    }
    onInterfaceMethodOverload(ifc, overload, _originalMethod) {
        this.onInterfaceMethod(ifc, overload);
    }
    onInterfaceProperty(ifc, prop) {
        if (!prop.abstract) {
            throw new Error(`Interface properties must be abstract: ${prop.name}`);
        }
        if (prop.protected) {
            throw new Error(`Protected properties are not allowed on interfaces: ${prop.name}`);
        }
        if (prop.static) {
            throw new Error(`Property ${ifc.name}.${prop.name} is marked as static, but interfaces must not contain static members.`);
        }
        this.emitNewLineIfNecessary();
        this.dotnetDocGenerator.emitDocs(prop, {
            api: 'member',
            fqn: ifc.fqn,
            memberName: prop.name,
        });
        this.dotnetRuntimeGenerator.emitAttributesForProperty(prop);
        const propType = this.typeresolver.toDotNetType(prop.type);
        const propName = this.nameutils.convertPropertyName(prop.name);
        if (prop.optional) {
            this.code.line('[Amazon.JSII.Runtime.Deputy.JsiiOptional]');
        }
        // Specifying that a type is nullable is only required for primitive value types
        const isOptional = prop.optional ? '?' : '';
        this.code.openBlock(`${propType}${isOptional} ${propName}`);
        if (prop.optional) {
            this.code.openBlock('get');
            this.code.line('return null;');
            this.code.closeBlock();
            if (!prop.immutable) {
                this.code.openBlock('set');
                this.code.line(`throw new System.NotSupportedException("'set' for '${propName}' is not implemented");`);
                this.code.closeBlock();
            }
        }
        else {
            this.code.line('get;');
            if (!prop.immutable) {
                this.code.line('set;');
            }
        }
        this.code.closeBlock();
        this.flagFirstMemberWritten(true);
    }
    onBeginClass(cls, abstract) {
        let baseTypeNames = [];
        const namespace = this.namespaceFor(this.assembly, cls);
        // A class can derive from only one base class
        // But can implement multiple interfaces
        if (!cls.base) {
            baseTypeNames.push('DeputyBase');
        }
        else {
            const classBase = this.typeresolver.toDotNetType({ fqn: cls.base });
            baseTypeNames.push(classBase);
        }
        if (cls.interfaces && cls.interfaces.length > 0) {
            const implementations = this.typeresolver.resolveImplementedInterfaces(cls);
            baseTypeNames = baseTypeNames.concat(implementations);
        }
        const className = this.nameutils.convertClassName(cls);
        // Nested classes will be dealt with during calc code generation
        const nested = this.isNested(cls);
        const absPrefix = abstract ? ' abstract' : '';
        this.openFileIfNeeded(className, namespace, nested);
        const implementsExpr = ` : ${baseTypeNames.join(', ')}`;
        this.dotnetDocGenerator.emitDocs(cls, {
            api: 'type',
            fqn: cls.fqn,
        });
        this.dotnetRuntimeGenerator.emitAttributesForClass(cls);
        this.code.openBlock(`public${absPrefix} class ${className}${implementsExpr}`);
        // Compute the class parameters
        let parametersDefinition = '';
        let parametersBase = '';
        const initializer = cls.initializer;
        if (initializer) {
            this.dotnetDocGenerator.emitDocs(initializer, {
                api: 'initializer',
                fqn: cls.fqn,
            });
            this.dotnetRuntimeGenerator.emitDeprecatedAttributeIfNecessary(initializer);
            if (initializer.parameters) {
                parametersDefinition = this.renderParametersString(initializer.parameters);
                for (const p of initializer.parameters) {
                    parametersBase += `${this.nameutils.convertParameterName(p.name)}`;
                    // If this is not the last parameter, append ,
                    if (initializer.parameters.indexOf(p) !==
                        initializer.parameters.length - 1) {
                        parametersBase += ', ';
                    }
                }
            }
            // Create the constructors:
            // Abstract classes have protected constructors.
            const visibility = cls.abstract ? 'protected' : 'public';
            const args = parametersBase.length > 0
                ? `new object?[]{${parametersBase}}`
                : `System.Array.Empty<object?>()`;
            this.code.openBlock(`${visibility} ${className}(${parametersDefinition}): base(new DeputyProps(${args}))`);
            this.code.closeBlock();
            this.code.line();
        }
        this.code.line('/// <summary>Used by jsii to construct an instance of this class from a Javascript-owned object reference</summary>');
        this.code.line('/// <param name="reference">The Javascript-owned object reference</param>');
        this.dotnetRuntimeGenerator.emitDeprecatedAttributeIfNecessary(initializer);
        this.emitHideAttribute();
        this.code.openBlock(`protected ${className}(ByRefValue reference): base(reference)`);
        this.code.closeBlock();
        this.code.line();
        this.code.line('/// <summary>Used by jsii to construct an instance of this class from DeputyProps</summary>');
        this.code.line('/// <param name="props">The deputy props</param>');
        this.dotnetRuntimeGenerator.emitDeprecatedAttributeIfNecessary(initializer);
        this.emitHideAttribute();
        this.code.openBlock(`protected ${className}(DeputyProps props): base(props)`);
        this.code.closeBlock();
        // We have already outputted members (constructors), setting the flag to true
        this.flagFirstMemberWritten(true);
    }
    onEndClass(cls) {
        if (cls.abstract) {
            this.emitInterfaceProxy(cls);
        }
        this.code.closeBlock();
        const className = this.nameutils.convertClassName(cls);
        const namespace = this.namespaceFor(this.assembly, cls);
        this.closeFileIfNeeded(className, namespace, this.isNested(cls));
    }
    onField(_cls, _prop, _union) {
        /* noop */
    }
    onMethod(cls, method) {
        this.emitMethod(cls, method, cls);
    }
    onMethodOverload(cls, overload, _originalMethod) {
        this.onMethod(cls, overload);
    }
    onProperty(cls, prop) {
        this.emitProperty(cls, prop, cls);
    }
    onStaticMethod(cls, method) {
        this.emitMethod(cls, method, cls);
    }
    onStaticMethodOverload(cls, overload, _originalMethod) {
        this.emitMethod(cls, overload, cls);
    }
    onStaticProperty(cls, prop) {
        if (prop.const) {
            this.emitConstProperty(cls, prop);
        }
        else {
            this.emitProperty(cls, prop, cls);
        }
    }
    onUnionProperty(cls, prop, _union) {
        this.emitProperty(cls, prop, cls);
    }
    onBeginEnum(enm) {
        const enumName = this.nameutils.convertTypeName(enm.name);
        const namespace = this.namespaceFor(this.assembly, enm);
        this.openFileIfNeeded(enumName, namespace, this.isNested(enm));
        this.emitNewLineIfNecessary();
        this.dotnetDocGenerator.emitDocs(enm, {
            api: 'type',
            fqn: enm.fqn,
        });
        this.dotnetRuntimeGenerator.emitAttributesForEnum(enm, enumName);
        this.code.openBlock(`public enum ${enm.name}`);
    }
    onEndEnum(enm) {
        this.code.closeBlock();
        const enumName = this.nameutils.convertTypeName(enm.name);
        const namespace = this.namespaceFor(this.assembly, enm);
        this.closeFileIfNeeded(enumName, namespace, this.isNested(enm));
    }
    onEnumMember(enm, member) {
        this.dotnetDocGenerator.emitDocs(member, {
            api: 'member',
            fqn: enm.fqn,
            memberName: member.name,
        });
        const enumMemberName = this.nameutils.convertEnumMemberName(member.name);
        this.dotnetRuntimeGenerator.emitAttributesForEnumMember(enumMemberName, member);
        // If we are on the last enum member, we don't need a comma
        if (enm.members.indexOf(member) !== enm.members.length - 1) {
            this.code.line(`${enumMemberName},`);
        }
        else {
            this.code.line(`${enumMemberName}`);
        }
    }
    namespaceFor(assm, type) {
        var _a;
        let ns = type.namespace;
        while (ns != null && ((_a = assm.types) === null || _a === void 0 ? void 0 : _a[`${assm.name}.${ns}`]) != null) {
            const nesting = assm.types[`${assm.name}.${ns}`];
            ns = nesting.namespace;
        }
        if (ns != null) {
            return this.typeresolver.resolveNamespace(assm, assm.name, ns);
        }
        return assm.targets.dotnet.namespace;
    }
    emitMethod(cls, method, definingType, emitForProxyOrDatatype = false) {
        this.emitNewLineIfNecessary();
        const returnType = method.returns
            ? this.typeresolver.toDotNetType(method.returns.type)
            : 'void';
        const staticKeyWord = method.static ? 'static ' : '';
        let overrideKeyWord = '';
        let virtualKeyWord = '';
        let definedOnAncestor = false;
        // In the case of the source being a class, we check if it is already defined on an ancestor
        if (spec.isClassType(cls)) {
            definedOnAncestor = this.isMemberDefinedOnAncestor(cls, method);
        }
        // The method is an override if it's defined on the ancestor, or if the parent is a class and we are generating a proxy or datatype class
        let overrides = definedOnAncestor || (spec.isClassType(cls) && emitForProxyOrDatatype);
        // We also inspect the jsii model to see if it overrides a class member.
        if (method.overrides) {
            const overrideType = this.findType(method.overrides);
            if (spec.isClassType(overrideType)) {
                // Overrides a class, needs overrides keyword
                overrides = true;
            }
        }
        if (overrides) {
            // Add the override key word if the method is emitted for a proxy or data type or is defined on an ancestor. If
            // the member is static, use the "new" keyword instead, to indicate we are intentionally hiding the ancestor
            // declaration (as C# does not inherit statics, they can be hidden but not overridden). The "new" keyword is
            // optional in this context, but helps clarify intention.
            overrideKeyWord = method.static ? 'new ' : 'override ';
        }
        else if (!method.static &&
            (method.abstract || !definedOnAncestor) &&
            !emitForProxyOrDatatype) {
            // Add the virtual key word if the method is abstract or not defined on an ancestor and we are NOT generating a proxy or datatype class
            // Methods should always be virtual when possible
            virtualKeyWord = 'virtual ';
        }
        const access = this.renderAccessLevel(method);
        const methodName = this.nameutils.convertMethodName(method.name);
        const isOptional = method.returns && method.returns.optional ? '?' : '';
        const signature = `${returnType}${isOptional} ${methodName}(${this.renderMethodParameters(method)})`;
        this.dotnetDocGenerator.emitDocs(method, {
            api: 'member',
            fqn: definingType.fqn,
            memberName: method.name,
        });
        this.dotnetRuntimeGenerator.emitAttributesForMethod(cls, method /*, emitForProxyOrDatatype*/);
        if (method.abstract) {
            this.code.line(`${access} ${overrideKeyWord}abstract ${signature};`);
            this.code.line();
        }
        else {
            this.code.openBlock(`${access} ${staticKeyWord}${overrideKeyWord}${virtualKeyWord}${signature}`);
            this.code.line(this.dotnetRuntimeGenerator.createInvokeMethodIdentifier(method, cls));
            this.code.closeBlock();
        }
    }
    /**
     * Founds out if a member (property or method) is already defined in one of the base classes
     *
     * Used to figure out if the override or virtual keywords are necessary.
     */
    isMemberDefinedOnAncestor(cls, member) {
        if (member) {
            const objectMethods = ['ToString', 'GetHashCode', 'Equals'];
            // Methods defined on the Object class should be overridden, return true;
            if (objectMethods.includes(this.nameutils.convertMethodName(member.name))) {
                return true;
            }
        }
        const base = cls.base;
        if (base) {
            const baseType = this.findType(base);
            if (member) {
                if (baseType.properties) {
                    if (baseType.properties.filter((property) => property.name === member.name).length > 0) {
                        // property found in base parent
                        return true;
                    }
                }
                return this.isMemberDefinedOnAncestor(baseType, member);
            }
            else if (member) {
                if (baseType.methods) {
                    const myMethod = member;
                    // If the name, parameters and returns are similar then it is the same method in .NET
                    for (const m of baseType.methods) {
                        if (m.name === myMethod.name &&
                            m.parameters === myMethod.parameters &&
                            m.returns === myMethod.returns) {
                            return true;
                        }
                    }
                }
                return this.isMemberDefinedOnAncestor(baseType, member);
            }
            return false;
        }
        return false;
    }
    /**
     * Renders method parameters string
     */
    renderMethodParameters(method) {
        return this.renderParametersString(method.parameters);
    }
    /**
     * Renders parameters string for methods or constructors
     */
    renderParametersString(parameters) {
        const params = [];
        if (parameters) {
            for (const p of parameters) {
                let optionalPrimitive = '';
                let optionalKeyword = '';
                let type = this.typeresolver.toDotNetType(p.type);
                if (p.optional) {
                    optionalKeyword = ' = null';
                    if (p.optional) {
                        optionalPrimitive = '?';
                    }
                }
                else if (p.variadic) {
                    type = `params ${type}[]`;
                }
                const st = `${type}${optionalPrimitive} ${this.nameutils.convertParameterName(p.name)}${optionalKeyword}`;
                params.push(st);
            }
        }
        return params.join(', ');
    }
    /**
     * Emits an interface proxy for an interface or an abstract class.
     */
    emitInterfaceProxy(ifc) {
        const name = '_Proxy';
        const namespace = this.namespaceFor(this.assembly, ifc);
        const isNested = true;
        this.openFileIfNeeded(name, namespace, isNested);
        this.code.line();
        this.dotnetDocGenerator.emitDocs(ifc, {
            api: 'type',
            fqn: ifc.fqn,
        });
        this.dotnetRuntimeGenerator.emitAttributesForInterfaceProxy(ifc);
        const interfaceFqn = this.typeresolver.toNativeFqn(ifc.fqn);
        const suffix = spec.isInterfaceType(ifc)
            ? `: DeputyBase, ${interfaceFqn}`
            : `: ${interfaceFqn}`;
        const newModifier = this.proxyMustUseNewModifier(ifc) ? 'new ' : '';
        this.code.openBlock(`${newModifier}internal sealed class ${name} ${suffix}`);
        // Create the private constructor
        this.code.openBlock(`private ${name}(ByRefValue reference): base(reference)`);
        this.code.closeBlock();
        // We have already output a member (constructor), setting the first member flag to true
        this.flagFirstMemberWritten(true);
        const datatype = false;
        const proxy = true;
        this.emitInterfaceMembersForProxyOrDatatype(ifc, datatype, proxy);
        this.code.closeBlock();
        this.closeFileIfNeeded(name, namespace, isNested);
    }
    /**
     * Determines whether any ancestor of the given type must use the `new`
     * modifier when introducing it's own proxy.
     *
     * If the type is a `class`, then it must use `new` if it extends another
     * abstract class defined in the same assembly (since proxies are internal,
     * external types' proxies are not visible in that context).
     *
     * If the type is an `interface`, then it must use `new` if it extends another
     * interface from the same assembly.
     *
     * @param type the tested proxy-able type (an abstract class or an interface).
     *
     * @returns true if any ancestor of this type has a visible proxy.
     */
    proxyMustUseNewModifier(type) {
        var _a;
        if (spec.isClassType(type)) {
            if (type.base == null) {
                return false;
            }
            const base = this.findType(type.base);
            return (base.assembly === type.assembly &&
                (base.abstract
                    ? true
                    : // An abstract class could extend a concrete class... We must walk up the inheritance tree in this case...
                        this.proxyMustUseNewModifier(base)));
        }
        return (((_a = type.interfaces) === null || _a === void 0 ? void 0 : _a.find((fqn) => this.findType(fqn).assembly === type.assembly)) != null);
    }
    /**
     * Emits an Interface Datatype class
     *
     * This is used to emit a class implementing an interface when the datatype property is true in the jsii model
     * The generation of the interface proxy may not be needed if the interface is also set as a datatype
     */
    emitInterfaceDataType(ifc) {
        var _a;
        // Interface datatypes do not need to be prefixed by I, we can call convertClassName
        const name = this.nameutils.convertClassName(ifc);
        const namespace = this.namespaceFor(this.assembly, ifc);
        const isNested = this.isNested(ifc);
        this.openFileIfNeeded(name, namespace, isNested);
        if (((_a = ifc.properties) === null || _a === void 0 ? void 0 : _a.find((prop) => !prop.optional)) != null) {
            // We don't want to be annoyed by the lack of initialization of non-nullable fields in this case.
            this.code.line('#pragma warning disable CS8618');
            this.code.line();
        }
        this.dotnetDocGenerator.emitDocs(ifc, {
            api: 'type',
            fqn: ifc.fqn,
        });
        const suffix = `: ${this.typeresolver.toNativeFqn(ifc.fqn)}`;
        this.dotnetRuntimeGenerator.emitAttributesForInterfaceDatatype(ifc);
        this.code.openBlock(`public class ${name} ${suffix}`);
        this.flagFirstMemberWritten(false);
        const datatype = true;
        const proxy = false;
        this.emitInterfaceMembersForProxyOrDatatype(ifc, datatype, proxy);
        this.code.closeBlock();
        this.closeFileIfNeeded(name, namespace, isNested);
    }
    /**
     * Generates the body of the interface proxy or data type class
     *
     * This loops through all the member and generates them
     */
    emitInterfaceMembersForProxyOrDatatype(ifc, datatype, proxy) {
        // The key is in the form 'method.name;parameter1;parameter2;' etc
        const methods = new Map();
        /*
              Only get the first declaration encountered, and keep it if it is abstract. The list contains ALL
              methods and properties encountered, in the order encountered. An abstract class can have concrete
              implementations. Therefore, we only generate methods/properties if the first member encountered
              is unimplemented.
            */
        const excludedMethod = []; // Keeps track of the methods we already ran into and don't want to emit
        const excludedProperties = []; // Keeps track of the properties we already ran into and don't want to emit
        const properties = {};
        const collectAbstractMembers = (currentType) => {
            var _a, _b, _c;
            for (const prop of (_a = currentType.properties) !== null && _a !== void 0 ? _a : []) {
                if (!excludedProperties.includes(prop.name)) {
                    // If we have never run into this property before and it is abstract, we keep it
                    if (prop.abstract) {
                        properties[prop.name] = { prop, definingType: currentType };
                    }
                    excludedProperties.push(prop.name);
                }
            }
            for (const method of (_b = currentType.methods) !== null && _b !== void 0 ? _b : []) {
                let methodParameters = '';
                if (method.parameters) {
                    method.parameters.forEach((param) => {
                        methodParameters += `;${this.typeresolver.toDotNetType(param.type)}`;
                    });
                }
                if (!excludedMethod.includes(`${method.name}${methodParameters}`)) {
                    // If we have never run into this method before and it is abstract, we keep it
                    if (method.abstract) {
                        methods.set(`${method.name}${methodParameters}`, {
                            method,
                            definingType: currentType,
                        });
                    }
                    excludedMethod.push(`${method.name}${methodParameters}`);
                }
            }
            const bases = new Array();
            bases.push(...((_c = currentType.interfaces) !== null && _c !== void 0 ? _c : []).map((iface) => this.findType(iface)));
            if (spec.isClassType(currentType) && currentType.base) {
                bases.push(this.findType(currentType.base));
            }
            for (const base of bases) {
                const type = this.findType(base.fqn);
                if (type.kind !== spec.TypeKind.Interface &&
                    type.kind !== spec.TypeKind.Class) {
                    throw new Error(`Base interfaces of an interface must be an interface or a class (${base.fqn} is of type ${type.kind})`);
                }
                collectAbstractMembers(type);
            }
        };
        collectAbstractMembers(ifc);
        // emit all properties
        for (const propName of Object.keys(properties)) {
            const prop = clone(properties[propName]);
            prop.prop.abstract = false;
            this.emitProperty(ifc, prop.prop, prop.definingType, datatype, proxy);
        }
        // emit all the methods
        for (const methodNameAndParameters of methods.keys()) {
            const originalMethod = methods.get(methodNameAndParameters);
            if (originalMethod) {
                const method = clone(originalMethod);
                method.method.abstract = false;
                this.emitMethod(ifc, method.method, method.definingType, 
                /* emitForProxyOrDatatype */ true);
                for (const overloadedMethod of this.createOverloadsForOptionals(method.method)) {
                    overloadedMethod.abstract = false;
                    this.emitMethod(ifc, overloadedMethod, method.definingType, 
                    /* emitForProxyOrDatatype */ true);
                }
            }
        }
    }
    /**
     * Emits a property
     */
    emitProperty(cls, prop, definingType, datatype = false, proxy = false) {
        this.emitNewLineIfNecessary();
        const className = this.typeresolver.toNativeFqn(cls.fqn);
        const access = this.renderAccessLevel(prop);
        const staticKeyWord = prop.static ? 'static ' : '';
        const propName = this.nameutils.convertPropertyName(prop.name);
        this.dotnetDocGenerator.emitDocs(prop, {
            api: 'member',
            fqn: definingType.fqn,
            memberName: prop.name,
        });
        if (prop.optional) {
            this.code.line('[JsiiOptional]');
        }
        this.dotnetRuntimeGenerator.emitAttributesForProperty(prop, datatype);
        let isOverrideKeyWord = '';
        let isVirtualKeyWord = '';
        let isAbstractKeyword = '';
        // If the prop parent is a class
        if (spec.isClassType(cls)) {
            const implementedInBase = this.isMemberDefinedOnAncestor(cls, prop);
            if (implementedInBase || datatype || proxy) {
                // Override if the property is in a datatype or proxy class or declared in a parent class. If the member is
                // static, use the "new" keyword instead, to indicate we are intentionally hiding the ancestor declaration (as
                // C# does not inherit statics, they can be hidden but not overridden).The "new" keyword is optional in this
                // context, but helps clarify intention.
                isOverrideKeyWord = prop.static ? 'new ' : 'override ';
            }
            else if (prop.abstract) {
                // Abstract members get decorated as such
                isAbstractKeyword = 'abstract ';
            }
            else if (!prop.static && !implementedInBase) {
                // Virtual if the prop is not static, and is not implemented in base member, this way we can later override it.
                isVirtualKeyWord = 'virtual ';
            }
        }
        const propTypeFQN = this.typeresolver.toDotNetType(prop.type);
        const isOptional = prop.optional ? '?' : '';
        const statement = `${access} ${isAbstractKeyword}${isVirtualKeyWord}${staticKeyWord}${isOverrideKeyWord}${propTypeFQN}${isOptional} ${propName}`;
        this.code.openBlock(statement);
        // Emit getters
        if (datatype || prop.const || prop.abstract) {
            this.code.line('get;');
        }
        else {
            // If the property is non-optional, add a bang to silence compiler warning
            const bang = prop.optional ? '' : '!';
            if (prop.static) {
                this.code.line(`get => GetStaticProperty<${propTypeFQN}${isOptional}>(typeof(${className}))${bang};`);
            }
            else {
                this.code.line(`get => GetInstanceProperty<${propTypeFQN}${isOptional}>()${bang};`);
            }
        }
        // Emit setters
        if (datatype || (!prop.immutable && prop.abstract)) {
            this.code.line('set;');
        }
        else {
            if (!prop.immutable) {
                if (prop.static) {
                    this.code.line(`set => SetStaticProperty(typeof(${className}), value);`);
                }
                else {
                    this.code.line('set => SetInstanceProperty(value);');
                }
            }
        }
        this.code.closeBlock();
        this.flagFirstMemberWritten(true);
    }
    /**
     * Emits a constant property
     */
    emitConstProperty(cls, prop) {
        this.emitNewLineIfNecessary();
        this.flagFirstMemberWritten(true);
        const propType = this.typeresolver.toDotNetType(prop.type);
        const isOptional = prop.optional ? '?' : '';
        this.dotnetDocGenerator.emitDocs(prop, {
            api: 'member',
            fqn: cls.fqn,
            memberName: prop.name,
        });
        this.dotnetRuntimeGenerator.emitAttributesForProperty(prop);
        const access = this.renderAccessLevel(prop);
        const propName = this.nameutils.convertPropertyName(prop.name);
        const staticKeyword = prop.static ? 'static ' : '';
        this.code.openBlock(`${access} ${staticKeyword}${propType}${isOptional} ${propName}`);
        this.code.line('get;');
        this.code.closeBlock();
        const className = this.typeresolver.toNativeFqn(cls.fqn);
        // If the property is non-optional, add a bang to silence the compiler warning
        const bang = prop.optional ? '' : '!';
        const initializer = prop.static
            ? `= GetStaticProperty<${propType}>(typeof(${className}))${bang};`
            : `= GetInstanceProperty<${propType}>(typeof(${className}))${bang};`;
        this.code.line(initializer);
    }
    renderAccessLevel(method) {
        return method.protected ? 'protected' : 'public';
    }
    isNested(type) {
        if (!this.assembly.types || !type.namespace) {
            return false;
        }
        const parent = `${type.assembly}.${type.namespace}`;
        return parent in this.assembly.types;
    }
    toCSharpFilePath(type) {
        return `${type}.cs`;
    }
    openFileIfNeeded(typeName, namespace, isNested, usingDeputy = true) {
        var _a, _b;
        // If Nested type, we shouldn't open/close a file
        if (isNested) {
            return;
        }
        const dotnetPackageId = (_b = (_a = this.assembly.targets) === null || _a === void 0 ? void 0 : _a.dotnet) === null || _b === void 0 ? void 0 : _b.packageId;
        if (!dotnetPackageId) {
            throw new Error(`The module ${this.assembly.name} does not have a dotnet.packageId setting`);
        }
        const filePath = namespace.replace(/[.]/g, '/');
        this.code.openFile(path.join(dotnetPackageId, filePath, this.toCSharpFilePath(typeName)));
        if (usingDeputy) {
            this.code.line('using Amazon.JSII.Runtime.Deputy;');
            this.code.line();
        }
        // Suppress warnings about missing XMLDoc, Obsolete inconsistencies
        this.code.line('#pragma warning disable CS0672,CS0809,CS1591');
        this.code.line();
        this.code.openBlock(`namespace ${namespace}`);
    }
    closeFileIfNeeded(typeName, namespace, isNested) {
        var _a, _b;
        if (isNested) {
            return;
        }
        this.code.closeBlock();
        const dotnetPackageId = (_b = (_a = this.assembly.targets) === null || _a === void 0 ? void 0 : _a.dotnet) === null || _b === void 0 ? void 0 : _b.packageId;
        if (!dotnetPackageId) {
            throw new Error(`The module ${this.assembly.name} does not have a dotnet.packageId setting`);
        }
        const filePath = namespace.replace(/[.]/g, '/');
        this.code.closeFile(path.join(dotnetPackageId, filePath, this.toCSharpFilePath(typeName)));
    }
    /**
     * Resets the firstMember boolean flag to keep track of the first member of a new file
     *
     * This avoids unnecessary white lines
     */
    flagFirstMemberWritten(first) {
        this.firstMemberWritten = first;
    }
    /**
     * Emits a new line prior to writing a new property, method, if the property is not the first one in the class
     *
     * This avoids unnecessary white lines.
     */
    emitNewLineIfNecessary() {
        // If the first member has already been written, it is safe to write a new line
        if (this.firstMemberWritten) {
            this.code.line();
        }
        else {
            this.firstMemberWritten = false;
        }
    }
    emitAssemblyDocs() {
        this.emitNamespaceDocs(this.assembly.targets.dotnet.namespace, this.assembly.name, this.assembly);
    }
    /**
     * Emit an unused, empty class called `NamespaceDoc` to attach the module README to
     *
     * There is no way to attach doc comments to a namespace in C#, and this trick has been
     * semi-standardized by NDoc and Sandcastle Help File Builder.
     *
     * DocFX doesn't support it out of the box, but we should be able to get there with a
     * bit of hackery.
     *
     * In any case, we need a place to attach the docs where they can be transported around,
     * might as well be this method.
     */
    emitNamespaceDocs(namespace, jsiiFqn, docSource) {
        if (!docSource.readme) {
            return;
        }
        const className = 'NamespaceDoc';
        this.openFileIfNeeded(className, namespace, false, false);
        this.dotnetDocGenerator.emitMarkdownAsRemarks(docSource.readme.markdown, {
            api: 'moduleReadme',
            moduleFqn: jsiiFqn,
        });
        this.emitHideAttribute();
        // Traditionally this class is made 'internal', but that interacts poorly with DocFX's default filters
        // which aren't overridable. So we make it public, but use attributes to hide it from users' IntelliSense,
        // so that we can access the class in DocFX.
        this.code.openBlock(`public class ${className}`);
        this.code.closeBlock();
        this.closeFileIfNeeded(className, namespace, false);
    }
    /**
     * Emit an attribute that will hide the subsequent API element from users
     */
    emitHideAttribute() {
        this.code.line('[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]');
    }
}
exports.DotNetGenerator = DotNetGenerator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG90bmV0Z2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG90bmV0Z2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsK0JBQStCO0FBRy9CLDZCQUE2QjtBQUU3QiwrQ0FBc0Q7QUFFdEQsNkRBQTBEO0FBQzFELHFFQUFrRTtBQUNsRSw2REFBMEQ7QUFDMUQsbURBQWdEO0FBQ2hELDJDQUE4QztBQUU5Qzs7R0FFRztBQUNILE1BQWEsZUFBZ0IsU0FBUSxxQkFBUztJQVk1QyxZQUNtQixnQ0FBMEMsRUFDMUMsT0FBZ0I7UUFFakMsS0FBSyxFQUFFLENBQUM7UUFIUyxxQ0FBZ0MsR0FBaEMsZ0NBQWdDLENBQVU7UUFDMUMsWUFBTyxHQUFQLE9BQU8sQ0FBUztRQWJuQywyRUFBMkU7UUFDbkUsdUJBQWtCLEdBQUcsS0FBSyxDQUFDO1FBSWxCLGNBQVMsR0FBb0IsSUFBSSwyQkFBZSxFQUFFLENBQUM7UUFZbEUsb0dBQW9HO1FBQ3BHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLFVBQVUsSUFBSTtZQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakIsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVNLEtBQUssQ0FBQyxJQUFJLENBQ2YsV0FBbUIsRUFDbkIsUUFBMEI7UUFFMUIsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRLENBQUMsV0FBb0I7UUFDbEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLHVDQUFrQixDQUN4QyxJQUFJLENBQUMsUUFBUSxFQUNiLENBQUMsR0FBVyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxF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LEVBQUUsT0FBTztTQUNuQixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN6QixzR0FBc0c7UUFDdEcsMEdBQTBHO1FBQzFHLDRDQUE0QztRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsU0FBUyxFQUFFLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7T0FFRztJQUNLLGlCQUFpQjtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDWiwyRkFBMkYsQ0FDNUYsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQXRwQ0QsMENBc3BDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHNwZWMgZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgKiBhcyBjbG9uZSBmcm9tICdjbG9uZSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyByZWZsZWN0IGZyb20gJ2pzaWktcmVmbGVjdCc7XG5pbXBvcnQgeyBSb3NldHRhIH0gZnJvbSAnanNpaS1yb3NldHRhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IEdlbmVyYXRvciwgTGVnYWxlc2UgfSBmcm9tICcuLi8uLi9nZW5lcmF0b3InO1xuaW1wb3J0IHsgTWV0aG9kRGVmaW5pdGlvbiwgUHJvcGVydHlEZWZpbml0aW9uIH0gZnJvbSAnLi4vX3V0aWxzJztcbmltcG9ydCB7IERvdE5ldERvY0dlbmVyYXRvciB9IGZyb20gJy4vZG90bmV0ZG9jZ2VuZXJhdG9yJztcbmltcG9ydCB7IERvdE5ldFJ1bnRpbWVHZW5lcmF0b3IgfSBmcm9tICcuL2RvdG5ldHJ1bnRpbWVnZW5lcmF0b3InO1xuaW1wb3J0IHsgRG90TmV0VHlwZVJlc29sdmVyIH0gZnJvbSAnLi9kb3RuZXR0eXBlcmVzb2x2ZXInO1xuaW1wb3J0IHsgRmlsZUdlbmVyYXRvciB9IGZyb20gJy4vZmlsZWdlbmVyYXRvcic7XG5pbXBvcnQgeyBEb3ROZXROYW1lVXRpbHMgfSBmcm9tICcuL25hbWV1dGlscyc7XG5cbi8qKlxuICogQ09ERSBHRU5FUkFUT1IgVjJcbiAqL1xuZXhwb3J0IGNsYXNzIERvdE5ldEdlbmVyYXRvciBleHRlbmRzIEdlbmVyYXRvciB7XG4gIC8vIEZsYWdzIHRoYXQgdHJhY2tzIGlmIHdlIGhhdmUgYWxyZWFkeSB3cm90ZSB0aGUgZmlyc3QgbWVtYmVyIG9mIHRoZSBjbGFzc1xuICBwcml2YXRlIGZpcnN0TWVtYmVyV3JpdHRlbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgdHlwZXJlc29sdmVyITogRG90TmV0VHlwZVJlc29sdmVyO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbmFtZXV0aWxzOiBEb3ROZXROYW1lVXRpbHMgPSBuZXcgRG90TmV0TmFtZVV0aWxzKCk7XG5cbiAgcHJpdmF0ZSBkb3RuZXRSdW50aW1lR2VuZXJhdG9yITogRG90TmV0UnVudGltZUdlbmVyYXRvcjtcblxuICBwcml2YXRlIGRvdG5ldERvY0dlbmVyYXRvciE6IERvdE5ldERvY0dlbmVyYXRvcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBhc3NlbWJsaWVzQ3VycmVudGx5QmVpbmdDb21waWxlZDogc3RyaW5nW10sXG4gICAgcHJpdmF0ZSByZWFkb25seSByb3NldHRhOiBSb3NldHRhLFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gT3ZlcnJpZGUgdGhlIG9wZW5CbG9jayB0byBnZXQgYSBjb3JyZWN0IEMjIGxvb2tpbmcgY29kZSBibG9jayB3aXRoIHRoZSBjdXJseSBicmFjZSBhZnRlciB0aGUgbGluZVxuICAgIHRoaXMuY29kZS5vcGVuQmxvY2sgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgdGhpcy5saW5lKHRleHQpO1xuICAgICAgdGhpcy5vcGVuKCd7Jyk7XG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBsb2FkKFxuICAgIHBhY2thZ2VSb290OiBzdHJpbmcsXG4gICAgYXNzZW1ibHk6IHJlZmxlY3QuQXNzZW1ibHksXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHN1cGVyLmxvYWQocGFja2FnZVJvb3QsIGFzc2VtYmx5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBnZW5lcmF0b3IgKGluLW1lbW9yeSkuXG4gICAqL1xuICBwdWJsaWMgZ2VuZXJhdGUoZmluZ2VycHJpbnQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnR5cGVyZXNvbHZlciA9IG5ldyBEb3ROZXRUeXBlUmVzb2x2ZXIoXG4gICAgICB0aGlzLmFzc2VtYmx5LFxuICAgICAgKGZxbjogc3RyaW5nKSA9PiB0aGlzLmZpbmRNb2R1bGUoZnFuKSxcbiAgICAgIChmcW46IHN0cmluZykgPT4gdGhpcy5maW5kVHlwZShmcW4pLFxuICAgICAgdGhpcy5hc3NlbWJsaWVzQ3VycmVudGx5QmVpbmdDb21waWxlZCxcbiAgICApO1xuXG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yID0gbmV3IERvdE5ldFJ1bnRpbWVHZW5lcmF0b3IoXG4gICAgICB0aGlzLmNvZGUsXG4gICAgICB0aGlzLnR5cGVyZXNvbHZlcixcbiAgICApO1xuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yID0gbmV3IERvdE5ldERvY0dlbmVyYXRvcihcbiAgICAgIHRoaXMuY29kZSxcbiAgICAgIHRoaXMucm9zZXR0YSxcbiAgICAgIHRoaXMuYXNzZW1ibHksXG4gICAgKTtcblxuICAgIHRoaXMuZW1pdEFzc2VtYmx5RG9jcygpO1xuXG4gICAgLy8gV2UgbmVlZCB0byByZXNvbHZlIHRoZSBkZXBlbmRlbmN5IHRyZWVcbiAgICB0aGlzLnR5cGVyZXNvbHZlci5yZXNvbHZlTmFtZXNwYWNlc0RlcGVuZGVuY2llcygpO1xuICAgIHN1cGVyLmdlbmVyYXRlKGZpbmdlcnByaW50KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlKFxuICAgIG91dGRpcjogc3RyaW5nLFxuICAgIHRhcmJhbGw6IHN0cmluZyxcbiAgICB7IGxpY2Vuc2UsIG5vdGljZSB9OiBMZWdhbGVzZSxcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIEdlbmVyYXRpbmcgdGhlIGNzcHJvaiBhbmQgQXNzZW1ibHlJbmZvLmNzIGZpbGVzXG4gICAgY29uc3QgdGFyYmFsbEZpbGVOYW1lID0gcGF0aC5iYXNlbmFtZSh0YXJiYWxsKTtcbiAgICBjb25zdCBmaWxlZ2VuID0gbmV3IEZpbGVHZW5lcmF0b3IoXG4gICAgICB0aGlzLmFzc2VtYmx5LFxuICAgICAgdGFyYmFsbEZpbGVOYW1lLFxuICAgICAgdGhpcy5jb2RlLFxuICAgICk7XG4gICAgZmlsZWdlbi5nZW5lcmF0ZUFzc2VtYmx5SW5mb0ZpbGUoKTtcbiAgICBmaWxlZ2VuLmdlbmVyYXRlUHJvamVjdEZpbGUodGhpcy50eXBlcmVzb2x2ZXIubmFtZXNwYWNlRGVwZW5kZW5jaWVzKTtcbiAgICAvLyBDYWxsaW5nIHN1cGVyLnNhdmUoKSBkdW1wcyB0aGUgdGFyYmFsbCBpbiB0aGUgZm9ybWF0IG5hbWVAdmVyc2lvbi5qc2lpLnRnei5cbiAgICAvLyBUaGlzIGlzIG5vdCBpbiBzeW5jIHdpdGggdGhlIE9sZCAuTkVUIGdlbmVyYXRvciB3aGVyZSB0aGUgbmFtZSBpcyBzY29wZS1uYW1lLXZlcnNpb24udGd6LlxuICAgIC8vIEhlbmNlIHdlIGFyZSBzYXZpbmcgdGhlIGZpbGVzIG91cnNlbHZlcyBoZXJlOlxuICAgIGNvbnN0IGFzc20gPSB0aGlzLmFzc2VtYmx5O1xuICAgIGNvbnN0IHBhY2thZ2VJZDogc3RyaW5nID0gYXNzbS50YXJnZXRzIS5kb3RuZXQhLnBhY2thZ2VJZDtcbiAgICBpZiAoIXBhY2thZ2VJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIG1vZHVsZSAke2Fzc20ubmFtZX0gZG9lcyBub3QgaGF2ZSBhIGRvdG5ldC5wYWNrYWdlSWQgc2V0dGluZ2AsXG4gICAgICApO1xuICAgIH1cbiAgICBhd2FpdCBmcy5ta2RpcnAocGF0aC5qb2luKG91dGRpciwgcGFja2FnZUlkKSk7XG4gICAgYXdhaXQgZnMuY29weUZpbGUodGFyYmFsbCwgcGF0aC5qb2luKG91dGRpciwgcGFja2FnZUlkLCB0YXJiYWxsRmlsZU5hbWUpKTtcblxuICAgIC8vIENyZWF0ZSBhbiBhbmNob3IgZmlsZSBmb3IgdGhlIGN1cnJlbnQgbW9kZWxcbiAgICB0aGlzLmdlbmVyYXRlRGVwZW5kZW5jeUFuY2hvckZpbGUoKTtcblxuICAgIGlmIChsaWNlbnNlKSB7XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUocGF0aC5qb2luKG91dGRpciwgcGFja2FnZUlkLCAnTElDRU5TRScpLCBsaWNlbnNlLCB7XG4gICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5vdGljZSkge1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHBhdGguam9pbihvdXRkaXIsIHBhY2thZ2VJZCwgJ05PVElDRScpLCBub3RpY2UsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNhdmluZyB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAgcmV0dXJuIHRoaXMuY29kZS5zYXZlKG91dGRpcik7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBhbmNob3IgZmlsZVxuICAgKi9cbiAgcHJvdGVjdGVkIGdlbmVyYXRlRGVwZW5kZW5jeUFuY2hvckZpbGUoKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gYCR7XG4gICAgICB0aGlzLmFzc2VtYmx5LnRhcmdldHMhLmRvdG5ldCEubmFtZXNwYWNlXG4gICAgfS5JbnRlcm5hbC5EZXBlbmRlbmN5UmVzb2x1dGlvbmA7XG4gICAgdGhpcy5vcGVuRmlsZUlmTmVlZGVkKCdBbmNob3InLCBuYW1lc3BhY2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5jb2RlLm9wZW5CbG9jaygncHVibGljIHNlYWxlZCBjbGFzcyBBbmNob3InKTtcbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKCdwdWJsaWMgQW5jaG9yKCknKTtcbiAgICB0aGlzLnR5cGVyZXNvbHZlci5uYW1lc3BhY2VEZXBlbmRlbmNpZXMuZm9yRWFjaCgodmFsdWUpID0+XG4gICAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICAgYG5ldyAke3ZhbHVlLm5hbWVzcGFjZX0uSW50ZXJuYWwuRGVwZW5kZW5jeVJlc29sdXRpb24uQW5jaG9yKCk7YCxcbiAgICAgICksXG4gICAgKTtcbiAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgdGhpcy5jbG9zZUZpbGVJZk5lZWRlZCgnQW5jaG9yJywgbmFtZXNwYWNlLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogTm90IHVzZWQgYXMgd2Ugb3ZlcnJpZGUgdGhlIHNhdmUoKSBtZXRob2RcbiAgICovXG4gIHByb3RlY3RlZCBnZXRBc3NlbWJseU91dHB1dERpcihtb2Q6IHNwZWMuQXNzZW1ibHkpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5hbWV1dGlscy5jb252ZXJ0UGFja2FnZU5hbWUobW9kLm5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hbWVzcGFjZXMgYXJlIGhhbmRsZWQgaW1wbGljaXRseSBieSBvcGVuRmlsZUlmTmVlZGVkKCkuXG4gICAqXG4gICAqIERvIGdlbmVyYXRlIGRvY3MgaWYgdGhpcyBpcyBmb3IgYSBzdWJtb2R1bGUgdGhvdWdoLlxuICAgKi9cbiAgcHJvdGVjdGVkIG9uQmVnaW5OYW1lc3BhY2UoanNpaU5zOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdWJtb2R1bGUgPSB0aGlzLmFzc2VtYmx5LnN1Ym1vZHVsZXM/Lltqc2lpTnNdO1xuICAgIGlmIChzdWJtb2R1bGUpIHtcbiAgICAgIGNvbnN0IGRvdG5ldE5zID0gdGhpcy50eXBlcmVzb2x2ZXIucmVzb2x2ZU5hbWVzcGFjZShcbiAgICAgICAgdGhpcy5hc3NlbWJseSxcbiAgICAgICAgdGhpcy5hc3NlbWJseS5uYW1lLFxuICAgICAgICAvLyBTdHJpcCB0aGUgYCR7YXNzbU5hbWV9LmAgcHJlZml4IGhlcmUsIGFzIHRoZSBcImFzc2VtYmx5LXJlbGF0aXZlXCIgTlNcbiAgICAgICAgLy8gaXMgZXhwZWN0ZWQgYnkgYHRoaXMudHlwZVJlc29sdmVyLnJlc292bGVOYW1lc3BhY2VgLlxuICAgICAgICBqc2lpTnMuc3Vic3RyKHRoaXMuYXNzZW1ibHkubmFtZS5sZW5ndGggKyAxKSxcbiAgICAgICk7XG4gICAgICB0aGlzLmVtaXROYW1lc3BhY2VEb2NzKGRvdG5ldE5zLCBqc2lpTnMsIHN1Ym1vZHVsZSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uRW5kTmFtZXNwYWNlKF9uczogc3RyaW5nKSB7XG4gICAgLyogbm9vcCAqL1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQmVnaW5JbnRlcmZhY2UoaWZjOiBzcGVjLkludGVyZmFjZVR5cGUpIHtcbiAgICBjb25zdCBpbXBsZW1lbnRhdGlvbnMgPSB0aGlzLnR5cGVyZXNvbHZlci5yZXNvbHZlSW1wbGVtZW50ZWRJbnRlcmZhY2VzKGlmYyk7XG4gICAgY29uc3QgaW50ZXJmYWNlTmFtZSA9IHRoaXMubmFtZXV0aWxzLmNvbnZlcnRJbnRlcmZhY2VOYW1lKGlmYyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VGb3IodGhpcy5hc3NlbWJseSwgaWZjKTtcbiAgICB0aGlzLm9wZW5GaWxlSWZOZWVkZWQoaW50ZXJmYWNlTmFtZSwgbmFtZXNwYWNlLCB0aGlzLmlzTmVzdGVkKGlmYykpO1xuXG4gICAgdGhpcy5kb3RuZXREb2NHZW5lcmF0b3IuZW1pdERvY3MoaWZjLCB7IGFwaTogJ3R5cGUnLCBmcW46IGlmYy5mcW4gfSk7XG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXRBdHRyaWJ1dGVzRm9ySW50ZXJmYWNlKGlmYyk7XG5cbiAgICBpZiAoaW1wbGVtZW50YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29kZS5vcGVuQmxvY2soXG4gICAgICAgIGBwdWJsaWMgaW50ZXJmYWNlICR7aW50ZXJmYWNlTmFtZX0gOiAke2ltcGxlbWVudGF0aW9ucy5qb2luKCcsICcpfWAsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvZGUub3BlbkJsb2NrKGBwdWJsaWMgaW50ZXJmYWNlICR7aW50ZXJmYWNlTmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy5mbGFnRmlyc3RNZW1iZXJXcml0dGVuKGZhbHNlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkVuZEludGVyZmFjZShpZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSkge1xuICAgIC8vIGVtaXQgaW50ZXJmYWNlIHByb3h5IGNsYXNzXG4gICAgdGhpcy5lbWl0SW50ZXJmYWNlUHJveHkoaWZjKTtcblxuICAgIGNvbnN0IGludGVyZmFjZU5hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0SW50ZXJmYWNlTmFtZShpZmMpO1xuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VGb3IodGhpcy5hc3NlbWJseSwgaWZjKTtcbiAgICB0aGlzLmNsb3NlRmlsZUlmTmVlZGVkKGludGVyZmFjZU5hbWUsIG5hbWVzcGFjZSwgdGhpcy5pc05lc3RlZChpZmMpKTtcblxuICAgIC8vIGVtaXQgaW1wbGVtZW50YXRpb24gY2xhc3NcbiAgICAvLyBUT0RPOiBJZiBkYXRhdHlwZSB0aGVuIHdlIG1heSBub3QgbmVlZCB0aGUgaW50ZXJmYWNlIHByb3h5IHRvIGJlIGNyZWF0ZWQsIFdlIGNvdWxkIGRvIHdpdGgganVzdCB0aGUgaW50ZXJmYWNlIGltcGw/XG4gICAgaWYgKGlmYy5kYXRhdHlwZSkge1xuICAgICAgdGhpcy5lbWl0SW50ZXJmYWNlRGF0YVR5cGUoaWZjKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25JbnRlcmZhY2VNZXRob2QoaWZjOiBzcGVjLkludGVyZmFjZVR5cGUsIG1ldGhvZDogc3BlYy5NZXRob2QpIHtcbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvci5lbWl0RG9jcyhtZXRob2QsIHtcbiAgICAgIGFwaTogJ21lbWJlcicsXG4gICAgICBmcW46IGlmYy5mcW4sXG4gICAgICBtZW1iZXJOYW1lOiBtZXRob2QubmFtZSxcbiAgICB9KTtcbiAgICB0aGlzLmRvdG5ldFJ1bnRpbWVHZW5lcmF0b3IuZW1pdEF0dHJpYnV0ZXNGb3JNZXRob2QoaWZjLCBtZXRob2QpO1xuICAgIGNvbnN0IHJldHVyblR5cGUgPSBtZXRob2QucmV0dXJuc1xuICAgICAgPyB0aGlzLnR5cGVyZXNvbHZlci50b0RvdE5ldFR5cGUobWV0aG9kLnJldHVybnMudHlwZSlcbiAgICAgIDogJ3ZvaWQnO1xuICAgIGNvbnN0IG51bGxhYmxlID0gbWV0aG9kLnJldHVybnM/Lm9wdGlvbmFsID8gJz8nIDogJyc7XG4gICAgdGhpcy5jb2RlLmxpbmUoXG4gICAgICBgJHtyZXR1cm5UeXBlfSR7bnVsbGFibGV9ICR7dGhpcy5uYW1ldXRpbHMuY29udmVydE1ldGhvZE5hbWUoXG4gICAgICAgIG1ldGhvZC5uYW1lLFxuICAgICAgKX0oJHt0aGlzLnJlbmRlck1ldGhvZFBhcmFtZXRlcnMobWV0aG9kKX0pO2AsXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkludGVyZmFjZU1ldGhvZE92ZXJsb2FkKFxuICAgIGlmYzogc3BlYy5JbnRlcmZhY2VUeXBlLFxuICAgIG92ZXJsb2FkOiBzcGVjLk1ldGhvZCxcbiAgICBfb3JpZ2luYWxNZXRob2Q6IHNwZWMuTWV0aG9kLFxuICApIHtcbiAgICB0aGlzLm9uSW50ZXJmYWNlTWV0aG9kKGlmYywgb3ZlcmxvYWQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uSW50ZXJmYWNlUHJvcGVydHkoaWZjOiBzcGVjLkludGVyZmFjZVR5cGUsIHByb3A6IHNwZWMuUHJvcGVydHkpIHtcbiAgICBpZiAoIXByb3AuYWJzdHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJmYWNlIHByb3BlcnRpZXMgbXVzdCBiZSBhYnN0cmFjdDogJHtwcm9wLm5hbWV9YCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3AucHJvdGVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQcm90ZWN0ZWQgcHJvcGVydGllcyBhcmUgbm90IGFsbG93ZWQgb24gaW50ZXJmYWNlczogJHtwcm9wLm5hbWV9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHByb3Auc3RhdGljKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQcm9wZXJ0eSAke2lmYy5uYW1lfS4ke3Byb3AubmFtZX0gaXMgbWFya2VkIGFzIHN0YXRpYywgYnV0IGludGVyZmFjZXMgbXVzdCBub3QgY29udGFpbiBzdGF0aWMgbWVtYmVycy5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXROZXdMaW5lSWZOZWNlc3NhcnkoKTtcbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvci5lbWl0RG9jcyhwcm9wLCB7XG4gICAgICBhcGk6ICdtZW1iZXInLFxuICAgICAgZnFuOiBpZmMuZnFuLFxuICAgICAgbWVtYmVyTmFtZTogcHJvcC5uYW1lLFxuICAgIH0pO1xuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0ZvclByb3BlcnR5KHByb3ApO1xuXG4gICAgY29uc3QgcHJvcFR5cGUgPSB0aGlzLnR5cGVyZXNvbHZlci50b0RvdE5ldFR5cGUocHJvcC50eXBlKTtcbiAgICBjb25zdCBwcm9wTmFtZSA9IHRoaXMubmFtZXV0aWxzLmNvbnZlcnRQcm9wZXJ0eU5hbWUocHJvcC5uYW1lKTtcblxuICAgIGlmIChwcm9wLm9wdGlvbmFsKSB7XG4gICAgICB0aGlzLmNvZGUubGluZSgnW0FtYXpvbi5KU0lJLlJ1bnRpbWUuRGVwdXR5LkpzaWlPcHRpb25hbF0nKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWZ5aW5nIHRoYXQgYSB0eXBlIGlzIG51bGxhYmxlIGlzIG9ubHkgcmVxdWlyZWQgZm9yIHByaW1pdGl2ZSB2YWx1ZSB0eXBlc1xuICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBwcm9wLm9wdGlvbmFsID8gJz8nIDogJyc7XG4gICAgdGhpcy5jb2RlLm9wZW5CbG9jayhgJHtwcm9wVHlwZX0ke2lzT3B0aW9uYWx9ICR7cHJvcE5hbWV9YCk7XG5cbiAgICBpZiAocHJvcC5vcHRpb25hbCkge1xuICAgICAgdGhpcy5jb2RlLm9wZW5CbG9jaygnZ2V0Jyk7XG4gICAgICB0aGlzLmNvZGUubGluZSgncmV0dXJuIG51bGw7Jyk7XG4gICAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgICAgaWYgKCFwcm9wLmltbXV0YWJsZSkge1xuICAgICAgICB0aGlzLmNvZGUub3BlbkJsb2NrKCdzZXQnKTtcbiAgICAgICAgdGhpcy5jb2RlLmxpbmUoXG4gICAgICAgICAgYHRocm93IG5ldyBTeXN0ZW0uTm90U3VwcG9ydGVkRXhjZXB0aW9uKFwiJ3NldCcgZm9yICcke3Byb3BOYW1lfScgaXMgbm90IGltcGxlbWVudGVkXCIpO2AsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29kZS5saW5lKCdnZXQ7Jyk7XG4gICAgICBpZiAoIXByb3AuaW1tdXRhYmxlKSB7XG4gICAgICAgIHRoaXMuY29kZS5saW5lKCdzZXQ7Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICB0aGlzLmZsYWdGaXJzdE1lbWJlcldyaXR0ZW4odHJ1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25CZWdpbkNsYXNzKGNsczogc3BlYy5DbGFzc1R5cGUsIGFic3RyYWN0OiBib29sZWFuKSB7XG4gICAgbGV0IGJhc2VUeXBlTmFtZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VGb3IodGhpcy5hc3NlbWJseSwgY2xzKTtcblxuICAgIC8vIEEgY2xhc3MgY2FuIGRlcml2ZSBmcm9tIG9ubHkgb25lIGJhc2UgY2xhc3NcbiAgICAvLyBCdXQgY2FuIGltcGxlbWVudCBtdWx0aXBsZSBpbnRlcmZhY2VzXG4gICAgaWYgKCFjbHMuYmFzZSkge1xuICAgICAgYmFzZVR5cGVOYW1lcy5wdXNoKCdEZXB1dHlCYXNlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNsYXNzQmFzZSA9IHRoaXMudHlwZXJlc29sdmVyLnRvRG90TmV0VHlwZSh7IGZxbjogY2xzLmJhc2UgfSk7XG4gICAgICBiYXNlVHlwZU5hbWVzLnB1c2goY2xhc3NCYXNlKTtcbiAgICB9XG5cbiAgICBpZiAoY2xzLmludGVyZmFjZXMgJiYgY2xzLmludGVyZmFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaW1wbGVtZW50YXRpb25zID1cbiAgICAgICAgdGhpcy50eXBlcmVzb2x2ZXIucmVzb2x2ZUltcGxlbWVudGVkSW50ZXJmYWNlcyhjbHMpO1xuICAgICAgYmFzZVR5cGVOYW1lcyA9IGJhc2VUeXBlTmFtZXMuY29uY2F0KGltcGxlbWVudGF0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydENsYXNzTmFtZShjbHMpO1xuXG4gICAgLy8gTmVzdGVkIGNsYXNzZXMgd2lsbCBiZSBkZWFsdCB3aXRoIGR1cmluZyBjYWxjIGNvZGUgZ2VuZXJhdGlvblxuICAgIGNvbnN0IG5lc3RlZCA9IHRoaXMuaXNOZXN0ZWQoY2xzKTtcbiAgICBjb25zdCBhYnNQcmVmaXggPSBhYnN0cmFjdCA/ICcgYWJzdHJhY3QnIDogJyc7XG5cbiAgICB0aGlzLm9wZW5GaWxlSWZOZWVkZWQoY2xhc3NOYW1lLCBuYW1lc3BhY2UsIG5lc3RlZCk7XG5cbiAgICBjb25zdCBpbXBsZW1lbnRzRXhwciA9IGAgOiAke2Jhc2VUeXBlTmFtZXMuam9pbignLCAnKX1gO1xuXG4gICAgdGhpcy5kb3RuZXREb2NHZW5lcmF0b3IuZW1pdERvY3MoY2xzLCB7XG4gICAgICBhcGk6ICd0eXBlJyxcbiAgICAgIGZxbjogY2xzLmZxbixcbiAgICB9KTtcblxuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0ZvckNsYXNzKGNscyk7XG5cbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKFxuICAgICAgYHB1YmxpYyR7YWJzUHJlZml4fSBjbGFzcyAke2NsYXNzTmFtZX0ke2ltcGxlbWVudHNFeHByfWAsXG4gICAgKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGNsYXNzIHBhcmFtZXRlcnNcbiAgICBsZXQgcGFyYW1ldGVyc0RlZmluaXRpb24gPSAnJztcbiAgICBsZXQgcGFyYW1ldGVyc0Jhc2UgPSAnJztcbiAgICBjb25zdCBpbml0aWFsaXplciA9IGNscy5pbml0aWFsaXplcjtcbiAgICBpZiAoaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKGluaXRpYWxpemVyLCB7XG4gICAgICAgIGFwaTogJ2luaXRpYWxpemVyJyxcbiAgICAgICAgZnFuOiBjbHMuZnFuLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRvdG5ldFJ1bnRpbWVHZW5lcmF0b3IuZW1pdERlcHJlY2F0ZWRBdHRyaWJ1dGVJZk5lY2Vzc2FyeShcbiAgICAgICAgaW5pdGlhbGl6ZXIsXG4gICAgICApO1xuICAgICAgaWYgKGluaXRpYWxpemVyLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgcGFyYW1ldGVyc0RlZmluaXRpb24gPSB0aGlzLnJlbmRlclBhcmFtZXRlcnNTdHJpbmcoXG4gICAgICAgICAgaW5pdGlhbGl6ZXIucGFyYW1ldGVycyxcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIGluaXRpYWxpemVyLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzQmFzZSArPSBgJHt0aGlzLm5hbWV1dGlscy5jb252ZXJ0UGFyYW1ldGVyTmFtZShwLm5hbWUpfWA7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGxhc3QgcGFyYW1ldGVyLCBhcHBlbmQgLFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGluaXRpYWxpemVyLnBhcmFtZXRlcnMuaW5kZXhPZihwKSAhPT1cbiAgICAgICAgICAgIGluaXRpYWxpemVyLnBhcmFtZXRlcnMubGVuZ3RoIC0gMVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcGFyYW1ldGVyc0Jhc2UgKz0gJywgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHRoZSBjb25zdHJ1Y3RvcnM6XG4gICAgICAvLyBBYnN0cmFjdCBjbGFzc2VzIGhhdmUgcHJvdGVjdGVkIGNvbnN0cnVjdG9ycy5cbiAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSBjbHMuYWJzdHJhY3QgPyAncHJvdGVjdGVkJyA6ICdwdWJsaWMnO1xuXG4gICAgICBjb25zdCBhcmdzID1cbiAgICAgICAgcGFyYW1ldGVyc0Jhc2UubGVuZ3RoID4gMFxuICAgICAgICAgID8gYG5ldyBvYmplY3Q/W117JHtwYXJhbWV0ZXJzQmFzZX19YFxuICAgICAgICAgIDogYFN5c3RlbS5BcnJheS5FbXB0eTxvYmplY3Q/PigpYDtcbiAgICAgIHRoaXMuY29kZS5vcGVuQmxvY2soXG4gICAgICAgIGAke3Zpc2liaWxpdHl9ICR7Y2xhc3NOYW1lfSgke3BhcmFtZXRlcnNEZWZpbml0aW9ufSk6IGJhc2UobmV3IERlcHV0eVByb3BzKCR7YXJnc30pKWAsXG4gICAgICApO1xuICAgICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICAgIHRoaXMuY29kZS5saW5lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2RlLmxpbmUoXG4gICAgICAnLy8vIDxzdW1tYXJ5PlVzZWQgYnkganNpaSB0byBjb25zdHJ1Y3QgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBmcm9tIGEgSmF2YXNjcmlwdC1vd25lZCBvYmplY3QgcmVmZXJlbmNlPC9zdW1tYXJ5PicsXG4gICAgKTtcbiAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICcvLy8gPHBhcmFtIG5hbWU9XCJyZWZlcmVuY2VcIj5UaGUgSmF2YXNjcmlwdC1vd25lZCBvYmplY3QgcmVmZXJlbmNlPC9wYXJhbT4nLFxuICAgICk7XG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXREZXByZWNhdGVkQXR0cmlidXRlSWZOZWNlc3NhcnkoaW5pdGlhbGl6ZXIpO1xuICAgIHRoaXMuZW1pdEhpZGVBdHRyaWJ1dGUoKTtcbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKFxuICAgICAgYHByb3RlY3RlZCAke2NsYXNzTmFtZX0oQnlSZWZWYWx1ZSByZWZlcmVuY2UpOiBiYXNlKHJlZmVyZW5jZSlgLFxuICAgICk7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICB0aGlzLmNvZGUubGluZSgpO1xuXG4gICAgdGhpcy5jb2RlLmxpbmUoXG4gICAgICAnLy8vIDxzdW1tYXJ5PlVzZWQgYnkganNpaSB0byBjb25zdHJ1Y3QgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBmcm9tIERlcHV0eVByb3BzPC9zdW1tYXJ5PicsXG4gICAgKTtcbiAgICB0aGlzLmNvZGUubGluZSgnLy8vIDxwYXJhbSBuYW1lPVwicHJvcHNcIj5UaGUgZGVwdXR5IHByb3BzPC9wYXJhbT4nKTtcbiAgICB0aGlzLmRvdG5ldFJ1bnRpbWVHZW5lcmF0b3IuZW1pdERlcHJlY2F0ZWRBdHRyaWJ1dGVJZk5lY2Vzc2FyeShpbml0aWFsaXplcik7XG4gICAgdGhpcy5lbWl0SGlkZUF0dHJpYnV0ZSgpO1xuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soXG4gICAgICBgcHJvdGVjdGVkICR7Y2xhc3NOYW1lfShEZXB1dHlQcm9wcyBwcm9wcyk6IGJhc2UocHJvcHMpYCxcbiAgICApO1xuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICAvLyBXZSBoYXZlIGFscmVhZHkgb3V0cHV0dGVkIG1lbWJlcnMgKGNvbnN0cnVjdG9ycyksIHNldHRpbmcgdGhlIGZsYWcgdG8gdHJ1ZVxuICAgIHRoaXMuZmxhZ0ZpcnN0TWVtYmVyV3JpdHRlbih0cnVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkVuZENsYXNzKGNsczogc3BlYy5DbGFzc1R5cGUpIHtcbiAgICBpZiAoY2xzLmFic3RyYWN0KSB7XG4gICAgICB0aGlzLmVtaXRJbnRlcmZhY2VQcm94eShjbHMpO1xuICAgIH1cblxuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydENsYXNzTmFtZShjbHMpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlRm9yKHRoaXMuYXNzZW1ibHksIGNscyk7XG4gICAgdGhpcy5jbG9zZUZpbGVJZk5lZWRlZChjbGFzc05hbWUsIG5hbWVzcGFjZSwgdGhpcy5pc05lc3RlZChjbHMpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkZpZWxkKFxuICAgIF9jbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIF9wcm9wOiBzcGVjLlByb3BlcnR5LFxuICAgIF91bmlvbj86IHNwZWMuVW5pb25UeXBlUmVmZXJlbmNlLFxuICApIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZXRob2QoY2xzOiBzcGVjLkNsYXNzVHlwZSwgbWV0aG9kOiBzcGVjLk1ldGhvZCkge1xuICAgIHRoaXMuZW1pdE1ldGhvZChjbHMsIG1ldGhvZCwgY2xzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1ldGhvZE92ZXJsb2FkKFxuICAgIGNsczogc3BlYy5DbGFzc1R5cGUsXG4gICAgb3ZlcmxvYWQ6IHNwZWMuTWV0aG9kLFxuICAgIF9vcmlnaW5hbE1ldGhvZDogc3BlYy5NZXRob2QsXG4gICkge1xuICAgIHRoaXMub25NZXRob2QoY2xzLCBvdmVybG9hZCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25Qcm9wZXJ0eShjbHM6IHNwZWMuQ2xhc3NUeXBlLCBwcm9wOiBzcGVjLlByb3BlcnR5KSB7XG4gICAgdGhpcy5lbWl0UHJvcGVydHkoY2xzLCBwcm9wLCBjbHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uU3RhdGljTWV0aG9kKGNsczogc3BlYy5DbGFzc1R5cGUsIG1ldGhvZDogc3BlYy5NZXRob2QpIHtcbiAgICB0aGlzLmVtaXRNZXRob2QoY2xzLCBtZXRob2QsIGNscyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25TdGF0aWNNZXRob2RPdmVybG9hZChcbiAgICBjbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIG92ZXJsb2FkOiBzcGVjLk1ldGhvZCxcbiAgICBfb3JpZ2luYWxNZXRob2Q6IHNwZWMuTWV0aG9kLFxuICApIHtcbiAgICB0aGlzLmVtaXRNZXRob2QoY2xzLCBvdmVybG9hZCwgY2xzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblN0YXRpY1Byb3BlcnR5KGNsczogc3BlYy5DbGFzc1R5cGUsIHByb3A6IHNwZWMuUHJvcGVydHkpIHtcbiAgICBpZiAocHJvcC5jb25zdCkge1xuICAgICAgdGhpcy5lbWl0Q29uc3RQcm9wZXJ0eShjbHMsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXRQcm9wZXJ0eShjbHMsIHByb3AsIGNscyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uVW5pb25Qcm9wZXJ0eShcbiAgICBjbHM6IHNwZWMuQ2xhc3NUeXBlLFxuICAgIHByb3A6IHNwZWMuUHJvcGVydHksXG4gICAgX3VuaW9uOiBzcGVjLlVuaW9uVHlwZVJlZmVyZW5jZSxcbiAgKSB7XG4gICAgdGhpcy5lbWl0UHJvcGVydHkoY2xzLCBwcm9wLCBjbHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQmVnaW5FbnVtKGVubTogc3BlYy5FbnVtVHlwZSkge1xuICAgIGNvbnN0IGVudW1OYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydFR5cGVOYW1lKGVubS5uYW1lKTtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZUZvcih0aGlzLmFzc2VtYmx5LCBlbm0pO1xuICAgIHRoaXMub3BlbkZpbGVJZk5lZWRlZChlbnVtTmFtZSwgbmFtZXNwYWNlLCB0aGlzLmlzTmVzdGVkKGVubSkpO1xuICAgIHRoaXMuZW1pdE5ld0xpbmVJZk5lY2Vzc2FyeSgpO1xuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKGVubSwge1xuICAgICAgYXBpOiAndHlwZScsXG4gICAgICBmcW46IGVubS5mcW4sXG4gICAgfSk7XG4gICAgdGhpcy5kb3RuZXRSdW50aW1lR2VuZXJhdG9yLmVtaXRBdHRyaWJ1dGVzRm9yRW51bShlbm0sIGVudW1OYW1lKTtcbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKGBwdWJsaWMgZW51bSAke2VubS5uYW1lfWApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRW5kRW51bShlbm06IHNwZWMuRW51bVR5cGUpIHtcbiAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgIGNvbnN0IGVudW1OYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydFR5cGVOYW1lKGVubS5uYW1lKTtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZUZvcih0aGlzLmFzc2VtYmx5LCBlbm0pO1xuICAgIHRoaXMuY2xvc2VGaWxlSWZOZWVkZWQoZW51bU5hbWUsIG5hbWVzcGFjZSwgdGhpcy5pc05lc3RlZChlbm0pKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkVudW1NZW1iZXIoZW5tOiBzcGVjLkVudW1UeXBlLCBtZW1iZXI6IHNwZWMuRW51bU1lbWJlcikge1xuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKG1lbWJlciwge1xuICAgICAgYXBpOiAnbWVtYmVyJyxcbiAgICAgIGZxbjogZW5tLmZxbixcbiAgICAgIG1lbWJlck5hbWU6IG1lbWJlci5uYW1lLFxuICAgIH0pO1xuICAgIGNvbnN0IGVudW1NZW1iZXJOYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydEVudW1NZW1iZXJOYW1lKG1lbWJlci5uYW1lKTtcbiAgICB0aGlzLmRvdG5ldFJ1bnRpbWVHZW5lcmF0b3IuZW1pdEF0dHJpYnV0ZXNGb3JFbnVtTWVtYmVyKFxuICAgICAgZW51bU1lbWJlck5hbWUsXG4gICAgICBtZW1iZXIsXG4gICAgKTtcbiAgICAvLyBJZiB3ZSBhcmUgb24gdGhlIGxhc3QgZW51bSBtZW1iZXIsIHdlIGRvbid0IG5lZWQgYSBjb21tYVxuICAgIGlmIChlbm0ubWVtYmVycy5pbmRleE9mKG1lbWJlcikgIT09IGVubS5tZW1iZXJzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29kZS5saW5lKGAke2VudW1NZW1iZXJOYW1lfSxgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2RlLmxpbmUoYCR7ZW51bU1lbWJlck5hbWV9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBuYW1lc3BhY2VGb3IoYXNzbTogc3BlYy5Bc3NlbWJseSwgdHlwZTogc3BlYy5UeXBlKTogc3RyaW5nIHtcbiAgICBsZXQgbnMgPSB0eXBlLm5hbWVzcGFjZTtcbiAgICB3aGlsZSAobnMgIT0gbnVsbCAmJiBhc3NtLnR5cGVzPy5bYCR7YXNzbS5uYW1lfS4ke25zfWBdICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5lc3RpbmcgPSBhc3NtLnR5cGVzW2Ake2Fzc20ubmFtZX0uJHtuc31gXTtcbiAgICAgIG5zID0gbmVzdGluZy5uYW1lc3BhY2U7XG4gICAgfVxuICAgIGlmIChucyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlcmVzb2x2ZXIucmVzb2x2ZU5hbWVzcGFjZShhc3NtLCBhc3NtLm5hbWUsIG5zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc20udGFyZ2V0cyEuZG90bmV0IS5uYW1lc3BhY2U7XG4gIH1cblxuICBwcml2YXRlIGVtaXRNZXRob2QoXG4gICAgY2xzOiBzcGVjLkNsYXNzVHlwZSB8IHNwZWMuSW50ZXJmYWNlVHlwZSxcbiAgICBtZXRob2Q6IHNwZWMuTWV0aG9kLFxuICAgIGRlZmluaW5nVHlwZTogc3BlYy5UeXBlLFxuICAgIGVtaXRGb3JQcm94eU9yRGF0YXR5cGUgPSBmYWxzZSxcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5lbWl0TmV3TGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgY29uc3QgcmV0dXJuVHlwZSA9IG1ldGhvZC5yZXR1cm5zXG4gICAgICA/IHRoaXMudHlwZXJlc29sdmVyLnRvRG90TmV0VHlwZShtZXRob2QucmV0dXJucy50eXBlKVxuICAgICAgOiAndm9pZCc7XG4gICAgY29uc3Qgc3RhdGljS2V5V29yZCA9IG1ldGhvZC5zdGF0aWMgPyAnc3RhdGljICcgOiAnJztcbiAgICBsZXQgb3ZlcnJpZGVLZXlXb3JkID0gJyc7XG4gICAgbGV0IHZpcnR1YWxLZXlXb3JkID0gJyc7XG5cbiAgICBsZXQgZGVmaW5lZE9uQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiB0aGUgc291cmNlIGJlaW5nIGEgY2xhc3MsIHdlIGNoZWNrIGlmIGl0IGlzIGFscmVhZHkgZGVmaW5lZCBvbiBhbiBhbmNlc3RvclxuICAgIGlmIChzcGVjLmlzQ2xhc3NUeXBlKGNscykpIHtcbiAgICAgIGRlZmluZWRPbkFuY2VzdG9yID0gdGhpcy5pc01lbWJlckRlZmluZWRPbkFuY2VzdG9yKGNscywgbWV0aG9kKTtcbiAgICB9XG4gICAgLy8gVGhlIG1ldGhvZCBpcyBhbiBvdmVycmlkZSBpZiBpdCdzIGRlZmluZWQgb24gdGhlIGFuY2VzdG9yLCBvciBpZiB0aGUgcGFyZW50IGlzIGEgY2xhc3MgYW5kIHdlIGFyZSBnZW5lcmF0aW5nIGEgcHJveHkgb3IgZGF0YXR5cGUgY2xhc3NcbiAgICBsZXQgb3ZlcnJpZGVzID1cbiAgICAgIGRlZmluZWRPbkFuY2VzdG9yIHx8IChzcGVjLmlzQ2xhc3NUeXBlKGNscykgJiYgZW1pdEZvclByb3h5T3JEYXRhdHlwZSk7XG4gICAgLy8gV2UgYWxzbyBpbnNwZWN0IHRoZSBqc2lpIG1vZGVsIHRvIHNlZSBpZiBpdCBvdmVycmlkZXMgYSBjbGFzcyBtZW1iZXIuXG4gICAgaWYgKG1ldGhvZC5vdmVycmlkZXMpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlVHlwZSA9IHRoaXMuZmluZFR5cGUobWV0aG9kLm92ZXJyaWRlcyk7XG4gICAgICBpZiAoc3BlYy5pc0NsYXNzVHlwZShvdmVycmlkZVR5cGUpKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlcyBhIGNsYXNzLCBuZWVkcyBvdmVycmlkZXMga2V5d29yZFxuICAgICAgICBvdmVycmlkZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICAvLyBBZGQgdGhlIG92ZXJyaWRlIGtleSB3b3JkIGlmIHRoZSBtZXRob2QgaXMgZW1pdHRlZCBmb3IgYSBwcm94eSBvciBkYXRhIHR5cGUgb3IgaXMgZGVmaW5lZCBvbiBhbiBhbmNlc3Rvci4gSWZcbiAgICAgIC8vIHRoZSBtZW1iZXIgaXMgc3RhdGljLCB1c2UgdGhlIFwibmV3XCIga2V5d29yZCBpbnN0ZWFkLCB0byBpbmRpY2F0ZSB3ZSBhcmUgaW50ZW50aW9uYWxseSBoaWRpbmcgdGhlIGFuY2VzdG9yXG4gICAgICAvLyBkZWNsYXJhdGlvbiAoYXMgQyMgZG9lcyBub3QgaW5oZXJpdCBzdGF0aWNzLCB0aGV5IGNhbiBiZSBoaWRkZW4gYnV0IG5vdCBvdmVycmlkZGVuKS4gVGhlIFwibmV3XCIga2V5d29yZCBpc1xuICAgICAgLy8gb3B0aW9uYWwgaW4gdGhpcyBjb250ZXh0LCBidXQgaGVscHMgY2xhcmlmeSBpbnRlbnRpb24uXG4gICAgICBvdmVycmlkZUtleVdvcmQgPSBtZXRob2Quc3RhdGljID8gJ25ldyAnIDogJ292ZXJyaWRlICc7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICFtZXRob2Quc3RhdGljICYmXG4gICAgICAobWV0aG9kLmFic3RyYWN0IHx8ICFkZWZpbmVkT25BbmNlc3RvcikgJiZcbiAgICAgICFlbWl0Rm9yUHJveHlPckRhdGF0eXBlXG4gICAgKSB7XG4gICAgICAvLyBBZGQgdGhlIHZpcnR1YWwga2V5IHdvcmQgaWYgdGhlIG1ldGhvZCBpcyBhYnN0cmFjdCBvciBub3QgZGVmaW5lZCBvbiBhbiBhbmNlc3RvciBhbmQgd2UgYXJlIE5PVCBnZW5lcmF0aW5nIGEgcHJveHkgb3IgZGF0YXR5cGUgY2xhc3NcbiAgICAgIC8vIE1ldGhvZHMgc2hvdWxkIGFsd2F5cyBiZSB2aXJ0dWFsIHdoZW4gcG9zc2libGVcbiAgICAgIHZpcnR1YWxLZXlXb3JkID0gJ3ZpcnR1YWwgJztcbiAgICB9XG5cbiAgICBjb25zdCBhY2Nlc3MgPSB0aGlzLnJlbmRlckFjY2Vzc0xldmVsKG1ldGhvZCk7XG4gICAgY29uc3QgbWV0aG9kTmFtZSA9IHRoaXMubmFtZXV0aWxzLmNvbnZlcnRNZXRob2ROYW1lKG1ldGhvZC5uYW1lKTtcblxuICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBtZXRob2QucmV0dXJucyAmJiBtZXRob2QucmV0dXJucy5vcHRpb25hbCA/ICc/JyA6ICcnO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGAke3JldHVyblR5cGV9JHtpc09wdGlvbmFsfSAke21ldGhvZE5hbWV9KCR7dGhpcy5yZW5kZXJNZXRob2RQYXJhbWV0ZXJzKFxuICAgICAgbWV0aG9kLFxuICAgICl9KWA7XG5cbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvci5lbWl0RG9jcyhtZXRob2QsIHtcbiAgICAgIGFwaTogJ21lbWJlcicsXG4gICAgICBmcW46IGRlZmluaW5nVHlwZS5mcW4sXG4gICAgICBtZW1iZXJOYW1lOiBtZXRob2QubmFtZSxcbiAgICB9KTtcbiAgICB0aGlzLmRvdG5ldFJ1bnRpbWVHZW5lcmF0b3IuZW1pdEF0dHJpYnV0ZXNGb3JNZXRob2QoXG4gICAgICBjbHMsXG4gICAgICBtZXRob2QgLyosIGVtaXRGb3JQcm94eU9yRGF0YXR5cGUqLyxcbiAgICApO1xuXG4gICAgaWYgKG1ldGhvZC5hYnN0cmFjdCkge1xuICAgICAgdGhpcy5jb2RlLmxpbmUoYCR7YWNjZXNzfSAke292ZXJyaWRlS2V5V29yZH1hYnN0cmFjdCAke3NpZ25hdHVyZX07YCk7XG4gICAgICB0aGlzLmNvZGUubGluZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvZGUub3BlbkJsb2NrKFxuICAgICAgICBgJHthY2Nlc3N9ICR7c3RhdGljS2V5V29yZH0ke292ZXJyaWRlS2V5V29yZH0ke3ZpcnR1YWxLZXlXb3JkfSR7c2lnbmF0dXJlfWAsXG4gICAgICApO1xuICAgICAgdGhpcy5jb2RlLmxpbmUoXG4gICAgICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5jcmVhdGVJbnZva2VNZXRob2RJZGVudGlmaWVyKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBjbHMgYXMgc3BlYy5DbGFzc1R5cGUsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm91bmRzIG91dCBpZiBhIG1lbWJlciAocHJvcGVydHkgb3IgbWV0aG9kKSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gb25lIG9mIHRoZSBiYXNlIGNsYXNzZXNcbiAgICpcbiAgICogVXNlZCB0byBmaWd1cmUgb3V0IGlmIHRoZSBvdmVycmlkZSBvciB2aXJ0dWFsIGtleXdvcmRzIGFyZSBuZWNlc3NhcnkuXG4gICAqL1xuICBwcml2YXRlIGlzTWVtYmVyRGVmaW5lZE9uQW5jZXN0b3IoXG4gICAgY2xzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBtZW1iZXI6IHNwZWMuUHJvcGVydHkgfCBzcGVjLk1ldGhvZCxcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKG1lbWJlciBhcyBzcGVjLk1ldGhvZCkge1xuICAgICAgY29uc3Qgb2JqZWN0TWV0aG9kcyA9IFsnVG9TdHJpbmcnLCAnR2V0SGFzaENvZGUnLCAnRXF1YWxzJ107XG4gICAgICAvLyBNZXRob2RzIGRlZmluZWQgb24gdGhlIE9iamVjdCBjbGFzcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiwgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoXG4gICAgICAgIG9iamVjdE1ldGhvZHMuaW5jbHVkZXModGhpcy5uYW1ldXRpbHMuY29udmVydE1ldGhvZE5hbWUobWVtYmVyLm5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJhc2UgPSBjbHMuYmFzZTtcbiAgICBpZiAoYmFzZSkge1xuICAgICAgY29uc3QgYmFzZVR5cGUgPSB0aGlzLmZpbmRUeXBlKGJhc2UpIGFzIHNwZWMuQ2xhc3NUeXBlO1xuXG4gICAgICBpZiAobWVtYmVyIGFzIHNwZWMuUHJvcGVydHkpIHtcbiAgICAgICAgaWYgKGJhc2VUeXBlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBiYXNlVHlwZS5wcm9wZXJ0aWVzLmZpbHRlcihcbiAgICAgICAgICAgICAgKHByb3BlcnR5KSA9PiBwcm9wZXJ0eS5uYW1lID09PSBtZW1iZXIubmFtZSxcbiAgICAgICAgICAgICkubGVuZ3RoID4gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gcHJvcGVydHkgZm91bmQgaW4gYmFzZSBwYXJlbnRcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc01lbWJlckRlZmluZWRPbkFuY2VzdG9yKGJhc2VUeXBlLCBtZW1iZXIpO1xuICAgICAgfSBlbHNlIGlmIChtZW1iZXIgYXMgc3BlYy5NZXRob2QpIHtcbiAgICAgICAgaWYgKGJhc2VUeXBlLm1ldGhvZHMpIHtcbiAgICAgICAgICBjb25zdCBteU1ldGhvZCA9IG1lbWJlciBhcyBzcGVjLk1ldGhvZDtcbiAgICAgICAgICAvLyBJZiB0aGUgbmFtZSwgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhcmUgc2ltaWxhciB0aGVuIGl0IGlzIHRoZSBzYW1lIG1ldGhvZCBpbiAuTkVUXG4gICAgICAgICAgZm9yIChjb25zdCBtIG9mIGJhc2VUeXBlLm1ldGhvZHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbS5uYW1lID09PSBteU1ldGhvZC5uYW1lICYmXG4gICAgICAgICAgICAgIG0ucGFyYW1ldGVycyA9PT0gbXlNZXRob2QucGFyYW1ldGVycyAmJlxuICAgICAgICAgICAgICBtLnJldHVybnMgPT09IG15TWV0aG9kLnJldHVybnNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNNZW1iZXJEZWZpbmVkT25BbmNlc3RvcihiYXNlVHlwZSwgbWVtYmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgbWV0aG9kIHBhcmFtZXRlcnMgc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIHJlbmRlck1ldGhvZFBhcmFtZXRlcnMobWV0aG9kOiBzcGVjLk1ldGhvZCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUGFyYW1ldGVyc1N0cmluZyhtZXRob2QucGFyYW1ldGVycyk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBwYXJhbWV0ZXJzIHN0cmluZyBmb3IgbWV0aG9kcyBvciBjb25zdHJ1Y3RvcnNcbiAgICovXG4gIHByaXZhdGUgcmVuZGVyUGFyYW1ldGVyc1N0cmluZyhcbiAgICBwYXJhbWV0ZXJzOiBzcGVjLlBhcmFtZXRlcltdIHwgdW5kZWZpbmVkLFxuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgcGFyYW1ldGVycykge1xuICAgICAgICBsZXQgb3B0aW9uYWxQcmltaXRpdmUgPSAnJztcbiAgICAgICAgbGV0IG9wdGlvbmFsS2V5d29yZCA9ICcnO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMudHlwZXJlc29sdmVyLnRvRG90TmV0VHlwZShwLnR5cGUpO1xuICAgICAgICBpZiAocC5vcHRpb25hbCkge1xuICAgICAgICAgIG9wdGlvbmFsS2V5d29yZCA9ICcgPSBudWxsJztcbiAgICAgICAgICBpZiAocC5vcHRpb25hbCkge1xuICAgICAgICAgICAgb3B0aW9uYWxQcmltaXRpdmUgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHAudmFyaWFkaWMpIHtcbiAgICAgICAgICB0eXBlID0gYHBhcmFtcyAke3R5cGV9W11gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ID0gYCR7dHlwZX0ke29wdGlvbmFsUHJpbWl0aXZlfSAke3RoaXMubmFtZXV0aWxzLmNvbnZlcnRQYXJhbWV0ZXJOYW1lKFxuICAgICAgICAgIHAubmFtZSxcbiAgICAgICAgKX0ke29wdGlvbmFsS2V5d29yZH1gO1xuICAgICAgICBwYXJhbXMucHVzaChzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXMuam9pbignLCAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBpbnRlcmZhY2UgcHJveHkgZm9yIGFuIGludGVyZmFjZSBvciBhbiBhYnN0cmFjdCBjbGFzcy5cbiAgICovXG4gIHByaXZhdGUgZW1pdEludGVyZmFjZVByb3h5KGlmYzogc3BlYy5JbnRlcmZhY2VUeXBlIHwgc3BlYy5DbGFzc1R5cGUpOiB2b2lkIHtcbiAgICBjb25zdCBuYW1lID0gJ19Qcm94eSc7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VGb3IodGhpcy5hc3NlbWJseSwgaWZjKTtcbiAgICBjb25zdCBpc05lc3RlZCA9IHRydWU7XG4gICAgdGhpcy5vcGVuRmlsZUlmTmVlZGVkKG5hbWUsIG5hbWVzcGFjZSwgaXNOZXN0ZWQpO1xuXG4gICAgdGhpcy5jb2RlLmxpbmUoKTtcbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvci5lbWl0RG9jcyhpZmMsIHtcbiAgICAgIGFwaTogJ3R5cGUnLFxuICAgICAgZnFuOiBpZmMuZnFuLFxuICAgIH0pO1xuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0ZvckludGVyZmFjZVByb3h5KGlmYyk7XG5cbiAgICBjb25zdCBpbnRlcmZhY2VGcW4gPSB0aGlzLnR5cGVyZXNvbHZlci50b05hdGl2ZUZxbihpZmMuZnFuKTtcbiAgICBjb25zdCBzdWZmaXggPSBzcGVjLmlzSW50ZXJmYWNlVHlwZShpZmMpXG4gICAgICA/IGA6IERlcHV0eUJhc2UsICR7aW50ZXJmYWNlRnFufWBcbiAgICAgIDogYDogJHtpbnRlcmZhY2VGcW59YDtcbiAgICBjb25zdCBuZXdNb2RpZmllciA9IHRoaXMucHJveHlNdXN0VXNlTmV3TW9kaWZpZXIoaWZjKSA/ICduZXcgJyA6ICcnO1xuXG4gICAgdGhpcy5jb2RlLm9wZW5CbG9jayhcbiAgICAgIGAke25ld01vZGlmaWVyfWludGVybmFsIHNlYWxlZCBjbGFzcyAke25hbWV9ICR7c3VmZml4fWAsXG4gICAgKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgcHJpdmF0ZSBjb25zdHJ1Y3RvclxuICAgIHRoaXMuY29kZS5vcGVuQmxvY2soXG4gICAgICBgcHJpdmF0ZSAke25hbWV9KEJ5UmVmVmFsdWUgcmVmZXJlbmNlKTogYmFzZShyZWZlcmVuY2UpYCxcbiAgICApO1xuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICAvLyBXZSBoYXZlIGFscmVhZHkgb3V0cHV0IGEgbWVtYmVyIChjb25zdHJ1Y3RvciksIHNldHRpbmcgdGhlIGZpcnN0IG1lbWJlciBmbGFnIHRvIHRydWVcbiAgICB0aGlzLmZsYWdGaXJzdE1lbWJlcldyaXR0ZW4odHJ1ZSk7XG5cbiAgICBjb25zdCBkYXRhdHlwZSA9IGZhbHNlO1xuICAgIGNvbnN0IHByb3h5ID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXRJbnRlcmZhY2VNZW1iZXJzRm9yUHJveHlPckRhdGF0eXBlKGlmYywgZGF0YXR5cGUsIHByb3h5KTtcblxuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG4gICAgdGhpcy5jbG9zZUZpbGVJZk5lZWRlZChuYW1lLCBuYW1lc3BhY2UsIGlzTmVzdGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW55IGFuY2VzdG9yIG9mIHRoZSBnaXZlbiB0eXBlIG11c3QgdXNlIHRoZSBgbmV3YFxuICAgKiBtb2RpZmllciB3aGVuIGludHJvZHVjaW5nIGl0J3Mgb3duIHByb3h5LlxuICAgKlxuICAgKiBJZiB0aGUgdHlwZSBpcyBhIGBjbGFzc2AsIHRoZW4gaXQgbXVzdCB1c2UgYG5ld2AgaWYgaXQgZXh0ZW5kcyBhbm90aGVyXG4gICAqIGFic3RyYWN0IGNsYXNzIGRlZmluZWQgaW4gdGhlIHNhbWUgYXNzZW1ibHkgKHNpbmNlIHByb3hpZXMgYXJlIGludGVybmFsLFxuICAgKiBleHRlcm5hbCB0eXBlcycgcHJveGllcyBhcmUgbm90IHZpc2libGUgaW4gdGhhdCBjb250ZXh0KS5cbiAgICpcbiAgICogSWYgdGhlIHR5cGUgaXMgYW4gYGludGVyZmFjZWAsIHRoZW4gaXQgbXVzdCB1c2UgYG5ld2AgaWYgaXQgZXh0ZW5kcyBhbm90aGVyXG4gICAqIGludGVyZmFjZSBmcm9tIHRoZSBzYW1lIGFzc2VtYmx5LlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgdGVzdGVkIHByb3h5LWFibGUgdHlwZSAoYW4gYWJzdHJhY3QgY2xhc3Mgb3IgYW4gaW50ZXJmYWNlKS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbnkgYW5jZXN0b3Igb2YgdGhpcyB0eXBlIGhhcyBhIHZpc2libGUgcHJveHkuXG4gICAqL1xuICBwcml2YXRlIHByb3h5TXVzdFVzZU5ld01vZGlmaWVyKFxuICAgIHR5cGU6IHNwZWMuQ2xhc3NUeXBlIHwgc3BlYy5JbnRlcmZhY2VUeXBlLFxuICApOiBib29sZWFuIHtcbiAgICBpZiAoc3BlYy5pc0NsYXNzVHlwZSh0eXBlKSkge1xuICAgICAgaWYgKHR5cGUuYmFzZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFzZSA9IHRoaXMuZmluZFR5cGUodHlwZS5iYXNlKSBhcyBzcGVjLkNsYXNzVHlwZTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGJhc2UuYXNzZW1ibHkgPT09IHR5cGUuYXNzZW1ibHkgJiZcbiAgICAgICAgKGJhc2UuYWJzdHJhY3RcbiAgICAgICAgICA/IHRydWVcbiAgICAgICAgICA6IC8vIEFuIGFic3RyYWN0IGNsYXNzIGNvdWxkIGV4dGVuZCBhIGNvbmNyZXRlIGNsYXNzLi4uIFdlIG11c3Qgd2FsayB1cCB0aGUgaW5oZXJpdGFuY2UgdHJlZSBpbiB0aGlzIGNhc2UuLi5cbiAgICAgICAgICAgIHRoaXMucHJveHlNdXN0VXNlTmV3TW9kaWZpZXIoYmFzZSkpXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICB0eXBlLmludGVyZmFjZXM/LmZpbmQoXG4gICAgICAgIChmcW4pID0+IHRoaXMuZmluZFR5cGUoZnFuKS5hc3NlbWJseSA9PT0gdHlwZS5hc3NlbWJseSxcbiAgICAgICkgIT0gbnVsbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYW4gSW50ZXJmYWNlIERhdGF0eXBlIGNsYXNzXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBlbWl0IGEgY2xhc3MgaW1wbGVtZW50aW5nIGFuIGludGVyZmFjZSB3aGVuIHRoZSBkYXRhdHlwZSBwcm9wZXJ0eSBpcyB0cnVlIGluIHRoZSBqc2lpIG1vZGVsXG4gICAqIFRoZSBnZW5lcmF0aW9uIG9mIHRoZSBpbnRlcmZhY2UgcHJveHkgbWF5IG5vdCBiZSBuZWVkZWQgaWYgdGhlIGludGVyZmFjZSBpcyBhbHNvIHNldCBhcyBhIGRhdGF0eXBlXG4gICAqL1xuICBwcml2YXRlIGVtaXRJbnRlcmZhY2VEYXRhVHlwZShpZmM6IHNwZWMuSW50ZXJmYWNlVHlwZSk6IHZvaWQge1xuICAgIC8vIEludGVyZmFjZSBkYXRhdHlwZXMgZG8gbm90IG5lZWQgdG8gYmUgcHJlZml4ZWQgYnkgSSwgd2UgY2FuIGNhbGwgY29udmVydENsYXNzTmFtZVxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0Q2xhc3NOYW1lKGlmYyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VGb3IodGhpcy5hc3NlbWJseSwgaWZjKTtcbiAgICBjb25zdCBpc05lc3RlZCA9IHRoaXMuaXNOZXN0ZWQoaWZjKTtcbiAgICB0aGlzLm9wZW5GaWxlSWZOZWVkZWQobmFtZSwgbmFtZXNwYWNlLCBpc05lc3RlZCk7XG5cbiAgICBpZiAoaWZjLnByb3BlcnRpZXM/LmZpbmQoKHByb3ApID0+ICFwcm9wLm9wdGlvbmFsKSAhPSBudWxsKSB7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGJlIGFubm95ZWQgYnkgdGhlIGxhY2sgb2YgaW5pdGlhbGl6YXRpb24gb2Ygbm9uLW51bGxhYmxlIGZpZWxkcyBpbiB0aGlzIGNhc2UuXG4gICAgICB0aGlzLmNvZGUubGluZSgnI3ByYWdtYSB3YXJuaW5nIGRpc2FibGUgQ1M4NjE4Jyk7XG4gICAgICB0aGlzLmNvZGUubGluZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXREb2NzKGlmYywge1xuICAgICAgYXBpOiAndHlwZScsXG4gICAgICBmcW46IGlmYy5mcW4sXG4gICAgfSk7XG4gICAgY29uc3Qgc3VmZml4ID0gYDogJHt0aGlzLnR5cGVyZXNvbHZlci50b05hdGl2ZUZxbihpZmMuZnFuKX1gO1xuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0ZvckludGVyZmFjZURhdGF0eXBlKGlmYyk7XG4gICAgdGhpcy5jb2RlLm9wZW5CbG9jayhgcHVibGljIGNsYXNzICR7bmFtZX0gJHtzdWZmaXh9YCk7XG4gICAgdGhpcy5mbGFnRmlyc3RNZW1iZXJXcml0dGVuKGZhbHNlKTtcbiAgICBjb25zdCBkYXRhdHlwZSA9IHRydWU7XG4gICAgY29uc3QgcHJveHkgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXRJbnRlcmZhY2VNZW1iZXJzRm9yUHJveHlPckRhdGF0eXBlKGlmYywgZGF0YXR5cGUsIHByb3h5KTtcbiAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuICAgIHRoaXMuY2xvc2VGaWxlSWZOZWVkZWQobmFtZSwgbmFtZXNwYWNlLCBpc05lc3RlZCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBib2R5IG9mIHRoZSBpbnRlcmZhY2UgcHJveHkgb3IgZGF0YSB0eXBlIGNsYXNzXG4gICAqXG4gICAqIFRoaXMgbG9vcHMgdGhyb3VnaCBhbGwgdGhlIG1lbWJlciBhbmQgZ2VuZXJhdGVzIHRoZW1cbiAgICovXG4gIHByaXZhdGUgZW1pdEludGVyZmFjZU1lbWJlcnNGb3JQcm94eU9yRGF0YXR5cGUoXG4gICAgaWZjOiBzcGVjLkludGVyZmFjZVR5cGUgfCBzcGVjLkNsYXNzVHlwZSxcbiAgICBkYXRhdHlwZTogYm9vbGVhbixcbiAgICBwcm94eTogYm9vbGVhbixcbiAgKTogdm9pZCB7XG4gICAgLy8gVGhlIGtleSBpcyBpbiB0aGUgZm9ybSAnbWV0aG9kLm5hbWU7cGFyYW1ldGVyMTtwYXJhbWV0ZXIyOycgZXRjXG4gICAgY29uc3QgbWV0aG9kcyA9IG5ldyBNYXA8c3RyaW5nLCBNZXRob2REZWZpbml0aW9uPigpO1xuICAgIC8qXG4gICAgICAgICAgT25seSBnZXQgdGhlIGZpcnN0IGRlY2xhcmF0aW9uIGVuY291bnRlcmVkLCBhbmQga2VlcCBpdCBpZiBpdCBpcyBhYnN0cmFjdC4gVGhlIGxpc3QgY29udGFpbnMgQUxMXG4gICAgICAgICAgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBlbmNvdW50ZXJlZCwgaW4gdGhlIG9yZGVyIGVuY291bnRlcmVkLiBBbiBhYnN0cmFjdCBjbGFzcyBjYW4gaGF2ZSBjb25jcmV0ZVxuICAgICAgICAgIGltcGxlbWVudGF0aW9ucy4gVGhlcmVmb3JlLCB3ZSBvbmx5IGdlbmVyYXRlIG1ldGhvZHMvcHJvcGVydGllcyBpZiB0aGUgZmlyc3QgbWVtYmVyIGVuY291bnRlcmVkXG4gICAgICAgICAgaXMgdW5pbXBsZW1lbnRlZC5cbiAgICAgICAgKi9cbiAgICBjb25zdCBleGNsdWRlZE1ldGhvZDogc3RyaW5nW10gPSBbXTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIG1ldGhvZHMgd2UgYWxyZWFkeSByYW4gaW50byBhbmQgZG9uJ3Qgd2FudCB0byBlbWl0XG4gICAgY29uc3QgZXhjbHVkZWRQcm9wZXJ0aWVzOiBzdHJpbmdbXSA9IFtdOyAvLyBLZWVwcyB0cmFjayBvZiB0aGUgcHJvcGVydGllcyB3ZSBhbHJlYWR5IHJhbiBpbnRvIGFuZCBkb24ndCB3YW50IHRvIGVtaXRcbiAgICBjb25zdCBwcm9wZXJ0aWVzOiB7IFtuYW1lOiBzdHJpbmddOiBQcm9wZXJ0eURlZmluaXRpb24gfSA9IHt9O1xuICAgIGNvbnN0IGNvbGxlY3RBYnN0cmFjdE1lbWJlcnMgPSAoXG4gICAgICBjdXJyZW50VHlwZTogc3BlYy5JbnRlcmZhY2VUeXBlIHwgc3BlYy5DbGFzc1R5cGUsXG4gICAgKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgY3VycmVudFR5cGUucHJvcGVydGllcyA/PyBbXSkge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVkUHJvcGVydGllcy5pbmNsdWRlcyhwcm9wLm5hbWUpKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBuZXZlciBydW4gaW50byB0aGlzIHByb3BlcnR5IGJlZm9yZSBhbmQgaXQgaXMgYWJzdHJhY3QsIHdlIGtlZXAgaXRcbiAgICAgICAgICBpZiAocHJvcC5hYnN0cmFjdCkge1xuICAgICAgICAgICAgcHJvcGVydGllc1twcm9wLm5hbWVdID0geyBwcm9wLCBkZWZpbmluZ1R5cGU6IGN1cnJlbnRUeXBlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4Y2x1ZGVkUHJvcGVydGllcy5wdXNoKHByb3AubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgY3VycmVudFR5cGUubWV0aG9kcyA/PyBbXSkge1xuICAgICAgICBsZXQgbWV0aG9kUGFyYW1ldGVycyA9ICcnO1xuICAgICAgICBpZiAobWV0aG9kLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBtZXRob2QucGFyYW1ldGVycy5mb3JFYWNoKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgbWV0aG9kUGFyYW1ldGVycyArPSBgOyR7dGhpcy50eXBlcmVzb2x2ZXIudG9Eb3ROZXRUeXBlKFxuICAgICAgICAgICAgICBwYXJhbS50eXBlLFxuICAgICAgICAgICAgKX1gO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjbHVkZWRNZXRob2QuaW5jbHVkZXMoYCR7bWV0aG9kLm5hbWV9JHttZXRob2RQYXJhbWV0ZXJzfWApKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBuZXZlciBydW4gaW50byB0aGlzIG1ldGhvZCBiZWZvcmUgYW5kIGl0IGlzIGFic3RyYWN0LCB3ZSBrZWVwIGl0XG4gICAgICAgICAgaWYgKG1ldGhvZC5hYnN0cmFjdCkge1xuICAgICAgICAgICAgbWV0aG9kcy5zZXQoYCR7bWV0aG9kLm5hbWV9JHttZXRob2RQYXJhbWV0ZXJzfWAsIHtcbiAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICBkZWZpbmluZ1R5cGU6IGN1cnJlbnRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4Y2x1ZGVkTWV0aG9kLnB1c2goYCR7bWV0aG9kLm5hbWV9JHttZXRob2RQYXJhbWV0ZXJzfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhc2VzID0gbmV3IEFycmF5PHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlPigpO1xuICAgICAgYmFzZXMucHVzaChcbiAgICAgICAgLi4uKGN1cnJlbnRUeXBlLmludGVyZmFjZXMgPz8gW10pLm1hcCgoaWZhY2UpID0+IHRoaXMuZmluZFR5cGUoaWZhY2UpKSxcbiAgICAgICk7XG4gICAgICBpZiAoc3BlYy5pc0NsYXNzVHlwZShjdXJyZW50VHlwZSkgJiYgY3VycmVudFR5cGUuYmFzZSkge1xuICAgICAgICBiYXNlcy5wdXNoKHRoaXMuZmluZFR5cGUoY3VycmVudFR5cGUuYmFzZSkpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBiYXNlIG9mIGJhc2VzKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZpbmRUeXBlKGJhc2UuZnFuKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGUua2luZCAhPT0gc3BlYy5UeXBlS2luZC5JbnRlcmZhY2UgJiZcbiAgICAgICAgICB0eXBlLmtpbmQgIT09IHNwZWMuVHlwZUtpbmQuQ2xhc3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEJhc2UgaW50ZXJmYWNlcyBvZiBhbiBpbnRlcmZhY2UgbXVzdCBiZSBhbiBpbnRlcmZhY2Ugb3IgYSBjbGFzcyAoJHtiYXNlLmZxbn0gaXMgb2YgdHlwZSAke3R5cGUua2luZH0pYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3RBYnN0cmFjdE1lbWJlcnModHlwZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2xsZWN0QWJzdHJhY3RNZW1iZXJzKGlmYyk7XG5cbiAgICAvLyBlbWl0IGFsbCBwcm9wZXJ0aWVzXG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSkge1xuICAgICAgY29uc3QgcHJvcCA9IGNsb25lKHByb3BlcnRpZXNbcHJvcE5hbWVdKTtcbiAgICAgIHByb3AucHJvcC5hYnN0cmFjdCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0UHJvcGVydHkoaWZjLCBwcm9wLnByb3AsIHByb3AuZGVmaW5pbmdUeXBlLCBkYXRhdHlwZSwgcHJveHkpO1xuICAgIH1cbiAgICAvLyBlbWl0IGFsbCB0aGUgbWV0aG9kc1xuICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZUFuZFBhcmFtZXRlcnMgb2YgbWV0aG9kcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gbWV0aG9kcy5nZXQobWV0aG9kTmFtZUFuZFBhcmFtZXRlcnMpO1xuICAgICAgaWYgKG9yaWdpbmFsTWV0aG9kKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNsb25lKG9yaWdpbmFsTWV0aG9kKTtcbiAgICAgICAgbWV0aG9kLm1ldGhvZC5hYnN0cmFjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXRNZXRob2QoXG4gICAgICAgICAgaWZjLFxuICAgICAgICAgIG1ldGhvZC5tZXRob2QsXG4gICAgICAgICAgbWV0aG9kLmRlZmluaW5nVHlwZSxcbiAgICAgICAgICAvKiBlbWl0Rm9yUHJveHlPckRhdGF0eXBlICovIHRydWUsXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBvdmVybG9hZGVkTWV0aG9kIG9mIHRoaXMuY3JlYXRlT3ZlcmxvYWRzRm9yT3B0aW9uYWxzKFxuICAgICAgICAgIG1ldGhvZC5tZXRob2QsXG4gICAgICAgICkpIHtcbiAgICAgICAgICBvdmVybG9hZGVkTWV0aG9kLmFic3RyYWN0ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5lbWl0TWV0aG9kKFxuICAgICAgICAgICAgaWZjLFxuICAgICAgICAgICAgb3ZlcmxvYWRlZE1ldGhvZCxcbiAgICAgICAgICAgIG1ldGhvZC5kZWZpbmluZ1R5cGUsXG4gICAgICAgICAgICAvKiBlbWl0Rm9yUHJveHlPckRhdGF0eXBlICovIHRydWUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIHByb3BlcnR5XG4gICAqL1xuICBwcml2YXRlIGVtaXRQcm9wZXJ0eShcbiAgICBjbHM6IHNwZWMuVHlwZSxcbiAgICBwcm9wOiBzcGVjLlByb3BlcnR5LFxuICAgIGRlZmluaW5nVHlwZTogc3BlYy5UeXBlLFxuICAgIGRhdGF0eXBlID0gZmFsc2UsXG4gICAgcHJveHkgPSBmYWxzZSxcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5lbWl0TmV3TGluZUlmTmVjZXNzYXJ5KCk7XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnR5cGVyZXNvbHZlci50b05hdGl2ZUZxbihjbHMuZnFuKTtcbiAgICBjb25zdCBhY2Nlc3MgPSB0aGlzLnJlbmRlckFjY2Vzc0xldmVsKHByb3ApO1xuICAgIGNvbnN0IHN0YXRpY0tleVdvcmQgPSBwcm9wLnN0YXRpYyA/ICdzdGF0aWMgJyA6ICcnO1xuICAgIGNvbnN0IHByb3BOYW1lID0gdGhpcy5uYW1ldXRpbHMuY29udmVydFByb3BlcnR5TmFtZShwcm9wLm5hbWUpO1xuXG4gICAgdGhpcy5kb3RuZXREb2NHZW5lcmF0b3IuZW1pdERvY3MocHJvcCwge1xuICAgICAgYXBpOiAnbWVtYmVyJyxcbiAgICAgIGZxbjogZGVmaW5pbmdUeXBlLmZxbixcbiAgICAgIG1lbWJlck5hbWU6IHByb3AubmFtZSxcbiAgICB9KTtcbiAgICBpZiAocHJvcC5vcHRpb25hbCkge1xuICAgICAgdGhpcy5jb2RlLmxpbmUoJ1tKc2lpT3B0aW9uYWxdJyk7XG4gICAgfVxuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0ZvclByb3BlcnR5KHByb3AsIGRhdGF0eXBlKTtcblxuICAgIGxldCBpc092ZXJyaWRlS2V5V29yZCA9ICcnO1xuICAgIGxldCBpc1ZpcnR1YWxLZXlXb3JkID0gJyc7XG4gICAgbGV0IGlzQWJzdHJhY3RLZXl3b3JkID0gJyc7XG5cbiAgICAvLyBJZiB0aGUgcHJvcCBwYXJlbnQgaXMgYSBjbGFzc1xuICAgIGlmIChzcGVjLmlzQ2xhc3NUeXBlKGNscykpIHtcbiAgICAgIGNvbnN0IGltcGxlbWVudGVkSW5CYXNlID0gdGhpcy5pc01lbWJlckRlZmluZWRPbkFuY2VzdG9yKFxuICAgICAgICBjbHMgYXMgc3BlYy5DbGFzc1R5cGUsXG4gICAgICAgIHByb3AsXG4gICAgICApO1xuICAgICAgaWYgKGltcGxlbWVudGVkSW5CYXNlIHx8IGRhdGF0eXBlIHx8IHByb3h5KSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIGlmIHRoZSBwcm9wZXJ0eSBpcyBpbiBhIGRhdGF0eXBlIG9yIHByb3h5IGNsYXNzIG9yIGRlY2xhcmVkIGluIGEgcGFyZW50IGNsYXNzLiBJZiB0aGUgbWVtYmVyIGlzXG4gICAgICAgIC8vIHN0YXRpYywgdXNlIHRoZSBcIm5ld1wiIGtleXdvcmQgaW5zdGVhZCwgdG8gaW5kaWNhdGUgd2UgYXJlIGludGVudGlvbmFsbHkgaGlkaW5nIHRoZSBhbmNlc3RvciBkZWNsYXJhdGlvbiAoYXNcbiAgICAgICAgLy8gQyMgZG9lcyBub3QgaW5oZXJpdCBzdGF0aWNzLCB0aGV5IGNhbiBiZSBoaWRkZW4gYnV0IG5vdCBvdmVycmlkZGVuKS5UaGUgXCJuZXdcIiBrZXl3b3JkIGlzIG9wdGlvbmFsIGluIHRoaXNcbiAgICAgICAgLy8gY29udGV4dCwgYnV0IGhlbHBzIGNsYXJpZnkgaW50ZW50aW9uLlxuICAgICAgICBpc092ZXJyaWRlS2V5V29yZCA9IHByb3Auc3RhdGljID8gJ25ldyAnIDogJ292ZXJyaWRlICc7XG4gICAgICB9IGVsc2UgaWYgKHByb3AuYWJzdHJhY3QpIHtcbiAgICAgICAgLy8gQWJzdHJhY3QgbWVtYmVycyBnZXQgZGVjb3JhdGVkIGFzIHN1Y2hcbiAgICAgICAgaXNBYnN0cmFjdEtleXdvcmQgPSAnYWJzdHJhY3QgJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3Auc3RhdGljICYmICFpbXBsZW1lbnRlZEluQmFzZSkge1xuICAgICAgICAvLyBWaXJ0dWFsIGlmIHRoZSBwcm9wIGlzIG5vdCBzdGF0aWMsIGFuZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gYmFzZSBtZW1iZXIsIHRoaXMgd2F5IHdlIGNhbiBsYXRlciBvdmVycmlkZSBpdC5cbiAgICAgICAgaXNWaXJ0dWFsS2V5V29yZCA9ICd2aXJ0dWFsICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcFR5cGVGUU4gPSB0aGlzLnR5cGVyZXNvbHZlci50b0RvdE5ldFR5cGUocHJvcC50eXBlKTtcbiAgICBjb25zdCBpc09wdGlvbmFsID0gcHJvcC5vcHRpb25hbCA/ICc/JyA6ICcnO1xuICAgIGNvbnN0IHN0YXRlbWVudCA9IGAke2FjY2Vzc30gJHtpc0Fic3RyYWN0S2V5d29yZH0ke2lzVmlydHVhbEtleVdvcmR9JHtzdGF0aWNLZXlXb3JkfSR7aXNPdmVycmlkZUtleVdvcmR9JHtwcm9wVHlwZUZRTn0ke2lzT3B0aW9uYWx9ICR7cHJvcE5hbWV9YDtcbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKHN0YXRlbWVudCk7XG5cbiAgICAvLyBFbWl0IGdldHRlcnNcbiAgICBpZiAoZGF0YXR5cGUgfHwgcHJvcC5jb25zdCB8fCBwcm9wLmFic3RyYWN0KSB7XG4gICAgICB0aGlzLmNvZGUubGluZSgnZ2V0OycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgbm9uLW9wdGlvbmFsLCBhZGQgYSBiYW5nIHRvIHNpbGVuY2UgY29tcGlsZXIgd2FybmluZ1xuICAgICAgY29uc3QgYmFuZyA9IHByb3Aub3B0aW9uYWwgPyAnJyA6ICchJztcbiAgICAgIGlmIChwcm9wLnN0YXRpYykge1xuICAgICAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICAgICBgZ2V0ID0+IEdldFN0YXRpY1Byb3BlcnR5PCR7cHJvcFR5cGVGUU59JHtpc09wdGlvbmFsfT4odHlwZW9mKCR7Y2xhc3NOYW1lfSkpJHtiYW5nfTtgLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb2RlLmxpbmUoXG4gICAgICAgICAgYGdldCA9PiBHZXRJbnN0YW5jZVByb3BlcnR5PCR7cHJvcFR5cGVGUU59JHtpc09wdGlvbmFsfT4oKSR7YmFuZ307YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbWl0IHNldHRlcnNcbiAgICBpZiAoZGF0YXR5cGUgfHwgKCFwcm9wLmltbXV0YWJsZSAmJiBwcm9wLmFic3RyYWN0KSkge1xuICAgICAgdGhpcy5jb2RlLmxpbmUoJ3NldDsnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFwcm9wLmltbXV0YWJsZSkge1xuICAgICAgICBpZiAocHJvcC5zdGF0aWMpIHtcbiAgICAgICAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICAgICAgIGBzZXQgPT4gU2V0U3RhdGljUHJvcGVydHkodHlwZW9mKCR7Y2xhc3NOYW1lfSksIHZhbHVlKTtgLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb2RlLmxpbmUoJ3NldCA9PiBTZXRJbnN0YW5jZVByb3BlcnR5KHZhbHVlKTsnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICB0aGlzLmZsYWdGaXJzdE1lbWJlcldyaXR0ZW4odHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYSBjb25zdGFudCBwcm9wZXJ0eVxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0Q29uc3RQcm9wZXJ0eShjbHM6IHNwZWMuQ2xhc3NUeXBlLCBwcm9wOiBzcGVjLlByb3BlcnR5KTogdm9pZCB7XG4gICAgdGhpcy5lbWl0TmV3TGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgdGhpcy5mbGFnRmlyc3RNZW1iZXJXcml0dGVuKHRydWUpO1xuICAgIGNvbnN0IHByb3BUeXBlID0gdGhpcy50eXBlcmVzb2x2ZXIudG9Eb3ROZXRUeXBlKHByb3AudHlwZSk7XG4gICAgY29uc3QgaXNPcHRpb25hbCA9IHByb3Aub3B0aW9uYWwgPyAnPycgOiAnJztcbiAgICB0aGlzLmRvdG5ldERvY0dlbmVyYXRvci5lbWl0RG9jcyhwcm9wLCB7XG4gICAgICBhcGk6ICdtZW1iZXInLFxuICAgICAgZnFuOiBjbHMuZnFuLFxuICAgICAgbWVtYmVyTmFtZTogcHJvcC5uYW1lLFxuICAgIH0pO1xuICAgIHRoaXMuZG90bmV0UnVudGltZUdlbmVyYXRvci5lbWl0QXR0cmlidXRlc0ZvclByb3BlcnR5KHByb3ApO1xuICAgIGNvbnN0IGFjY2VzcyA9IHRoaXMucmVuZGVyQWNjZXNzTGV2ZWwocHJvcCk7XG4gICAgY29uc3QgcHJvcE5hbWUgPSB0aGlzLm5hbWV1dGlscy5jb252ZXJ0UHJvcGVydHlOYW1lKHByb3AubmFtZSk7XG4gICAgY29uc3Qgc3RhdGljS2V5d29yZCA9IHByb3Auc3RhdGljID8gJ3N0YXRpYyAnIDogJyc7XG5cbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKFxuICAgICAgYCR7YWNjZXNzfSAke3N0YXRpY0tleXdvcmR9JHtwcm9wVHlwZX0ke2lzT3B0aW9uYWx9ICR7cHJvcE5hbWV9YCxcbiAgICApO1xuICAgIHRoaXMuY29kZS5saW5lKCdnZXQ7Jyk7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnR5cGVyZXNvbHZlci50b05hdGl2ZUZxbihjbHMuZnFuKTtcbiAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgbm9uLW9wdGlvbmFsLCBhZGQgYSBiYW5nIHRvIHNpbGVuY2UgdGhlIGNvbXBpbGVyIHdhcm5pbmdcbiAgICBjb25zdCBiYW5nID0gcHJvcC5vcHRpb25hbCA/ICcnIDogJyEnO1xuICAgIGNvbnN0IGluaXRpYWxpemVyID0gcHJvcC5zdGF0aWNcbiAgICAgID8gYD0gR2V0U3RhdGljUHJvcGVydHk8JHtwcm9wVHlwZX0+KHR5cGVvZigke2NsYXNzTmFtZX0pKSR7YmFuZ307YFxuICAgICAgOiBgPSBHZXRJbnN0YW5jZVByb3BlcnR5PCR7cHJvcFR5cGV9Pih0eXBlb2YoJHtjbGFzc05hbWV9KSkke2Jhbmd9O2A7XG4gICAgdGhpcy5jb2RlLmxpbmUoaW5pdGlhbGl6ZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJBY2Nlc3NMZXZlbChtZXRob2Q6IHNwZWMuTWV0aG9kIHwgc3BlYy5Qcm9wZXJ0eSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG1ldGhvZC5wcm90ZWN0ZWQgPyAncHJvdGVjdGVkJyA6ICdwdWJsaWMnO1xuICB9XG5cbiAgcHJpdmF0ZSBpc05lc3RlZCh0eXBlOiBzcGVjLlR5cGUpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuYXNzZW1ibHkudHlwZXMgfHwgIXR5cGUubmFtZXNwYWNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IGAke3R5cGUuYXNzZW1ibHl9LiR7dHlwZS5uYW1lc3BhY2V9YDtcbiAgICByZXR1cm4gcGFyZW50IGluIHRoaXMuYXNzZW1ibHkudHlwZXM7XG4gIH1cblxuICBwcml2YXRlIHRvQ1NoYXJwRmlsZVBhdGgodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dHlwZX0uY3NgO1xuICB9XG5cbiAgcHJpdmF0ZSBvcGVuRmlsZUlmTmVlZGVkKFxuICAgIHR5cGVOYW1lOiBzdHJpbmcsXG4gICAgbmFtZXNwYWNlOiBzdHJpbmcsXG4gICAgaXNOZXN0ZWQ6IGJvb2xlYW4sXG4gICAgdXNpbmdEZXB1dHkgPSB0cnVlLFxuICApOiB2b2lkIHtcbiAgICAvLyBJZiBOZXN0ZWQgdHlwZSwgd2Ugc2hvdWxkbid0IG9wZW4vY2xvc2UgYSBmaWxlXG4gICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZG90bmV0UGFja2FnZUlkID0gdGhpcy5hc3NlbWJseS50YXJnZXRzPy5kb3RuZXQ/LnBhY2thZ2VJZDtcbiAgICBpZiAoIWRvdG5ldFBhY2thZ2VJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIG1vZHVsZSAke3RoaXMuYXNzZW1ibHkubmFtZX0gZG9lcyBub3QgaGF2ZSBhIGRvdG5ldC5wYWNrYWdlSWQgc2V0dGluZ2AsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBmaWxlUGF0aCA9IG5hbWVzcGFjZS5yZXBsYWNlKC9bLl0vZywgJy8nKTtcbiAgICB0aGlzLmNvZGUub3BlbkZpbGUoXG4gICAgICBwYXRoLmpvaW4oZG90bmV0UGFja2FnZUlkLCBmaWxlUGF0aCwgdGhpcy50b0NTaGFycEZpbGVQYXRoKHR5cGVOYW1lKSksXG4gICAgKTtcbiAgICBpZiAodXNpbmdEZXB1dHkpIHtcbiAgICAgIHRoaXMuY29kZS5saW5lKCd1c2luZyBBbWF6b24uSlNJSS5SdW50aW1lLkRlcHV0eTsnKTtcbiAgICAgIHRoaXMuY29kZS5saW5lKCk7XG4gICAgfVxuXG4gICAgLy8gU3VwcHJlc3Mgd2FybmluZ3MgYWJvdXQgbWlzc2luZyBYTUxEb2MsIE9ic29sZXRlIGluY29uc2lzdGVuY2llc1xuICAgIHRoaXMuY29kZS5saW5lKCcjcHJhZ21hIHdhcm5pbmcgZGlzYWJsZSBDUzA2NzIsQ1MwODA5LENTMTU5MScpO1xuICAgIHRoaXMuY29kZS5saW5lKCk7XG5cbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKGBuYW1lc3BhY2UgJHtuYW1lc3BhY2V9YCk7XG4gIH1cblxuICBwcml2YXRlIGNsb3NlRmlsZUlmTmVlZGVkKFxuICAgIHR5cGVOYW1lOiBzdHJpbmcsXG4gICAgbmFtZXNwYWNlOiBzdHJpbmcsXG4gICAgaXNOZXN0ZWQ6IGJvb2xlYW4sXG4gICk6IHZvaWQge1xuICAgIGlmIChpc05lc3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvZGUuY2xvc2VCbG9jaygpO1xuXG4gICAgY29uc3QgZG90bmV0UGFja2FnZUlkID0gdGhpcy5hc3NlbWJseS50YXJnZXRzPy5kb3RuZXQ/LnBhY2thZ2VJZDtcbiAgICBpZiAoIWRvdG5ldFBhY2thZ2VJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIG1vZHVsZSAke3RoaXMuYXNzZW1ibHkubmFtZX0gZG9lcyBub3QgaGF2ZSBhIGRvdG5ldC5wYWNrYWdlSWQgc2V0dGluZ2AsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBmaWxlUGF0aCA9IG5hbWVzcGFjZS5yZXBsYWNlKC9bLl0vZywgJy8nKTtcbiAgICB0aGlzLmNvZGUuY2xvc2VGaWxlKFxuICAgICAgcGF0aC5qb2luKGRvdG5ldFBhY2thZ2VJZCwgZmlsZVBhdGgsIHRoaXMudG9DU2hhcnBGaWxlUGF0aCh0eXBlTmFtZSkpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBmaXJzdE1lbWJlciBib29sZWFuIGZsYWcgdG8ga2VlcCB0cmFjayBvZiB0aGUgZmlyc3QgbWVtYmVyIG9mIGEgbmV3IGZpbGVcbiAgICpcbiAgICogVGhpcyBhdm9pZHMgdW5uZWNlc3Nhcnkgd2hpdGUgbGluZXNcbiAgICovXG4gIHByaXZhdGUgZmxhZ0ZpcnN0TWVtYmVyV3JpdHRlbihmaXJzdDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuZmlyc3RNZW1iZXJXcml0dGVuID0gZmlyc3Q7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYSBuZXcgbGluZSBwcmlvciB0byB3cml0aW5nIGEgbmV3IHByb3BlcnR5LCBtZXRob2QsIGlmIHRoZSBwcm9wZXJ0eSBpcyBub3QgdGhlIGZpcnN0IG9uZSBpbiB0aGUgY2xhc3NcbiAgICpcbiAgICogVGhpcyBhdm9pZHMgdW5uZWNlc3Nhcnkgd2hpdGUgbGluZXMuXG4gICAqL1xuICBwcml2YXRlIGVtaXROZXdMaW5lSWZOZWNlc3NhcnkoKTogdm9pZCB7XG4gICAgLy8gSWYgdGhlIGZpcnN0IG1lbWJlciBoYXMgYWxyZWFkeSBiZWVuIHdyaXR0ZW4sIGl0IGlzIHNhZmUgdG8gd3JpdGUgYSBuZXcgbGluZVxuICAgIGlmICh0aGlzLmZpcnN0TWVtYmVyV3JpdHRlbikge1xuICAgICAgdGhpcy5jb2RlLmxpbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maXJzdE1lbWJlcldyaXR0ZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVtaXRBc3NlbWJseURvY3MoKSB7XG4gICAgdGhpcy5lbWl0TmFtZXNwYWNlRG9jcyhcbiAgICAgIHRoaXMuYXNzZW1ibHkudGFyZ2V0cyEuZG90bmV0IS5uYW1lc3BhY2UsXG4gICAgICB0aGlzLmFzc2VtYmx5Lm5hbWUsXG4gICAgICB0aGlzLmFzc2VtYmx5LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhbiB1bnVzZWQsIGVtcHR5IGNsYXNzIGNhbGxlZCBgTmFtZXNwYWNlRG9jYCB0byBhdHRhY2ggdGhlIG1vZHVsZSBSRUFETUUgdG9cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gd2F5IHRvIGF0dGFjaCBkb2MgY29tbWVudHMgdG8gYSBuYW1lc3BhY2UgaW4gQyMsIGFuZCB0aGlzIHRyaWNrIGhhcyBiZWVuXG4gICAqIHNlbWktc3RhbmRhcmRpemVkIGJ5IE5Eb2MgYW5kIFNhbmRjYXN0bGUgSGVscCBGaWxlIEJ1aWxkZXIuXG4gICAqXG4gICAqIERvY0ZYIGRvZXNuJ3Qgc3VwcG9ydCBpdCBvdXQgb2YgdGhlIGJveCwgYnV0IHdlIHNob3VsZCBiZSBhYmxlIHRvIGdldCB0aGVyZSB3aXRoIGFcbiAgICogYml0IG9mIGhhY2tlcnkuXG4gICAqXG4gICAqIEluIGFueSBjYXNlLCB3ZSBuZWVkIGEgcGxhY2UgdG8gYXR0YWNoIHRoZSBkb2NzIHdoZXJlIHRoZXkgY2FuIGJlIHRyYW5zcG9ydGVkIGFyb3VuZCxcbiAgICogbWlnaHQgYXMgd2VsbCBiZSB0aGlzIG1ldGhvZC5cbiAgICovXG4gIHByaXZhdGUgZW1pdE5hbWVzcGFjZURvY3MoXG4gICAgbmFtZXNwYWNlOiBzdHJpbmcsXG4gICAganNpaUZxbjogc3RyaW5nLFxuICAgIGRvY1NvdXJjZTogc3BlYy5UYXJnZXRhYmxlICYgc3BlYy5SZWFkTWVDb250YWluZXIsXG4gICkge1xuICAgIGlmICghZG9jU291cmNlLnJlYWRtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9ICdOYW1lc3BhY2VEb2MnO1xuICAgIHRoaXMub3BlbkZpbGVJZk5lZWRlZChjbGFzc05hbWUsIG5hbWVzcGFjZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIHRoaXMuZG90bmV0RG9jR2VuZXJhdG9yLmVtaXRNYXJrZG93bkFzUmVtYXJrcyhkb2NTb3VyY2UucmVhZG1lLm1hcmtkb3duLCB7XG4gICAgICBhcGk6ICdtb2R1bGVSZWFkbWUnLFxuICAgICAgbW9kdWxlRnFuOiBqc2lpRnFuLFxuICAgIH0pO1xuICAgIHRoaXMuZW1pdEhpZGVBdHRyaWJ1dGUoKTtcbiAgICAvLyBUcmFkaXRpb25hbGx5IHRoaXMgY2xhc3MgaXMgbWFkZSAnaW50ZXJuYWwnLCBidXQgdGhhdCBpbnRlcmFjdHMgcG9vcmx5IHdpdGggRG9jRlgncyBkZWZhdWx0IGZpbHRlcnNcbiAgICAvLyB3aGljaCBhcmVuJ3Qgb3ZlcnJpZGFibGUuIFNvIHdlIG1ha2UgaXQgcHVibGljLCBidXQgdXNlIGF0dHJpYnV0ZXMgdG8gaGlkZSBpdCBmcm9tIHVzZXJzJyBJbnRlbGxpU2Vuc2UsXG4gICAgLy8gc28gdGhhdCB3ZSBjYW4gYWNjZXNzIHRoZSBjbGFzcyBpbiBEb2NGWC5cbiAgICB0aGlzLmNvZGUub3BlbkJsb2NrKGBwdWJsaWMgY2xhc3MgJHtjbGFzc05hbWV9YCk7XG4gICAgdGhpcy5jb2RlLmNsb3NlQmxvY2soKTtcbiAgICB0aGlzLmNsb3NlRmlsZUlmTmVlZGVkKGNsYXNzTmFtZSwgbmFtZXNwYWNlLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhbiBhdHRyaWJ1dGUgdGhhdCB3aWxsIGhpZGUgdGhlIHN1YnNlcXVlbnQgQVBJIGVsZW1lbnQgZnJvbSB1c2Vyc1xuICAgKi9cbiAgcHJpdmF0ZSBlbWl0SGlkZUF0dHJpYnV0ZSgpIHtcbiAgICB0aGlzLmNvZGUubGluZShcbiAgICAgICdbU3lzdGVtLkNvbXBvbmVudE1vZGVsLkVkaXRvckJyb3dzYWJsZShTeXN0ZW0uQ29tcG9uZW50TW9kZWwuRWRpdG9yQnJvd3NhYmxlU3RhdGUuTmV2ZXIpXScsXG4gICAgKTtcbiAgfVxufVxuIl19