"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeMaker = void 0;
const util = require("util");
const caseutils = require("./case-utils");
const filebuff_1 = require("./filebuff");
/**
 * Multi-file text writer with some code-generation features.
 */
class CodeMaker {
    constructor({ indentationLevel = 4, indentCharacter = ' ', } = {}) {
        this.currIndent = 0;
        this.files = new Array();
        this.excludes = new Array();
        /**
         * Formats an block open statement.
         */
        this.openBlockFormatter = (s) => `${s} {`;
        /**
         * Formats a block close statement.
         */
        this.closeBlockFormatter = () => '}';
        this.indentation = indentationLevel;
        this.indentCharacter = indentCharacter;
    }
    get currentIndentLength() {
        return this.currIndent * this.indentation;
    }
    /**
     * Saves all the files created in this code maker.
     * @param rootDir The root directory for all saved files.
     * @returns A sorted list of all the files saved (absolute paths).
     */
    async save(rootDir) {
        const paths = this.files
            .filter((file) => !this.excludes.includes(file.filePath))
            .map((file) => file.save(rootDir));
        return (await Promise.all(paths)).sort();
    }
    /**
     * Sets the name of the current file we are working with.
     * Note that this doesn't really create a new file (files are only created when save() is called.
     * Use `closeFile` to close this file.
     * @param filePath The relative path of the new file.
     */
    openFile(filePath) {
        if (this.currentFile) {
            throw new Error(`Cannot open file ${filePath} without closing the previous file ${this.currentFile.filePath}`);
        }
        this.currentFile = new filebuff_1.default(filePath);
    }
    /**
     * Indicates that we finished generating the current file.
     * @param filePath The relative file path (must be the same as one passed to openFile)
     */
    closeFile(filePath) {
        if (!this.currentFile) {
            throw new Error(`Cannot close file ${filePath}. It was never opened`);
        }
        if (this.currentFile.filePath !== filePath) {
            throw new Error(`Cannot close file ${filePath}. The currently opened file is ${this.currentFile.filePath}`);
        }
        this.files.push(this.currentFile);
        this.currentFile = undefined;
    }
    /**
     * Emits a line into the currently opened file.
     * Line is emitted with the current level of indentation.
     * If no arguments are provided, an empty new line is emitted.
     * @param fmt String format arguments (passed to `util.format`)
     * @param args String arguments
     */
    line(fmt, ...args) {
        if (!this.currentFile) {
            throw new Error('Cannot emit source lines without opening a file');
        }
        if (fmt) {
            fmt = this.makeIndent() + fmt;
            this.currentFile.write(util.format(fmt, ...args));
        }
        this.currentFile.write('\n');
    }
    /**
     * Same as `open`.
     */
    indent(textBefore) {
        this.open(textBefore);
    }
    /**
     * Same as `close`.
     */
    unindent(textAfter) {
        this.close(textAfter);
    }
    /**
     * Increases the indentation level by `indentation` spaces for the next line.
     * @param textBefore Text to emit before the newline (i.e. block open).
     */
    open(textBefore) {
        this.line(textBefore);
        this.currIndent++;
    }
    /**
     * Decreases the indentation level by `indentation` for the next line.
     * @param textAfter Text to emit in the line after indentation was decreased.
     *                  If `false` no line will be emitted at all, but the indent
     *                  counter will be decremented.
     */
    close(textAfter) {
        this.currIndent--;
        if (textAfter !== false) {
            this.line(textAfter);
        }
    }
    /**
     * Opens a code block. The formatting of the block is determined by `openBlockFormatter`.
     * @param text The text to pass to the formatter.
     */
    openBlock(text) {
        this.open(this.openBlockFormatter(text));
    }
    /**
     * Closes a code block. The formatting of the block is determined by `closeBlockFormatter`.
     * @param text The text to pass to the formatter.
     */
    closeBlock(text) {
        this.close(this.closeBlockFormatter(text));
    }
    /**
     * Adds a file to the exclude list. This means this file will not be saved during save().
     * @param filePath The relative path of the file.
     */
    exclude(filePath) {
        this.excludes.push(filePath);
    }
    /**
     * convertsStringToCamelCase
     */
    toCamelCase(...args) {
        return caseutils.toCamelCase(...args);
    }
    /**
     * ConvertsStringToPascalCase
     */
    toPascalCase(...args) {
        return caseutils.toPascalCase(...args);
    }
    /**
     * convert_string_to_snake_case
     * @param sep Separator (defaults to '_')
     */
    toSnakeCase(s, sep = '_') {
        return caseutils.toSnakeCase(s, sep);
    }
    makeIndent() {
        const length = this.currentIndentLength;
        if (length <= 0) {
            return '';
        }
        return this.indentCharacter.repeat(length);
    }
}
exports.CodeMaker = CodeMaker;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZW1ha2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29kZW1ha2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUU3QiwwQ0FBMEM7QUFDMUMseUNBQW9DO0FBRXBDOztHQUVHO0FBQ0gsTUFBYSxTQUFTO0lBaUJwQixZQUFtQixFQUNqQixnQkFBZ0IsR0FBRyxDQUFDLEVBQ3BCLGVBQWUsR0FBRyxHQUFHLE1BSW5CLEVBQUU7UUFYRSxlQUFVLEdBQUcsQ0FBQyxDQUFDO1FBRU4sVUFBSyxHQUFHLElBQUksS0FBSyxFQUFjLENBQUM7UUFDaEMsYUFBUSxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7UUFpQmhEOztXQUVHO1FBQ0ksdUJBQWtCLEdBQTJCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1FBRXBFOztXQUVHO1FBQ0ksd0JBQW1CLEdBQW1DLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQztRQWhCckUsSUFBSSxDQUFDLFdBQVcsR0FBRyxnQkFBZ0IsQ0FBQztRQUNwQyxJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBVyxtQkFBbUI7UUFDNUIsT0FBTyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDNUMsQ0FBQztJQVlEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQWU7UUFDL0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUs7YUFDckIsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUN4RCxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNyQyxPQUFPLENBQUMsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksUUFBUSxDQUFDLFFBQWdCO1FBQzlCLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNwQixNQUFNLElBQUksS0FBSyxDQUNiLG9CQUFvQixRQUFRLHNDQUFzQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUM5RixDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksa0JBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksU0FBUyxDQUFDLFFBQWdCO1FBQy9CLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLFFBQVEsdUJBQXVCLENBQUMsQ0FBQztTQUN2RTtRQUNELElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO1lBQzFDLE1BQU0sSUFBSSxLQUFLLENBQ2IscUJBQXFCLFFBQVEsa0NBQWtDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQzNGLENBQUM7U0FDSDtRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksSUFBSSxDQUFDLEdBQVksRUFBRSxHQUFHLElBQWM7UUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO1NBQ3BFO1FBRUQsSUFBSSxHQUFHLEVBQUU7WUFDUCxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDbkQ7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsVUFBbUI7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRLENBQUMsU0FBMEI7UUFDeEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksSUFBSSxDQUFDLFVBQW1CO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLEtBQUssQ0FBQyxTQUEwQjtRQUNyQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEIsSUFBSSxTQUFTLEtBQUssS0FBSyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksU0FBUyxDQUFDLElBQVk7UUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksVUFBVSxDQUFDLElBQWE7UUFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksT0FBTyxDQUFDLFFBQWdCO1FBQzdCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRztJQUNJLFdBQVcsQ0FBQyxHQUFHLElBQWM7UUFDbEMsT0FBTyxTQUFTLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksWUFBWSxDQUFDLEdBQUcsSUFBYztRQUNuQyxPQUFPLFNBQVMsQ0FBQyxZQUFZLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksV0FBVyxDQUFDLENBQVMsRUFBRSxHQUFHLEdBQUcsR0FBRztRQUNyQyxPQUFPLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFTyxVQUFVO1FBQ2hCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztRQUN4QyxJQUFJLE1BQU0sSUFBSSxDQUFDLEVBQUU7WUFDZixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3QyxDQUFDO0NBQ0Y7QUFyTUQsOEJBcU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICd1dGlsJztcblxuaW1wb3J0ICogYXMgY2FzZXV0aWxzIGZyb20gJy4vY2FzZS11dGlscyc7XG5pbXBvcnQgRmlsZUJ1ZmZlciBmcm9tICcuL2ZpbGVidWZmJztcblxuLyoqXG4gKiBNdWx0aS1maWxlIHRleHQgd3JpdGVyIHdpdGggc29tZSBjb2RlLWdlbmVyYXRpb24gZmVhdHVyZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlTWFrZXIge1xuICAvKipcbiAgICogVGhlIGluZGVudGF0aW9uIGxldmVsIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgcHVibGljIGluZGVudGF0aW9uOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgdG8gdXNlIGZvciBpbmRlbnRhdGlvbi4gV2hlbiBzZXR0aW5nIHRoaXMgdG8gYFxcdGAsIGNvbnNpZGVyXG4gICAqIGFsc28gc2V0dGluZyBgaW5kZW50YXRpb25gIHRvIGAxYC5cbiAgICovXG4gIHB1YmxpYyBpbmRlbnRDaGFyYWN0ZXI6ICcgJyB8ICdcXHQnO1xuXG4gIHByaXZhdGUgY3VyckluZGVudCA9IDA7XG4gIHByaXZhdGUgY3VycmVudEZpbGU/OiBGaWxlQnVmZmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGZpbGVzID0gbmV3IEFycmF5PEZpbGVCdWZmZXI+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZXhjbHVkZXMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcih7XG4gICAgaW5kZW50YXRpb25MZXZlbCA9IDQsXG4gICAgaW5kZW50Q2hhcmFjdGVyID0gJyAnLFxuICB9OiB7XG4gICAgaW5kZW50YXRpb25MZXZlbD86IENvZGVNYWtlclsnaW5kZW50YXRpb24nXTtcbiAgICBpbmRlbnRDaGFyYWN0ZXI/OiBDb2RlTWFrZXJbJ2luZGVudENoYXJhY3RlciddO1xuICB9ID0ge30pIHtcbiAgICB0aGlzLmluZGVudGF0aW9uID0gaW5kZW50YXRpb25MZXZlbDtcbiAgICB0aGlzLmluZGVudENoYXJhY3RlciA9IGluZGVudENoYXJhY3RlcjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY3VycmVudEluZGVudExlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJJbmRlbnQgKiB0aGlzLmluZGVudGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgYW4gYmxvY2sgb3BlbiBzdGF0ZW1lbnQuXG4gICAqL1xuICBwdWJsaWMgb3BlbkJsb2NrRm9ybWF0dGVyOiAocz86IHN0cmluZykgPT4gc3RyaW5nID0gKHMpID0+IGAke3N9IHtgO1xuXG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgYmxvY2sgY2xvc2Ugc3RhdGVtZW50LlxuICAgKi9cbiAgcHVibGljIGNsb3NlQmxvY2tGb3JtYXR0ZXI6IChzPzogc3RyaW5nKSA9PiBzdHJpbmcgfCBmYWxzZSA9ICgpID0+ICd9JztcblxuICAvKipcbiAgICogU2F2ZXMgYWxsIHRoZSBmaWxlcyBjcmVhdGVkIGluIHRoaXMgY29kZSBtYWtlci5cbiAgICogQHBhcmFtIHJvb3REaXIgVGhlIHJvb3QgZGlyZWN0b3J5IGZvciBhbGwgc2F2ZWQgZmlsZXMuXG4gICAqIEByZXR1cm5zIEEgc29ydGVkIGxpc3Qgb2YgYWxsIHRoZSBmaWxlcyBzYXZlZCAoYWJzb2x1dGUgcGF0aHMpLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNhdmUocm9vdERpcjogc3RyaW5nKSB7XG4gICAgY29uc3QgcGF0aHMgPSB0aGlzLmZpbGVzXG4gICAgICAuZmlsdGVyKChmaWxlKSA9PiAhdGhpcy5leGNsdWRlcy5pbmNsdWRlcyhmaWxlLmZpbGVQYXRoKSlcbiAgICAgIC5tYXAoKGZpbGUpID0+IGZpbGUuc2F2ZShyb290RGlyKSk7XG4gICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChwYXRocykpLnNvcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGZpbGUgd2UgYXJlIHdvcmtpbmcgd2l0aC5cbiAgICogTm90ZSB0aGF0IHRoaXMgZG9lc24ndCByZWFsbHkgY3JlYXRlIGEgbmV3IGZpbGUgKGZpbGVzIGFyZSBvbmx5IGNyZWF0ZWQgd2hlbiBzYXZlKCkgaXMgY2FsbGVkLlxuICAgKiBVc2UgYGNsb3NlRmlsZWAgdG8gY2xvc2UgdGhpcyBmaWxlLlxuICAgKiBAcGFyYW0gZmlsZVBhdGggVGhlIHJlbGF0aXZlIHBhdGggb2YgdGhlIG5ldyBmaWxlLlxuICAgKi9cbiAgcHVibGljIG9wZW5GaWxlKGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50RmlsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IG9wZW4gZmlsZSAke2ZpbGVQYXRofSB3aXRob3V0IGNsb3NpbmcgdGhlIHByZXZpb3VzIGZpbGUgJHt0aGlzLmN1cnJlbnRGaWxlLmZpbGVQYXRofWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudEZpbGUgPSBuZXcgRmlsZUJ1ZmZlcihmaWxlUGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgd2UgZmluaXNoZWQgZ2VuZXJhdGluZyB0aGUgY3VycmVudCBmaWxlLlxuICAgKiBAcGFyYW0gZmlsZVBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aCAobXVzdCBiZSB0aGUgc2FtZSBhcyBvbmUgcGFzc2VkIHRvIG9wZW5GaWxlKVxuICAgKi9cbiAgcHVibGljIGNsb3NlRmlsZShmaWxlUGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRGaWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjbG9zZSBmaWxlICR7ZmlsZVBhdGh9LiBJdCB3YXMgbmV2ZXIgb3BlbmVkYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRGaWxlLmZpbGVQYXRoICE9PSBmaWxlUGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNsb3NlIGZpbGUgJHtmaWxlUGF0aH0uIFRoZSBjdXJyZW50bHkgb3BlbmVkIGZpbGUgaXMgJHt0aGlzLmN1cnJlbnRGaWxlLmZpbGVQYXRofWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZmlsZXMucHVzaCh0aGlzLmN1cnJlbnRGaWxlKTtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgbGluZSBpbnRvIHRoZSBjdXJyZW50bHkgb3BlbmVkIGZpbGUuXG4gICAqIExpbmUgaXMgZW1pdHRlZCB3aXRoIHRoZSBjdXJyZW50IGxldmVsIG9mIGluZGVudGF0aW9uLlxuICAgKiBJZiBubyBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBhbiBlbXB0eSBuZXcgbGluZSBpcyBlbWl0dGVkLlxuICAgKiBAcGFyYW0gZm10IFN0cmluZyBmb3JtYXQgYXJndW1lbnRzIChwYXNzZWQgdG8gYHV0aWwuZm9ybWF0YClcbiAgICogQHBhcmFtIGFyZ3MgU3RyaW5nIGFyZ3VtZW50c1xuICAgKi9cbiAgcHVibGljIGxpbmUoZm10Pzogc3RyaW5nLCAuLi5hcmdzOiBzdHJpbmdbXSkge1xuICAgIGlmICghdGhpcy5jdXJyZW50RmlsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW1pdCBzb3VyY2UgbGluZXMgd2l0aG91dCBvcGVuaW5nIGEgZmlsZScpO1xuICAgIH1cblxuICAgIGlmIChmbXQpIHtcbiAgICAgIGZtdCA9IHRoaXMubWFrZUluZGVudCgpICsgZm10O1xuICAgICAgdGhpcy5jdXJyZW50RmlsZS53cml0ZSh1dGlsLmZvcm1hdChmbXQsIC4uLmFyZ3MpKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRGaWxlLndyaXRlKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGBvcGVuYC5cbiAgICovXG4gIHB1YmxpYyBpbmRlbnQodGV4dEJlZm9yZT86IHN0cmluZykge1xuICAgIHRoaXMub3Blbih0ZXh0QmVmb3JlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGBjbG9zZWAuXG4gICAqL1xuICBwdWJsaWMgdW5pbmRlbnQodGV4dEFmdGVyPzogc3RyaW5nIHwgZmFsc2UpIHtcbiAgICB0aGlzLmNsb3NlKHRleHRBZnRlcik7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRoZSBpbmRlbnRhdGlvbiBsZXZlbCBieSBgaW5kZW50YXRpb25gIHNwYWNlcyBmb3IgdGhlIG5leHQgbGluZS5cbiAgICogQHBhcmFtIHRleHRCZWZvcmUgVGV4dCB0byBlbWl0IGJlZm9yZSB0aGUgbmV3bGluZSAoaS5lLiBibG9jayBvcGVuKS5cbiAgICovXG4gIHB1YmxpYyBvcGVuKHRleHRCZWZvcmU/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmxpbmUodGV4dEJlZm9yZSk7XG4gICAgdGhpcy5jdXJySW5kZW50Kys7XG4gIH1cblxuICAvKipcbiAgICogRGVjcmVhc2VzIHRoZSBpbmRlbnRhdGlvbiBsZXZlbCBieSBgaW5kZW50YXRpb25gIGZvciB0aGUgbmV4dCBsaW5lLlxuICAgKiBAcGFyYW0gdGV4dEFmdGVyIFRleHQgdG8gZW1pdCBpbiB0aGUgbGluZSBhZnRlciBpbmRlbnRhdGlvbiB3YXMgZGVjcmVhc2VkLlxuICAgKiAgICAgICAgICAgICAgICAgIElmIGBmYWxzZWAgbm8gbGluZSB3aWxsIGJlIGVtaXR0ZWQgYXQgYWxsLCBidXQgdGhlIGluZGVudFxuICAgKiAgICAgICAgICAgICAgICAgIGNvdW50ZXIgd2lsbCBiZSBkZWNyZW1lbnRlZC5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSh0ZXh0QWZ0ZXI/OiBzdHJpbmcgfCBmYWxzZSkge1xuICAgIHRoaXMuY3VyckluZGVudC0tO1xuICAgIGlmICh0ZXh0QWZ0ZXIgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxpbmUodGV4dEFmdGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYSBjb2RlIGJsb2NrLiBUaGUgZm9ybWF0dGluZyBvZiB0aGUgYmxvY2sgaXMgZGV0ZXJtaW5lZCBieSBgb3BlbkJsb2NrRm9ybWF0dGVyYC5cbiAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gcGFzcyB0byB0aGUgZm9ybWF0dGVyLlxuICAgKi9cbiAgcHVibGljIG9wZW5CbG9jayh0ZXh0OiBzdHJpbmcpIHtcbiAgICB0aGlzLm9wZW4odGhpcy5vcGVuQmxvY2tGb3JtYXR0ZXIodGV4dCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhIGNvZGUgYmxvY2suIFRoZSBmb3JtYXR0aW5nIG9mIHRoZSBibG9jayBpcyBkZXRlcm1pbmVkIGJ5IGBjbG9zZUJsb2NrRm9ybWF0dGVyYC5cbiAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gcGFzcyB0byB0aGUgZm9ybWF0dGVyLlxuICAgKi9cbiAgcHVibGljIGNsb3NlQmxvY2sodGV4dD86IHN0cmluZykge1xuICAgIHRoaXMuY2xvc2UodGhpcy5jbG9zZUJsb2NrRm9ybWF0dGVyKHRleHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZmlsZSB0byB0aGUgZXhjbHVkZSBsaXN0LiBUaGlzIG1lYW5zIHRoaXMgZmlsZSB3aWxsIG5vdCBiZSBzYXZlZCBkdXJpbmcgc2F2ZSgpLlxuICAgKiBAcGFyYW0gZmlsZVBhdGggVGhlIHJlbGF0aXZlIHBhdGggb2YgdGhlIGZpbGUuXG4gICAqL1xuICBwdWJsaWMgZXhjbHVkZShmaWxlUGF0aDogc3RyaW5nKSB7XG4gICAgdGhpcy5leGNsdWRlcy5wdXNoKGZpbGVQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJ0c1N0cmluZ1RvQ2FtZWxDYXNlXG4gICAqL1xuICBwdWJsaWMgdG9DYW1lbENhc2UoLi4uYXJnczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gY2FzZXV0aWxzLnRvQ2FtZWxDYXNlKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzU3RyaW5nVG9QYXNjYWxDYXNlXG4gICAqL1xuICBwdWJsaWMgdG9QYXNjYWxDYXNlKC4uLmFyZ3M6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIGNhc2V1dGlscy50b1Bhc2NhbENhc2UoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogY29udmVydF9zdHJpbmdfdG9fc25ha2VfY2FzZVxuICAgKiBAcGFyYW0gc2VwIFNlcGFyYXRvciAoZGVmYXVsdHMgdG8gJ18nKVxuICAgKi9cbiAgcHVibGljIHRvU25ha2VDYXNlKHM6IHN0cmluZywgc2VwID0gJ18nKSB7XG4gICAgcmV0dXJuIGNhc2V1dGlscy50b1NuYWtlQ2FzZShzLCBzZXApO1xuICB9XG5cbiAgcHJpdmF0ZSBtYWtlSW5kZW50KCk6IHN0cmluZyB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5jdXJyZW50SW5kZW50TGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbmRlbnRDaGFyYWN0ZXIucmVwZWF0KGxlbmd0aCk7XG4gIH1cbn1cbiJdfQ==