"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const caseutils = require("./case-utils");
const filebuff_1 = require("./filebuff");
/**
 * Multi-file text writer with some code-generation features.
 */
class CodeMaker {
    constructor() {
        /**
           * The indentation level of the file.
           */
        this.indentation = 4;
        this.currIndent = 0;
        this.files = new Array();
        this.excludes = new Array();
        /**
           * Formats an block open statement.
           */
        this.openBlockFormatter = s => `${s} {`;
        /**
           * Formats a block close statement.
           */
        this.closeBlockFormatter = () => '}';
    }
    /**
       * Saves all the files created in this code maker.
       * @param rootDir The root directory for all saved files.
       * @returns A sorted list of all the files saved (absolute paths).
       */
    async save(rootDir) {
        const paths = this.files
            .filter(file => !this.excludes.includes(file.filePath))
            .map(file => file.save(rootDir));
        return (await Promise.all(paths)).sort();
    }
    /**
       * Sets the name of the current file we are working with.
       * Note that this doesn't really create a new file (files are only created when save() is called.
       * Use `closeFile` to close this file.
       * @param filePath The relative path of the new file.
       */
    openFile(filePath) {
        if (this.currentFile) {
            throw new Error(`Cannot open file ${filePath} without closing the previous file ${this.currentFile.filePath}`);
        }
        this.currentFile = new filebuff_1.default(filePath);
    }
    /**
       * Indicates that we finished generating the current file.
       * @param filePath The relative file path (must be the same as one passed to openFile)
       */
    closeFile(filePath) {
        if (!this.currentFile) {
            throw new Error(`Cannot close file ${filePath}. It was never opened`);
        }
        if (this.currentFile.filePath !== filePath) {
            throw new Error(`Cannot close file ${filePath}. The currently opened file is ${this.currentFile.filePath}`);
        }
        this.files.push(this.currentFile);
        this.currentFile = undefined;
    }
    /**
       * Emits a line into the currently opened file.
       * Line is emitted with the current level of indentation.
       * If no arguments are provided, an empty new line is emitted.
       * @param fmt String format arguments (passed to `util.format`)
       * @param args String arguments
       */
    line(fmt, ...args) {
        if (!this.currentFile) {
            throw new Error('Cannot emit source lines without openning a file');
        }
        if (fmt) {
            fmt = this.makeIndent() + fmt;
            this.currentFile.write(util.format(fmt, ...args));
        }
        this.currentFile.write('\n');
    }
    /**
       * Same as `open`.
       */
    indent(textBefore) {
        this.open(textBefore);
    }
    /**
       * Same as `close`.
       */
    unindent(textAfter) {
        this.close(textAfter);
    }
    /**
       * Increases the indentation level by `indentation` spaces for the next line.
       * @param textBefore Text to emit before the newline (i.e. block open).
       */
    open(textBefore) {
        this.line(textBefore);
        this.currIndent++;
    }
    /**
       * Decreases the indentation level by `indentation` for the next line.
       * @param textAfter Text to emit in the line after indentation was decreased.
       */
    close(textAfter) {
        this.currIndent--;
        this.line(textAfter);
    }
    /**
       * Opens a code block. The formatting of the block is determined by `openBlockFormatter`.
       * @param text The text to pass to the formatter.
       */
    openBlock(text) {
        this.open(this.openBlockFormatter(text));
    }
    /**
       * Closes a code block. The formatting of the block is determined by `closeBlockFormatter`.
       * @param text The text to pass to the formatter.
       */
    closeBlock(text) {
        this.close(this.closeBlockFormatter(text));
    }
    /**
       * Adds a file to the exclude list. This means this file will not be saved during save().
       * @param filePath The relative path of the file.
       */
    exclude(filePath) {
        this.excludes.push(filePath);
    }
    /**
       * convertsStringToCamelCase
       */
    toCamelCase(...args) {
        return caseutils.toCamelCase(...args);
    }
    /**
       * ConvertsStringToPascalCase
       */
    toPascalCase(...args) {
        return caseutils.toPascalCase(...args);
    }
    /**
       * convert_string_to_snake_case
       * @param sep Separator (defaults to '_')
       */
    toSnakeCase(s, sep = '_') {
        return caseutils.toSnakeCase(s, sep);
    }
    makeIndent() {
        let spaces = '';
        for (let i = 0; i < this.currIndent; ++i) {
            for (let j = 0; j < this.indentation; ++j) {
                spaces += ' ';
            }
        }
        return spaces;
    }
}
exports.CodeMaker = CodeMaker;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZW1ha2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29kZW1ha2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsNkJBQTZCO0FBQzdCLDBDQUEwQztBQUMxQyx5Q0FBb0M7QUFFcEM7O0dBRUc7QUFDSCxNQUFhLFNBQVM7SUFBdEI7UUFDRTs7YUFFSztRQUNFLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBRWYsZUFBVSxHQUFHLENBQUMsQ0FBQztRQUVOLFVBQUssR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO1FBQ2hDLGFBQVEsR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO1FBRWhEOzthQUVLO1FBQ0UsdUJBQWtCLEdBQTJCLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztRQUVsRTs7YUFFSztRQUNFLHdCQUFtQixHQUEyQixHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7SUF1SmpFLENBQUM7SUFySkM7Ozs7U0FJSztJQUNFLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBZTtRQUMvQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSzthQUNyQixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUN0RCxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDbkMsT0FBTyxDQUFDLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFRDs7Ozs7U0FLSztJQUNFLFFBQVEsQ0FBQyxRQUFnQjtRQUM5QixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsUUFBUSxzQ0FBc0MsSUFBSSxD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QUcsR0FBRyxHQUFHO1FBQ3JDLE9BQU8sU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVPLFVBQVU7UUFDaEIsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQ3hDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxFQUFFO2dCQUN6QyxNQUFNLElBQUksR0FBRyxDQUFDO2FBQ2Y7U0FDRjtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7Q0FDRjtBQTFLRCw4QkEwS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY2FzZXV0aWxzIGZyb20gJy4vY2FzZS11dGlscyc7XG5pbXBvcnQgRmlsZUJ1ZmZlciBmcm9tICcuL2ZpbGVidWZmJztcblxuLyoqXG4gKiBNdWx0aS1maWxlIHRleHQgd3JpdGVyIHdpdGggc29tZSBjb2RlLWdlbmVyYXRpb24gZmVhdHVyZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlTWFrZXIge1xuICAvKipcbiAgICAgKiBUaGUgaW5kZW50YXRpb24gbGV2ZWwgb2YgdGhlIGZpbGUuXG4gICAgICovXG4gIHB1YmxpYyBpbmRlbnRhdGlvbiA9IDQ7XG5cbiAgcHJpdmF0ZSBjdXJySW5kZW50ID0gMDtcbiAgcHJpdmF0ZSBjdXJyZW50RmlsZT86IEZpbGVCdWZmZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZmlsZXMgPSBuZXcgQXJyYXk8RmlsZUJ1ZmZlcj4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBleGNsdWRlcyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgLyoqXG4gICAgICogRm9ybWF0cyBhbiBibG9jayBvcGVuIHN0YXRlbWVudC5cbiAgICAgKi9cbiAgcHVibGljIG9wZW5CbG9ja0Zvcm1hdHRlcjogKHM/OiBzdHJpbmcpID0+IHN0cmluZyA9IHMgPT4gYCR7c30ge2A7XG5cbiAgLyoqXG4gICAgICogRm9ybWF0cyBhIGJsb2NrIGNsb3NlIHN0YXRlbWVudC5cbiAgICAgKi9cbiAgcHVibGljIGNsb3NlQmxvY2tGb3JtYXR0ZXI6IChzPzogc3RyaW5nKSA9PiBzdHJpbmcgPSAoKSA9PiAnfSc7XG5cbiAgLyoqXG4gICAgICogU2F2ZXMgYWxsIHRoZSBmaWxlcyBjcmVhdGVkIGluIHRoaXMgY29kZSBtYWtlci5cbiAgICAgKiBAcGFyYW0gcm9vdERpciBUaGUgcm9vdCBkaXJlY3RvcnkgZm9yIGFsbCBzYXZlZCBmaWxlcy5cbiAgICAgKiBAcmV0dXJucyBBIHNvcnRlZCBsaXN0IG9mIGFsbCB0aGUgZmlsZXMgc2F2ZWQgKGFic29sdXRlIHBhdGhzKS5cbiAgICAgKi9cbiAgcHVibGljIGFzeW5jIHNhdmUocm9vdERpcjogc3RyaW5nKSB7XG4gICAgY29uc3QgcGF0aHMgPSB0aGlzLmZpbGVzXG4gICAgICAuZmlsdGVyKGZpbGUgPT4gIXRoaXMuZXhjbHVkZXMuaW5jbHVkZXMoZmlsZS5maWxlUGF0aCkpXG4gICAgICAubWFwKGZpbGUgPT4gZmlsZS5zYXZlKHJvb3REaXIpKTtcbiAgICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKHBhdGhzKSkuc29ydCgpO1xuICB9XG5cbiAgLyoqXG4gICAgICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBmaWxlIHdlIGFyZSB3b3JraW5nIHdpdGguXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZG9lc24ndCByZWFsbHkgY3JlYXRlIGEgbmV3IGZpbGUgKGZpbGVzIGFyZSBvbmx5IGNyZWF0ZWQgd2hlbiBzYXZlKCkgaXMgY2FsbGVkLlxuICAgICAqIFVzZSBgY2xvc2VGaWxlYCB0byBjbG9zZSB0aGlzIGZpbGUuXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIFRoZSByZWxhdGl2ZSBwYXRoIG9mIHRoZSBuZXcgZmlsZS5cbiAgICAgKi9cbiAgcHVibGljIG9wZW5GaWxlKGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50RmlsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3BlbiBmaWxlICR7ZmlsZVBhdGh9IHdpdGhvdXQgY2xvc2luZyB0aGUgcHJldmlvdXMgZmlsZSAke3RoaXMuY3VycmVudEZpbGUuZmlsZVBhdGh9YCk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG5ldyBGaWxlQnVmZmVyKGZpbGVQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHdlIGZpbmlzaGVkIGdlbmVyYXRpbmcgdGhlIGN1cnJlbnQgZmlsZS5cbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aCAobXVzdCBiZSB0aGUgc2FtZSBhcyBvbmUgcGFzc2VkIHRvIG9wZW5GaWxlKVxuICAgICAqL1xuICBwdWJsaWMgY2xvc2VGaWxlKGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudEZpbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNsb3NlIGZpbGUgJHtmaWxlUGF0aH0uIEl0IHdhcyBuZXZlciBvcGVuZWRgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudEZpbGUuZmlsZVBhdGggIT09IGZpbGVQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjbG9zZSBmaWxlICR7ZmlsZVBhdGh9LiBUaGUgY3VycmVudGx5IG9wZW5lZCBmaWxlIGlzICR7dGhpcy5jdXJyZW50RmlsZS5maWxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbGVzLnB1c2godGhpcy5jdXJyZW50RmlsZSk7XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEVtaXRzIGEgbGluZSBpbnRvIHRoZSBjdXJyZW50bHkgb3BlbmVkIGZpbGUuXG4gICAgICogTGluZSBpcyBlbWl0dGVkIHdpdGggdGhlIGN1cnJlbnQgbGV2ZWwgb2YgaW5kZW50YXRpb24uXG4gICAgICogSWYgbm8gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYW4gZW1wdHkgbmV3IGxpbmUgaXMgZW1pdHRlZC5cbiAgICAgKiBAcGFyYW0gZm10IFN0cmluZyBmb3JtYXQgYXJndW1lbnRzIChwYXNzZWQgdG8gYHV0aWwuZm9ybWF0YClcbiAgICAgKiBAcGFyYW0gYXJncyBTdHJpbmcgYXJndW1lbnRzXG4gICAgICovXG4gIHB1YmxpYyBsaW5lKGZtdD86IHN0cmluZywgLi4uYXJnczogc3RyaW5nW10pIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudEZpbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVtaXQgc291cmNlIGxpbmVzIHdpdGhvdXQgb3Blbm5pbmcgYSBmaWxlJyk7XG4gICAgfVxuXG4gICAgaWYgKGZtdCkge1xuICAgICAgZm10ID0gdGhpcy5tYWtlSW5kZW50KCkgKyBmbXQ7XG4gICAgICB0aGlzLmN1cnJlbnRGaWxlLndyaXRlKHV0aWwuZm9ybWF0KGZtdCwgLi4uYXJncykpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudEZpbGUud3JpdGUoJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAgICogU2FtZSBhcyBgb3BlbmAuXG4gICAgICovXG4gIHB1YmxpYyBpbmRlbnQodGV4dEJlZm9yZT86IHN0cmluZykge1xuICAgIHRoaXMub3Blbih0ZXh0QmVmb3JlKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFNhbWUgYXMgYGNsb3NlYC5cbiAgICAgKi9cbiAgcHVibGljIHVuaW5kZW50KHRleHRBZnRlcj86IHN0cmluZykge1xuICAgIHRoaXMuY2xvc2UodGV4dEFmdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEluY3JlYXNlcyB0aGUgaW5kZW50YXRpb24gbGV2ZWwgYnkgYGluZGVudGF0aW9uYCBzcGFjZXMgZm9yIHRoZSBuZXh0IGxpbmUuXG4gICAgICogQHBhcmFtIHRleHRCZWZvcmUgVGV4dCB0byBlbWl0IGJlZm9yZSB0aGUgbmV3bGluZSAoaS5lLiBibG9jayBvcGVuKS5cbiAgICAgKi9cbiAgcHVibGljIG9wZW4odGV4dEJlZm9yZT86IHN0cmluZykge1xuICAgIHRoaXMubGluZSh0ZXh0QmVmb3JlKTtcbiAgICB0aGlzLmN1cnJJbmRlbnQrKztcbiAgfVxuXG4gIC8qKlxuICAgICAqIERlY3JlYXNlcyB0aGUgaW5kZW50YXRpb24gbGV2ZWwgYnkgYGluZGVudGF0aW9uYCBmb3IgdGhlIG5leHQgbGluZS5cbiAgICAgKiBAcGFyYW0gdGV4dEFmdGVyIFRleHQgdG8gZW1pdCBpbiB0aGUgbGluZSBhZnRlciBpbmRlbnRhdGlvbiB3YXMgZGVjcmVhc2VkLlxuICAgICAqL1xuICBwdWJsaWMgY2xvc2UodGV4dEFmdGVyPzogc3RyaW5nKSB7XG4gICAgdGhpcy5jdXJySW5kZW50LS07XG4gICAgdGhpcy5saW5lKHRleHRBZnRlcik7XG4gIH1cblxuICAvKipcbiAgICAgKiBPcGVucyBhIGNvZGUgYmxvY2suIFRoZSBmb3JtYXR0aW5nIG9mIHRoZSBibG9jayBpcyBkZXRlcm1pbmVkIGJ5IGBvcGVuQmxvY2tGb3JtYXR0ZXJgLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIHBhc3MgdG8gdGhlIGZvcm1hdHRlci5cbiAgICAgKi9cbiAgcHVibGljIG9wZW5CbG9jayh0ZXh0OiBzdHJpbmcpIHtcbiAgICB0aGlzLm9wZW4odGhpcy5vcGVuQmxvY2tGb3JtYXR0ZXIodGV4dCkpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQ2xvc2VzIGEgY29kZSBibG9jay4gVGhlIGZvcm1hdHRpbmcgb2YgdGhlIGJsb2NrIGlzIGRldGVybWluZWQgYnkgYGNsb3NlQmxvY2tGb3JtYXR0ZXJgLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIHBhc3MgdG8gdGhlIGZvcm1hdHRlci5cbiAgICAgKi9cbiAgcHVibGljIGNsb3NlQmxvY2sodGV4dD86IHN0cmluZykge1xuICAgIHRoaXMuY2xvc2UodGhpcy5jbG9zZUJsb2NrRm9ybWF0dGVyKHRleHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEFkZHMgYSBmaWxlIHRvIHRoZSBleGNsdWRlIGxpc3QuIFRoaXMgbWVhbnMgdGhpcyBmaWxlIHdpbGwgbm90IGJlIHNhdmVkIGR1cmluZyBzYXZlKCkuXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIFRoZSByZWxhdGl2ZSBwYXRoIG9mIHRoZSBmaWxlLlxuICAgICAqL1xuICBwdWJsaWMgZXhjbHVkZShmaWxlUGF0aDogc3RyaW5nKSB7XG4gICAgdGhpcy5leGNsdWRlcy5wdXNoKGZpbGVQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIGNvbnZlcnRzU3RyaW5nVG9DYW1lbENhc2VcbiAgICAgKi9cbiAgcHVibGljIHRvQ2FtZWxDYXNlKC4uLmFyZ3M6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIGNhc2V1dGlscy50b0NhbWVsQ2FzZSguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIENvbnZlcnRzU3RyaW5nVG9QYXNjYWxDYXNlXG4gICAgICovXG4gIHB1YmxpYyB0b1Bhc2NhbENhc2UoLi4uYXJnczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gY2FzZXV0aWxzLnRvUGFzY2FsQ2FzZSguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIGNvbnZlcnRfc3RyaW5nX3RvX3NuYWtlX2Nhc2VcbiAgICAgKiBAcGFyYW0gc2VwIFNlcGFyYXRvciAoZGVmYXVsdHMgdG8gJ18nKVxuICAgICAqL1xuICBwdWJsaWMgdG9TbmFrZUNhc2Uoczogc3RyaW5nLCBzZXAgPSAnXycpIHtcbiAgICByZXR1cm4gY2FzZXV0aWxzLnRvU25ha2VDYXNlKHMsIHNlcCk7XG4gIH1cblxuICBwcml2YXRlIG1ha2VJbmRlbnQoKSB7XG4gICAgbGV0IHNwYWNlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jdXJySW5kZW50OyArK2kpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5pbmRlbnRhdGlvbjsgKytqKSB7XG4gICAgICAgIHNwYWNlcyArPSAnICc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGFjZXM7XG4gIH1cbn1cbiJdfQ==