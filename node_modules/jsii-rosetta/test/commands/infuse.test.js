"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const lib_1 = require("../../lib");
const extract_1 = require("../../lib/commands/extract");
const infuse_1 = require("../../lib/commands/infuse");
const assemblies_1 = require("../../lib/jsii/assemblies");
const testutil_1 = require("../testutil");
const DUMMY_README = `
  Here is an example of how to use ClassA:

  \`\`\`ts some=metadata
  import * as ass from 'my_assembly';
  const aClass = new ass.ClassA();
  aClass.someMethod();
  \`\`\`
`;
const TABLET_FILE = 'text.tabl.json';
let assembly;
beforeEach(async () => {
    // Create an assembly in a temp directory
    assembly = await testutil_1.TestJsiiModule.fromSource({
        'index.ts': `
      export class ClassA {
        public someMethod() {
        }
      }
      export class ClassB {
        public argumentMethod(args: BeeArgs) {
          Array.isArray(args);
        }
      }
      export interface BeeArgs { readonly value: string; readonly nested?: NestedType; }
      export interface NestedType { readonly x: number; }
      `,
        'README.md': DUMMY_README,
    }, {
        name: 'my_assembly',
        jsii: testutil_1.DUMMY_JSII_CONFIG,
    });
    // Create a tabletFile in the same directory
    await extract_1.extractSnippets([assembly.moduleDirectory], {
        cacheToFile: path.join(assembly.moduleDirectory, TABLET_FILE),
        includeCompilerDiagnostics: false,
        validateAssemblies: false,
    });
});
afterEach(async () => assembly.cleanup());
test('examples are added in the assembly', async () => {
    var _a;
    await infuse_1.infuse([assembly.moduleDirectory]);
    const assemblies = await assemblies_1.loadAssemblies([assembly.moduleDirectory], false);
    const types = assemblies[0].assembly.types;
    expect(types).toBeDefined();
    expect((_a = types['my_assembly.ClassA'].docs) === null || _a === void 0 ? void 0 : _a.example).toBeDefined();
});
test('infuse copies example metadata', async () => {
    var _a, _b, _c;
    await infuse_1.infuse([assembly.moduleDirectory]);
    // THEN: the metadata that used to be on the README snippet is also on the class example
    const updatedAssembly = (await fs.readJson(path.join(assembly.moduleDirectory, '.jsii')));
    const typeDocs = (_b = (_a = updatedAssembly.types) === null || _a === void 0 ? void 0 : _a['my_assembly.ClassA']) === null || _b === void 0 ? void 0 : _b.docs;
    expect((_c = typeDocs === null || typeDocs === void 0 ? void 0 : typeDocs.custom) === null || _c === void 0 ? void 0 : _c.exampleMetadata).toEqual('some=metadata infused');
});
test('examples are added to the tablet under new keys', async () => {
    const originalTabletFile = path.join(assembly.moduleDirectory, TABLET_FILE);
    const updatedTabletFile = path.join(assembly.moduleDirectory, 'tablet2.tabl.json');
    const originalDefaultTablet = await lib_1.LanguageTablet.fromFile(path.join(assembly.moduleDirectory, lib_1.DEFAULT_TABLET_NAME));
    await infuse_1.infuse([assembly.moduleDirectory], {
        cacheFromFile: originalTabletFile,
        cacheToFile: updatedTabletFile,
    });
    const originalCache = await lib_1.LanguageTablet.fromFile(originalTabletFile);
    const updatedCache = await lib_1.LanguageTablet.fromFile(updatedTabletFile);
    const updatedDefaultTablet = await lib_1.LanguageTablet.fromFile(path.join(assembly.moduleDirectory, lib_1.DEFAULT_TABLET_NAME));
    expect(updatedDefaultTablet.count).toEqual(originalDefaultTablet.count + 1);
    expect(updatedCache.count).toEqual(originalCache.count);
    expect(updatedCache.snippetKeys).not.toEqual(originalCache.snippetKeys);
});
test('can log to output file', async () => {
    await infuse_1.infuse([assembly.moduleDirectory], {
        logFile: path.join(assembly.moduleDirectory, infuse_1.DEFAULT_INFUSION_RESULTS_NAME),
    });
    // assert that the output file exists and there is some information in the file.
    const stats = await fs.stat(path.join(assembly.moduleDirectory, infuse_1.DEFAULT_INFUSION_RESULTS_NAME));
    expect(stats.isFile()).toBeTruthy();
    expect(stats.size).toBeGreaterThan(0);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5mdXNlLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmZ1c2UudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFFN0IsbUNBQWdFO0FBQ2hFLHdEQUE2RDtBQUM3RCxzREFBa0Y7QUFDbEYsMERBQTJEO0FBQzNELDBDQUFnRTtBQUVoRSxNQUFNLFlBQVksR0FBRzs7Ozs7Ozs7Q0FRcEIsQ0FBQztBQUVGLE1BQU0sV0FBVyxHQUFHLGdCQUFnQixDQUFDO0FBRXJDLElBQUksUUFBd0IsQ0FBQztBQUM3QixVQUFVLENBQUMsS0FBSyxJQUFJLEVBQUU7SUFDcEIseUNBQXlDO0lBQ3pDLFFBQVEsR0FBRyxNQUFNLHlCQUFjLENBQUMsVUFBVSxDQUN4QztRQUNFLFVBQVUsRUFBRTs7Ozs7Ozs7Ozs7O09BWVg7UUFDRCxXQUFXLEVBQUUsWUFBWTtLQUMxQixFQUNEO1FBQ0UsSUFBSSxFQUFFLGFBQWE7UUFDbkIsSUFBSSxFQUFFLDRCQUFpQjtLQUN4QixDQUNGLENBQUM7SUFFRiw0Q0FBNEM7SUFDNUMsTUFBTSx5QkFBZSxDQUFDLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxFQUFFO1FBQ2hELFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsV0FBVyxDQUFDO1FBQzdELDBCQUEwQixFQUFFLEtBQUs7UUFDakMsa0JBQWtCLEVBQUUsS0FBSztLQUMxQixDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUVILFNBQVMsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBRTFDLElBQUksQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLElBQUksRUFBRTs7SUFDcEQsTUFBTSxlQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztJQUV6QyxNQUFNLFVBQVUsR0FBRyxNQUFN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O0lBRUgsZ0ZBQWdGO0lBQ2hGLE1BQU0sS0FBSyxHQUFHLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsc0NBQTZCLENBQUMsQ0FBQyxDQUFDO0lBRWhHLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUNwQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4QyxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHNwZWMgZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBMYW5ndWFnZVRhYmxldCwgREVGQVVMVF9UQUJMRVRfTkFNRSB9IGZyb20gJy4uLy4uL2xpYic7XG5pbXBvcnQgeyBleHRyYWN0U25pcHBldHMgfSBmcm9tICcuLi8uLi9saWIvY29tbWFuZHMvZXh0cmFjdCc7XG5pbXBvcnQgeyBpbmZ1c2UsIERFRkFVTFRfSU5GVVNJT05fUkVTVUxUU19OQU1FIH0gZnJvbSAnLi4vLi4vbGliL2NvbW1hbmRzL2luZnVzZSc7XG5pbXBvcnQgeyBsb2FkQXNzZW1ibGllcyB9IGZyb20gJy4uLy4uL2xpYi9qc2lpL2Fzc2VtYmxpZXMnO1xuaW1wb3J0IHsgVGVzdEpzaWlNb2R1bGUsIERVTU1ZX0pTSUlfQ09ORklHIH0gZnJvbSAnLi4vdGVzdHV0aWwnO1xuXG5jb25zdCBEVU1NWV9SRUFETUUgPSBgXG4gIEhlcmUgaXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gdXNlIENsYXNzQTpcblxuICBcXGBcXGBcXGB0cyBzb21lPW1ldGFkYXRhXG4gIGltcG9ydCAqIGFzIGFzcyBmcm9tICdteV9hc3NlbWJseSc7XG4gIGNvbnN0IGFDbGFzcyA9IG5ldyBhc3MuQ2xhc3NBKCk7XG4gIGFDbGFzcy5zb21lTWV0aG9kKCk7XG4gIFxcYFxcYFxcYFxuYDtcblxuY29uc3QgVEFCTEVUX0ZJTEUgPSAndGV4dC50YWJsLmpzb24nO1xuXG5sZXQgYXNzZW1ibHk6IFRlc3RKc2lpTW9kdWxlO1xuYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gIC8vIENyZWF0ZSBhbiBhc3NlbWJseSBpbiBhIHRlbXAgZGlyZWN0b3J5XG4gIGFzc2VtYmx5ID0gYXdhaXQgVGVzdEpzaWlNb2R1bGUuZnJvbVNvdXJjZShcbiAgICB7XG4gICAgICAnaW5kZXgudHMnOiBgXG4gICAgICBleHBvcnQgY2xhc3MgQ2xhc3NBIHtcbiAgICAgICAgcHVibGljIHNvbWVNZXRob2QoKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV4cG9ydCBjbGFzcyBDbGFzc0Ige1xuICAgICAgICBwdWJsaWMgYXJndW1lbnRNZXRob2QoYXJnczogQmVlQXJncykge1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkoYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmVlQXJncyB7IHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7IHJlYWRvbmx5IG5lc3RlZD86IE5lc3RlZFR5cGU7IH1cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgTmVzdGVkVHlwZSB7IHJlYWRvbmx5IHg6IG51bWJlcjsgfVxuICAgICAgYCxcbiAgICAgICdSRUFETUUubWQnOiBEVU1NWV9SRUFETUUsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbXlfYXNzZW1ibHknLFxuICAgICAganNpaTogRFVNTVlfSlNJSV9DT05GSUcsXG4gICAgfSxcbiAgKTtcblxuICAvLyBDcmVhdGUgYSB0YWJsZXRGaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeVxuICBhd2FpdCBleHRyYWN0U25pcHBldHMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIHtcbiAgICBjYWNoZVRvRmlsZTogcGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgVEFCTEVUX0ZJTEUpLFxuICAgIGluY2x1ZGVDb21waWxlckRpYWdub3N0aWNzOiBmYWxzZSxcbiAgICB2YWxpZGF0ZUFzc2VtYmxpZXM6IGZhbHNlLFxuICB9KTtcbn0pO1xuXG5hZnRlckVhY2goYXN5bmMgKCkgPT4gYXNzZW1ibHkuY2xlYW51cCgpKTtcblxudGVzdCgnZXhhbXBsZXMgYXJlIGFkZGVkIGluIHRoZSBhc3NlbWJseScsIGFzeW5jICgpID0+IHtcbiAgYXdhaXQgaW5mdXNlKFthc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldKTtcblxuICBjb25zdCBhc3NlbWJsaWVzID0gYXdhaXQgbG9hZEFzc2VtYmxpZXMoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0sIGZhbHNlKTtcbiAgY29uc3QgdHlwZXMgPSBhc3NlbWJsaWVzWzBdLmFzc2VtYmx5LnR5cGVzO1xuICBleHBlY3QodHlwZXMpLnRvQmVEZWZpbmVkKCk7XG4gIGV4cGVjdCh0eXBlcyFbJ215X2Fzc2VtYmx5LkNsYXNzQSddLmRvY3M/LmV4YW1wbGUpLnRvQmVEZWZpbmVkKCk7XG59KTtcblxudGVzdCgnaW5mdXNlIGNvcGllcyBleGFtcGxlIG1ldGFkYXRhJywgYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBpbmZ1c2UoW2Fzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeV0pO1xuXG4gIC8vIFRIRU46IHRoZSBtZXRhZGF0YSB0aGF0IHVzZWQgdG8gYmUgb24gdGhlIFJFQURNRSBzbmlwcGV0IGlzIGFsc28gb24gdGhlIGNsYXNzIGV4YW1wbGVcbiAgY29uc3QgdXBkYXRlZEFzc2VtYmx5ID0gKGF3YWl0IGZzLnJlYWRKc29uKHBhdGguam9pbihhc3NlbWJseS5tb2R1bGVEaXJlY3RvcnksICcuanNpaScpKSkgYXMgc3BlYy5Bc3NlbWJseTtcblxuICBjb25zdCB0eXBlRG9jcyA9IHVwZGF0ZWRBc3NlbWJseS50eXBlcz8uWydteV9hc3NlbWJseS5DbGFzc0EnXT8uZG9jcztcbiAgZXhwZWN0KHR5cGVEb2NzPy5jdXN0b20/LmV4YW1wbGVNZXRhZGF0YSkudG9FcXVhbCgnc29tZT1tZXRhZGF0YSBpbmZ1c2VkJyk7XG59KTtcblxudGVzdCgnZXhhbXBsZXMgYXJlIGFkZGVkIHRvIHRoZSB0YWJsZXQgdW5kZXIgbmV3IGtleXMnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsVGFibGV0RmlsZSA9IHBhdGguam9pbihhc3NlbWJseS5tb2R1bGVEaXJlY3RvcnksIFRBQkxFVF9GSUxFKTtcbiAgY29uc3QgdXBkYXRlZFRhYmxldEZpbGUgPSBwYXRoLmpvaW4oYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5LCAndGFibGV0Mi50YWJsLmpzb24nKTtcbiAgY29uc3Qgb3JpZ2luYWxEZWZhdWx0VGFibGV0ID0gYXdhaXQgTGFuZ3VhZ2VUYWJsZXQuZnJvbUZpbGUocGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgREVGQVVMVF9UQUJMRVRfTkFNRSkpO1xuXG4gIGF3YWl0IGluZnVzZShbYXNzZW1ibHkubW9kdWxlRGlyZWN0b3J5XSwge1xuICAgIGNhY2hlRnJvbUZpbGU6IG9yaWdpbmFsVGFibGV0RmlsZSxcbiAgICBjYWNoZVRvRmlsZTogdXBkYXRlZFRhYmxldEZpbGUsXG4gIH0pO1xuXG4gIGNvbnN0IG9yaWdpbmFsQ2FjaGUgPSBhd2FpdCBMYW5ndWFnZVRhYmxldC5mcm9tRmlsZShvcmlnaW5hbFRhYmxldEZpbGUpO1xuICBjb25zdCB1cGRhdGVkQ2FjaGUgPSBhd2FpdCBMYW5ndWFnZVRhYmxldC5mcm9tRmlsZSh1cGRhdGVkVGFibGV0RmlsZSk7XG4gIGNvbnN0IHVwZGF0ZWREZWZhdWx0VGFibGV0ID0gYXdhaXQgTGFuZ3VhZ2VUYWJsZXQuZnJvbUZpbGUocGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgREVGQVVMVF9UQUJMRVRfTkFNRSkpO1xuXG4gIGV4cGVjdCh1cGRhdGVkRGVmYXVsdFRhYmxldC5jb3VudCkudG9FcXVhbChvcmlnaW5hbERlZmF1bHRUYWJsZXQuY291bnQgKyAxKTtcbiAgZXhwZWN0KHVwZGF0ZWRDYWNoZS5jb3VudCkudG9FcXVhbChvcmlnaW5hbENhY2hlLmNvdW50KTtcbiAgZXhwZWN0KHVwZGF0ZWRDYWNoZS5zbmlwcGV0S2V5cykubm90LnRvRXF1YWwob3JpZ2luYWxDYWNoZS5zbmlwcGV0S2V5cyk7XG59KTtcblxudGVzdCgnY2FuIGxvZyB0byBvdXRwdXQgZmlsZScsIGFzeW5jICgpID0+IHtcbiAgYXdhaXQgaW5mdXNlKFthc3NlbWJseS5tb2R1bGVEaXJlY3RvcnldLCB7XG4gICAgbG9nRmlsZTogcGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgREVGQVVMVF9JTkZVU0lPTl9SRVNVTFRTX05BTUUpLFxuICB9KTtcblxuICAvLyBhc3NlcnQgdGhhdCB0aGUgb3V0cHV0IGZpbGUgZXhpc3RzIGFuZCB0aGVyZSBpcyBzb21lIGluZm9ybWF0aW9uIGluIHRoZSBmaWxlLlxuICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnN0YXQocGF0aC5qb2luKGFzc2VtYmx5Lm1vZHVsZURpcmVjdG9yeSwgREVGQVVMVF9JTkZVU0lPTl9SRVNVTFRTX05BTUUpKTtcblxuICBleHBlY3Qoc3RhdHMuaXNGaWxlKCkpLnRvQmVUcnV0aHkoKTtcbiAgZXhwZWN0KHN0YXRzLnNpemUpLnRvQmVHcmVhdGVyVGhhbigwKTtcbn0pO1xuIl19