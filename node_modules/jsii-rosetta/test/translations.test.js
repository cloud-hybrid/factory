"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SUPPORTED_LANGUAGES = void 0;
const fs = require("fs-extra");
const path = require("path");
const lib_1 = require("../lib");
const languages_1 = require("../lib/languages");
const visualize_1 = require("../lib/languages/visualize");
const testutil_1 = require("./testutil");
exports.SUPPORTED_LANGUAGES = new Array({
    name: 'Python',
    extension: '.py',
    visitorFactory: languages_1.TARGET_LANGUAGES[languages_1.TargetLanguage.PYTHON],
}, {
    name: 'Java',
    extension: '.java',
    visitorFactory: languages_1.TARGET_LANGUAGES[languages_1.TargetLanguage.JAVA],
}, {
    name: 'C#',
    extension: '.cs',
    visitorFactory: languages_1.TARGET_LANGUAGES[languages_1.TargetLanguage.CSHARP],
});
const translationsRoot = path.join(__dirname, 'translations');
const typeScriptTests = allFiles(translationsRoot)
    .filter((f) => f.endsWith('.ts') && !f.endsWith('.d.ts'))
    .filter((f) => !f.endsWith('.test.ts')); // Exclude self and other jest tests in this dir
for (const typeScriptTest of typeScriptTests) {
    describe(`Translating ${path.relative(translationsRoot, typeScriptTest)}`, () => {
        const typeScriptSource = fs.readFileSync(typeScriptTest, {
            encoding: 'utf-8',
        });
        let translator;
        let anyFailed = false;
        beforeAll(() => {
            translator = new lib_1.SnippetTranslator({
                visibleSource: typeScriptSource,
                location: testutil_1.testSnippetLocation(typeScriptTest),
            });
        });
        afterAll(() => {
            // Print the AST for tests that failed (to help debugging)
            if (anyFailed && translator) {
                const vis = translator.renderUsing(new visualize_1.VisualizeAstVisitor(true));
                console.log(`${vis}\n`);
            }
            translator = undefined; // Need this to properly release memory
        });
        for (const { name, extension, visitorFactory } of exports.SUPPORTED_LANGUAGES) {
            const languageFile = replaceExtension(typeScriptTest, extension);
            // Use 'test.skip' if the file doesn't exist so that we can clearly see it's missing.
            const testConstructor = fs.existsSync(languageFile) ? test : test.skip;
            testConstructor(`to ${name}`, () => {
                const expected = fs.readFileSync(languageFile, { encoding: 'utf-8' });
                try {
                    const translation = translator.renderUsing(visitorFactory.createVisitor());
                    expect(stripEmptyLines(translation)).toEqual(stripEmptyLines(stripCommonWhitespace(expected)));
                }
                catch (e) {
                    anyFailed = true;
                    throw e;
                }
            });
        }
    });
}
function allFiles(root) {
    const ret = [];
    recurse(root);
    return ret;
    function recurse(dir) {
        for (const file of fs.readdirSync(dir)) {
            const fullPath = path.join(dir, file);
            const stat = fs.statSync(fullPath);
            if (stat.isFile()) {
                ret.push(fullPath);
            }
            if (stat.isDirectory()) {
                recurse(fullPath);
            }
        }
    }
}
function replaceExtension(x, newExtension) {
    return x.replace(/\.[^.]*$/, '') + newExtension;
}
function stripCommonWhitespace(x) {
    const lines = x.split('\n');
    const whitespaces = lines
        .filter((l) => !emptyLine(l.trim()))
        /* eslint-disable-next-line @typescript-eslint/prefer-regexp-exec */
        .map((l) => l.match(/(\s*)/)[1].length);
    const minWS = Math.min(...whitespaces);
    return lines.map((l) => l.substr(minWS)).join('\n');
}
function stripEmptyLines(x) {
    const lines = x.split('\n');
    while (lines.length > 0 && emptyLine(lines[0])) {
        lines.splice(0, 1);
    }
    while (lines.length > 0 && emptyLine(lines[lines.length - 1])) {
        lines.pop();
    }
    return lines.join('\n');
}
function emptyLine(x) {
    return x.trim() === '';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRpb25zLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0cmFuc2xhdGlvbnMudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBRTdCLGdDQUEyQztBQUMzQyxnREFBb0Y7QUFDcEYsMERBQWlFO0FBQ2pFLHlDQUFpRDtBQTBCcEMsUUFBQSxtQkFBbUIsR0FBRyxJQUFJLEtBQUssQ0FDMUM7SUFDRSxJQUFJLEVBQUUsUUFBUTtJQUNkLFNBQVMsRUFBRSxLQUFLO0lBQ2hCLGNBQWMsRUFBRSw0QkFBZ0IsQ0FBQywwQkFBYyxDQUFDLE1BQU0sQ0FBQztDQUN4RCxFQUNEO0lBQ0UsSUFBSSxFQUFFLE1BQU07SUFDWixTQUFTLEVBQUUsT0FBTztJQUNsQixjQUFjLEVBQUUsNEJBQWdCLENBQUMsMEJBQWMsQ0FBQyxJQUFJLENBQUM7Q0FDdEQsRUFDRDtJQUNFLElBQUksRUFBRSxJQUFJO0lBQ1YsU0FBUyxFQUFFLEtBQUs7SUFDaEIsY0FBYyxFQUFFLDRCQUFnQixDQUFDLDBCQUFjLENBQUMsTUFBTSxDQUFDO0NBQ3hELENBQ0YsQ0FBQztBQUVGLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFDOUQsTUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDO0tBQy9DLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDeEQsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLGdEQUFnRDtBQUUzRixLQUFLLE1BQU0sY0FBYyxJQUFJLGVBQWUsRUFB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QyxNQUFNLEdBQUcsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzdELEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUNiO0lBQ0QsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzFCLENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBQyxDQUFTO0lBQzFCLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUN6QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgU25pcHBldFRyYW5zbGF0b3IgfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgVEFSR0VUX0xBTkdVQUdFUywgVGFyZ2V0TGFuZ3VhZ2UsIFZpc2l0b3JGYWN0b3J5IH0gZnJvbSAnLi4vbGliL2xhbmd1YWdlcyc7XG5pbXBvcnQgeyBWaXN1YWxpemVBc3RWaXNpdG9yIH0gZnJvbSAnLi4vbGliL2xhbmd1YWdlcy92aXN1YWxpemUnO1xuaW1wb3J0IHsgdGVzdFNuaXBwZXRMb2NhdGlvbiB9IGZyb20gJy4vdGVzdHV0aWwnO1xuXG4vLyBUaGlzIGl0ZXJhdGVzIHRocm91Z2ggYWxsIHN1YmRpcmVjdG9yaWVzIG9mIHRoaXMgZGlyZWN0b3J5LFxuLy8gYW5kIGNyZWF0ZXMgYSBKZXN0IHRlc3QgZm9yIGVhY2gsIGJ5IHRyYW5zbGF0aW5nIHRoZSBUeXBlU2NyaXB0IGZpbGUgaXQgZmluZHMgdGhlcmUsXG4vLyBhbmQgY29tcGFyaW5nIGl0IHRvIGVhY2ggb2YgdGhlIGxhbmd1YWdlLXNwZWNpZmljIGZpbGVzIGFsc28gcHJlc2VudCB0aGVyZVxuLy8gd2l0aCB0aGUgc2FtZSBiYXNlIG5hbWUgKGJ1dCBhIGRpZmZlcmVudCBleHRlbnNpb24sIG9mIGNvdXJzZSkuXG4vLyBUbyBhZGQgYSBuZXcgbGFuZ3VhZ2UgdG8gdGhlIHRlc3RzLFxuLy8gYWRkIGFuIGVsZW1lbnQgdG8gdGhlIFNVUFBPUlRFRF9MQU5HVUFHRVMgY29uc3RhbnRcbi8vXG4vLyBUbyBydW4gb25seSB0aGUgdGVzdHMgZm9yIGEgY2VydGFpbiBsYW5ndWFnZSB5b3UncmUgd29ya2luZyBvbiwgZG8gdGhpczpcbi8vXG4vLyAgICB5YXJuIHRlc3QgdGVzdC90cmFuc2xhdGlvbnMudGVzdCAtdCAnVHJhbnNsYXRpbmcgLiogdG8gUHl0aG9uJ1xuLy8gICAgeWFybiB0ZXN0IHRlc3QvdHJhbnNsYXRpb25zLnRlc3QgLXQgJ1RyYW5zbGF0aW5nIC4qIHRvIEphdmEnXG4vLyAgICB5YXJuIHRlc3QgdGVzdC90cmFuc2xhdGlvbnMudGVzdCAtdCAnVHJhbnNsYXRpbmcgLiogdG8gQyMnXG4vL1xuLy8gVG8gbmFycm93IGl0IGRvd24gZXZlbiBtb3JlIHlvdSBjYW4gb2YgY291cnNlIHJlcGxhY2UgdGhlICcuKicgcmVnZXggd2l0aFxuLy8gd2hhdGV2ZXIgZmlsZSBpbmRpY2F0aW9uIHlvdSBkZXNpcmUuXG5cbmludGVyZmFjZSBTdXBwb3J0ZWRMYW5ndWFnZSB7XG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICByZWFkb25seSBleHRlbnNpb246IHN0cmluZztcblxuICByZWFkb25seSB2aXNpdG9yRmFjdG9yeTogVmlzaXRvckZhY3Rvcnk7XG59XG5cbmV4cG9ydCBjb25zdCBTVVBQT1JURURfTEFOR1VBR0VTID0gbmV3IEFycmF5PFN1cHBvcnRlZExhbmd1YWdlPihcbiAge1xuICAgIG5hbWU6ICdQeXRob24nLFxuICAgIGV4dGVuc2lvbjogJy5weScsXG4gICAgdmlzaXRvckZhY3Rvcnk6IFRBUkdFVF9MQU5HVUFHRVNbVGFyZ2V0TGFuZ3VhZ2UuUFlUSE9OXSxcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdKYXZhJyxcbiAgICBleHRlbnNpb246ICcuamF2YScsXG4gICAgdmlzaXRvckZhY3Rvcnk6IFRBUkdFVF9MQU5HVUFHRVNbVGFyZ2V0TGFuZ3VhZ2UuSkFWQV0sXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnQyMnLFxuICAgIGV4dGVuc2lvbjogJy5jcycsXG4gICAgdmlzaXRvckZhY3Rvcnk6IFRBUkdFVF9MQU5HVUFHRVNbVGFyZ2V0TGFuZ3VhZ2UuQ1NIQVJQXSxcbiAgfSxcbik7XG5cbmNvbnN0IHRyYW5zbGF0aW9uc1Jvb3QgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndHJhbnNsYXRpb25zJyk7XG5jb25zdCB0eXBlU2NyaXB0VGVzdHMgPSBhbGxGaWxlcyh0cmFuc2xhdGlvbnNSb290KVxuICAuZmlsdGVyKChmKSA9PiBmLmVuZHNXaXRoKCcudHMnKSAmJiAhZi5lbmRzV2l0aCgnLmQudHMnKSlcbiAgLmZpbHRlcigoZikgPT4gIWYuZW5kc1dpdGgoJy50ZXN0LnRzJykpOyAvLyBFeGNsdWRlIHNlbGYgYW5kIG90aGVyIGplc3QgdGVzdHMgaW4gdGhpcyBkaXJcblxuZm9yIChjb25zdCB0eXBlU2NyaXB0VGVzdCBvZiB0eXBlU2NyaXB0VGVzdHMpIHtcbiAgZGVzY3JpYmUoYFRyYW5zbGF0aW5nICR7cGF0aC5yZWxhdGl2ZSh0cmFuc2xhdGlvbnNSb290LCB0eXBlU2NyaXB0VGVzdCl9YCwgKCkgPT4ge1xuICAgIGNvbnN0IHR5cGVTY3JpcHRTb3VyY2UgPSBmcy5yZWFkRmlsZVN5bmModHlwZVNjcmlwdFRlc3QsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgIH0pO1xuXG4gICAgbGV0IHRyYW5zbGF0b3I6IFNuaXBwZXRUcmFuc2xhdG9yO1xuICAgIGxldCBhbnlGYWlsZWQgPSBmYWxzZTtcbiAgICBiZWZvcmVBbGwoKCkgPT4ge1xuICAgICAgdHJhbnNsYXRvciA9IG5ldyBTbmlwcGV0VHJhbnNsYXRvcih7XG4gICAgICAgIHZpc2libGVTb3VyY2U6IHR5cGVTY3JpcHRTb3VyY2UsXG4gICAgICAgIGxvY2F0aW9uOiB0ZXN0U25pcHBldExvY2F0aW9uKHR5cGVTY3JpcHRUZXN0KSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgICAgLy8gUHJpbnQgdGhlIEFTVCBmb3IgdGVzdHMgdGhhdCBmYWlsZWQgKHRvIGhlbHAgZGVidWdnaW5nKVxuICAgICAgaWYgKGFueUZhaWxlZCAmJiB0cmFuc2xhdG9yKSB7XG4gICAgICAgIGNvbnN0IHZpcyA9IHRyYW5zbGF0b3IucmVuZGVyVXNpbmcobmV3IFZpc3VhbGl6ZUFzdFZpc2l0b3IodHJ1ZSkpO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt2aXN9XFxuYCk7XG4gICAgICB9XG4gICAgICB0cmFuc2xhdG9yID0gdW5kZWZpbmVkIGFzIGFueTsgLy8gTmVlZCB0aGlzIHRvIHByb3Blcmx5IHJlbGVhc2UgbWVtb3J5XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHsgbmFtZSwgZXh0ZW5zaW9uLCB2aXNpdG9yRmFjdG9yeSB9IG9mIFNVUFBPUlRFRF9MQU5HVUFHRVMpIHtcbiAgICAgIGNvbnN0IGxhbmd1YWdlRmlsZSA9IHJlcGxhY2VFeHRlbnNpb24odHlwZVNjcmlwdFRlc3QsIGV4dGVuc2lvbik7XG5cbiAgICAgIC8vIFVzZSAndGVzdC5za2lwJyBpZiB0aGUgZmlsZSBkb2Vzbid0IGV4aXN0IHNvIHRoYXQgd2UgY2FuIGNsZWFybHkgc2VlIGl0J3MgbWlzc2luZy5cbiAgICAgIGNvbnN0IHRlc3RDb25zdHJ1Y3RvciA9IGZzLmV4aXN0c1N5bmMobGFuZ3VhZ2VGaWxlKSA/IHRlc3QgOiB0ZXN0LnNraXA7XG5cbiAgICAgIHRlc3RDb25zdHJ1Y3RvcihgdG8gJHtuYW1lfWAsICgpID0+IHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBmcy5yZWFkRmlsZVN5bmMobGFuZ3VhZ2VGaWxlLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdHJhbnNsYXRvci5yZW5kZXJVc2luZyh2aXNpdG9yRmFjdG9yeS5jcmVhdGVWaXNpdG9yKCkpO1xuICAgICAgICAgIGV4cGVjdChzdHJpcEVtcHR5TGluZXModHJhbnNsYXRpb24pKS50b0VxdWFsKHN0cmlwRW1wdHlMaW5lcyhzdHJpcENvbW1vbldoaXRlc3BhY2UoZXhwZWN0ZWQpKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBhbnlGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFsbEZpbGVzKHJvb3Q6IHN0cmluZykge1xuICBjb25zdCByZXQ6IHN0cmluZ1tdID0gW107XG4gIHJlY3Vyc2Uocm9vdCk7XG4gIHJldHVybiByZXQ7XG5cbiAgZnVuY3Rpb24gcmVjdXJzZShkaXI6IHN0cmluZykge1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmcy5yZWFkZGlyU3luYyhkaXIpKSB7XG4gICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIGZpbGUpO1xuICAgICAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKGZ1bGxQYXRoKTtcbiAgICAgIGlmIChzdGF0LmlzRmlsZSgpKSB7XG4gICAgICAgIHJldC5wdXNoKGZ1bGxQYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmVjdXJzZShmdWxsUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VFeHRlbnNpb24oeDogc3RyaW5nLCBuZXdFeHRlbnNpb246IHN0cmluZykge1xuICByZXR1cm4geC5yZXBsYWNlKC9cXC5bXi5dKiQvLCAnJykgKyBuZXdFeHRlbnNpb247XG59XG5cbmZ1bmN0aW9uIHN0cmlwQ29tbW9uV2hpdGVzcGFjZSh4OiBzdHJpbmcpIHtcbiAgY29uc3QgbGluZXMgPSB4LnNwbGl0KCdcXG4nKTtcbiAgY29uc3Qgd2hpdGVzcGFjZXMgPSBsaW5lc1xuICAgIC5maWx0ZXIoKGwpID0+ICFlbXB0eUxpbmUobC50cmltKCkpKVxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXJlZ2V4cC1leGVjICovXG4gICAgLm1hcCgobCkgPT4gbC5tYXRjaCgvKFxccyopLykhWzFdLmxlbmd0aCk7XG4gIGNvbnN0IG1pbldTID0gTWF0aC5taW4oLi4ud2hpdGVzcGFjZXMpO1xuICByZXR1cm4gbGluZXMubWFwKChsKSA9PiBsLnN1YnN0cihtaW5XUykpLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBzdHJpcEVtcHR5TGluZXMoeDogc3RyaW5nKSB7XG4gIGNvbnN0IGxpbmVzID0geC5zcGxpdCgnXFxuJyk7XG4gIHdoaWxlIChsaW5lcy5sZW5ndGggPiAwICYmIGVtcHR5TGluZShsaW5lc1swXSkpIHtcbiAgICBsaW5lcy5zcGxpY2UoMCwgMSk7XG4gIH1cbiAgd2hpbGUgKGxpbmVzLmxlbmd0aCA+IDAgJiYgZW1wdHlMaW5lKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSkge1xuICAgIGxpbmVzLnBvcCgpO1xuICB9XG4gIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gZW1wdHlMaW5lKHg6IHN0cmluZykge1xuICByZXR1cm4geC50cmltKCkgPT09ICcnO1xufVxuIl19