"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PythonVisitor = void 0;
const ts = require("typescript");
const jsii_types_1 = require("../jsii/jsii-types");
const jsii_utils_1 = require("../jsii/jsii-utils");
const packages_1 = require("../jsii/packages");
const target_language_1 = require("../languages/target-language");
const o_tree_1 = require("../o-tree");
const renderer_1 = require("../renderer");
const ast_utils_1 = require("../typescript/ast-utils");
const types_1 = require("../typescript/types");
const util_1 = require("../util");
const default_1 = require("./default");
class PythonVisitor extends default_1.DefaultVisitor {
    constructor(options = {}) {
        super();
        this.options = options;
        this.language = target_language_1.TargetLanguage.PYTHON;
        this.defaultContext = {};
        /**
         * Keep track of module imports we've seen, so that if we need to render a type we can pick from these modules
         */
        this.imports = new Array();
        /**
         * Synthetic imports that need to be added as a final step
         */
        this.syntheticImportsToAdd = new Array();
        this.statementTerminator = '';
    }
    mergeContext(old, update) {
        return Object.assign({}, old, update);
    }
    commentRange(comment, _context) {
        const commentText = ast_utils_1.stripCommentMarkers(comment.text, comment.kind === ts.SyntaxKind.MultiLineCommentTrivia);
        const hashLines = commentText
            .split('\n')
            .map((l) => `# ${l}`)
            .join('\n');
        const needsAdditionalTrailer = comment.hasTrailingNewLine;
        return new o_tree_1.OTree([comment.isTrailing ? ' ' : '', hashLines, needsAdditionalTrailer ? '\n' : ''], [], {
            // Make sure comment is rendered exactly once in the output tree, no
            // matter how many source nodes it is attached to.
            renderOnce: `comment-${comment.pos}`,
        });
    }
    sourceFile(node, context) {
        let rendered = super.sourceFile(node, context);
        // Add synthetic imports
        if (this.syntheticImportsToAdd.length > 0) {
            rendered = new o_tree_1.OTree([...this.renderSyntheticImports(), rendered]);
        }
        if (this.options.disclaimer) {
            rendered = new o_tree_1.OTree([`# ${this.options.disclaimer}\n`, rendered]);
        }
        return rendered;
    }
    importStatement(node, context) {
        var _a, _b, _c, _d;
        if (node.imports.import === 'full') {
            const moduleName = (_a = util_1.fmap(node.moduleSymbol, findPythonName)) !== null && _a !== void 0 ? _a : guessPythonPackageName(node.packageName);
            this.addImport({
                importedFqn: (_c = (_b = node.moduleSymbol) === null || _b === void 0 ? void 0 : _b.fqn) !== null && _c !== void 0 ? _c : node.packageName,
                importName: node.imports.alias,
            });
            return new o_tree_1.OTree([`import ${moduleName} as ${mangleIdentifier(node.imports.alias)}`], [], {
                canBreakLine: true,
            });
        }
        if (node.imports.import === 'selective') {
            for (const im of node.imports.elements) {
                if (im.importedSymbol) {
                    this.addImport({
                        importName: im.alias ? im.alias : im.sourceName,
                        importedFqn: im.importedSymbol.fqn,
                    });
                }
            }
            const imports = node.imports.elements.map((im) => {
                var _a, _b;
                const localName = (_a = im.alias) !== null && _a !== void 0 ? _a : im.sourceName;
                const originalName = (_b = util_1.fmap(util_1.fmap(im.importedSymbol, findPythonName), jsii_utils_1.simpleName)) !== null && _b !== void 0 ? _b : im.sourceName;
                return localName === originalName
                    ? mangleIdentifier(originalName)
                    : `${mangleIdentifier(originalName)} as ${mangleIdentifier(localName)}`;
            });
            const moduleName = (_d = util_1.fmap(node.moduleSymbol, findPythonName)) !== null && _d !== void 0 ? _d : guessPythonPackageName(node.packageName);
            return new o_tree_1.OTree([`from ${moduleName} import ${imports.join(', ')}`], [], {
                canBreakLine: true,
            });
        }
        return renderer_1.nimpl(node.node, context);
    }
    token(node, context) {
        const text = context.textOf(node);
        const mapped = TOKEN_REWRITES[text];
        if (mapped) {
            return new o_tree_1.OTree([mapped]);
        }
        return super.token(node, context);
    }
    identifier(node, context) {
        const originalIdentifier = node.text;
        const explodedParameter = context.currentContext.explodedParameter;
        if (context.currentContext.tailPositionArgument &&
            explodedParameter &&
            explodedParameter.type &&
            explodedParameter.variableName === originalIdentifier) {
            return new o_tree_1.OTree([], jsii_utils_1.propertiesOfStruct(explodedParameter.type, context).map((prop) => new o_tree_1.OTree([prop.name, '=', prop.name])), { separator: ', ' });
        }
        return new o_tree_1.OTree([mangleIdentifier(originalIdentifier)]);
    }
    functionDeclaration(node, context) {
        return this.functionLike(node, context);
    }
    constructorDeclaration(node, context) {
        return this.functionLike(node, context, { isConstructor: true });
    }
    methodDeclaration(node, context) {
        return this.functionLike(node, context);
    }
    expressionStatement(node, context) {
        const text = context.textOf(node);
        if (text === 'true') {
            return new o_tree_1.OTree(['True']);
        }
        if (text === 'false') {
            return new o_tree_1.OTree(['False']);
        }
        return super.expressionStatement(node, context);
    }
    // tslint:disable-next-line:max-line-length
    functionLike(node, context, opts = {}) {
        const methodName = opts.isConstructor ? '__init__' : o_tree_1.renderTree(context.convert(node.name));
        const [paramDecls, explodedParameter] = this.convertFunctionCallParameters(node.parameters, context);
        const ret = new o_tree_1.OTree([
            'def ',
            methodName,
            '(',
            new o_tree_1.OTree([], [context.currentContext.inClass ? 'self' : undefined, ...paramDecls], {
                separator: ', ',
            }),
            '): ',
        ], [context.updateContext({ explodedParameter, currentMethodName: methodName }).convert(node.body)], {
            canBreakLine: true,
        });
        return ret;
    }
    block(node, context) {
        if (node.statements.length === 0) {
            return new o_tree_1.OTree([], ['\npass'], { indent: 4, canBreakLine: true });
        }
        return new o_tree_1.OTree([], context.convertAll(node.statements), {
            separator: '',
            indent: 4,
            canBreakLine: true,
        });
    }
    regularCallExpression(node, context) {
        var _a;
        let expressionText = context.convert(node.expression);
        if (ast_utils_1.matchAst(node.expression, ast_utils_1.nodeOfType(ts.SyntaxKind.SuperKeyword)) && context.currentContext.currentMethodName) {
            expressionText = `super().${context.currentContext.currentMethodName}`;
        }
        const signature = context.typeChecker.getResolvedSignature(node);
        return new o_tree_1.OTree([
            expressionText,
            '(',
            this.convertFunctionCallArguments(node.arguments, context, (_a = signature === null || signature === void 0 ? void 0 : signature.parameters) === null || _a === void 0 ? void 0 : _a.map((p) => p.valueDeclaration)),
            ')',
        ], [], { canBreakLine: true });
    }
    propertyAccessExpression(node, context) {
        const fullText = context.textOf(node);
        if (fullText in BUILTIN_FUNCTIONS) {
            return new o_tree_1.OTree([BUILTIN_FUNCTIONS[fullText]]);
        }
        const explodedParameter = context.currentContext.explodedParameter;
        // We might be in a context where we've exploded this struct into arguments,
        // in which case we will return just the accessed variable.
        if (explodedParameter && context.textOf(node.expression) === explodedParameter.variableName) {
            return context.convert(node.name);
        }
        return super.propertyAccessExpression(node, context);
    }
    parameterDeclaration(node, context) {
        const type = node.type && context.typeOfType(node.type);
        if (context.currentContext.tailPositionParameter &&
            type &&
            jsii_utils_1.analyzeStructType(context.typeChecker, type) !== false) {
            // Return the parameter that we exploded so that we can use this information
            // while translating the body.
            if (context.currentContext.returnExplodedParameter) {
                context.currentContext.returnExplodedParameter.value = {
                    variableName: context.textOf(node.name),
                    type,
                };
            }
            // Explode to fields
            return new o_tree_1.OTree([], ['*', ...jsii_utils_1.propertiesOfStruct(type, context).map(renderStructProperty)], { separator: ', ' });
        }
        const suffix = types_1.parameterAcceptsUndefined(node, type) ? '=None' : '';
        return new o_tree_1.OTree([node.dotDotDotToken ? '*' : '', context.convert(node.name), suffix]);
        function renderStructProperty(prop) {
            const sfx = jsii_utils_1.structPropertyAcceptsUndefined(prop) ? '=None' : '';
            return prop.name + sfx;
        }
    }
    ifStatement(node, context) {
        const ifStmt = new o_tree_1.OTree(['if ', context.convert(node.expression), ': '], [context.convert(node.thenStatement)], {
            canBreakLine: true,
        });
        const elseStmt = node.elseStatement
            ? new o_tree_1.OTree(['else: '], [context.convert(node.elseStatement)], {
                canBreakLine: true,
            })
            : undefined;
        return elseStmt
            ? new o_tree_1.OTree([], [ifStmt, elseStmt], {
                separator: '\n',
                canBreakLine: true,
            })
            : ifStmt;
    }
    unknownTypeObjectLiteralExpression(node, context) {
        // Neutralize local modifiers if any for transforming further down.
        const downContext = context.updateContext({
            tailPositionArgument: false,
            variadicArgument: false,
        });
        if (context.currentContext.tailPositionArgument && !context.currentContext.variadicArgument) {
            // Guess that it's a struct we can probably inline the kwargs for
            return this.renderObjectLiteralExpression('', '', true, node, downContext);
        }
        return this.renderObjectLiteralExpression('{', '}', false, node, downContext);
    }
    knownStructObjectLiteralExpression(node, structType, context) {
        if (context.currentContext.tailPositionArgument) {
            // We know it's a struct we can DEFINITELY inline the args for
            return this.renderObjectLiteralExpression('', '', true, node, context);
        }
        const structName = structType.kind === 'struct' ? this.importedNameForType(structType.jsiiSym) : structType.type.symbol.name;
        return this.renderObjectLiteralExpression(`${structName}(`, ')', true, node, context);
    }
    keyValueObjectLiteralExpression(node, context) {
        return this.renderObjectLiteralExpression('{', '}', false, node, context);
    }
    translateUnaryOperator(operator) {
        if (operator === ts.SyntaxKind.ExclamationToken) {
            return 'not ';
        }
        return super.translateUnaryOperator(operator);
    }
    renderObjectLiteralExpression(prefix, suffix, renderObjectLiteralAsKeywords, node, context) {
        return new o_tree_1.OTree([prefix], context.updateContext({ renderObjectLiteralAsKeywords }).convertAll(node.properties), {
            suffix: context.mirrorNewlineBefore(node.properties[0], suffix),
            separator: ', ',
            indent: 4,
        });
    }
    arrayLiteralExpression(node, context) {
        return new o_tree_1.OTree(['['], context.convertAll(node.elements), {
            suffix: context.mirrorNewlineBefore(node.elements[0], ']'),
            separator: ', ',
            indent: 4,
        });
    }
    propertyAssignment(node, context) {
        const mid = context.currentContext.renderObjectLiteralAsKeywords ? '=' : ': ';
        // node.name is either an identifier or a string literal. The string literal
        // needs to be converted differently.
        let name = context.convert(node.name);
        ast_utils_1.matchAst(node.name, ast_utils_1.nodeOfType('stringLiteral', ts.SyntaxKind.StringLiteral), (captured) => {
            name = new o_tree_1.OTree([mangleIdentifier(captured.stringLiteral.text)]);
        });
        // If this isn't a computed property, we must quote the key (unless it's rendered as a keyword)
        if (!context.currentContext.renderObjectLiteralAsKeywords && !ts.isComputedPropertyName(node.name)) {
            name = new o_tree_1.OTree(['"', name, '"']);
        }
        return new o_tree_1.OTree([name, mid, context.updateContext({ tailPositionArgument: false }).convert(node.initializer)], [], { canBreakLine: true });
    }
    shorthandPropertyAssignment(node, context) {
        let before = '"';
        let mid = '": ';
        if (context.currentContext.renderObjectLiteralAsKeywords) {
            before = '';
            mid = '=';
        }
        return new o_tree_1.OTree([before, context.convert(node.name), mid, context.convert(node.name)], [], { canBreakLine: true });
    }
    newExpression(node, context) {
        return new o_tree_1.OTree([context.convert(node.expression), '(', this.convertFunctionCallArguments(node.arguments, context), ')'], [], { canBreakLine: true });
    }
    variableDeclaration(node, context) {
        let fallback = 'object';
        if (node.type) {
            fallback = node.type.getText();
        }
        if (!node.initializer) {
            const type = (node.type && context.typeOfType(node.type)) ||
                (node.initializer && context.typeOfExpression(node.initializer));
            const renderedType = type ? this.renderType(node, type, context, fallback) : fallback;
            return new o_tree_1.OTree(['# ', context.convert(node.name), ' is of type ', renderedType], []);
        }
        return new o_tree_1.OTree([context.convert(node.name), ' = ', context.convert(node.initializer)], [], {
            canBreakLine: true,
        });
    }
    thisKeyword() {
        return new o_tree_1.OTree(['self']);
    }
    forOfStatement(node, context) {
        // This is what a "for (const x of ...)" looks like in the AST
        let variableName = '???';
        ast_utils_1.matchAst(node.initializer, ast_utils_1.nodeOfType(ts.SyntaxKind.VariableDeclarationList, ast_utils_1.nodeOfType('var', ts.SyntaxKind.VariableDeclaration)), (bindings) => {
            variableName = mangleIdentifier(context.textOf(bindings.var.name));
        });
        return new o_tree_1.OTree(['for ', variableName, ' in ', context.convert(node.expression), ': '], [context.convert(node.statement)], { canBreakLine: true });
    }
    classDeclaration(node, context) {
        var _a;
        const heritage = util_1.flat(Array.from((_a = node.heritageClauses) !== null && _a !== void 0 ? _a : []).map((h) => Array.from(h.types))).map((t) => context.convert(t.expression));
        const hasHeritage = heritage.length > 0;
        const members = context.updateContext({ inClass: true }).convertAll(node.members);
        if (members.length === 0) {
            members.push(new o_tree_1.OTree(['\npass'], []));
        }
        const ret = new o_tree_1.OTree([
            'class ',
            node.name ? context.textOf(node.name) : '???',
            hasHeritage ? '(' : '',
            ...heritage,
            hasHeritage ? ')' : '',
            ': ',
        ], members, {
            indent: 4,
            canBreakLine: true,
        });
        return ret;
    }
    printStatement(args, context) {
        return new o_tree_1.OTree(['print', '(', new o_tree_1.OTree([], context.convertAll(args), { separator: ', ' }), ')']);
    }
    propertyDeclaration(_node, _context) {
        return new o_tree_1.OTree([]);
    }
    /**
     * We have to do something special here
     *
     * Best-effort, we remember the fields of struct interfaces and keep track of
     * them. Fortunately we can determine from the name whether what to do.
     */
    interfaceDeclaration(_node, _context) {
        // Whatever we do, nothing here will have a representation
        return o_tree_1.NO_SYNTAX;
    }
    propertySignature(_node, _context) {
        // Does not represent in Python
        return o_tree_1.NO_SYNTAX;
    }
    methodSignature(_node, _context) {
        // Does not represent in Python
        return o_tree_1.NO_SYNTAX;
    }
    asExpression(node, context) {
        return context.convert(node.expression);
    }
    stringLiteral(node, _context) {
        const rawText = node.text;
        if (rawText.includes('\n')) {
            return new o_tree_1.OTree([
                '"""',
                rawText
                    // Escape all occurrences of back-slash once more
                    .replace(/\\/g, '\\\\')
                    // Escape only the first one in triple-quotes
                    .replace(/"""/g, '\\"""'),
                '"""',
            ]);
        }
        return new o_tree_1.OTree([JSON.stringify(rawText)]);
    }
    templateExpression(node, context) {
        const parts = new Array();
        if (node.head.rawText) {
            parts.push(ast_utils_1.quoteStringLiteral(node.head.rawText));
        }
        for (const span of node.templateSpans) {
            parts.push(`{${context.textOf(span.expression)}}`);
            if (span.literal.rawText) {
                parts.push(ast_utils_1.quoteStringLiteral(span.literal.rawText));
            }
        }
        const quote = parts.some((part) => part.includes('\n')) ? '"""' : '"';
        return new o_tree_1.OTree([`f${quote}`, ...parts, quote]);
    }
    maskingVoidExpression(node, _context) {
        const arg = ast_utils_1.voidExpressionString(node);
        if (arg === 'block') {
            return new o_tree_1.OTree(['# ...'], [], { canBreakLine: true });
        }
        if (arg === '...') {
            return new o_tree_1.OTree(['...']);
        }
        return o_tree_1.NO_SYNTAX;
    }
    /**
     * Convert parameters
     *
     * If the last one has the type of a known struct, explode to keyword-only arguments.
     *
     * Returns a pair of [decls, excploded-var-name].
     */
    // tslint:disable-next-line:max-line-length
    convertFunctionCallParameters(params, context) {
        if (!params || params.length === 0) {
            return [[], undefined];
        }
        const returnExplodedParameter = {};
        // Convert the last element differently
        const converted = params.length > 0
            ? [
                ...context.convertAll(params.slice(0, params.length - 1)),
                context
                    .updateContext({
                    tailPositionParameter: true,
                    returnExplodedParameter,
                })
                    .convert(last(params)),
            ]
            : [];
        return [converted, returnExplodedParameter.value];
    }
    /**
     * Convert arguments.
     *
     * If the last argument:
     *
     * - is an object literal, explode it.
     * - is itself an exploded argument in our call signature, explode the fields
     */
    convertFunctionCallArguments(args, context, parameterDeclarations) {
        if (!args) {
            return o_tree_1.NO_SYNTAX;
        }
        const converted = context.convertWithModifier(args, (ctx, _arg, index) => {
            const decl = parameterDeclarations === null || parameterDeclarations === void 0 ? void 0 : parameterDeclarations[Math.min(index, parameterDeclarations.length - 1)];
            const variadicArgument = (decl === null || decl === void 0 ? void 0 : decl.dotDotDotToken) != null;
            const tailPositionArgument = index >= args.length - 1;
            return ctx.updateContext({ variadicArgument, tailPositionArgument });
        });
        return new o_tree_1.OTree([], converted, { separator: ', ', indent: 4 });
    }
    /**
     * Render a type.
     *
     * Not usually a thing in Python, but useful for declared variables.
     */
    renderType(owningNode, type, renderer, fallback) {
        return doRender(jsii_types_1.determineJsiiType(renderer.typeChecker, type));
        // eslint-disable-next-line consistent-return
        function doRender(jsiiType) {
            switch (jsiiType.kind) {
                case 'unknown':
                    return fallback;
                case 'error':
                    renderer.report(owningNode, jsiiType.message);
                    return fallback;
                case 'map':
                    return `dictionary of string to ${doRender(jsiiType.elementType)}`;
                case 'list':
                    return `list of ${doRender(jsiiType.elementType)}`;
                case 'namedType':
                    return jsiiType.name;
                case 'builtIn':
                    switch (jsiiType.builtIn) {
                        case 'boolean':
                            return 'boolean';
                        case 'number':
                            return 'number';
                        case 'string':
                            return 'string';
                        case 'any':
                            return 'object';
                        default:
                            return jsiiType.builtIn;
                    }
            }
        }
    }
    addImport(x) {
        this.imports.push(x);
        // Sort in reverse order of FQN length
        util_1.sortBy(this.imports, (i) => [-i.importedFqn.length]);
    }
    /**
     * Find the import for the FQNs submodule, and return it and the rest of the name
     */
    importedNameForType(jsiiSym) {
        // Look for an existing import that contains this symbol
        for (const imp of this.imports) {
            if (jsiiSym.fqn.startsWith(`${imp.importedFqn}.`)) {
                const remainder = jsiiSym.fqn.substring(imp.importedFqn.length + 1);
                return `${imp.importName}.${remainder}`;
            }
        }
        // Otherwise look up the Python name of this symbol (but not for fake imports from tests)
        const pythonName = findPythonName(jsiiSym);
        if (!jsiiSym.fqn.startsWith('fake_jsii.') && pythonName) {
            this.syntheticImportsToAdd.push(pythonName);
        }
        return jsii_utils_1.simpleName(jsiiSym.fqn);
    }
    renderSyntheticImports() {
        const grouped = util_1.groupBy(this.syntheticImportsToAdd, jsii_utils_1.namespaceName);
        return Object.entries(grouped).map(([namespaceFqn, fqns]) => {
            const simpleNames = fqns.map(jsii_utils_1.simpleName);
            return `from ${namespaceFqn} import ${simpleNames.join(', ')}\n`;
        });
    }
}
exports.PythonVisitor = PythonVisitor;
/**
 * Translation version
 *
 * Bump this when you change something in the implementation to invalidate
 * existing cached translations.
 */
PythonVisitor.VERSION = '1';
function mangleIdentifier(originalIdentifier) {
    if (util_1.startsWithUppercase(originalIdentifier)) {
        // Probably a class, leave as-is
        return originalIdentifier;
    }
    // Turn into snake-case
    const cased = originalIdentifier.replace(/[^A-Z][A-Z]/g, (m) => `${m[0].substr(0, 1)}_${m.substr(1).toLowerCase()}`);
    return IDENTIFIER_KEYWORDS.includes(cased) ? `${cased}_` : cased;
}
const BUILTIN_FUNCTIONS = {
    'console.log': 'print',
    'console.error': 'sys.stderr.write',
    'Math.random': 'random.random',
};
const TOKEN_REWRITES = {
    this: 'self',
    true: 'True',
    false: 'False',
};
const IDENTIFIER_KEYWORDS = ['lambda'];
function last(xs) {
    return xs[xs.length - 1];
}
/**
 * Find the Python name of a module or type
 */
function findPythonName(jsiiSymbol) {
    var _a, _b;
    if (!((_a = jsiiSymbol.sourceAssembly) === null || _a === void 0 ? void 0 : _a.assembly)) {
        // Don't have accurate info, just guess
        return jsiiSymbol.symbolType !== 'module' ? jsii_utils_1.simpleName(jsiiSymbol.fqn) : guessPythonPackageName(jsiiSymbol.fqn);
    }
    const asm = (_b = jsiiSymbol.sourceAssembly) === null || _b === void 0 ? void 0 : _b.assembly;
    return recurse(jsiiSymbol.fqn);
    function recurse(fqn) {
        var _a, _b;
        if (fqn === asm.name) {
            return (_a = packages_1.jsiiTargetParameter(asm, 'python.module')) !== null && _a !== void 0 ? _a : guessPythonPackageName(fqn);
        }
        if ((_b = asm.submodules) === null || _b === void 0 ? void 0 : _b[fqn]) {
            const modName = packages_1.jsiiTargetParameter(asm.submodules[fqn], 'python.module');
            if (modName) {
                return modName;
            }
        }
        return `${recurse(jsii_utils_1.namespaceName(fqn))}.${jsii_utils_1.simpleName(jsiiSymbol.fqn)}`;
    }
}
/**
 * Pythonify an assembly name and hope it is correct
 */
function guessPythonPackageName(ref) {
    return ref.replace(/^@/, '').replace(/\//g, '.').replace(/-/g, '_');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHl0aG9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicHl0aG9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUFpQztBQUVqQyxtREFBc0Y7QUFDdEYsbURBUTRCO0FBQzVCLCtDQUF1RDtBQUN2RCxrRUFBOEQ7QUFDOUQsc0NBQXlEO0FBQ3pELDBDQUFnRTtBQUNoRSx1REFNaUM7QUFFakMsK0NBQWdFO0FBQ2hFLGtDQUEyRTtBQUMzRSx1Q0FBMkM7QUF1RTNDLE1BQWEsYUFBYyxTQUFRLHdCQUFxQztJQXdCdEUsWUFBb0MsVUFBZ0MsRUFBRTtRQUNwRSxLQUFLLEVBQUUsQ0FBQztRQUQwQixZQUFPLEdBQVAsT0FBTyxDQUEyQjtRQWZ0RCxhQUFRLEdBQUcsZ0NBQWMsQ0FBQyxNQUFNLENBQUM7UUFDakMsbUJBQWMsR0FBRyxFQUFFLENBQUM7UUFFcEM7O1dBRUc7UUFDYyxZQUFPLEdBQUcsSUFBSSxLQUFLLEVBQWtCLENBQUM7UUFFdkQ7O1dBRUc7UUFDYywwQkFBcUIsR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO1FBRW5ELHdCQUFtQixHQUFHLEVBQUUsQ0FBQztJQUluQyxDQUFDO0lBRU0sWUFBWSxDQUFDLEdBQTBCLEVBQUUsTUFBc0M7UUFDcEYsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVNLFlBQVksQ0FBQyxPQUFzQixFQUFFLFFBQThCO1FBQ3hFLE1BQU0sV0FBVyxHQUFHLCtCQUFtQixDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDN0csTUFBTSxTQUFTLEdBQUcsV0FBVzthQUMxQixLQUFLLENBQUMsSUFBSSxDQUFDO2FBQ1gsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxD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QUUsUUFBUSxDQUFDO0lBQ2hELE9BQU8sT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUUvQixTQUFTLE9BQU8sQ0FBQyxHQUFXOztRQUMxQixJQUFJLEdBQUcsS0FBSyxHQUFHLENBQUMsSUFBSSxFQUFFO1lBQ3BCLGFBQU8sOEJBQW1CLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxtQ0FBSSxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNqRjtRQUNELFVBQUksR0FBRyxDQUFDLFVBQVUsMENBQUcsR0FBRyxHQUFHO1lBQ3pCLE1BQU0sT0FBTyxHQUFHLDhCQUFtQixDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDMUUsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsT0FBTyxPQUFPLENBQUM7YUFDaEI7U0FDRjtRQUVELE9BQU8sR0FBRyxPQUFPLENBQUMsMEJBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLHVCQUFVLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7SUFDeEUsQ0FBQztBQUNILENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsc0JBQXNCLENBQUMsR0FBVztJQUN6QyxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN0RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IGRldGVybWluZUpzaWlUeXBlLCBKc2lpVHlwZSwgT2JqZWN0TGl0ZXJhbFN0cnVjdCB9IGZyb20gJy4uL2pzaWkvanNpaS10eXBlcyc7XG5pbXBvcnQge1xuICBwcm9wZXJ0aWVzT2ZTdHJ1Y3QsXG4gIFN0cnVjdFByb3BlcnR5LFxuICBzdHJ1Y3RQcm9wZXJ0eUFjY2VwdHNVbmRlZmluZWQsXG4gIGFuYWx5emVTdHJ1Y3RUeXBlLFxuICBKc2lpU3ltYm9sLFxuICBzaW1wbGVOYW1lLFxuICBuYW1lc3BhY2VOYW1lLFxufSBmcm9tICcuLi9qc2lpL2pzaWktdXRpbHMnO1xuaW1wb3J0IHsganNpaVRhcmdldFBhcmFtZXRlciB9IGZyb20gJy4uL2pzaWkvcGFja2FnZXMnO1xuaW1wb3J0IHsgVGFyZ2V0TGFuZ3VhZ2UgfSBmcm9tICcuLi9sYW5ndWFnZXMvdGFyZ2V0LWxhbmd1YWdlJztcbmltcG9ydCB7IE5PX1NZTlRBWCwgT1RyZWUsIHJlbmRlclRyZWUgfSBmcm9tICcuLi9vLXRyZWUnO1xuaW1wb3J0IHsgQXN0UmVuZGVyZXIsIG5pbXBsLCBDb21tZW50U3ludGF4IH0gZnJvbSAnLi4vcmVuZGVyZXInO1xuaW1wb3J0IHtcbiAgbWF0Y2hBc3QsXG4gIG5vZGVPZlR5cGUsXG4gIHN0cmlwQ29tbWVudE1hcmtlcnMsXG4gIHZvaWRFeHByZXNzaW9uU3RyaW5nLFxuICBxdW90ZVN0cmluZ0xpdGVyYWwsXG59IGZyb20gJy4uL3R5cGVzY3JpcHQvYXN0LXV0aWxzJztcbmltcG9ydCB7IEltcG9ydFN0YXRlbWVudCB9IGZyb20gJy4uL3R5cGVzY3JpcHQvaW1wb3J0cyc7XG5pbXBvcnQgeyBwYXJhbWV0ZXJBY2NlcHRzVW5kZWZpbmVkIH0gZnJvbSAnLi4vdHlwZXNjcmlwdC90eXBlcyc7XG5pbXBvcnQgeyBzdGFydHNXaXRoVXBwZXJjYXNlLCBmbGF0LCBzb3J0QnksIGdyb3VwQnksIGZtYXAgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IERlZmF1bHRWaXNpdG9yIH0gZnJvbSAnLi9kZWZhdWx0JztcblxuaW50ZXJmYWNlIFN0cnVjdFZhciB7XG4gIHZhcmlhYmxlTmFtZTogc3RyaW5nO1xuICB0eXBlOiB0cy5UeXBlIHwgdW5kZWZpbmVkO1xufVxuXG50eXBlIFJldHVybkZyb21UcmVlPEE+ID0geyB2YWx1ZT86IEEgfTtcblxuaW50ZXJmYWNlIFB5dGhvbkxhbmd1YWdlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgYSBwYXJhbWV0ZXIgaW4gdGFpbCBwb3NpdGlvblxuICAgKlxuICAgKiBJZiBzbywgYW5kIHRoZSBwYXJhbWV0ZXIgaXMgb2YgdHlwZSBzdHJ1Y3QsIGV4cGxvZGUgaXQgdG8ga2V5d29yZCBhcmdzXG4gICAqIGFuZCByZXR1cm4gaXRzIGluZm9ybWF0aW9uIGluIGByZXR1cm5FeHBsb2RlZFBhcmFtZXRlcmAuXG4gICAqL1xuICByZWFkb25seSB0YWlsUG9zaXRpb25QYXJhbWV0ZXI/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJldHVybiBkZXRhaWxzIGFib3V0IGFueSBleHBsb2RlZCBwYXJhbWV0ZXJcbiAgICovXG4gIHJlYWRvbmx5IHJldHVybkV4cGxvZGVkUGFyYW1ldGVyPzogUmV0dXJuRnJvbVRyZWU8U3RydWN0VmFyPjtcblxuICAvKipcbiAgICogV2hldGhlciB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIGEgdmFsdWUvZXhwcmVzc2lvbiBpbiB0YWlsIHBvc2l0aW9uXG4gICAqXG4gICAqIElmIHNvLCBhbmQgdGhlIGV4cHJlc3Npb24gc2VlbXMgdG8gYmUgb2YgYSBzdHJ1Y3QgdHlwZSwgZXhwbG9kZSBpdFxuICAgKiB0byBrZXl3b3JkIGFyZ3MuXG4gICAqL1xuICByZWFkb25seSB0YWlsUG9zaXRpb25Bcmd1bWVudD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb2JqZWN0IGxpdGVyYWwgbWVtYmVycyBzaG91bGQgcmVuZGVyIHRoZW1zZWx2ZXMgYXMgZGljdFxuICAgKiBtZW1iZXJzIG9yIGtleXdvcmQgYXJnc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVuZGVyT2JqZWN0TGl0ZXJhbEFzS2V5d29yZHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbiBhIGNvZGUgYmxvY2ssIGlmIGFueSBwYXJhbWV0ZXIgaXMgZXhwbG9kZWQsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwYXJhbWV0ZXIgaGVyZVxuICAgKi9cbiAgcmVhZG9ubHkgZXhwbG9kZWRQYXJhbWV0ZXI/OiBTdHJ1Y3RWYXI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2UncmUgcmVuZGVyaW5nIGEgbWV0aG9kIG9yIHByb3BlcnR5IGluc2lkZSBhIGNsYXNzXG4gICAqL1xuICByZWFkb25seSBpbkNsYXNzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgd2UncmUgaW4gYSBtZXRob2QsIHdoYXQgaXMgaXQncyBuYW1lXG4gICAqXG4gICAqIChVc2VkIHRvIHJlbmRlciBzdXBlcigpIGNhbGwuKTtcbiAgICovXG4gIHJlYWRvbmx5IGN1cnJlbnRNZXRob2ROYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiB3ZSdyZSByZW5kZXJpbmcgYSB2YXJpYWRpYyBhcmd1bWVudCB2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFyaWFkaWNBcmd1bWVudD86IGJvb2xlYW47XG59XG5cbnR5cGUgUHl0aG9uVmlzaXRvckNvbnRleHQgPSBBc3RSZW5kZXJlcjxQeXRob25MYW5ndWFnZUNvbnRleHQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFB5dGhvblZpc2l0b3JPcHRpb25zIHtcbiAgZGlzY2xhaW1lcj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEltcG9ydGVkTW9kdWxlIHtcbiAgcmVhZG9ubHkgaW1wb3J0ZWRGcW46IHN0cmluZztcbiAgcmVhZG9ubHkgaW1wb3J0TmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgUHl0aG9uVmlzaXRvciBleHRlbmRzIERlZmF1bHRWaXNpdG9yPFB5dGhvbkxhbmd1YWdlQ29udGV4dD4ge1xuICAvKipcbiAgICogVHJhbnNsYXRpb24gdmVyc2lvblxuICAgKlxuICAgKiBCdW1wIHRoaXMgd2hlbiB5b3UgY2hhbmdlIHNvbWV0aGluZyBpbiB0aGUgaW1wbGVtZW50YXRpb24gdG8gaW52YWxpZGF0ZVxuICAgKiBleGlzdGluZyBjYWNoZWQgdHJhbnNsYXRpb25zLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBWRVJTSU9OID0gJzEnO1xuXG4gIHB1YmxpYyByZWFkb25seSBsYW5ndWFnZSA9IFRhcmdldExhbmd1YWdlLlBZVEhPTjtcbiAgcHVibGljIHJlYWRvbmx5IGRlZmF1bHRDb250ZXh0ID0ge307XG5cbiAgLyoqXG4gICAqIEtlZXAgdHJhY2sgb2YgbW9kdWxlIGltcG9ydHMgd2UndmUgc2Vlbiwgc28gdGhhdCBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhIHR5cGUgd2UgY2FuIHBpY2sgZnJvbSB0aGVzZSBtb2R1bGVzXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGltcG9ydHMgPSBuZXcgQXJyYXk8SW1wb3J0ZWRNb2R1bGU+KCk7XG5cbiAgLyoqXG4gICAqIFN5bnRoZXRpYyBpbXBvcnRzIHRoYXQgbmVlZCB0byBiZSBhZGRlZCBhcyBhIGZpbmFsIHN0ZXBcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc3ludGhldGljSW1wb3J0c1RvQWRkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICBwcm90ZWN0ZWQgc3RhdGVtZW50VGVybWluYXRvciA9ICcnO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFB5dGhvblZpc2l0b3JPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHVibGljIG1lcmdlQ29udGV4dChvbGQ6IFB5dGhvbkxhbmd1YWdlQ29udGV4dCwgdXBkYXRlOiBQYXJ0aWFsPFB5dGhvbkxhbmd1YWdlQ29udGV4dD4pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2xkLCB1cGRhdGUpO1xuICB9XG5cbiAgcHVibGljIGNvbW1lbnRSYW5nZShjb21tZW50OiBDb21tZW50U3ludGF4LCBfY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgY29uc3QgY29tbWVudFRleHQgPSBzdHJpcENvbW1lbnRNYXJrZXJzKGNvbW1lbnQudGV4dCwgY29tbWVudC5raW5kID09PSB0cy5TeW50YXhLaW5kLk11bHRpTGluZUNvbW1lbnRUcml2aWEpO1xuICAgIGNvbnN0IGhhc2hMaW5lcyA9IGNvbW1lbnRUZXh0XG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAubWFwKChsKSA9PiBgIyAke2x9YClcbiAgICAgIC5qb2luKCdcXG4nKTtcbiAgICBjb25zdCBuZWVkc0FkZGl0aW9uYWxUcmFpbGVyID0gY29tbWVudC5oYXNUcmFpbGluZ05ld0xpbmU7XG5cbiAgICByZXR1cm4gbmV3IE9UcmVlKFtjb21tZW50LmlzVHJhaWxpbmcgPyAnICcgOiAnJywgaGFzaExpbmVzLCBuZWVkc0FkZGl0aW9uYWxUcmFpbGVyID8gJ1xcbicgOiAnJ10sIFtdLCB7XG4gICAgICAvLyBNYWtlIHN1cmUgY29tbWVudCBpcyByZW5kZXJlZCBleGFjdGx5IG9uY2UgaW4gdGhlIG91dHB1dCB0cmVlLCBub1xuICAgICAgLy8gbWF0dGVyIGhvdyBtYW55IHNvdXJjZSBub2RlcyBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAgIHJlbmRlck9uY2U6IGBjb21tZW50LSR7Y29tbWVudC5wb3N9YCxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzb3VyY2VGaWxlKG5vZGU6IHRzLlNvdXJjZUZpbGUsIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0KTogT1RyZWUge1xuICAgIGxldCByZW5kZXJlZCA9IHN1cGVyLnNvdXJjZUZpbGUobm9kZSwgY29udGV4dCk7XG5cbiAgICAvLyBBZGQgc3ludGhldGljIGltcG9ydHNcbiAgICBpZiAodGhpcy5zeW50aGV0aWNJbXBvcnRzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgICAgcmVuZGVyZWQgPSBuZXcgT1RyZWUoWy4uLnRoaXMucmVuZGVyU3ludGhldGljSW1wb3J0cygpLCByZW5kZXJlZF0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzY2xhaW1lcikge1xuICAgICAgcmVuZGVyZWQgPSBuZXcgT1RyZWUoW2AjICR7dGhpcy5vcHRpb25zLmRpc2NsYWltZXJ9XFxuYCwgcmVuZGVyZWRdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVkO1xuICB9XG5cbiAgcHVibGljIGltcG9ydFN0YXRlbWVudChub2RlOiBJbXBvcnRTdGF0ZW1lbnQsIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0KTogT1RyZWUge1xuICAgIGlmIChub2RlLmltcG9ydHMuaW1wb3J0ID09PSAnZnVsbCcpIHtcbiAgICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBmbWFwKG5vZGUubW9kdWxlU3ltYm9sLCBmaW5kUHl0aG9uTmFtZSkgPz8gZ3Vlc3NQeXRob25QYWNrYWdlTmFtZShub2RlLnBhY2thZ2VOYW1lKTtcblxuICAgICAgdGhpcy5hZGRJbXBvcnQoe1xuICAgICAgICBpbXBvcnRlZEZxbjogbm9kZS5tb2R1bGVTeW1ib2w/LmZxbiA/PyBub2RlLnBhY2thZ2VOYW1lLFxuICAgICAgICBpbXBvcnROYW1lOiBub2RlLmltcG9ydHMuYWxpYXMsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBPVHJlZShbYGltcG9ydCAke21vZHVsZU5hbWV9IGFzICR7bWFuZ2xlSWRlbnRpZmllcihub2RlLmltcG9ydHMuYWxpYXMpfWBdLCBbXSwge1xuICAgICAgICBjYW5CcmVha0xpbmU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5vZGUuaW1wb3J0cy5pbXBvcnQgPT09ICdzZWxlY3RpdmUnKSB7XG4gICAgICBmb3IgKGNvbnN0IGltIG9mIG5vZGUuaW1wb3J0cy5lbGVtZW50cykge1xuICAgICAgICBpZiAoaW0uaW1wb3J0ZWRTeW1ib2wpIHtcbiAgICAgICAgICB0aGlzLmFkZEltcG9ydCh7XG4gICAgICAgICAgICBpbXBvcnROYW1lOiBpbS5hbGlhcyA/IGltLmFsaWFzIDogaW0uc291cmNlTmFtZSxcbiAgICAgICAgICAgIGltcG9ydGVkRnFuOiBpbS5pbXBvcnRlZFN5bWJvbC5mcW4sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1wb3J0cyA9IG5vZGUuaW1wb3J0cy5lbGVtZW50cy5tYXAoKGltKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGltLmFsaWFzID8/IGltLnNvdXJjZU5hbWU7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IGZtYXAoZm1hcChpbS5pbXBvcnRlZFN5bWJvbCwgZmluZFB5dGhvbk5hbWUpLCBzaW1wbGVOYW1lKSA/PyBpbS5zb3VyY2VOYW1lO1xuXG4gICAgICAgIHJldHVybiBsb2NhbE5hbWUgPT09IG9yaWdpbmFsTmFtZVxuICAgICAgICAgID8gbWFuZ2xlSWRlbnRpZmllcihvcmlnaW5hbE5hbWUpXG4gICAgICAgICAgOiBgJHttYW5nbGVJZGVudGlmaWVyKG9yaWdpbmFsTmFtZSl9IGFzICR7bWFuZ2xlSWRlbnRpZmllcihsb2NhbE5hbWUpfWA7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IGZtYXAobm9kZS5tb2R1bGVTeW1ib2wsIGZpbmRQeXRob25OYW1lKSA/PyBndWVzc1B5dGhvblBhY2thZ2VOYW1lKG5vZGUucGFja2FnZU5hbWUpO1xuXG4gICAgICByZXR1cm4gbmV3IE9UcmVlKFtgZnJvbSAke21vZHVsZU5hbWV9IGltcG9ydCAke2ltcG9ydHMuam9pbignLCAnKX1gXSwgW10sIHtcbiAgICAgICAgY2FuQnJlYWtMaW5lOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5pbXBsKG5vZGUubm9kZSwgY29udGV4dCk7XG4gIH1cblxuICBwdWJsaWMgdG9rZW48QSBleHRlbmRzIHRzLlN5bnRheEtpbmQ+KG5vZGU6IHRzLlRva2VuPEE+LCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICBjb25zdCB0ZXh0ID0gY29udGV4dC50ZXh0T2Yobm9kZSk7XG4gICAgY29uc3QgbWFwcGVkID0gVE9LRU5fUkVXUklURVNbdGV4dF07XG4gICAgaWYgKG1hcHBlZCkge1xuICAgICAgcmV0dXJuIG5ldyBPVHJlZShbbWFwcGVkXSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci50b2tlbihub2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHB1YmxpYyBpZGVudGlmaWVyKG5vZGU6IHRzLklkZW50aWZpZXIsIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxJZGVudGlmaWVyID0gbm9kZS50ZXh0O1xuXG4gICAgY29uc3QgZXhwbG9kZWRQYXJhbWV0ZXIgPSBjb250ZXh0LmN1cnJlbnRDb250ZXh0LmV4cGxvZGVkUGFyYW1ldGVyO1xuICAgIGlmIChcbiAgICAgIGNvbnRleHQuY3VycmVudENvbnRleHQudGFpbFBvc2l0aW9uQXJndW1lbnQgJiZcbiAgICAgIGV4cGxvZGVkUGFyYW1ldGVyICYmXG4gICAgICBleHBsb2RlZFBhcmFtZXRlci50eXBlICYmXG4gICAgICBleHBsb2RlZFBhcmFtZXRlci52YXJpYWJsZU5hbWUgPT09IG9yaWdpbmFsSWRlbnRpZmllclxuICAgICkge1xuICAgICAgcmV0dXJuIG5ldyBPVHJlZShcbiAgICAgICAgW10sXG4gICAgICAgIHByb3BlcnRpZXNPZlN0cnVjdChleHBsb2RlZFBhcmFtZXRlci50eXBlLCBjb250ZXh0KS5tYXAoKHByb3ApID0+IG5ldyBPVHJlZShbcHJvcC5uYW1lLCAnPScsIHByb3AubmFtZV0pKSxcbiAgICAgICAgeyBzZXBhcmF0b3I6ICcsICcgfSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPVHJlZShbbWFuZ2xlSWRlbnRpZmllcihvcmlnaW5hbElkZW50aWZpZXIpXSk7XG4gIH1cblxuICBwdWJsaWMgZnVuY3Rpb25EZWNsYXJhdGlvbihub2RlOiB0cy5GdW5jdGlvbkRlY2xhcmF0aW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbkxpa2Uobm9kZSwgY29udGV4dCk7XG4gIH1cblxuICBwdWJsaWMgY29uc3RydWN0b3JEZWNsYXJhdGlvbihub2RlOiB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbkxpa2Uobm9kZSwgY29udGV4dCwgeyBpc0NvbnN0cnVjdG9yOiB0cnVlIH0pO1xuICB9XG5cbiAgcHVibGljIG1ldGhvZERlY2xhcmF0aW9uKG5vZGU6IHRzLk1ldGhvZERlY2xhcmF0aW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jdGlvbkxpa2Uobm9kZSwgY29udGV4dCk7XG4gIH1cblxuICBwdWJsaWMgZXhwcmVzc2lvblN0YXRlbWVudChub2RlOiB0cy5FeHByZXNzaW9uU3RhdGVtZW50LCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICBjb25zdCB0ZXh0ID0gY29udGV4dC50ZXh0T2Yobm9kZSk7XG4gICAgaWYgKHRleHQgPT09ICd0cnVlJykge1xuICAgICAgcmV0dXJuIG5ldyBPVHJlZShbJ1RydWUnXSk7XG4gICAgfVxuICAgIGlmICh0ZXh0ID09PSAnZmFsc2UnKSB7XG4gICAgICByZXR1cm4gbmV3IE9UcmVlKFsnRmFsc2UnXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgY29udGV4dCk7XG4gIH1cblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gIHB1YmxpYyBmdW5jdGlvbkxpa2UoXG4gICAgbm9kZTogdHMuRnVuY3Rpb25MaWtlRGVjbGFyYXRpb25CYXNlLFxuICAgIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0LFxuICAgIG9wdHM6IHsgaXNDb25zdHJ1Y3Rvcj86IGJvb2xlYW4gfSA9IHt9LFxuICApOiBPVHJlZSB7XG4gICAgY29uc3QgbWV0aG9kTmFtZSA9IG9wdHMuaXNDb25zdHJ1Y3RvciA/ICdfX2luaXRfXycgOiByZW5kZXJUcmVlKGNvbnRleHQuY29udmVydChub2RlLm5hbWUpKTtcblxuICAgIGNvbnN0IFtwYXJhbURlY2xzLCBleHBsb2RlZFBhcmFtZXRlcl0gPSB0aGlzLmNvbnZlcnRGdW5jdGlvbkNhbGxQYXJhbWV0ZXJzKG5vZGUucGFyYW1ldGVycywgY29udGV4dCk7XG5cbiAgICBjb25zdCByZXQgPSBuZXcgT1RyZWUoXG4gICAgICBbXG4gICAgICAgICdkZWYgJyxcbiAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgJygnLFxuICAgICAgICBuZXcgT1RyZWUoW10sIFtjb250ZXh0LmN1cnJlbnRDb250ZXh0LmluQ2xhc3MgPyAnc2VsZicgOiB1bmRlZmluZWQsIC4uLnBhcmFtRGVjbHNdLCB7XG4gICAgICAgICAgc2VwYXJhdG9yOiAnLCAnLFxuICAgICAgICB9KSxcbiAgICAgICAgJyk6ICcsXG4gICAgICBdLFxuICAgICAgW2NvbnRleHQudXBkYXRlQ29udGV4dCh7IGV4cGxvZGVkUGFyYW1ldGVyLCBjdXJyZW50TWV0aG9kTmFtZTogbWV0aG9kTmFtZSB9KS5jb252ZXJ0KG5vZGUuYm9keSldLFxuICAgICAge1xuICAgICAgICBjYW5CcmVha0xpbmU6IHRydWUsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgcHVibGljIGJsb2NrKG5vZGU6IHRzLkJsb2NrLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICBpZiAobm9kZS5zdGF0ZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBPVHJlZShbXSwgWydcXG5wYXNzJ10sIHsgaW5kZW50OiA0LCBjYW5CcmVha0xpbmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPVHJlZShbXSwgY29udGV4dC5jb252ZXJ0QWxsKG5vZGUuc3RhdGVtZW50cyksIHtcbiAgICAgIHNlcGFyYXRvcjogJycsXG4gICAgICBpbmRlbnQ6IDQsXG4gICAgICBjYW5CcmVha0xpbmU6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVndWxhckNhbGxFeHByZXNzaW9uKG5vZGU6IHRzLkNhbGxFeHByZXNzaW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICBsZXQgZXhwcmVzc2lvblRleHQ6IE9UcmVlIHwgc3RyaW5nID0gY29udGV4dC5jb252ZXJ0KG5vZGUuZXhwcmVzc2lvbik7XG5cbiAgICBpZiAobWF0Y2hBc3Qobm9kZS5leHByZXNzaW9uLCBub2RlT2ZUeXBlKHRzLlN5bnRheEtpbmQuU3VwZXJLZXl3b3JkKSkgJiYgY29udGV4dC5jdXJyZW50Q29udGV4dC5jdXJyZW50TWV0aG9kTmFtZSkge1xuICAgICAgZXhwcmVzc2lvblRleHQgPSBgc3VwZXIoKS4ke2NvbnRleHQuY3VycmVudENvbnRleHQuY3VycmVudE1ldGhvZE5hbWV9YDtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduYXR1cmUgPSBjb250ZXh0LnR5cGVDaGVja2VyLmdldFJlc29sdmVkU2lnbmF0dXJlKG5vZGUpO1xuXG4gICAgcmV0dXJuIG5ldyBPVHJlZShcbiAgICAgIFtcbiAgICAgICAgZXhwcmVzc2lvblRleHQsXG4gICAgICAgICcoJyxcbiAgICAgICAgdGhpcy5jb252ZXJ0RnVuY3Rpb25DYWxsQXJndW1lbnRzKFxuICAgICAgICAgIG5vZGUuYXJndW1lbnRzLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgc2lnbmF0dXJlPy5wYXJhbWV0ZXJzPy5tYXAoKHApID0+IHAudmFsdWVEZWNsYXJhdGlvbiBhcyB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbiksXG4gICAgICAgICksXG4gICAgICAgICcpJyxcbiAgICAgIF0sXG4gICAgICBbXSxcbiAgICAgIHsgY2FuQnJlYWtMaW5lOiB0cnVlIH0sXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBwcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24obm9kZTogdHMuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCkge1xuICAgIGNvbnN0IGZ1bGxUZXh0ID0gY29udGV4dC50ZXh0T2Yobm9kZSk7XG4gICAgaWYgKGZ1bGxUZXh0IGluIEJVSUxUSU5fRlVOQ1RJT05TKSB7XG4gICAgICByZXR1cm4gbmV3IE9UcmVlKFtCVUlMVElOX0ZVTkNUSU9OU1tmdWxsVGV4dF1dKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBsb2RlZFBhcmFtZXRlciA9IGNvbnRleHQuY3VycmVudENvbnRleHQuZXhwbG9kZWRQYXJhbWV0ZXI7XG5cbiAgICAvLyBXZSBtaWdodCBiZSBpbiBhIGNvbnRleHQgd2hlcmUgd2UndmUgZXhwbG9kZWQgdGhpcyBzdHJ1Y3QgaW50byBhcmd1bWVudHMsXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIHJldHVybiBqdXN0IHRoZSBhY2Nlc3NlZCB2YXJpYWJsZS5cbiAgICBpZiAoZXhwbG9kZWRQYXJhbWV0ZXIgJiYgY29udGV4dC50ZXh0T2Yobm9kZS5leHByZXNzaW9uKSA9PT0gZXhwbG9kZWRQYXJhbWV0ZXIudmFyaWFibGVOYW1lKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5jb252ZXJ0KG5vZGUubmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHB1YmxpYyBwYXJhbWV0ZXJEZWNsYXJhdGlvbihub2RlOiB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbiwgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgY29uc3QgdHlwZSA9IG5vZGUudHlwZSAmJiBjb250ZXh0LnR5cGVPZlR5cGUobm9kZS50eXBlKTtcblxuICAgIGlmIChcbiAgICAgIGNvbnRleHQuY3VycmVudENvbnRleHQudGFpbFBvc2l0aW9uUGFyYW1ldGVyICYmXG4gICAgICB0eXBlICYmXG4gICAgICBhbmFseXplU3RydWN0VHlwZShjb250ZXh0LnR5cGVDaGVja2VyLCB0eXBlKSAhPT0gZmFsc2VcbiAgICApIHtcbiAgICAgIC8vIFJldHVybiB0aGUgcGFyYW1ldGVyIHRoYXQgd2UgZXhwbG9kZWQgc28gdGhhdCB3ZSBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb25cbiAgICAgIC8vIHdoaWxlIHRyYW5zbGF0aW5nIHRoZSBib2R5LlxuICAgICAgaWYgKGNvbnRleHQuY3VycmVudENvbnRleHQucmV0dXJuRXhwbG9kZWRQYXJhbWV0ZXIpIHtcbiAgICAgICAgY29udGV4dC5jdXJyZW50Q29udGV4dC5yZXR1cm5FeHBsb2RlZFBhcmFtZXRlci52YWx1ZSA9IHtcbiAgICAgICAgICB2YXJpYWJsZU5hbWU6IGNvbnRleHQudGV4dE9mKG5vZGUubmFtZSksXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gRXhwbG9kZSB0byBmaWVsZHNcbiAgICAgIHJldHVybiBuZXcgT1RyZWUoW10sIFsnKicsIC4uLnByb3BlcnRpZXNPZlN0cnVjdCh0eXBlLCBjb250ZXh0KS5tYXAocmVuZGVyU3RydWN0UHJvcGVydHkpXSwgeyBzZXBhcmF0b3I6ICcsICcgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3VmZml4ID0gcGFyYW1ldGVyQWNjZXB0c1VuZGVmaW5lZChub2RlLCB0eXBlKSA/ICc9Tm9uZScgOiAnJztcblxuICAgIHJldHVybiBuZXcgT1RyZWUoW25vZGUuZG90RG90RG90VG9rZW4gPyAnKicgOiAnJywgY29udGV4dC5jb252ZXJ0KG5vZGUubmFtZSksIHN1ZmZpeF0pO1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyU3RydWN0UHJvcGVydHkocHJvcDogU3RydWN0UHJvcGVydHkpOiBzdHJpbmcge1xuICAgICAgY29uc3Qgc2Z4ID0gc3RydWN0UHJvcGVydHlBY2NlcHRzVW5kZWZpbmVkKHByb3ApID8gJz1Ob25lJyA6ICcnO1xuICAgICAgcmV0dXJuIHByb3AubmFtZSArIHNmeDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaWZTdGF0ZW1lbnQobm9kZTogdHMuSWZTdGF0ZW1lbnQsIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0KTogT1RyZWUge1xuICAgIGNvbnN0IGlmU3RtdCA9IG5ldyBPVHJlZShbJ2lmICcsIGNvbnRleHQuY29udmVydChub2RlLmV4cHJlc3Npb24pLCAnOiAnXSwgW2NvbnRleHQuY29udmVydChub2RlLnRoZW5TdGF0ZW1lbnQpXSwge1xuICAgICAgY2FuQnJlYWtMaW5lOiB0cnVlLFxuICAgIH0pO1xuICAgIGNvbnN0IGVsc2VTdG10ID0gbm9kZS5lbHNlU3RhdGVtZW50XG4gICAgICA/IG5ldyBPVHJlZShbJ2Vsc2U6ICddLCBbY29udGV4dC5jb252ZXJ0KG5vZGUuZWxzZVN0YXRlbWVudCldLCB7XG4gICAgICAgICAgY2FuQnJlYWtMaW5lOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZWxzZVN0bXRcbiAgICAgID8gbmV3IE9UcmVlKFtdLCBbaWZTdG10LCBlbHNlU3RtdF0sIHtcbiAgICAgICAgICBzZXBhcmF0b3I6ICdcXG4nLFxuICAgICAgICAgIGNhbkJyZWFrTGluZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIDogaWZTdG10O1xuICB9XG5cbiAgcHVibGljIHVua25vd25UeXBlT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24obm9kZTogdHMuT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24sIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0KTogT1RyZWUge1xuICAgIC8vIE5ldXRyYWxpemUgbG9jYWwgbW9kaWZpZXJzIGlmIGFueSBmb3IgdHJhbnNmb3JtaW5nIGZ1cnRoZXIgZG93bi5cbiAgICBjb25zdCBkb3duQ29udGV4dCA9IGNvbnRleHQudXBkYXRlQ29udGV4dCh7XG4gICAgICB0YWlsUG9zaXRpb25Bcmd1bWVudDogZmFsc2UsXG4gICAgICB2YXJpYWRpY0FyZ3VtZW50OiBmYWxzZSxcbiAgICB9KTtcblxuICAgIGlmIChjb250ZXh0LmN1cnJlbnRDb250ZXh0LnRhaWxQb3NpdGlvbkFyZ3VtZW50ICYmICFjb250ZXh0LmN1cnJlbnRDb250ZXh0LnZhcmlhZGljQXJndW1lbnQpIHtcbiAgICAgIC8vIEd1ZXNzIHRoYXQgaXQncyBhIHN0cnVjdCB3ZSBjYW4gcHJvYmFibHkgaW5saW5lIHRoZSBrd2FyZ3MgZm9yXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJPYmplY3RMaXRlcmFsRXhwcmVzc2lvbignJywgJycsIHRydWUsIG5vZGUsIGRvd25Db250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24oJ3snLCAnfScsIGZhbHNlLCBub2RlLCBkb3duQ29udGV4dCk7XG4gIH1cblxuICBwdWJsaWMga25vd25TdHJ1Y3RPYmplY3RMaXRlcmFsRXhwcmVzc2lvbihcbiAgICBub2RlOiB0cy5PYmplY3RMaXRlcmFsRXhwcmVzc2lvbixcbiAgICBzdHJ1Y3RUeXBlOiBPYmplY3RMaXRlcmFsU3RydWN0LFxuICAgIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0LFxuICApOiBPVHJlZSB7XG4gICAgaWYgKGNvbnRleHQuY3VycmVudENvbnRleHQudGFpbFBvc2l0aW9uQXJndW1lbnQpIHtcbiAgICAgIC8vIFdlIGtub3cgaXQncyBhIHN0cnVjdCB3ZSBjYW4gREVGSU5JVEVMWSBpbmxpbmUgdGhlIGFyZ3MgZm9yXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJPYmplY3RMaXRlcmFsRXhwcmVzc2lvbignJywgJycsIHRydWUsIG5vZGUsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0cnVjdE5hbWUgPVxuICAgICAgc3RydWN0VHlwZS5raW5kID09PSAnc3RydWN0JyA/IHRoaXMuaW1wb3J0ZWROYW1lRm9yVHlwZShzdHJ1Y3RUeXBlLmpzaWlTeW0pIDogc3RydWN0VHlwZS50eXBlLnN5bWJvbC5uYW1lO1xuXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24oYCR7c3RydWN0TmFtZX0oYCwgJyknLCB0cnVlLCBub2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHB1YmxpYyBrZXlWYWx1ZU9iamVjdExpdGVyYWxFeHByZXNzaW9uKG5vZGU6IHRzLk9iamVjdExpdGVyYWxFeHByZXNzaW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJPYmplY3RMaXRlcmFsRXhwcmVzc2lvbigneycsICd9JywgZmFsc2UsIG5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcHVibGljIHRyYW5zbGF0ZVVuYXJ5T3BlcmF0b3Iob3BlcmF0b3I6IHRzLlByZWZpeFVuYXJ5T3BlcmF0b3IpIHtcbiAgICBpZiAob3BlcmF0b3IgPT09IHRzLlN5bnRheEtpbmQuRXhjbGFtYXRpb25Ub2tlbikge1xuICAgICAgcmV0dXJuICdub3QgJztcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnRyYW5zbGF0ZVVuYXJ5T3BlcmF0b3Iob3BlcmF0b3IpO1xuICB9XG5cbiAgcHVibGljIHJlbmRlck9iamVjdExpdGVyYWxFeHByZXNzaW9uKFxuICAgIHByZWZpeDogc3RyaW5nLFxuICAgIHN1ZmZpeDogc3RyaW5nLFxuICAgIHJlbmRlck9iamVjdExpdGVyYWxBc0tleXdvcmRzOiBib29sZWFuLFxuICAgIG5vZGU6IHRzLk9iamVjdExpdGVyYWxFeHByZXNzaW9uLFxuICAgIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0LFxuICApOiBPVHJlZSB7XG4gICAgcmV0dXJuIG5ldyBPVHJlZShbcHJlZml4XSwgY29udGV4dC51cGRhdGVDb250ZXh0KHsgcmVuZGVyT2JqZWN0TGl0ZXJhbEFzS2V5d29yZHMgfSkuY29udmVydEFsbChub2RlLnByb3BlcnRpZXMpLCB7XG4gICAgICBzdWZmaXg6IGNvbnRleHQubWlycm9yTmV3bGluZUJlZm9yZShub2RlLnByb3BlcnRpZXNbMF0sIHN1ZmZpeCksXG4gICAgICBzZXBhcmF0b3I6ICcsICcsXG4gICAgICBpbmRlbnQ6IDQsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXJyYXlMaXRlcmFsRXhwcmVzc2lvbihub2RlOiB0cy5BcnJheUxpdGVyYWxFeHByZXNzaW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICByZXR1cm4gbmV3IE9UcmVlKFsnWyddLCBjb250ZXh0LmNvbnZlcnRBbGwobm9kZS5lbGVtZW50cyksIHtcbiAgICAgIHN1ZmZpeDogY29udGV4dC5taXJyb3JOZXdsaW5lQmVmb3JlKG5vZGUuZWxlbWVudHNbMF0sICddJyksXG4gICAgICBzZXBhcmF0b3I6ICcsICcsXG4gICAgICBpbmRlbnQ6IDQsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcHJvcGVydHlBc3NpZ25tZW50KG5vZGU6IHRzLlByb3BlcnR5QXNzaWdubWVudCwgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgY29uc3QgbWlkID0gY29udGV4dC5jdXJyZW50Q29udGV4dC5yZW5kZXJPYmplY3RMaXRlcmFsQXNLZXl3b3JkcyA/ICc9JyA6ICc6ICc7XG5cbiAgICAvLyBub2RlLm5hbWUgaXMgZWl0aGVyIGFuIGlkZW50aWZpZXIgb3IgYSBzdHJpbmcgbGl0ZXJhbC4gVGhlIHN0cmluZyBsaXRlcmFsXG4gICAgLy8gbmVlZHMgdG8gYmUgY29udmVydGVkIGRpZmZlcmVudGx5LlxuICAgIGxldCBuYW1lID0gY29udGV4dC5jb252ZXJ0KG5vZGUubmFtZSk7XG4gICAgbWF0Y2hBc3Qobm9kZS5uYW1lLCBub2RlT2ZUeXBlKCdzdHJpbmdMaXRlcmFsJywgdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsKSwgKGNhcHR1cmVkKSA9PiB7XG4gICAgICBuYW1lID0gbmV3IE9UcmVlKFttYW5nbGVJZGVudGlmaWVyKGNhcHR1cmVkLnN0cmluZ0xpdGVyYWwudGV4dCldKTtcbiAgICB9KTtcblxuICAgIC8vIElmIHRoaXMgaXNuJ3QgYSBjb21wdXRlZCBwcm9wZXJ0eSwgd2UgbXVzdCBxdW90ZSB0aGUga2V5ICh1bmxlc3MgaXQncyByZW5kZXJlZCBhcyBhIGtleXdvcmQpXG4gICAgaWYgKCFjb250ZXh0LmN1cnJlbnRDb250ZXh0LnJlbmRlck9iamVjdExpdGVyYWxBc0tleXdvcmRzICYmICF0cy5pc0NvbXB1dGVkUHJvcGVydHlOYW1lKG5vZGUubmFtZSkpIHtcbiAgICAgIG5hbWUgPSBuZXcgT1RyZWUoWydcIicsIG5hbWUsICdcIiddKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9UcmVlKFxuICAgICAgW25hbWUsIG1pZCwgY29udGV4dC51cGRhdGVDb250ZXh0KHsgdGFpbFBvc2l0aW9uQXJndW1lbnQ6IGZhbHNlIH0pLmNvbnZlcnQobm9kZS5pbml0aWFsaXplcildLFxuICAgICAgW10sXG4gICAgICB7IGNhbkJyZWFrTGluZTogdHJ1ZSB9LFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgc2hvcnRoYW5kUHJvcGVydHlBc3NpZ25tZW50KG5vZGU6IHRzLlNob3J0aGFuZFByb3BlcnR5QXNzaWdubWVudCwgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgbGV0IGJlZm9yZSA9ICdcIic7XG4gICAgbGV0IG1pZCA9ICdcIjogJztcblxuICAgIGlmIChjb250ZXh0LmN1cnJlbnRDb250ZXh0LnJlbmRlck9iamVjdExpdGVyYWxBc0tleXdvcmRzKSB7XG4gICAgICBiZWZvcmUgPSAnJztcbiAgICAgIG1pZCA9ICc9JztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9UcmVlKFtiZWZvcmUsIGNvbnRleHQuY29udmVydChub2RlLm5hbWUpLCBtaWQsIGNvbnRleHQuY29udmVydChub2RlLm5hbWUpXSwgW10sIHsgY2FuQnJlYWtMaW5lOiB0cnVlIH0pO1xuICB9XG5cbiAgcHVibGljIG5ld0V4cHJlc3Npb24obm9kZTogdHMuTmV3RXhwcmVzc2lvbiwgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgcmV0dXJuIG5ldyBPVHJlZShcbiAgICAgIFtjb250ZXh0LmNvbnZlcnQobm9kZS5leHByZXNzaW9uKSwgJygnLCB0aGlzLmNvbnZlcnRGdW5jdGlvbkNhbGxBcmd1bWVudHMobm9kZS5hcmd1bWVudHMsIGNvbnRleHQpLCAnKSddLFxuICAgICAgW10sXG4gICAgICB7IGNhbkJyZWFrTGluZTogdHJ1ZSB9LFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgdmFyaWFibGVEZWNsYXJhdGlvbihub2RlOiB0cy5WYXJpYWJsZURlY2xhcmF0aW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICBsZXQgZmFsbGJhY2sgPSAnb2JqZWN0JztcbiAgICBpZiAobm9kZS50eXBlKSB7XG4gICAgICBmYWxsYmFjayA9IG5vZGUudHlwZS5nZXRUZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlLmluaXRpYWxpemVyKSB7XG4gICAgICBjb25zdCB0eXBlID1cbiAgICAgICAgKG5vZGUudHlwZSAmJiBjb250ZXh0LnR5cGVPZlR5cGUobm9kZS50eXBlKSkgfHxcbiAgICAgICAgKG5vZGUuaW5pdGlhbGl6ZXIgJiYgY29udGV4dC50eXBlT2ZFeHByZXNzaW9uKG5vZGUuaW5pdGlhbGl6ZXIpKTtcblxuICAgICAgY29uc3QgcmVuZGVyZWRUeXBlID0gdHlwZSA/IHRoaXMucmVuZGVyVHlwZShub2RlLCB0eXBlLCBjb250ZXh0LCBmYWxsYmFjaykgOiBmYWxsYmFjaztcbiAgICAgIHJldHVybiBuZXcgT1RyZWUoWycjICcsIGNvbnRleHQuY29udmVydChub2RlLm5hbWUpLCAnIGlzIG9mIHR5cGUgJywgcmVuZGVyZWRUeXBlXSwgW10pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgT1RyZWUoW2NvbnRleHQuY29udmVydChub2RlLm5hbWUpLCAnID0gJywgY29udGV4dC5jb252ZXJ0KG5vZGUuaW5pdGlhbGl6ZXIpXSwgW10sIHtcbiAgICAgIGNhbkJyZWFrTGluZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB0aGlzS2V5d29yZCgpIHtcbiAgICByZXR1cm4gbmV3IE9UcmVlKFsnc2VsZiddKTtcbiAgfVxuXG4gIHB1YmxpYyBmb3JPZlN0YXRlbWVudChub2RlOiB0cy5Gb3JPZlN0YXRlbWVudCwgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgLy8gVGhpcyBpcyB3aGF0IGEgXCJmb3IgKGNvbnN0IHggb2YgLi4uKVwiIGxvb2tzIGxpa2UgaW4gdGhlIEFTVFxuICAgIGxldCB2YXJpYWJsZU5hbWUgPSAnPz8/JztcblxuICAgIG1hdGNoQXN0KFxuICAgICAgbm9kZS5pbml0aWFsaXplcixcbiAgICAgIG5vZGVPZlR5cGUodHMuU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uTGlzdCwgbm9kZU9mVHlwZSgndmFyJywgdHMuU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uKSksXG4gICAgICAoYmluZGluZ3MpID0+IHtcbiAgICAgICAgdmFyaWFibGVOYW1lID0gbWFuZ2xlSWRlbnRpZmllcihjb250ZXh0LnRleHRPZihiaW5kaW5ncy52YXIubmFtZSkpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgcmV0dXJuIG5ldyBPVHJlZShcbiAgICAgIFsnZm9yICcsIHZhcmlhYmxlTmFtZSwgJyBpbiAnLCBjb250ZXh0LmNvbnZlcnQobm9kZS5leHByZXNzaW9uKSwgJzogJ10sXG4gICAgICBbY29udGV4dC5jb252ZXJ0KG5vZGUuc3RhdGVtZW50KV0sXG4gICAgICB7IGNhbkJyZWFrTGluZTogdHJ1ZSB9LFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgY2xhc3NEZWNsYXJhdGlvbihub2RlOiB0cy5DbGFzc0RlY2xhcmF0aW9uLCBjb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICBjb25zdCBoZXJpdGFnZSA9IGZsYXQoQXJyYXkuZnJvbShub2RlLmhlcml0YWdlQ2xhdXNlcyA/PyBbXSkubWFwKChoKSA9PiBBcnJheS5mcm9tKGgudHlwZXMpKSkubWFwKCh0KSA9PlxuICAgICAgY29udGV4dC5jb252ZXJ0KHQuZXhwcmVzc2lvbiksXG4gICAgKTtcbiAgICBjb25zdCBoYXNIZXJpdGFnZSA9IGhlcml0YWdlLmxlbmd0aCA+IDA7XG5cbiAgICBjb25zdCBtZW1iZXJzID0gY29udGV4dC51cGRhdGVDb250ZXh0KHsgaW5DbGFzczogdHJ1ZSB9KS5jb252ZXJ0QWxsKG5vZGUubWVtYmVycyk7XG4gICAgaWYgKG1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBtZW1iZXJzLnB1c2gobmV3IE9UcmVlKFsnXFxucGFzcyddLCBbXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IG5ldyBPVHJlZShcbiAgICAgIFtcbiAgICAgICAgJ2NsYXNzICcsXG4gICAgICAgIG5vZGUubmFtZSA/IGNvbnRleHQudGV4dE9mKG5vZGUubmFtZSkgOiAnPz8/JyxcbiAgICAgICAgaGFzSGVyaXRhZ2UgPyAnKCcgOiAnJyxcbiAgICAgICAgLi4uaGVyaXRhZ2UsXG4gICAgICAgIGhhc0hlcml0YWdlID8gJyknIDogJycsXG4gICAgICAgICc6ICcsXG4gICAgICBdLFxuICAgICAgbWVtYmVycyxcbiAgICAgIHtcbiAgICAgICAgaW5kZW50OiA0LFxuICAgICAgICBjYW5CcmVha0xpbmU6IHRydWUsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgcHVibGljIHByaW50U3RhdGVtZW50KGFyZ3M6IHRzLk5vZGVBcnJheTx0cy5FeHByZXNzaW9uPiwgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IE9UcmVlKFsncHJpbnQnLCAnKCcsIG5ldyBPVHJlZShbXSwgY29udGV4dC5jb252ZXJ0QWxsKGFyZ3MpLCB7IHNlcGFyYXRvcjogJywgJyB9KSwgJyknXSk7XG4gIH1cblxuICBwdWJsaWMgcHJvcGVydHlEZWNsYXJhdGlvbihfbm9kZTogdHMuUHJvcGVydHlEZWNsYXJhdGlvbiwgX2NvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0KTogT1RyZWUge1xuICAgIHJldHVybiBuZXcgT1RyZWUoW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIGhhdmUgdG8gZG8gc29tZXRoaW5nIHNwZWNpYWwgaGVyZVxuICAgKlxuICAgKiBCZXN0LWVmZm9ydCwgd2UgcmVtZW1iZXIgdGhlIGZpZWxkcyBvZiBzdHJ1Y3QgaW50ZXJmYWNlcyBhbmQga2VlcCB0cmFjayBvZlxuICAgKiB0aGVtLiBGb3J0dW5hdGVseSB3ZSBjYW4gZGV0ZXJtaW5lIGZyb20gdGhlIG5hbWUgd2hldGhlciB3aGF0IHRvIGRvLlxuICAgKi9cbiAgcHVibGljIGludGVyZmFjZURlY2xhcmF0aW9uKF9ub2RlOiB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbiwgX2NvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0KTogT1RyZWUge1xuICAgIC8vIFdoYXRldmVyIHdlIGRvLCBub3RoaW5nIGhlcmUgd2lsbCBoYXZlIGEgcmVwcmVzZW50YXRpb25cbiAgICByZXR1cm4gTk9fU1lOVEFYO1xuICB9XG5cbiAgcHVibGljIHByb3BlcnR5U2lnbmF0dXJlKF9ub2RlOiB0cy5Qcm9wZXJ0eVNpZ25hdHVyZSwgX2NvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0KTogT1RyZWUge1xuICAgIC8vIERvZXMgbm90IHJlcHJlc2VudCBpbiBQeXRob25cbiAgICByZXR1cm4gTk9fU1lOVEFYO1xuICB9XG5cbiAgcHVibGljIG1ldGhvZFNpZ25hdHVyZShfbm9kZTogdHMuTWV0aG9kU2lnbmF0dXJlLCBfY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgLy8gRG9lcyBub3QgcmVwcmVzZW50IGluIFB5dGhvblxuICAgIHJldHVybiBOT19TWU5UQVg7XG4gIH1cblxuICBwdWJsaWMgYXNFeHByZXNzaW9uKG5vZGU6IHRzLkFzRXhwcmVzc2lvbiwgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY29udmVydChub2RlLmV4cHJlc3Npb24pO1xuICB9XG5cbiAgcHVibGljIHN0cmluZ0xpdGVyYWwoXG4gICAgbm9kZTogdHMuU3RyaW5nTGl0ZXJhbCB8IHRzLk5vU3Vic3RpdHV0aW9uVGVtcGxhdGVMaXRlcmFsLFxuICAgIF9jb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCxcbiAgKTogT1RyZWUge1xuICAgIGNvbnN0IHJhd1RleHQgPSBub2RlLnRleHQ7XG4gICAgaWYgKHJhd1RleHQuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICByZXR1cm4gbmV3IE9UcmVlKFtcbiAgICAgICAgJ1wiXCJcIicsXG4gICAgICAgIHJhd1RleHRcbiAgICAgICAgICAvLyBFc2NhcGUgYWxsIG9jY3VycmVuY2VzIG9mIGJhY2stc2xhc2ggb25jZSBtb3JlXG4gICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgICAgICAvLyBFc2NhcGUgb25seSB0aGUgZmlyc3Qgb25lIGluIHRyaXBsZS1xdW90ZXNcbiAgICAgICAgICAucmVwbGFjZSgvXCJcIlwiL2csICdcXFxcXCJcIlwiJyksXG4gICAgICAgICdcIlwiXCInLFxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT1RyZWUoW0pTT04uc3RyaW5naWZ5KHJhd1RleHQpXSk7XG4gIH1cblxuICBwdWJsaWMgdGVtcGxhdGVFeHByZXNzaW9uKG5vZGU6IHRzLlRlbXBsYXRlRXhwcmVzc2lvbiwgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQpOiBPVHJlZSB7XG4gICAgY29uc3QgcGFydHMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgIGlmIChub2RlLmhlYWQucmF3VGV4dCkge1xuICAgICAgcGFydHMucHVzaChxdW90ZVN0cmluZ0xpdGVyYWwobm9kZS5oZWFkLnJhd1RleHQpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzcGFuIG9mIG5vZGUudGVtcGxhdGVTcGFucykge1xuICAgICAgcGFydHMucHVzaChgeyR7Y29udGV4dC50ZXh0T2Yoc3Bhbi5leHByZXNzaW9uKX19YCk7XG4gICAgICBpZiAoc3Bhbi5saXRlcmFsLnJhd1RleHQpIHtcbiAgICAgICAgcGFydHMucHVzaChxdW90ZVN0cmluZ0xpdGVyYWwoc3Bhbi5saXRlcmFsLnJhd1RleHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBxdW90ZSA9IHBhcnRzLnNvbWUoKHBhcnQpID0+IHBhcnQuaW5jbHVkZXMoJ1xcbicpKSA/ICdcIlwiXCInIDogJ1wiJztcblxuICAgIHJldHVybiBuZXcgT1RyZWUoW2BmJHtxdW90ZX1gLCAuLi5wYXJ0cywgcXVvdGVdKTtcbiAgfVxuXG4gIHB1YmxpYyBtYXNraW5nVm9pZEV4cHJlc3Npb24obm9kZTogdHMuVm9pZEV4cHJlc3Npb24sIF9jb250ZXh0OiBQeXRob25WaXNpdG9yQ29udGV4dCk6IE9UcmVlIHtcbiAgICBjb25zdCBhcmcgPSB2b2lkRXhwcmVzc2lvblN0cmluZyhub2RlKTtcbiAgICBpZiAoYXJnID09PSAnYmxvY2snKSB7XG4gICAgICByZXR1cm4gbmV3IE9UcmVlKFsnIyAuLi4nXSwgW10sIHsgY2FuQnJlYWtMaW5lOiB0cnVlIH0pO1xuICAgIH1cbiAgICBpZiAoYXJnID09PSAnLi4uJykge1xuICAgICAgcmV0dXJuIG5ldyBPVHJlZShbJy4uLiddKTtcbiAgICB9XG4gICAgcmV0dXJuIE5PX1NZTlRBWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHBhcmFtZXRlcnNcbiAgICpcbiAgICogSWYgdGhlIGxhc3Qgb25lIGhhcyB0aGUgdHlwZSBvZiBhIGtub3duIHN0cnVjdCwgZXhwbG9kZSB0byBrZXl3b3JkLW9ubHkgYXJndW1lbnRzLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgcGFpciBvZiBbZGVjbHMsIGV4Y3Bsb2RlZC12YXItbmFtZV0uXG4gICAqL1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gIHByaXZhdGUgY29udmVydEZ1bmN0aW9uQ2FsbFBhcmFtZXRlcnMoXG4gICAgcGFyYW1zOiB0cy5Ob2RlQXJyYXk8dHMuUGFyYW1ldGVyRGVjbGFyYXRpb24+IHwgdW5kZWZpbmVkLFxuICAgIGNvbnRleHQ6IFB5dGhvblZpc2l0b3JDb250ZXh0LFxuICApOiBbQXJyYXk8c3RyaW5nIHwgT1RyZWU+LCBTdHJ1Y3RWYXIgfCB1bmRlZmluZWRdIHtcbiAgICBpZiAoIXBhcmFtcyB8fCBwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW1tdLCB1bmRlZmluZWRdO1xuICAgIH1cblxuICAgIGNvbnN0IHJldHVybkV4cGxvZGVkUGFyYW1ldGVyOiBSZXR1cm5Gcm9tVHJlZTxTdHJ1Y3RWYXI+ID0ge307XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBsYXN0IGVsZW1lbnQgZGlmZmVyZW50bHlcbiAgICBjb25zdCBjb252ZXJ0ZWQ6IEFycmF5PHN0cmluZyB8IE9UcmVlPiA9XG4gICAgICBwYXJhbXMubGVuZ3RoID4gMFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIC4uLmNvbnRleHQuY29udmVydEFsbChwYXJhbXMuc2xpY2UoMCwgcGFyYW1zLmxlbmd0aCAtIDEpKSxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgLnVwZGF0ZUNvbnRleHQoe1xuICAgICAgICAgICAgICAgIHRhaWxQb3NpdGlvblBhcmFtZXRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZXR1cm5FeHBsb2RlZFBhcmFtZXRlcixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNvbnZlcnQobGFzdChwYXJhbXMpKSxcbiAgICAgICAgICBdXG4gICAgICAgIDogW107XG5cbiAgICByZXR1cm4gW2NvbnZlcnRlZCwgcmV0dXJuRXhwbG9kZWRQYXJhbWV0ZXIudmFsdWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYXJndW1lbnRzLlxuICAgKlxuICAgKiBJZiB0aGUgbGFzdCBhcmd1bWVudDpcbiAgICpcbiAgICogLSBpcyBhbiBvYmplY3QgbGl0ZXJhbCwgZXhwbG9kZSBpdC5cbiAgICogLSBpcyBpdHNlbGYgYW4gZXhwbG9kZWQgYXJndW1lbnQgaW4gb3VyIGNhbGwgc2lnbmF0dXJlLCBleHBsb2RlIHRoZSBmaWVsZHNcbiAgICovXG4gIHByaXZhdGUgY29udmVydEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyhcbiAgICBhcmdzOiB0cy5Ob2RlQXJyYXk8dHMuRXhwcmVzc2lvbj4gfCB1bmRlZmluZWQsXG4gICAgY29udGV4dDogUHl0aG9uVmlzaXRvckNvbnRleHQsXG4gICAgcGFyYW1ldGVyRGVjbGFyYXRpb25zPzogcmVhZG9ubHkgdHMuUGFyYW1ldGVyRGVjbGFyYXRpb25bXSxcbiAgKSB7XG4gICAgaWYgKCFhcmdzKSB7XG4gICAgICByZXR1cm4gTk9fU1lOVEFYO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnZlcnRlZCA9IGNvbnRleHQuY29udmVydFdpdGhNb2RpZmllcihhcmdzLCAoY3R4LCBfYXJnLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGVjbCA9IHBhcmFtZXRlckRlY2xhcmF0aW9ucz8uW01hdGgubWluKGluZGV4LCBwYXJhbWV0ZXJEZWNsYXJhdGlvbnMubGVuZ3RoIC0gMSldO1xuICAgICAgY29uc3QgdmFyaWFkaWNBcmd1bWVudCA9IGRlY2w/LmRvdERvdERvdFRva2VuICE9IG51bGw7XG4gICAgICBjb25zdCB0YWlsUG9zaXRpb25Bcmd1bWVudCA9IGluZGV4ID49IGFyZ3MubGVuZ3RoIC0gMTtcblxuICAgICAgcmV0dXJuIGN0eC51cGRhdGVDb250ZXh0KHsgdmFyaWFkaWNBcmd1bWVudCwgdGFpbFBvc2l0aW9uQXJndW1lbnQgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IE9UcmVlKFtdLCBjb252ZXJ0ZWQsIHsgc2VwYXJhdG9yOiAnLCAnLCBpbmRlbnQ6IDQgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgdHlwZS5cbiAgICpcbiAgICogTm90IHVzdWFsbHkgYSB0aGluZyBpbiBQeXRob24sIGJ1dCB1c2VmdWwgZm9yIGRlY2xhcmVkIHZhcmlhYmxlcy5cbiAgICovXG4gIHByaXZhdGUgcmVuZGVyVHlwZShvd25pbmdOb2RlOiB0cy5Ob2RlLCB0eXBlOiB0cy5UeXBlLCByZW5kZXJlcjogUHl0aG9uVmlzaXRvckNvbnRleHQsIGZhbGxiYWNrOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBkb1JlbmRlcihkZXRlcm1pbmVKc2lpVHlwZShyZW5kZXJlci50eXBlQ2hlY2tlciwgdHlwZSkpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgZnVuY3Rpb24gZG9SZW5kZXIoanNpaVR5cGU6IEpzaWlUeXBlKTogc3RyaW5nIHtcbiAgICAgIHN3aXRjaCAoanNpaVR5cGUua2luZCkge1xuICAgICAgICBjYXNlICd1bmtub3duJzpcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICByZW5kZXJlci5yZXBvcnQob3duaW5nTm9kZSwganNpaVR5cGUubWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICAgIHJldHVybiBgZGljdGlvbmFyeSBvZiBzdHJpbmcgdG8gJHtkb1JlbmRlcihqc2lpVHlwZS5lbGVtZW50VHlwZSl9YDtcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgcmV0dXJuIGBsaXN0IG9mICR7ZG9SZW5kZXIoanNpaVR5cGUuZWxlbWVudFR5cGUpfWA7XG4gICAgICAgIGNhc2UgJ25hbWVkVHlwZSc6XG4gICAgICAgICAgcmV0dXJuIGpzaWlUeXBlLm5hbWU7XG4gICAgICAgIGNhc2UgJ2J1aWx0SW4nOlxuICAgICAgICAgIHN3aXRjaCAoanNpaVR5cGUuYnVpbHRJbikge1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgICAgICBjYXNlICdhbnknOlxuICAgICAgICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4ganNpaVR5cGUuYnVpbHRJbjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhZGRJbXBvcnQoeDogSW1wb3J0ZWRNb2R1bGUpIHtcbiAgICB0aGlzLmltcG9ydHMucHVzaCh4KTtcbiAgICAvLyBTb3J0IGluIHJldmVyc2Ugb3JkZXIgb2YgRlFOIGxlbmd0aFxuICAgIHNvcnRCeSh0aGlzLmltcG9ydHMsIChpKSA9PiBbLWkuaW1wb3J0ZWRGcW4ubGVuZ3RoXSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgaW1wb3J0IGZvciB0aGUgRlFOcyBzdWJtb2R1bGUsIGFuZCByZXR1cm4gaXQgYW5kIHRoZSByZXN0IG9mIHRoZSBuYW1lXG4gICAqL1xuICBwcml2YXRlIGltcG9ydGVkTmFtZUZvclR5cGUoanNpaVN5bTogSnNpaVN5bWJvbCkge1xuICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIGltcG9ydCB0aGF0IGNvbnRhaW5zIHRoaXMgc3ltYm9sXG4gICAgZm9yIChjb25zdCBpbXAgb2YgdGhpcy5pbXBvcnRzKSB7XG4gICAgICBpZiAoanNpaVN5bS5mcW4uc3RhcnRzV2l0aChgJHtpbXAuaW1wb3J0ZWRGcW59LmApKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IGpzaWlTeW0uZnFuLnN1YnN0cmluZyhpbXAuaW1wb3J0ZWRGcW4ubGVuZ3RoICsgMSk7XG4gICAgICAgIHJldHVybiBgJHtpbXAuaW1wb3J0TmFtZX0uJHtyZW1haW5kZXJ9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgbG9vayB1cCB0aGUgUHl0aG9uIG5hbWUgb2YgdGhpcyBzeW1ib2wgKGJ1dCBub3QgZm9yIGZha2UgaW1wb3J0cyBmcm9tIHRlc3RzKVxuICAgIGNvbnN0IHB5dGhvbk5hbWUgPSBmaW5kUHl0aG9uTmFtZShqc2lpU3ltKTtcbiAgICBpZiAoIWpzaWlTeW0uZnFuLnN0YXJ0c1dpdGgoJ2Zha2VfanNpaS4nKSAmJiBweXRob25OYW1lKSB7XG4gICAgICB0aGlzLnN5bnRoZXRpY0ltcG9ydHNUb0FkZC5wdXNoKHB5dGhvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlTmFtZShqc2lpU3ltLmZxbik7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlclN5bnRoZXRpY0ltcG9ydHMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGdyb3VwZWQgPSBncm91cEJ5KHRoaXMuc3ludGhldGljSW1wb3J0c1RvQWRkLCBuYW1lc3BhY2VOYW1lKTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZ3JvdXBlZCkubWFwKChbbmFtZXNwYWNlRnFuLCBmcW5zXSkgPT4ge1xuICAgICAgY29uc3Qgc2ltcGxlTmFtZXMgPSBmcW5zLm1hcChzaW1wbGVOYW1lKTtcbiAgICAgIHJldHVybiBgZnJvbSAke25hbWVzcGFjZUZxbn0gaW1wb3J0ICR7c2ltcGxlTmFtZXMuam9pbignLCAnKX1cXG5gO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hbmdsZUlkZW50aWZpZXIob3JpZ2luYWxJZGVudGlmaWVyOiBzdHJpbmcpIHtcbiAgaWYgKHN0YXJ0c1dpdGhVcHBlcmNhc2Uob3JpZ2luYWxJZGVudGlmaWVyKSkge1xuICAgIC8vIFByb2JhYmx5IGEgY2xhc3MsIGxlYXZlIGFzLWlzXG4gICAgcmV0dXJuIG9yaWdpbmFsSWRlbnRpZmllcjtcbiAgfVxuICAvLyBUdXJuIGludG8gc25ha2UtY2FzZVxuICBjb25zdCBjYXNlZCA9IG9yaWdpbmFsSWRlbnRpZmllci5yZXBsYWNlKC9bXkEtWl1bQS1aXS9nLCAobSkgPT4gYCR7bVswXS5zdWJzdHIoMCwgMSl9XyR7bS5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKX1gKTtcbiAgcmV0dXJuIElERU5USUZJRVJfS0VZV09SRFMuaW5jbHVkZXMoY2FzZWQpID8gYCR7Y2FzZWR9X2AgOiBjYXNlZDtcbn1cblxuY29uc3QgQlVJTFRJTl9GVU5DVElPTlM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICdjb25zb2xlLmxvZyc6ICdwcmludCcsXG4gICdjb25zb2xlLmVycm9yJzogJ3N5cy5zdGRlcnIud3JpdGUnLFxuICAnTWF0aC5yYW5kb20nOiAncmFuZG9tLnJhbmRvbScsXG59O1xuXG5jb25zdCBUT0tFTl9SRVdSSVRFUzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgdGhpczogJ3NlbGYnLFxuICB0cnVlOiAnVHJ1ZScsXG4gIGZhbHNlOiAnRmFsc2UnLFxufTtcblxuY29uc3QgSURFTlRJRklFUl9LRVlXT1JEUzogc3RyaW5nW10gPSBbJ2xhbWJkYSddO1xuXG5mdW5jdGlvbiBsYXN0PEE+KHhzOiByZWFkb25seSBBW10pOiBBIHtcbiAgcmV0dXJuIHhzW3hzLmxlbmd0aCAtIDFdO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIFB5dGhvbiBuYW1lIG9mIGEgbW9kdWxlIG9yIHR5cGVcbiAqL1xuZnVuY3Rpb24gZmluZFB5dGhvbk5hbWUoanNpaVN5bWJvbDogSnNpaVN5bWJvbCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghanNpaVN5bWJvbC5zb3VyY2VBc3NlbWJseT8uYXNzZW1ibHkpIHtcbiAgICAvLyBEb24ndCBoYXZlIGFjY3VyYXRlIGluZm8sIGp1c3QgZ3Vlc3NcbiAgICByZXR1cm4ganNpaVN5bWJvbC5zeW1ib2xUeXBlICE9PSAnbW9kdWxlJyA/IHNpbXBsZU5hbWUoanNpaVN5bWJvbC5mcW4pIDogZ3Vlc3NQeXRob25QYWNrYWdlTmFtZShqc2lpU3ltYm9sLmZxbik7XG4gIH1cblxuICBjb25zdCBhc20gPSBqc2lpU3ltYm9sLnNvdXJjZUFzc2VtYmx5Py5hc3NlbWJseTtcbiAgcmV0dXJuIHJlY3Vyc2UoanNpaVN5bWJvbC5mcW4pO1xuXG4gIGZ1bmN0aW9uIHJlY3Vyc2UoZnFuOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChmcW4gPT09IGFzbS5uYW1lKSB7XG4gICAgICByZXR1cm4ganNpaVRhcmdldFBhcmFtZXRlcihhc20sICdweXRob24ubW9kdWxlJykgPz8gZ3Vlc3NQeXRob25QYWNrYWdlTmFtZShmcW4pO1xuICAgIH1cbiAgICBpZiAoYXNtLnN1Ym1vZHVsZXM/LltmcW5dKSB7XG4gICAgICBjb25zdCBtb2ROYW1lID0ganNpaVRhcmdldFBhcmFtZXRlcihhc20uc3VibW9kdWxlc1tmcW5dLCAncHl0aG9uLm1vZHVsZScpO1xuICAgICAgaWYgKG1vZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1vZE5hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3JlY3Vyc2UobmFtZXNwYWNlTmFtZShmcW4pKX0uJHtzaW1wbGVOYW1lKGpzaWlTeW1ib2wuZnFuKX1gO1xuICB9XG59XG5cbi8qKlxuICogUHl0aG9uaWZ5IGFuIGFzc2VtYmx5IG5hbWUgYW5kIGhvcGUgaXQgaXMgY29ycmVjdFxuICovXG5mdW5jdGlvbiBndWVzc1B5dGhvblBhY2thZ2VOYW1lKHJlZjogc3RyaW5nKSB7XG4gIHJldHVybiByZWYucmVwbGFjZSgvXkAvLCAnJykucmVwbGFjZSgvXFwvL2csICcuJykucmVwbGFjZSgvLS9nLCAnXycpO1xufVxuIl19