"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.indexBy = exports.isDefined = exports.groupBy = exports.sortBy = exports.mapValues = exports.fmap = exports.mkDict = exports.setExtend = exports.partition = exports.flat = exports.divideEvenly = exports.hasStrictBranding = exports.annotateStrictDiagnostic = exports.StrictBrand = exports.printDiagnostics = exports.startsWithUppercase = void 0;
function startsWithUppercase(x) {
    return /^[A-Z]/.exec(x) != null;
}
exports.startsWithUppercase = startsWithUppercase;
function printDiagnostics(diags, stream) {
    // Don't print too much, at some point it just clogs up the log
    const maxDiags = 50;
    for (const diag of diags.slice(0, maxDiags)) {
        stream.write(diag.formattedMessage);
    }
    if (diags.length > maxDiags) {
        stream.write(`(...and ${diags.length - maxDiags} more diagnostics not shown)`);
    }
}
exports.printDiagnostics = printDiagnostics;
exports.StrictBrand = 'jsii.strict';
/**
 * Annotate a diagnostic with a magic property to indicate it's a strict diagnostic
 */
function annotateStrictDiagnostic(diag) {
    Object.defineProperty(diag, exports.StrictBrand, {
        configurable: false,
        enumerable: true,
        value: true,
        writable: false,
    });
}
exports.annotateStrictDiagnostic = annotateStrictDiagnostic;
/**
 * Return whether or not the given diagnostic was annotated with the magic strict property
 */
function hasStrictBranding(diag) {
    return !!diag[exports.StrictBrand];
}
exports.hasStrictBranding = hasStrictBranding;
/**
 * Chunk an array of elements into approximately equal groups
 */
function divideEvenly(groups, xs) {
    const chunkSize = Math.ceil(xs.length / groups);
    const ret = [];
    for (let i = 0; i < groups; i++) {
        ret.push(xs.slice(i * chunkSize, (i + 1) * chunkSize));
    }
    return ret;
}
exports.divideEvenly = divideEvenly;
function flat(xs) {
    return Array.prototype.concat.apply([], xs);
}
exports.flat = flat;
/**
 * Partition a list in twain using a predicate
 *
 * Returns [elements-matching-predicate, elements-not-matching-predicate];
 */
function partition(xs, pred) {
    const truthy = new Array();
    const falsy = new Array();
    for (const x of xs) {
        if (pred(x)) {
            truthy.push(x);
        }
        else {
            falsy.push(x);
        }
    }
    return [truthy, falsy];
}
exports.partition = partition;
function setExtend(xs, els) {
    for (const el of els) {
        xs.add(el);
    }
}
exports.setExtend = setExtend;
function mkDict(xs) {
    const ret = {};
    for (const [key, value] of xs) {
        ret[key] = value;
    }
    return ret;
}
exports.mkDict = mkDict;
function fmap(value, fn) {
    if (value == null) {
        return undefined;
    }
    return fn(value);
}
exports.fmap = fmap;
function mapValues(xs, fn) {
    const ret = {};
    for (const [key, value] of Object.entries(xs)) {
        ret[key] = fn(value);
    }
    return ret;
}
exports.mapValues = mapValues;
/**
 * Sort an array by a key function.
 *
 * Instead of having to write your own comparators for your types any time you
 * want to sort, you supply a function that maps a value to a compound sort key
 * consisting of numbers or strings. The sorting will happen by that sort key
 * instead.
 */
function sortBy(xs, keyFn) {
    return xs.sort((a, b) => {
        const aKey = keyFn(a);
        const bKey = keyFn(b);
        for (let i = 0; i < Math.min(aKey.length, bKey.length); i++) {
            // Compare aKey[i] to bKey[i]
            const av = aKey[i];
            const bv = bKey[i];
            if (av === bv) {
                continue;
            }
            if (typeof av !== typeof bv) {
                throw new Error(`Type of sort key ${JSON.stringify(aKey)} not same as ${JSON.stringify(bKey)}`);
            }
            if (typeof av === 'number' && typeof bv === 'number') {
                return av - bv;
            }
            if (typeof av === 'string' && typeof bv === 'string') {
                return av.localeCompare(bv);
            }
        }
        return aKey.length - bKey.length;
    });
}
exports.sortBy = sortBy;
/**
 * Group elements by a key
 *
 * Supply a function that maps each element to a key string.
 *
 * Returns a map of the key to the list of elements that map to that key.
 */
function groupBy(xs, keyFn) {
    const ret = {};
    for (const x of xs) {
        const key = keyFn(x);
        if (ret[key]) {
            ret[key].push(x);
        }
        else {
            ret[key] = [x];
        }
    }
    return ret;
}
exports.groupBy = groupBy;
function isDefined(x) {
    return x !== undefined;
}
exports.isDefined = isDefined;
function indexBy(xs, fn) {
    return mkDict(xs.map((x) => [fn(x), x]));
}
exports.indexBy = indexBy;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBSUEsU0FBZ0IsbUJBQW1CLENBQUMsQ0FBUztJQUMzQyxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDO0FBQ2xDLENBQUM7QUFGRCxrREFFQztBQU9ELFNBQWdCLGdCQUFnQixDQUFDLEtBQW1DLEVBQUUsTUFBNkI7SUFDakcsK0RBQStEO0lBQy9ELE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUVwQixLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxFQUFFO1FBQzNDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7S0FDckM7SUFFRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsUUFBUSxFQUFFO1FBQzNCLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxLQUFLLENBQUMsTUFBTSxHQUFHLFFBQVEsOEJBQThCLENBQUMsQ0FBQztLQUNoRjtBQUNILENBQUM7QUFYRCw0Q0FXQztBQUVZLFFBQUEsV0FBVyxHQUFHLGFBQWEsQ0FBQztBQUt6Qzs7R0FFRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLElBQW1CO0lBQzFELE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLG1CQUFXLEVBQUU7UUFDdkMsWUFBWSxFQUFFLEtBQUs7UUFDbkIsVUFBVSxFQUFFLElBQUk7UUFDaEIsS0FBSyxFQUFFLElBQUk7UUFDWCxRQUFRLEVBQUUsS0FBSztLQUNoQixDQUFDLENBQUM7QUFDTCxDQUFDO0FBUEQsNERBT0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLGlCQUFpQixDQUFDLElBQW1CO0lBQ25ELE9BQU8sQ0FBQyxDQUFFLElBQThCLENBQUMsbUJBQVcsQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUFGRCw4Q0FF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RUFBRTtRQUNsQixNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckIsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDWixHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2xCO2FBQU07WUFDTCxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoQjtLQUNGO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBWEQsMEJBV0M7QUFFRCxTQUFnQixTQUFTLENBQUksQ0FBSTtJQUMvQixPQUFPLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDekIsQ0FBQztBQUZELDhCQUVDO0FBRUQsU0FBZ0IsT0FBTyxDQUFJLEVBQU8sRUFBRSxFQUFvQjtJQUN0RCxPQUFPLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQVUsQ0FBQyxDQUFDLENBQUM7QUFDcEQsQ0FBQztBQUZELDBCQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IFJvc2V0dGFEaWFnbm9zdGljIH0gZnJvbSAnLi90cmFuc2xhdGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aFVwcGVyY2FzZSh4OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eW0EtWl0vLmV4ZWMoeCkgIT0gbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlIHtcbiAgcmVhZG9ubHkgY29udGVudHM6IHN0cmluZztcbiAgcmVhZG9ubHkgZmlsZU5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50RGlhZ25vc3RpY3MoZGlhZ3M6IHJlYWRvbmx5IFJvc2V0dGFEaWFnbm9zdGljW10sIHN0cmVhbTogTm9kZUpTLldyaXRhYmxlU3RyZWFtKSB7XG4gIC8vIERvbid0IHByaW50IHRvbyBtdWNoLCBhdCBzb21lIHBvaW50IGl0IGp1c3QgY2xvZ3MgdXAgdGhlIGxvZ1xuICBjb25zdCBtYXhEaWFncyA9IDUwO1xuXG4gIGZvciAoY29uc3QgZGlhZyBvZiBkaWFncy5zbGljZSgwLCBtYXhEaWFncykpIHtcbiAgICBzdHJlYW0ud3JpdGUoZGlhZy5mb3JtYXR0ZWRNZXNzYWdlKTtcbiAgfVxuXG4gIGlmIChkaWFncy5sZW5ndGggPiBtYXhEaWFncykge1xuICAgIHN0cmVhbS53cml0ZShgKC4uLmFuZCAke2RpYWdzLmxlbmd0aCAtIG1heERpYWdzfSBtb3JlIGRpYWdub3N0aWNzIG5vdCBzaG93bilgKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgU3RyaWN0QnJhbmQgPSAnanNpaS5zdHJpY3QnO1xuaW50ZXJmYWNlIE1heWJlU3RyaWN0RGlhZ25vc3RpYyB7XG4gIHJlYWRvbmx5IFtTdHJpY3RCcmFuZF0/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEFubm90YXRlIGEgZGlhZ25vc3RpYyB3aXRoIGEgbWFnaWMgcHJvcGVydHkgdG8gaW5kaWNhdGUgaXQncyBhIHN0cmljdCBkaWFnbm9zdGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbm5vdGF0ZVN0cmljdERpYWdub3N0aWMoZGlhZzogdHMuRGlhZ25vc3RpYykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGlhZywgU3RyaWN0QnJhbmQsIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGRpYWdub3N0aWMgd2FzIGFubm90YXRlZCB3aXRoIHRoZSBtYWdpYyBzdHJpY3QgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1N0cmljdEJyYW5kaW5nKGRpYWc6IHRzLkRpYWdub3N0aWMpIHtcbiAgcmV0dXJuICEhKGRpYWcgYXMgTWF5YmVTdHJpY3REaWFnbm9zdGljKVtTdHJpY3RCcmFuZF07XG59XG5cbi8qKlxuICogQ2h1bmsgYW4gYXJyYXkgb2YgZWxlbWVudHMgaW50byBhcHByb3hpbWF0ZWx5IGVxdWFsIGdyb3Vwc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlRXZlbmx5PEE+KGdyb3VwczogbnVtYmVyLCB4czogQVtdKTogQVtdW10ge1xuICBjb25zdCBjaHVua1NpemUgPSBNYXRoLmNlaWwoeHMubGVuZ3RoIC8gZ3JvdXBzKTtcbiAgY29uc3QgcmV0OiBBW11bXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzOyBpKyspIHtcbiAgICByZXQucHVzaCh4cy5zbGljZShpICogY2h1bmtTaXplLCAoaSArIDEpICogY2h1bmtTaXplKSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmxhdDxBPih4czogQVtdW10pOiBBW10ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgeHMpO1xufVxuXG4vKipcbiAqIFBhcnRpdGlvbiBhIGxpc3QgaW4gdHdhaW4gdXNpbmcgYSBwcmVkaWNhdGVcbiAqXG4gKiBSZXR1cm5zIFtlbGVtZW50cy1tYXRjaGluZy1wcmVkaWNhdGUsIGVsZW1lbnRzLW5vdC1tYXRjaGluZy1wcmVkaWNhdGVdO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFydGl0aW9uPEE+KHhzOiBBW10sIHByZWQ6ICh4OiBBKSA9PiBib29sZWFuKTogW0FbXSwgQVtdXSB7XG4gIGNvbnN0IHRydXRoeSA9IG5ldyBBcnJheTxBPigpO1xuICBjb25zdCBmYWxzeSA9IG5ldyBBcnJheTxBPigpO1xuXG4gIGZvciAoY29uc3QgeCBvZiB4cykge1xuICAgIGlmIChwcmVkKHgpKSB7XG4gICAgICB0cnV0aHkucHVzaCh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsc3kucHVzaCh4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RXh0ZW5kPEE+KHhzOiBTZXQ8QT4sIGVsczogSXRlcmFibGU8QT4pIHtcbiAgZm9yIChjb25zdCBlbCBvZiBlbHMpIHtcbiAgICB4cy5hZGQoZWwpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBta0RpY3Q8QSBleHRlbmRzIHN0cmluZywgQj4oeHM6IEFycmF5PHJlYWRvbmx5IFtBLCBCXT4pOiBSZWNvcmQ8QSwgQj4ge1xuICBjb25zdCByZXQ6IGFueSA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB4cykge1xuICAgIHJldFtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGEgdmFsdWUsIGFzIGxvbmcgYXMgaXQncyBub3QgYHVuZGVmaW5lZGBcbiAqXG4gKiBUaGlzIGlzIGEgY29tcGFuaW9uIGhlbHBlciB0byBUeXBlU2NyaXB0J3MgbmljZSBgPz9gIGFuZCBgPy5gIG51bGxpc2hcbiAqIG9wZXJhdG9ycy4gVGhvc2Ugb3BlcmF0b3JzIGFyZSBoZWxwZnVsIGlmIHlvdSdyZSBjYWxsaW5nIG1ldGhvZHM6XG4gKlxuICogICAgb2JqZWN0Py5tZXRob2QoKSAgPC0gcmV0dXJucyAndW5kZWZpbmVkJyBpZiAnb2JqZWN0JyBpcyBudWxsaXNoXG4gKlxuICogQnV0IGFyZSBubyBoZWxwIHdoZW4geW91IHdhbnQgdG8gdXNlIGZyZWUgZnVuY3Rpb25zOlxuICpcbiAqICAgIGZ1bmMob2JqZWN0KSAgICAgIDwtIGJ1dCB3aGF0IGlmICdvYmplY3QnIGlzIG51bGxpc2ggYW5kIGZ1bmNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdHMgaXQgbm90IHRvIGJlP1xuICpcbiAqIFllcyB5b3UgY2FuIHdyaXRlIGBvYmplY3QgPyBmdW5jKG9iamVjdCkgOiB1bmRlZmluZWRgIGJ1dCB0aGUgdHJhaWxpbmdcbiAqIGA6IHVuZGVmaW5lZGAgY2x1dHRlcnMgeW91ciBjb2RlLiBJbnN0ZWFkLCB5b3Ugd3JpdGU6XG4gKlxuICogICAgZm1hcChvYmplY3QsIGZ1bmMpXG4gKlxuICogVGhlIG5hbWUgYGZtYXBgIGlzIHRha2VuIGZyb20gSGFza2VsbDogaXQncyBhIFwiRnVuY3Rvci1tYXBcIiAoYWx0aG91Z2hcbiAqIG9ubHkgZm9yIHRoZSBgTWF5YmVgIEZ1bmN0b3IpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm1hcDxBLCBCPih2YWx1ZTogTm9uTnVsbGFibGU8QT4sIGZuOiAoeDogTm9uTnVsbGFibGU8QT4pID0+IEIpOiBCO1xuZXhwb3J0IGZ1bmN0aW9uIGZtYXA8QSwgQj4odmFsdWU6IHVuZGVmaW5lZCB8IG51bGwsIGZuOiAoeDogTm9uTnVsbGFibGU8QT4pID0+IEIpOiB1bmRlZmluZWQ7XG5leHBvcnQgZnVuY3Rpb24gZm1hcDxBLCBCPih2YWx1ZTogQSB8IHVuZGVmaW5lZCB8IG51bGwsIGZuOiAoeDogQSkgPT4gQik6IEIgfCB1bmRlZmluZWQ7XG5leHBvcnQgZnVuY3Rpb24gZm1hcDxBLCBCPih2YWx1ZTogQSwgZm46ICh4OiBBKSA9PiBCKTogQiB8IHVuZGVmaW5lZCB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZm4odmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVmFsdWVzPEEsIEI+KHhzOiBSZWNvcmQ8c3RyaW5nLCBBPiwgZm46ICh4OiBBKSA9PiBCKTogUmVjb3JkPHN0cmluZywgQj4ge1xuICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIEI+ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHhzKSkge1xuICAgIHJldFtrZXldID0gZm4odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogU29ydCBhbiBhcnJheSBieSBhIGtleSBmdW5jdGlvbi5cbiAqXG4gKiBJbnN0ZWFkIG9mIGhhdmluZyB0byB3cml0ZSB5b3VyIG93biBjb21wYXJhdG9ycyBmb3IgeW91ciB0eXBlcyBhbnkgdGltZSB5b3VcbiAqIHdhbnQgdG8gc29ydCwgeW91IHN1cHBseSBhIGZ1bmN0aW9uIHRoYXQgbWFwcyBhIHZhbHVlIHRvIGEgY29tcG91bmQgc29ydCBrZXlcbiAqIGNvbnNpc3Rpbmcgb2YgbnVtYmVycyBvciBzdHJpbmdzLiBUaGUgc29ydGluZyB3aWxsIGhhcHBlbiBieSB0aGF0IHNvcnQga2V5XG4gKiBpbnN0ZWFkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydEJ5PEE+KHhzOiBBW10sIGtleUZuOiAoeDogQSkgPT4gQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikge1xuICByZXR1cm4geHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGFLZXkgPSBrZXlGbihhKTtcbiAgICBjb25zdCBiS2V5ID0ga2V5Rm4oYik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGFLZXkubGVuZ3RoLCBiS2V5Lmxlbmd0aCk7IGkrKykge1xuICAgICAgLy8gQ29tcGFyZSBhS2V5W2ldIHRvIGJLZXlbaV1cbiAgICAgIGNvbnN0IGF2ID0gYUtleVtpXTtcbiAgICAgIGNvbnN0IGJ2ID0gYktleVtpXTtcblxuICAgICAgaWYgKGF2ID09PSBidikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhdiAhPT0gdHlwZW9mIGJ2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSBvZiBzb3J0IGtleSAke0pTT04uc3RyaW5naWZ5KGFLZXkpfSBub3Qgc2FtZSBhcyAke0pTT04uc3RyaW5naWZ5KGJLZXkpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF2ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYnYgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhdiAtIGJ2O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF2ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYnYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhdi5sb2NhbGVDb21wYXJlKGJ2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYUtleS5sZW5ndGggLSBiS2V5Lmxlbmd0aDtcbiAgfSk7XG59XG5cbi8qKlxuICogR3JvdXAgZWxlbWVudHMgYnkgYSBrZXlcbiAqXG4gKiBTdXBwbHkgYSBmdW5jdGlvbiB0aGF0IG1hcHMgZWFjaCBlbGVtZW50IHRvIGEga2V5IHN0cmluZy5cbiAqXG4gKiBSZXR1cm5zIGEgbWFwIG9mIHRoZSBrZXkgdG8gdGhlIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBtYXAgdG8gdGhhdCBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5PEE+KHhzOiBBW10sIGtleUZuOiAoeDogQSkgPT4gc3RyaW5nKTogUmVjb3JkPHN0cmluZywgQVtdPiB7XG4gIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgQVtdPiA9IHt9O1xuICBmb3IgKGNvbnN0IHggb2YgeHMpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlGbih4KTtcbiAgICBpZiAocmV0W2tleV0pIHtcbiAgICAgIHJldFtrZXldLnB1c2goeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtrZXldID0gW3hdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkPEE+KHg6IEEpOiB4IGlzIE5vbk51bGxhYmxlPEE+IHtcbiAgcmV0dXJuIHggIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4Qnk8QT4oeHM6IEFbXSwgZm46ICh4OiBBKSA9PiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBBPiB7XG4gIHJldHVybiBta0RpY3QoeHMubWFwKCh4KSA9PiBbZm4oeCksIHhdIGFzIGNvbnN0KSk7XG59XG4iXX0=