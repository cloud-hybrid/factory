"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findContainingSubmodule = exports.findTypeLookupAssembly = exports.replaceAssembly = exports.allTypeScriptSnippets = exports.allSnippetSources = exports.loadAllDefaultTablets = exports.loadAssemblies = exports.EXAMPLE_METADATA_JSDOCTAG = void 0;
const spec = require("@jsii/spec");
const crypto = require("crypto");
const fs = require("fs-extra");
const path = require("path");
const fixtures_1 = require("../fixtures");
const extract_snippets_1 = require("../markdown/extract-snippets");
const snippet_1 = require("../snippet");
const strict_1 = require("../strict");
const tablets_1 = require("../tablets/tablets");
const util_1 = require("../util");
// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
const sortJson = require('sort-json');
/**
 * The JSDoc tag users can use to associate non-visible metadata with an example
 *
 * In a Markdown section, metadata goes after the code block fence, where it will
 * be attached to the example but invisible.
 *
 *    ```ts metadata=goes here
 *
 * But in doc comments, '@example' already delineates the example, and any metadata
 * in there added by the '///' tags becomes part of the visible code (there is no
 * place to put hidden information).
 *
 * We introduce the '@exampleMetadata' tag to put that additional information.
 */
exports.EXAMPLE_METADATA_JSDOCTAG = 'exampleMetadata';
/**
 * Load assemblies by filename or directory
 */
async function loadAssemblies(assemblyLocations, validateAssemblies) {
    return Promise.all(assemblyLocations.map(loadAssembly));
    async function loadAssembly(location) {
        const stat = await fs.stat(location);
        if (stat.isDirectory()) {
            return loadAssembly(path.join(location, '.jsii'));
        }
        return {
            assembly: await loadAssemblyFromFile(location, validateAssemblies),
            directory: path.dirname(location),
        };
    }
}
exports.loadAssemblies = loadAssemblies;
async function loadAssemblyFromFile(filename, validate) {
    const contents = await fs.readJSON(filename, { encoding: 'utf-8' });
    return validate ? spec.validateAssembly(contents) : contents;
}
/**
 * Load the default tablets for every assembly, if available
 *
 * Returns a map of { directory -> tablet }.
 */
async function loadAllDefaultTablets(asms) {
    return util_1.mkDict(await Promise.all(asms.map(async (a) => [a.directory, await tablets_1.LanguageTablet.fromOptionalFile(path.join(a.directory, tablets_1.DEFAULT_TABLET_NAME))])));
}
exports.loadAllDefaultTablets = loadAllDefaultTablets;
/**
 * Return all markdown and example snippets from the given assembly
 */
function allSnippetSources(assembly) {
    var _a;
    const ret = [];
    if (assembly.readme) {
        ret.push({
            type: 'markdown',
            markdown: assembly.readme.markdown,
            location: { api: 'moduleReadme', moduleFqn: assembly.name },
        });
    }
    for (const [submoduleFqn, submodule] of Object.entries((_a = assembly.submodules) !== null && _a !== void 0 ? _a : {})) {
        if (submodule.readme) {
            ret.push({
                type: 'markdown',
                markdown: submodule.readme.markdown,
                location: { api: 'moduleReadme', moduleFqn: submoduleFqn },
            });
        }
    }
    if (assembly.types) {
        Object.values(assembly.types).forEach((type) => {
            var _a, _b;
            emitDocs(type.docs, { api: 'type', fqn: type.fqn });
            if (spec.isEnumType(type)) {
                type.members.forEach((m) => emitDocs(m.docs, { api: 'member', fqn: type.fqn, memberName: m.name }));
            }
            if (spec.isClassType(type)) {
                emitDocsForCallable(type.initializer, type.fqn);
            }
            if (spec.isClassOrInterfaceType(type)) {
                ((_a = type.methods) !== null && _a !== void 0 ? _a : []).forEach((m) => emitDocsForCallable(m, type.fqn, m.name));
                ((_b = type.properties) !== null && _b !== void 0 ? _b : []).forEach((m) => emitDocs(m.docs, { api: 'member', fqn: type.fqn, memberName: m.name }));
            }
        });
    }
    return ret;
    function emitDocsForCallable(callable, fqn, memberName) {
        var _a;
        if (!callable) {
            return;
        }
        emitDocs(callable.docs, memberName ? { api: 'member', fqn, memberName } : { api: 'initializer', fqn });
        for (const parameter of (_a = callable.parameters) !== null && _a !== void 0 ? _a : []) {
            emitDocs(parameter.docs, {
                api: 'parameter',
                fqn: fqn,
                methodName: memberName !== null && memberName !== void 0 ? memberName : snippet_1.INITIALIZER_METHOD_NAME,
                parameterName: parameter.name,
            });
        }
    }
    function emitDocs(docs, location) {
        var _a;
        if (!docs) {
            return;
        }
        if (docs.remarks) {
            ret.push({
                type: 'markdown',
                markdown: docs.remarks,
                location,
            });
        }
        if (docs.example) {
            ret.push({
                type: 'example',
                source: docs.example,
                metadata: util_1.fmap((_a = docs.custom) === null || _a === void 0 ? void 0 : _a[exports.EXAMPLE_METADATA_JSDOCTAG], snippet_1.parseMetadataLine),
                location,
            });
        }
    }
}
exports.allSnippetSources = allSnippetSources;
function allTypeScriptSnippets(assemblies, loose = false) {
    var _a;
    const ret = new Array();
    for (const { assembly, directory } of assemblies) {
        const strict = strict_1.enforcesStrictMode(assembly);
        for (const source of allSnippetSources(assembly)) {
            switch (source.type) {
                case 'example':
                    // If an example is an infused example, we do not care about compiler errors.
                    // We are relying on the tablet cache to have this example stored already.
                    const [strictForExample, looseForExample] = ((_a = source.metadata) === null || _a === void 0 ? void 0 : _a.infused) !== undefined ? [false, true] : [strict, loose];
                    const location = { api: source.location, field: { field: 'example' } };
                    const snippet = snippet_1.updateParameters(snippet_1.typeScriptSnippetFromSource(source.source, location, strictForExample), {
                        [snippet_1.SnippetParameters.$PROJECT_DIRECTORY]: directory,
                        ...source.metadata,
                    });
                    ret.push(fixtures_1.fixturize(snippet, looseForExample));
                    break;
                case 'markdown':
                    for (const snippet of extract_snippets_1.extractTypescriptSnippetsFromMarkdown(source.markdown, source.location, strict)) {
                        const withDirectory = snippet_1.updateParameters(snippet, {
                            [snippet_1.SnippetParameters.$PROJECT_DIRECTORY]: directory,
                        });
                        ret.push(fixtures_1.fixturize(withDirectory, loose));
                    }
            }
        }
    }
    return ret;
}
exports.allTypeScriptSnippets = allTypeScriptSnippets;
/**
 * Replaces the file where the original assembly file *should* be found with a new assembly file.
 * Recalculates the fingerprint of the assembly to avoid tampering detection.
 */
async function replaceAssembly(assembly, directory) {
    const fileName = path.join(directory, '.jsii');
    await fs.writeJson(fileName, _fingerprint(assembly), {
        encoding: 'utf8',
        spaces: 2,
    });
}
exports.replaceAssembly = replaceAssembly;
/**
 * This function is copied from `packages/jsii/lib/assembler.ts`.
 * We should make sure not to change one without changing the other as well.
 */
function _fingerprint(assembly) {
    delete assembly.fingerprint;
    assembly = sortJson(assembly);
    const fingerprint = crypto.createHash('sha256').update(JSON.stringify(assembly)).digest('base64');
    return { ...assembly, fingerprint };
}
const MAX_ASM_CACHE = 3;
const ASM_CACHE = [];
/**
 * Recursively searches for a .jsii file in the directory.
 * When file is found, checks cache to see if we already
 * stored the assembly in memory. If not, we synchronously
 * load the assembly into memory.
 */
function findTypeLookupAssembly(startingDirectory) {
    const pjLocation = findPackageJsonLocation(path.resolve(startingDirectory));
    if (!pjLocation) {
        return undefined;
    }
    const directory = path.dirname(pjLocation);
    const fromCache = ASM_CACHE.find((c) => c.directory === directory);
    if (fromCache) {
        return fromCache;
    }
    const loaded = loadLookupAssembly(directory);
    if (!loaded) {
        return undefined;
    }
    while (ASM_CACHE.length >= MAX_ASM_CACHE) {
        ASM_CACHE.pop();
    }
    ASM_CACHE.unshift(loaded);
    return loaded;
}
exports.findTypeLookupAssembly = findTypeLookupAssembly;
function loadLookupAssembly(directory) {
    var _a, _b;
    const assemblyFile = path.join(directory, '.jsii');
    if (!fs.pathExistsSync(assemblyFile)) {
        return undefined;
    }
    const packageJson = fs.readJSONSync(path.join(directory, 'package.json'), { encoding: 'utf-8' });
    const assembly = fs.readJSONSync(assemblyFile, { encoding: 'utf-8' });
    const symbolIdMap = util_1.mkDict([
        ...Object.values((_a = assembly.types) !== null && _a !== void 0 ? _a : {}).map((type) => { var _a; return [(_a = type.symbolId) !== null && _a !== void 0 ? _a : '', type.fqn]; }),
        ...Object.entries((_b = assembly.submodules) !== null && _b !== void 0 ? _b : {}).map(([fqn, mod]) => { var _a; return [(_a = mod.symbolId) !== null && _a !== void 0 ? _a : '', fqn]; }),
    ]);
    return {
        packageJson,
        assembly,
        directory,
        symbolIdMap,
    };
}
function findPackageJsonLocation(currentPath) {
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const candidate = path.join(currentPath, 'package.json');
        if (fs.existsSync(candidate)) {
            return candidate;
        }
        const parentPath = path.resolve(currentPath, '..');
        if (parentPath === currentPath) {
            return undefined;
        }
        currentPath = parentPath;
    }
}
/**
 * Find the jsii [sub]module that contains the given FQN
 *
 * @returns `undefined` if the type is a member of the assembly root.
 */
function findContainingSubmodule(assembly, fqn) {
    var _a;
    const submoduleNames = Object.keys((_a = assembly.submodules) !== null && _a !== void 0 ? _a : {});
    util_1.sortBy(submoduleNames, (s) => [-s.length]); // Longest first
    for (const s of submoduleNames) {
        if (fqn.startsWith(`${s}.`)) {
            return s;
        }
    }
    return undefined;
}
exports.findContainingSubmodule = findContainingSubmodule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZW1ibGllcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFzc2VtYmxpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0IsNkJBQTZCO0FBRTdCLDBDQUF3QztBQUN4QyxtRUFBcUY7QUFDckYsd0NBUW9CO0FBQ3BCLHNDQUErQztBQUMvQyxnREFBeUU7QUFDekUsa0NBQStDO0FBRS9DLHFHQUFxRztBQUNyRyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFdEM7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNVLFFBQUEseUJBQXlCLEdBQUcsaUJBQWlCLENBQUM7QUFPM0Q7O0dBRUc7QUFDSSxLQUFLLFVBQVUsY0FBYyxDQUNsQyxpQkFBb0MsRUFDcEMsa0JBQTJCO0lBRTNCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUV4RCxLQUFLLFVBQVUsWUFBWSxDQUFDLFFBQWdCO1FBQzFDLE1BQU0sSUFBSSxHQUFHLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNyQyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRTtZQUN0QixPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ25EO1FBRUQsT0FBTztZQUNMLFFBQVEsRUFBRSxNQUFNLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQztZQUNsRSxTQUFTLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7U0FDbEMsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDO0FBakJELHdDQWlCQztBQUVELEtBQUssVUFBVSxvQkFBb0IsQ0FBQyxRQUFnQixFQUFFLFFBQWlCO0lBQ3JFLE1BQU0sUUFB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c3BlYyBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgZml4dHVyaXplIH0gZnJvbSAnLi4vZml4dHVyZXMnO1xuaW1wb3J0IHsgZXh0cmFjdFR5cGVzY3JpcHRTbmlwcGV0c0Zyb21NYXJrZG93biB9IGZyb20gJy4uL21hcmtkb3duL2V4dHJhY3Qtc25pcHBldHMnO1xuaW1wb3J0IHtcbiAgVHlwZVNjcmlwdFNuaXBwZXQsXG4gIHR5cGVTY3JpcHRTbmlwcGV0RnJvbVNvdXJjZSxcbiAgdXBkYXRlUGFyYW1ldGVycyxcbiAgU25pcHBldFBhcmFtZXRlcnMsXG4gIEFwaUxvY2F0aW9uLFxuICBwYXJzZU1ldGFkYXRhTGluZSxcbiAgSU5JVElBTElaRVJfTUVUSE9EX05BTUUsXG59IGZyb20gJy4uL3NuaXBwZXQnO1xuaW1wb3J0IHsgZW5mb3JjZXNTdHJpY3RNb2RlIH0gZnJvbSAnLi4vc3RyaWN0JztcbmltcG9ydCB7IExhbmd1YWdlVGFibGV0LCBERUZBVUxUX1RBQkxFVF9OQU1FIH0gZnJvbSAnLi4vdGFibGV0cy90YWJsZXRzJztcbmltcG9ydCB7IGZtYXAsIG1rRGljdCwgc29ydEJ5IH0gZnJvbSAnLi4vdXRpbCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG5jb25zdCBzb3J0SnNvbiA9IHJlcXVpcmUoJ3NvcnQtanNvbicpO1xuXG4vKipcbiAqIFRoZSBKU0RvYyB0YWcgdXNlcnMgY2FuIHVzZSB0byBhc3NvY2lhdGUgbm9uLXZpc2libGUgbWV0YWRhdGEgd2l0aCBhbiBleGFtcGxlXG4gKlxuICogSW4gYSBNYXJrZG93biBzZWN0aW9uLCBtZXRhZGF0YSBnb2VzIGFmdGVyIHRoZSBjb2RlIGJsb2NrIGZlbmNlLCB3aGVyZSBpdCB3aWxsXG4gKiBiZSBhdHRhY2hlZCB0byB0aGUgZXhhbXBsZSBidXQgaW52aXNpYmxlLlxuICpcbiAqICAgIGBgYHRzIG1ldGFkYXRhPWdvZXMgaGVyZVxuICpcbiAqIEJ1dCBpbiBkb2MgY29tbWVudHMsICdAZXhhbXBsZScgYWxyZWFkeSBkZWxpbmVhdGVzIHRoZSBleGFtcGxlLCBhbmQgYW55IG1ldGFkYXRhXG4gKiBpbiB0aGVyZSBhZGRlZCBieSB0aGUgJy8vLycgdGFncyBiZWNvbWVzIHBhcnQgb2YgdGhlIHZpc2libGUgY29kZSAodGhlcmUgaXMgbm9cbiAqIHBsYWNlIHRvIHB1dCBoaWRkZW4gaW5mb3JtYXRpb24pLlxuICpcbiAqIFdlIGludHJvZHVjZSB0aGUgJ0BleGFtcGxlTWV0YWRhdGEnIHRhZyB0byBwdXQgdGhhdCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY29uc3QgRVhBTVBMRV9NRVRBREFUQV9KU0RPQ1RBRyA9ICdleGFtcGxlTWV0YWRhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZEFzc2VtYmx5IHtcbiAgcmVhZG9ubHkgYXNzZW1ibHk6IHNwZWMuQXNzZW1ibHk7XG4gIHJlYWRvbmx5IGRpcmVjdG9yeTogc3RyaW5nO1xufVxuXG4vKipcbiAqIExvYWQgYXNzZW1ibGllcyBieSBmaWxlbmFtZSBvciBkaXJlY3RvcnlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRBc3NlbWJsaWVzKFxuICBhc3NlbWJseUxvY2F0aW9uczogcmVhZG9ubHkgc3RyaW5nW10sXG4gIHZhbGlkYXRlQXNzZW1ibGllczogYm9vbGVhbixcbik6IFByb21pc2U8cmVhZG9ubHkgTG9hZGVkQXNzZW1ibHlbXT4ge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoYXNzZW1ibHlMb2NhdGlvbnMubWFwKGxvYWRBc3NlbWJseSkpO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRBc3NlbWJseShsb2NhdGlvbjogc3RyaW5nKTogUHJvbWlzZTxMb2FkZWRBc3NlbWJseT4ge1xuICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmcy5zdGF0KGxvY2F0aW9uKTtcbiAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gbG9hZEFzc2VtYmx5KHBhdGguam9pbihsb2NhdGlvbiwgJy5qc2lpJykpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhc3NlbWJseTogYXdhaXQgbG9hZEFzc2VtYmx5RnJvbUZpbGUobG9jYXRpb24sIHZhbGlkYXRlQXNzZW1ibGllcyksXG4gICAgICBkaXJlY3Rvcnk6IHBhdGguZGlybmFtZShsb2NhdGlvbiksXG4gICAgfTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkQXNzZW1ibHlGcm9tRmlsZShmaWxlbmFtZTogc3RyaW5nLCB2YWxpZGF0ZTogYm9vbGVhbik6IFByb21pc2U8c3BlYy5Bc3NlbWJseT4ge1xuICBjb25zdCBjb250ZW50cyA9IGF3YWl0IGZzLnJlYWRKU09OKGZpbGVuYW1lLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICByZXR1cm4gdmFsaWRhdGUgPyBzcGVjLnZhbGlkYXRlQXNzZW1ibHkoY29udGVudHMpIDogKGNvbnRlbnRzIGFzIHNwZWMuQXNzZW1ibHkpO1xufVxuXG4vKipcbiAqIExvYWQgdGhlIGRlZmF1bHQgdGFibGV0cyBmb3IgZXZlcnkgYXNzZW1ibHksIGlmIGF2YWlsYWJsZVxuICpcbiAqIFJldHVybnMgYSBtYXAgb2YgeyBkaXJlY3RvcnkgLT4gdGFibGV0IH0uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkQWxsRGVmYXVsdFRhYmxldHMoYXNtczogcmVhZG9ubHkgTG9hZGVkQXNzZW1ibHlbXSk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgTGFuZ3VhZ2VUYWJsZXQ+PiB7XG4gIHJldHVybiBta0RpY3QoXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBhc21zLm1hcChcbiAgICAgICAgYXN5bmMgKGEpID0+XG4gICAgICAgICAgW2EuZGlyZWN0b3J5LCBhd2FpdCBMYW5ndWFnZVRhYmxldC5mcm9tT3B0aW9uYWxGaWxlKHBhdGguam9pbihhLmRpcmVjdG9yeSwgREVGQVVMVF9UQUJMRVRfTkFNRSkpXSBhcyBjb25zdCxcbiAgICAgICksXG4gICAgKSxcbiAgKTtcbn1cblxuZXhwb3J0IHR5cGUgQXNzZW1ibHlTbmlwcGV0U291cmNlID1cbiAgfCB7IHR5cGU6ICdtYXJrZG93bic7IG1hcmtkb3duOiBzdHJpbmc7IGxvY2F0aW9uOiBBcGlMb2NhdGlvbiB9XG4gIHwgeyB0eXBlOiAnZXhhbXBsZSc7IHNvdXJjZTogc3RyaW5nOyBtZXRhZGF0YT86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07IGxvY2F0aW9uOiBBcGlMb2NhdGlvbiB9O1xuXG4vKipcbiAqIFJldHVybiBhbGwgbWFya2Rvd24gYW5kIGV4YW1wbGUgc25pcHBldHMgZnJvbSB0aGUgZ2l2ZW4gYXNzZW1ibHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsbFNuaXBwZXRTb3VyY2VzKGFzc2VtYmx5OiBzcGVjLkFzc2VtYmx5KTogQXNzZW1ibHlTbmlwcGV0U291cmNlW10ge1xuICBjb25zdCByZXQ6IEFzc2VtYmx5U25pcHBldFNvdXJjZVtdID0gW107XG5cbiAgaWYgKGFzc2VtYmx5LnJlYWRtZSkge1xuICAgIHJldC5wdXNoKHtcbiAgICAgIHR5cGU6ICdtYXJrZG93bicsXG4gICAgICBtYXJrZG93bjogYXNzZW1ibHkucmVhZG1lLm1hcmtkb3duLFxuICAgICAgbG9jYXRpb246IHsgYXBpOiAnbW9kdWxlUmVhZG1lJywgbW9kdWxlRnFuOiBhc3NlbWJseS5uYW1lIH0sXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IFtzdWJtb2R1bGVGcW4sIHN1Ym1vZHVsZV0gb2YgT2JqZWN0LmVudHJpZXMoYXNzZW1ibHkuc3VibW9kdWxlcyA/PyB7fSkpIHtcbiAgICBpZiAoc3VibW9kdWxlLnJlYWRtZSkge1xuICAgICAgcmV0LnB1c2goe1xuICAgICAgICB0eXBlOiAnbWFya2Rvd24nLFxuICAgICAgICBtYXJrZG93bjogc3VibW9kdWxlLnJlYWRtZS5tYXJrZG93bixcbiAgICAgICAgbG9jYXRpb246IHsgYXBpOiAnbW9kdWxlUmVhZG1lJywgbW9kdWxlRnFuOiBzdWJtb2R1bGVGcW4gfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhc3NlbWJseS50eXBlcykge1xuICAgIE9iamVjdC52YWx1ZXMoYXNzZW1ibHkudHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIGVtaXREb2NzKHR5cGUuZG9jcywgeyBhcGk6ICd0eXBlJywgZnFuOiB0eXBlLmZxbiB9KTtcblxuICAgICAgaWYgKHNwZWMuaXNFbnVtVHlwZSh0eXBlKSkge1xuICAgICAgICB0eXBlLm1lbWJlcnMuZm9yRWFjaCgobSkgPT4gZW1pdERvY3MobS5kb2NzLCB7IGFwaTogJ21lbWJlcicsIGZxbjogdHlwZS5mcW4sIG1lbWJlck5hbWU6IG0ubmFtZSB9KSk7XG4gICAgICB9XG4gICAgICBpZiAoc3BlYy5pc0NsYXNzVHlwZSh0eXBlKSkge1xuICAgICAgICBlbWl0RG9jc0ZvckNhbGxhYmxlKHR5cGUuaW5pdGlhbGl6ZXIsIHR5cGUuZnFuKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGVjLmlzQ2xhc3NPckludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICAgICAgKHR5cGUubWV0aG9kcyA/PyBbXSkuZm9yRWFjaCgobSkgPT4gZW1pdERvY3NGb3JDYWxsYWJsZShtLCB0eXBlLmZxbiwgbS5uYW1lKSk7XG4gICAgICAgICh0eXBlLnByb3BlcnRpZXMgPz8gW10pLmZvckVhY2goKG0pID0+IGVtaXREb2NzKG0uZG9jcywgeyBhcGk6ICdtZW1iZXInLCBmcW46IHR5cGUuZnFuLCBtZW1iZXJOYW1lOiBtLm5hbWUgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcblxuICBmdW5jdGlvbiBlbWl0RG9jc0ZvckNhbGxhYmxlKGNhbGxhYmxlOiBzcGVjLkNhbGxhYmxlIHwgdW5kZWZpbmVkLCBmcW46IHN0cmluZywgbWVtYmVyTmFtZT86IHN0cmluZykge1xuICAgIGlmICghY2FsbGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW1pdERvY3MoY2FsbGFibGUuZG9jcywgbWVtYmVyTmFtZSA/IHsgYXBpOiAnbWVtYmVyJywgZnFuLCBtZW1iZXJOYW1lIH0gOiB7IGFwaTogJ2luaXRpYWxpemVyJywgZnFuIH0pO1xuXG4gICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2YgY2FsbGFibGUucGFyYW1ldGVycyA/PyBbXSkge1xuICAgICAgZW1pdERvY3MocGFyYW1ldGVyLmRvY3MsIHtcbiAgICAgICAgYXBpOiAncGFyYW1ldGVyJyxcbiAgICAgICAgZnFuOiBmcW4sXG4gICAgICAgIG1ldGhvZE5hbWU6IG1lbWJlck5hbWUgPz8gSU5JVElBTElaRVJfTUVUSE9EX05BTUUsXG4gICAgICAgIHBhcmFtZXRlck5hbWU6IHBhcmFtZXRlci5uYW1lLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdERvY3MoZG9jczogc3BlYy5Eb2NzIHwgdW5kZWZpbmVkLCBsb2NhdGlvbjogQXBpTG9jYXRpb24pIHtcbiAgICBpZiAoIWRvY3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZG9jcy5yZW1hcmtzKSB7XG4gICAgICByZXQucHVzaCh7XG4gICAgICAgIHR5cGU6ICdtYXJrZG93bicsXG4gICAgICAgIG1hcmtkb3duOiBkb2NzLnJlbWFya3MsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb2NzLmV4YW1wbGUpIHtcbiAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2V4YW1wbGUnLFxuICAgICAgICBzb3VyY2U6IGRvY3MuZXhhbXBsZSxcbiAgICAgICAgbWV0YWRhdGE6IGZtYXAoZG9jcy5jdXN0b20/LltFWEFNUExFX01FVEFEQVRBX0pTRE9DVEFHXSwgcGFyc2VNZXRhZGF0YUxpbmUpLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsVHlwZVNjcmlwdFNuaXBwZXRzKGFzc2VtYmxpZXM6IHJlYWRvbmx5IExvYWRlZEFzc2VtYmx5W10sIGxvb3NlID0gZmFsc2UpOiBUeXBlU2NyaXB0U25pcHBldFtdIHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PFR5cGVTY3JpcHRTbmlwcGV0PigpO1xuXG4gIGZvciAoY29uc3QgeyBhc3NlbWJseSwgZGlyZWN0b3J5IH0gb2YgYXNzZW1ibGllcykge1xuICAgIGNvbnN0IHN0cmljdCA9IGVuZm9yY2VzU3RyaWN0TW9kZShhc3NlbWJseSk7XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgYWxsU25pcHBldFNvdXJjZXMoYXNzZW1ibHkpKSB7XG4gICAgICBzd2l0Y2ggKHNvdXJjZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2V4YW1wbGUnOlxuICAgICAgICAgIC8vIElmIGFuIGV4YW1wbGUgaXMgYW4gaW5mdXNlZCBleGFtcGxlLCB3ZSBkbyBub3QgY2FyZSBhYm91dCBjb21waWxlciBlcnJvcnMuXG4gICAgICAgICAgLy8gV2UgYXJlIHJlbHlpbmcgb24gdGhlIHRhYmxldCBjYWNoZSB0byBoYXZlIHRoaXMgZXhhbXBsZSBzdG9yZWQgYWxyZWFkeS5cbiAgICAgICAgICBjb25zdCBbc3RyaWN0Rm9yRXhhbXBsZSwgbG9vc2VGb3JFeGFtcGxlXSA9XG4gICAgICAgICAgICBzb3VyY2UubWV0YWRhdGE/LmluZnVzZWQgIT09IHVuZGVmaW5lZCA/IFtmYWxzZSwgdHJ1ZV0gOiBbc3RyaWN0LCBsb29zZV07XG4gICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB7IGFwaTogc291cmNlLmxvY2F0aW9uLCBmaWVsZDogeyBmaWVsZDogJ2V4YW1wbGUnIH0gfSBhcyBjb25zdDtcbiAgICAgICAgICBjb25zdCBzbmlwcGV0ID0gdXBkYXRlUGFyYW1ldGVycyh0eXBlU2NyaXB0U25pcHBldEZyb21Tb3VyY2Uoc291cmNlLnNvdXJjZSwgbG9jYXRpb24sIHN0cmljdEZvckV4YW1wbGUpLCB7XG4gICAgICAgICAgICBbU25pcHBldFBhcmFtZXRlcnMuJFBST0pFQ1RfRElSRUNUT1JZXTogZGlyZWN0b3J5LFxuICAgICAgICAgICAgLi4uc291cmNlLm1ldGFkYXRhLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldC5wdXNoKGZpeHR1cml6ZShzbmlwcGV0LCBsb29zZUZvckV4YW1wbGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWFya2Rvd24nOlxuICAgICAgICAgIGZvciAoY29uc3Qgc25pcHBldCBvZiBleHRyYWN0VHlwZXNjcmlwdFNuaXBwZXRzRnJvbU1hcmtkb3duKHNvdXJjZS5tYXJrZG93biwgc291cmNlLmxvY2F0aW9uLCBzdHJpY3QpKSB7XG4gICAgICAgICAgICBjb25zdCB3aXRoRGlyZWN0b3J5ID0gdXBkYXRlUGFyYW1ldGVycyhzbmlwcGV0LCB7XG4gICAgICAgICAgICAgIFtTbmlwcGV0UGFyYW1ldGVycy4kUFJPSkVDVF9ESVJFQ1RPUlldOiBkaXJlY3RvcnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldC5wdXNoKGZpeHR1cml6ZSh3aXRoRGlyZWN0b3J5LCBsb29zZSkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgZmlsZSB3aGVyZSB0aGUgb3JpZ2luYWwgYXNzZW1ibHkgZmlsZSAqc2hvdWxkKiBiZSBmb3VuZCB3aXRoIGEgbmV3IGFzc2VtYmx5IGZpbGUuXG4gKiBSZWNhbGN1bGF0ZXMgdGhlIGZpbmdlcnByaW50IG9mIHRoZSBhc3NlbWJseSB0byBhdm9pZCB0YW1wZXJpbmcgZGV0ZWN0aW9uLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVwbGFjZUFzc2VtYmx5KGFzc2VtYmx5OiBzcGVjLkFzc2VtYmx5LCBkaXJlY3Rvcnk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBmaWxlTmFtZSA9IHBhdGguam9pbihkaXJlY3RvcnksICcuanNpaScpO1xuICBhd2FpdCBmcy53cml0ZUpzb24oZmlsZU5hbWUsIF9maW5nZXJwcmludChhc3NlbWJseSksIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIHNwYWNlczogMixcbiAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjb3BpZWQgZnJvbSBgcGFja2FnZXMvanNpaS9saWIvYXNzZW1ibGVyLnRzYC5cbiAqIFdlIHNob3VsZCBtYWtlIHN1cmUgbm90IHRvIGNoYW5nZSBvbmUgd2l0aG91dCBjaGFuZ2luZyB0aGUgb3RoZXIgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gX2ZpbmdlcnByaW50KGFzc2VtYmx5OiBzcGVjLkFzc2VtYmx5KTogc3BlYy5Bc3NlbWJseSB7XG4gIGRlbGV0ZSAoYXNzZW1ibHkgYXMgYW55KS5maW5nZXJwcmludDtcbiAgYXNzZW1ibHkgPSBzb3J0SnNvbihhc3NlbWJseSk7XG4gIGNvbnN0IGZpbmdlcnByaW50ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShKU09OLnN0cmluZ2lmeShhc3NlbWJseSkpLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gIHJldHVybiB7IC4uLmFzc2VtYmx5LCBmaW5nZXJwcmludCB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVMb29rdXBBc3NlbWJseSB7XG4gIHJlYWRvbmx5IHBhY2thZ2VKc29uOiBhbnk7XG4gIHJlYWRvbmx5IGFzc2VtYmx5OiBzcGVjLkFzc2VtYmx5O1xuICByZWFkb25seSBkaXJlY3Rvcnk6IHN0cmluZztcbiAgcmVhZG9ubHkgc3ltYm9sSWRNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbmNvbnN0IE1BWF9BU01fQ0FDSEUgPSAzO1xuY29uc3QgQVNNX0NBQ0hFOiBUeXBlTG9va3VwQXNzZW1ibHlbXSA9IFtdO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGZvciBhIC5qc2lpIGZpbGUgaW4gdGhlIGRpcmVjdG9yeS5cbiAqIFdoZW4gZmlsZSBpcyBmb3VuZCwgY2hlY2tzIGNhY2hlIHRvIHNlZSBpZiB3ZSBhbHJlYWR5XG4gKiBzdG9yZWQgdGhlIGFzc2VtYmx5IGluIG1lbW9yeS4gSWYgbm90LCB3ZSBzeW5jaHJvbm91c2x5XG4gKiBsb2FkIHRoZSBhc3NlbWJseSBpbnRvIG1lbW9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUeXBlTG9va3VwQXNzZW1ibHkoc3RhcnRpbmdEaXJlY3Rvcnk6IHN0cmluZyk6IFR5cGVMb29rdXBBc3NlbWJseSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHBqTG9jYXRpb24gPSBmaW5kUGFja2FnZUpzb25Mb2NhdGlvbihwYXRoLnJlc29sdmUoc3RhcnRpbmdEaXJlY3RvcnkpKTtcbiAgaWYgKCFwakxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBkaXJlY3RvcnkgPSBwYXRoLmRpcm5hbWUocGpMb2NhdGlvbik7XG5cbiAgY29uc3QgZnJvbUNhY2hlID0gQVNNX0NBQ0hFLmZpbmQoKGMpID0+IGMuZGlyZWN0b3J5ID09PSBkaXJlY3RvcnkpO1xuICBpZiAoZnJvbUNhY2hlKSB7XG4gICAgcmV0dXJuIGZyb21DYWNoZTtcbiAgfVxuXG4gIGNvbnN0IGxvYWRlZCA9IGxvYWRMb29rdXBBc3NlbWJseShkaXJlY3RvcnkpO1xuICBpZiAoIWxvYWRlZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB3aGlsZSAoQVNNX0NBQ0hFLmxlbmd0aCA+PSBNQVhfQVNNX0NBQ0hFKSB7XG4gICAgQVNNX0NBQ0hFLnBvcCgpO1xuICB9XG4gIEFTTV9DQUNIRS51bnNoaWZ0KGxvYWRlZCk7XG4gIHJldHVybiBsb2FkZWQ7XG59XG5cbmZ1bmN0aW9uIGxvYWRMb29rdXBBc3NlbWJseShkaXJlY3Rvcnk6IHN0cmluZyk6IFR5cGVMb29rdXBBc3NlbWJseSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGFzc2VtYmx5RmlsZSA9IHBhdGguam9pbihkaXJlY3RvcnksICcuanNpaScpO1xuICBpZiAoIWZzLnBhdGhFeGlzdHNTeW5jKGFzc2VtYmx5RmlsZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgcGFja2FnZUpzb24gPSBmcy5yZWFkSlNPTlN5bmMocGF0aC5qb2luKGRpcmVjdG9yeSwgJ3BhY2thZ2UuanNvbicpLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICBjb25zdCBhc3NlbWJseTogc3BlYy5Bc3NlbWJseSA9IGZzLnJlYWRKU09OU3luYyhhc3NlbWJseUZpbGUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gIGNvbnN0IHN5bWJvbElkTWFwID0gbWtEaWN0KFtcbiAgICAuLi5PYmplY3QudmFsdWVzKGFzc2VtYmx5LnR5cGVzID8/IHt9KS5tYXAoKHR5cGUpID0+IFt0eXBlLnN5bWJvbElkID8/ICcnLCB0eXBlLmZxbl0gYXMgY29uc3QpLFxuICAgIC4uLk9iamVjdC5lbnRyaWVzKGFzc2VtYmx5LnN1Ym1vZHVsZXMgPz8ge30pLm1hcCgoW2ZxbiwgbW9kXSkgPT4gW21vZC5zeW1ib2xJZCA/PyAnJywgZnFuXSBhcyBjb25zdCksXG4gIF0pO1xuXG4gIHJldHVybiB7XG4gICAgcGFja2FnZUpzb24sXG4gICAgYXNzZW1ibHksXG4gICAgZGlyZWN0b3J5LFxuICAgIHN5bWJvbElkTWFwLFxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kUGFja2FnZUpzb25Mb2NhdGlvbihjdXJyZW50UGF0aDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHBhdGguam9pbihjdXJyZW50UGF0aCwgJ3BhY2thZ2UuanNvbicpO1xuICAgIGlmIChmcy5leGlzdHNTeW5jKGNhbmRpZGF0ZSkpIHtcbiAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGgucmVzb2x2ZShjdXJyZW50UGF0aCwgJy4uJyk7XG4gICAgaWYgKHBhcmVudFBhdGggPT09IGN1cnJlbnRQYXRoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjdXJyZW50UGF0aCA9IHBhcmVudFBhdGg7XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBqc2lpIFtzdWJdbW9kdWxlIHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIEZRTlxuICpcbiAqIEByZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSB0eXBlIGlzIGEgbWVtYmVyIG9mIHRoZSBhc3NlbWJseSByb290LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENvbnRhaW5pbmdTdWJtb2R1bGUoYXNzZW1ibHk6IHNwZWMuQXNzZW1ibHksIGZxbjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc3VibW9kdWxlTmFtZXMgPSBPYmplY3Qua2V5cyhhc3NlbWJseS5zdWJtb2R1bGVzID8/IHt9KTtcbiAgc29ydEJ5KHN1Ym1vZHVsZU5hbWVzLCAocykgPT4gWy1zLmxlbmd0aF0pOyAvLyBMb25nZXN0IGZpcnN0XG4gIGZvciAoY29uc3QgcyBvZiBzdWJtb2R1bGVOYW1lcykge1xuICAgIGlmIChmcW4uc3RhcnRzV2l0aChgJHtzfS5gKSkge1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXX0=