"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeObjectLiteral = exports.determineJsiiType = void 0;
const ts = require("typescript");
const types_1 = require("../typescript/types");
const jsii_utils_1 = require("./jsii-utils");
function determineJsiiType(typeChecker, type) {
    var _a, _b;
    // this means the snippet didn't have enough info for the TypeScript compiler to figure out the type -
    // so, just render the fallback
    if (type.intrinsicName === 'error') {
        return { kind: 'unknown' };
    }
    type = type.getNonNullableType();
    const mapValuesType = types_1.mapElementType(type, typeChecker);
    if (mapValuesType.result === 'map') {
        return {
            kind: 'map',
            elementType: mapValuesType.elementType
                ? determineJsiiType(typeChecker, mapValuesType.elementType)
                : { kind: 'builtIn', builtIn: 'any' },
        };
    }
    if (((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'Array') {
        const typeRef = type;
        if (((_b = typeRef.typeArguments) === null || _b === void 0 ? void 0 : _b.length) === 1) {
            return {
                kind: 'list',
                elementType: determineJsiiType(typeChecker, typeRef.typeArguments[0]),
            };
        }
        return {
            kind: 'list',
            elementType: { kind: 'builtIn', builtIn: 'any' },
        };
    }
    // User-defined or aliased type
    if (type.aliasSymbol) {
        return { kind: 'namedType', name: type.aliasSymbol.name };
    }
    if (type.symbol) {
        return { kind: 'namedType', name: type.symbol.name };
    }
    const typeScriptBuiltInType = types_1.builtInTypeName(type);
    if (typeScriptBuiltInType) {
        return { kind: 'builtIn', builtIn: typeScriptBuiltInType };
    }
    if (type.isUnion() || type.isIntersection()) {
        return {
            kind: 'error',
            message: `Type unions or intersections are not supported in examples, got: ${typeChecker.typeToString(type)}`,
        };
    }
    return { kind: 'unknown' };
}
exports.determineJsiiType = determineJsiiType;
function analyzeObjectLiteral(typeChecker, node) {
    var _a;
    const type = types_1.inferredTypeOfExpression(typeChecker, node);
    if (!type) {
        return { kind: 'unknown' };
    }
    const call = findEnclosingCallExpression(node);
    const isDeclaredCall = !!(call && ((_a = typeChecker.getResolvedSignature(call)) === null || _a === void 0 ? void 0 : _a.declaration));
    if (jsii_utils_1.hasAnyFlag(type.flags, ts.TypeFlags.Any)) {
        // The type checker by itself won't tell us the difference between an `any` that
        // was literally declared as a type in the code, vs an `any` it assumes because it
        // can't find a function's type declaration.
        //
        // Search for the function's declaration and only if we can't find it,
        // the type is actually unknown (otherwise it's a literal 'any').
        return isDeclaredCall ? { kind: 'map' } : { kind: 'unknown' };
    }
    // If the type is a union between a struct and something else, return the first possible struct
    const structCandidates = type.isUnion() ? type.types : [type];
    for (const candidate of structCandidates) {
        const structType = jsii_utils_1.analyzeStructType(typeChecker, candidate);
        if (structType) {
            return structType;
        }
    }
    return { kind: 'map' };
}
exports.analyzeObjectLiteral = analyzeObjectLiteral;
function findEnclosingCallExpression(node) {
    while (node) {
        if (ts.isCallLikeExpression(node)) {
            return node;
        }
        node = node.parent;
    }
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNpaS10eXBlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImpzaWktdHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBRWpDLCtDQUE2RztBQUM3Ryw2Q0FBeUU7QUFXekUsU0FBZ0IsaUJBQWlCLENBQUMsV0FBMkIsRUFBRSxJQUFhOztJQUMxRSxzR0FBc0c7SUFDdEcsK0JBQStCO0lBQy9CLElBQUssSUFBWSxDQUFDLGFBQWEsS0FBSyxPQUFPLEVBQUU7UUFDM0MsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsQ0FBQztLQUM1QjtJQUVELElBQUksR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUVqQyxNQUFNLGFBQWEsR0FBRyxzQkFBYyxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN4RCxJQUFJLGFBQWEsQ0FBQyxNQUFNLEtBQUssS0FBSyxFQUFFO1FBQ2xDLE9BQU87WUFDTCxJQUFJLEVBQUUsS0FBSztZQUNYLFdBQVcsRUFBRSxhQUFhLENBQUMsV0FBVztnQkFDcEMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsV0FBVyxDQUFDO2dCQUMzRCxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUU7U0FDeEMsQ0FBQztLQUNIO0lBRUQsSUFBSSxPQUFBLElBQUksQ0FBQyxNQUFNLDBDQUFFLElBQUksTUFBSyxPQUFPLEVBQUU7UUFDakMsTUFBTSxPQUFPLEdBQUcsSUFBd0IsQ0FBQztRQUV6QyxJQUFJLE9BQUEsT0FBTyxDQUFDLGFBQWEsMENBQUUsTUFBTSxNQUFLLENBQUMsRUFBRTtZQUN2QyxPQUFPO2dCQUNMLElBQUksRUFBRSxNQUFNO2dCQUNaLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN0RSxDQUFDO1NB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SUFFRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IGluZmVycmVkVHlwZU9mRXhwcmVzc2lvbiwgQnVpbHRJblR5cGUsIGJ1aWx0SW5UeXBlTmFtZSwgbWFwRWxlbWVudFR5cGUgfSBmcm9tICcuLi90eXBlc2NyaXB0L3R5cGVzJztcbmltcG9ydCB7IGhhc0FueUZsYWcsIGFuYWx5emVTdHJ1Y3RUeXBlLCBKc2lpU3ltYm9sIH0gZnJvbSAnLi9qc2lpLXV0aWxzJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZXR0aWVyL3ByZXR0aWVyXG5leHBvcnQgdHlwZSBKc2lpVHlwZSA9XG4gIHwgeyBraW5kOiAndW5rbm93bicgfVxuICB8IHsga2luZDogJ2Vycm9yJzsgbWVzc2FnZTogc3RyaW5nIH1cbiAgfCB7IGtpbmQ6ICdtYXAnOyBlbGVtZW50VHlwZTogSnNpaVR5cGUgfVxuICB8IHsga2luZDogJ2xpc3QnOyBlbGVtZW50VHlwZTogSnNpaVR5cGUgfVxuICB8IHsga2luZDogJ25hbWVkVHlwZSc7IG5hbWU6IHN0cmluZyB9XG4gIHwgeyBraW5kOiAnYnVpbHRJbic7IGJ1aWx0SW46IEJ1aWx0SW5UeXBlIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVKc2lpVHlwZSh0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIHR5cGU6IHRzLlR5cGUpOiBKc2lpVHlwZSB7XG4gIC8vIHRoaXMgbWVhbnMgdGhlIHNuaXBwZXQgZGlkbid0IGhhdmUgZW5vdWdoIGluZm8gZm9yIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIHRvIGZpZ3VyZSBvdXQgdGhlIHR5cGUgLVxuICAvLyBzbywganVzdCByZW5kZXIgdGhlIGZhbGxiYWNrXG4gIGlmICgodHlwZSBhcyBhbnkpLmludHJpbnNpY05hbWUgPT09ICdlcnJvcicpIHtcbiAgICByZXR1cm4geyBraW5kOiAndW5rbm93bicgfTtcbiAgfVxuXG4gIHR5cGUgPSB0eXBlLmdldE5vbk51bGxhYmxlVHlwZSgpO1xuXG4gIGNvbnN0IG1hcFZhbHVlc1R5cGUgPSBtYXBFbGVtZW50VHlwZSh0eXBlLCB0eXBlQ2hlY2tlcik7XG4gIGlmIChtYXBWYWx1ZXNUeXBlLnJlc3VsdCA9PT0gJ21hcCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ21hcCcsXG4gICAgICBlbGVtZW50VHlwZTogbWFwVmFsdWVzVHlwZS5lbGVtZW50VHlwZVxuICAgICAgICA/IGRldGVybWluZUpzaWlUeXBlKHR5cGVDaGVja2VyLCBtYXBWYWx1ZXNUeXBlLmVsZW1lbnRUeXBlKVxuICAgICAgICA6IHsga2luZDogJ2J1aWx0SW4nLCBidWlsdEluOiAnYW55JyB9LFxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZS5zeW1ib2w/Lm5hbWUgPT09ICdBcnJheScpIHtcbiAgICBjb25zdCB0eXBlUmVmID0gdHlwZSBhcyB0cy5UeXBlUmVmZXJlbmNlO1xuXG4gICAgaWYgKHR5cGVSZWYudHlwZUFyZ3VtZW50cz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAnbGlzdCcsXG4gICAgICAgIGVsZW1lbnRUeXBlOiBkZXRlcm1pbmVKc2lpVHlwZSh0eXBlQ2hlY2tlciwgdHlwZVJlZi50eXBlQXJndW1lbnRzWzBdKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdsaXN0JyxcbiAgICAgIGVsZW1lbnRUeXBlOiB7IGtpbmQ6ICdidWlsdEluJywgYnVpbHRJbjogJ2FueScgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gVXNlci1kZWZpbmVkIG9yIGFsaWFzZWQgdHlwZVxuICBpZiAodHlwZS5hbGlhc1N5bWJvbCkge1xuICAgIHJldHVybiB7IGtpbmQ6ICduYW1lZFR5cGUnLCBuYW1lOiB0eXBlLmFsaWFzU3ltYm9sLm5hbWUgfTtcbiAgfVxuICBpZiAodHlwZS5zeW1ib2wpIHtcbiAgICByZXR1cm4geyBraW5kOiAnbmFtZWRUeXBlJywgbmFtZTogdHlwZS5zeW1ib2wubmFtZSB9O1xuICB9XG5cbiAgY29uc3QgdHlwZVNjcmlwdEJ1aWx0SW5UeXBlID0gYnVpbHRJblR5cGVOYW1lKHR5cGUpO1xuICBpZiAodHlwZVNjcmlwdEJ1aWx0SW5UeXBlKSB7XG4gICAgcmV0dXJuIHsga2luZDogJ2J1aWx0SW4nLCBidWlsdEluOiB0eXBlU2NyaXB0QnVpbHRJblR5cGUgfTtcbiAgfVxuXG4gIGlmICh0eXBlLmlzVW5pb24oKSB8fCB0eXBlLmlzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2Vycm9yJyxcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHVuaW9ucyBvciBpbnRlcnNlY3Rpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIGV4YW1wbGVzLCBnb3Q6ICR7dHlwZUNoZWNrZXIudHlwZVRvU3RyaW5nKHR5cGUpfWAsXG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBraW5kOiAndW5rbm93bicgfTtcbn1cblxuZXhwb3J0IHR5cGUgT2JqZWN0TGl0ZXJhbEFuYWx5c2lzID0gT2JqZWN0TGl0ZXJhbFN0cnVjdCB8IHsgcmVhZG9ubHkga2luZDogJ21hcCcgfSB8IHsgcmVhZG9ubHkga2luZDogJ3Vua25vd24nIH07XG5cbmV4cG9ydCB0eXBlIE9iamVjdExpdGVyYWxTdHJ1Y3QgPVxuICB8IHsgcmVhZG9ubHkga2luZDogJ3N0cnVjdCc7IHJlYWRvbmx5IHR5cGU6IHRzLlR5cGU7IHJlYWRvbmx5IGpzaWlTeW06IEpzaWlTeW1ib2wgfVxuICB8IHsgcmVhZG9ubHkga2luZDogJ2xvY2FsLXN0cnVjdCc7IHJlYWRvbmx5IHR5cGU6IHRzLlR5cGUgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFuYWx5emVPYmplY3RMaXRlcmFsKFxuICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gIG5vZGU6IHRzLk9iamVjdExpdGVyYWxFeHByZXNzaW9uLFxuKTogT2JqZWN0TGl0ZXJhbEFuYWx5c2lzIHtcbiAgY29uc3QgdHlwZSA9IGluZmVycmVkVHlwZU9mRXhwcmVzc2lvbih0eXBlQ2hlY2tlciwgbm9kZSk7XG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiB7IGtpbmQ6ICd1bmtub3duJyB9O1xuICB9XG5cbiAgY29uc3QgY2FsbCA9IGZpbmRFbmNsb3NpbmdDYWxsRXhwcmVzc2lvbihub2RlKTtcbiAgY29uc3QgaXNEZWNsYXJlZENhbGwgPSAhIShjYWxsICYmIHR5cGVDaGVja2VyLmdldFJlc29sdmVkU2lnbmF0dXJlKGNhbGwpPy5kZWNsYXJhdGlvbik7XG5cbiAgaWYgKGhhc0FueUZsYWcodHlwZS5mbGFncywgdHMuVHlwZUZsYWdzLkFueSkpIHtcbiAgICAvLyBUaGUgdHlwZSBjaGVja2VyIGJ5IGl0c2VsZiB3b24ndCB0ZWxsIHVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYW4gYGFueWAgdGhhdFxuICAgIC8vIHdhcyBsaXRlcmFsbHkgZGVjbGFyZWQgYXMgYSB0eXBlIGluIHRoZSBjb2RlLCB2cyBhbiBgYW55YCBpdCBhc3N1bWVzIGJlY2F1c2UgaXRcbiAgICAvLyBjYW4ndCBmaW5kIGEgZnVuY3Rpb24ncyB0eXBlIGRlY2xhcmF0aW9uLlxuICAgIC8vXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgZnVuY3Rpb24ncyBkZWNsYXJhdGlvbiBhbmQgb25seSBpZiB3ZSBjYW4ndCBmaW5kIGl0LFxuICAgIC8vIHRoZSB0eXBlIGlzIGFjdHVhbGx5IHVua25vd24gKG90aGVyd2lzZSBpdCdzIGEgbGl0ZXJhbCAnYW55JykuXG4gICAgcmV0dXJuIGlzRGVjbGFyZWRDYWxsID8geyBraW5kOiAnbWFwJyB9IDogeyBraW5kOiAndW5rbm93bicgfTtcbiAgfVxuXG4gIC8vIElmIHRoZSB0eXBlIGlzIGEgdW5pb24gYmV0d2VlbiBhIHN0cnVjdCBhbmQgc29tZXRoaW5nIGVsc2UsIHJldHVybiB0aGUgZmlyc3QgcG9zc2libGUgc3RydWN0XG4gIGNvbnN0IHN0cnVjdENhbmRpZGF0ZXMgPSB0eXBlLmlzVW5pb24oKSA/IHR5cGUudHlwZXMgOiBbdHlwZV07XG4gIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHN0cnVjdENhbmRpZGF0ZXMpIHtcbiAgICBjb25zdCBzdHJ1Y3RUeXBlID0gYW5hbHl6ZVN0cnVjdFR5cGUodHlwZUNoZWNrZXIsIGNhbmRpZGF0ZSk7XG4gICAgaWYgKHN0cnVjdFR5cGUpIHtcbiAgICAgIHJldHVybiBzdHJ1Y3RUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGtpbmQ6ICdtYXAnIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRFbmNsb3NpbmdDYWxsRXhwcmVzc2lvbihub2RlPzogdHMuTm9kZSk6IHRzLkNhbGxMaWtlRXhwcmVzc2lvbiB8IHVuZGVmaW5lZCB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKHRzLmlzQ2FsbExpa2VFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiJdfQ==