"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeFingerprinter = void 0;
const spec = require("@jsii/spec");
const crypto = require("crypto");
/**
 * Return a fingerprint for a type.
 *
 * The fingerprint will change if the API of the given type changes.
 *
 * The fingerprint is an approximation, it's not exhaustive. It will not trace
 * into types from assemblies it can't see, for example. For the purposes of Rosetta,
 * we'll assume this is Good Enoughâ„¢.
 */
class TypeFingerprinter {
    constructor(assemblies) {
        this.cache = new Map();
        this.assemblies = new Map();
        for (const assembly of assemblies) {
            this.assemblies.set(assembly.name, assembly);
        }
    }
    /**
     * Return a single fingerprint that encompasses all fqns in the list
     */
    fingerprintAll(fqns) {
        const hash = crypto.createHash('sha256');
        for (const fqn of fqns) {
            hash.update(this.fingerprintType(fqn));
        }
        return hash.digest('hex');
    }
    /**
     * Return the fingerprint for the given FQN in the assembly of this fingerprinter
     *
     * The fingerprint is always going to contain the FQN, even if the type doesn't exist
     * in this assembly.
     */
    fingerprintType(fqn) {
        return this.doFingerprint(fqn, new Set([fqn]));
    }
    doFingerprint(fqn, recursionBreaker) {
        var _a, _b, _c, _d, _e;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const existing = this.cache.get(fqn);
        if (existing) {
            return existing;
        }
        const hash = crypto.createHash('sha256');
        hash.update(fqn);
        const type = this.findType(fqn);
        if (type) {
            hash.update(type.kind);
            switch (type.kind) {
                case spec.TypeKind.Enum:
                    for (const member of sortedByName(type.members)) {
                        hash.update(member.name);
                    }
                    break;
                case spec.TypeKind.Class:
                case spec.TypeKind.Interface:
                    if (type.kind === spec.TypeKind.Class) {
                        visitType(type.base);
                        visitCallable(type.initializer);
                    }
                    for (const prop of sortedByName((_a = type.properties) !== null && _a !== void 0 ? _a : [])) {
                        hash.update(prop.name);
                        visitBools(prop.immutable, prop.static, prop.optional, prop.protected);
                        visitTypeReference(prop.type);
                    }
                    for (const method of sortedByName((_b = type.methods) !== null && _b !== void 0 ? _b : [])) {
                        hash.update(method.name);
                        visitCallable(method);
                        visitBools((_c = method.returns) === null || _c === void 0 ? void 0 : _c.optional);
                        visitTypeReference((_d = method.returns) === null || _d === void 0 ? void 0 : _d.type);
                    }
                    for (const implint of (_e = type.interfaces) !== null && _e !== void 0 ? _e : []) {
                        visitType(implint);
                    }
                    break;
            }
        }
        const ret = hash.digest('hex');
        this.cache.set(fqn, ret);
        return ret;
        function visitType(fqn) {
            if (!fqn) {
                return;
            }
            if (recursionBreaker.has(fqn)) {
                hash.update('$RECURSION$');
                return;
            }
            recursionBreaker.add(fqn);
            hash.update(self.doFingerprint(fqn, recursionBreaker));
            recursionBreaker.delete(fqn);
        }
        function visitCallable(callable) {
            var _a;
            if (!callable) {
                return;
            }
            visitBools(callable.protected);
            for (const param of (_a = callable.parameters) !== null && _a !== void 0 ? _a : []) {
                visitBools(param.optional, param.variadic);
                visitTypeReference(param.type);
            }
        }
        function visitTypeReference(typeRef) {
            if (!typeRef) {
                return;
            }
            if (spec.isPrimitiveTypeReference(typeRef)) {
                hash.update(typeRef.primitive);
            }
            if (spec.isNamedTypeReference(typeRef)) {
                visitType(typeRef.fqn);
            }
            if (spec.isCollectionTypeReference(typeRef)) {
                hash.update(typeRef.collection.kind);
                visitTypeReference(typeRef.collection.elementtype);
            }
            if (spec.isUnionTypeReference(typeRef)) {
                for (const type of typeRef.union.types) {
                    visitTypeReference(type);
                }
            }
        }
        function visitBools(...vs) {
            hash.update(vs.map((v) => (v ? '1' : '0')).join(''));
        }
    }
    findType(fqn) {
        var _a, _b;
        const assemblyName = fqn.split('.')[0];
        return (_b = (_a = this.assemblies.get(assemblyName)) === null || _a === void 0 ? void 0 : _a.types) === null || _b === void 0 ? void 0 : _b[fqn];
    }
}
exports.TypeFingerprinter = TypeFingerprinter;
function sortedByName(xs) {
    xs.sort((a, b) => a.name.localeCompare(b.name));
    return xs;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZ2VycHJpbnRpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaW5nZXJwcmludGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBbUM7QUFDbkMsaUNBQWlDO0FBRWpDOzs7Ozs7OztHQVFHO0FBQ0gsTUFBYSxpQkFBaUI7SUFJNUIsWUFBbUIsVUFBMkI7UUFIN0IsVUFBSyxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO1FBQ2xDLGVBQVUsR0FBRyxJQUFJLEdBQUcsRUFBeUIsQ0FBQztRQUc3RCxLQUFLLE1BQU0sUUFBUSxJQUFJLFVBQVUsRUFBRTtZQUNqQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzlDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksY0FBYyxDQUFDLElBQWM7UUFDbEMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6QyxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtZQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUN4QztRQUNELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxlQUFlLENBQUMsR0FBVztRQUNoQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFTyxhQUFhLENBQUMsR0FBVyxFQUFFLGdCQUE2Qjs7UUFDOUQsNERBQTREO1FBQzVELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUVsQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxH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QyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDMUI7YUFDRjtRQUNILENBQUM7UUFFRCxTQUFTLFVBQVUsQ0FBQyxHQUFHLEVBQThCO1lBQ25ELElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN2RCxDQUFDO0lBQ0gsQ0FBQztJQUVPLFFBQVEsQ0FBQyxHQUFXOztRQUMxQixNQUFNLFlBQVksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLG1CQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQywwQ0FBRSxLQUFLLDBDQUFHLEdBQUcsRUFBRTtJQUN6RCxDQUFDO0NBQ0Y7QUE1SUQsOENBNElDO0FBRUQsU0FBUyxZQUFZLENBQTZCLEVBQU87SUFDdkQsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2hELE9BQU8sRUFBRSxDQUFDO0FBQ1osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHNwZWMgZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBSZXR1cm4gYSBmaW5nZXJwcmludCBmb3IgYSB0eXBlLlxuICpcbiAqIFRoZSBmaW5nZXJwcmludCB3aWxsIGNoYW5nZSBpZiB0aGUgQVBJIG9mIHRoZSBnaXZlbiB0eXBlIGNoYW5nZXMuXG4gKlxuICogVGhlIGZpbmdlcnByaW50IGlzIGFuIGFwcHJveGltYXRpb24sIGl0J3Mgbm90IGV4aGF1c3RpdmUuIEl0IHdpbGwgbm90IHRyYWNlXG4gKiBpbnRvIHR5cGVzIGZyb20gYXNzZW1ibGllcyBpdCBjYW4ndCBzZWUsIGZvciBleGFtcGxlLiBGb3IgdGhlIHB1cnBvc2VzIG9mIFJvc2V0dGEsXG4gKiB3ZSdsbCBhc3N1bWUgdGhpcyBpcyBHb29kIEVub3VnaOKEoi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVGaW5nZXJwcmludGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXNzZW1ibGllcyA9IG5ldyBNYXA8c3RyaW5nLCBzcGVjLkFzc2VtYmx5PigpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihhc3NlbWJsaWVzOiBzcGVjLkFzc2VtYmx5W10pIHtcbiAgICBmb3IgKGNvbnN0IGFzc2VtYmx5IG9mIGFzc2VtYmxpZXMpIHtcbiAgICAgIHRoaXMuYXNzZW1ibGllcy5zZXQoYXNzZW1ibHkubmFtZSwgYXNzZW1ibHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzaW5nbGUgZmluZ2VycHJpbnQgdGhhdCBlbmNvbXBhc3NlcyBhbGwgZnFucyBpbiB0aGUgbGlzdFxuICAgKi9cbiAgcHVibGljIGZpbmdlcnByaW50QWxsKGZxbnM6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICBmb3IgKGNvbnN0IGZxbiBvZiBmcW5zKSB7XG4gICAgICBoYXNoLnVwZGF0ZSh0aGlzLmZpbmdlcnByaW50VHlwZShmcW4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZpbmdlcnByaW50IGZvciB0aGUgZ2l2ZW4gRlFOIGluIHRoZSBhc3NlbWJseSBvZiB0aGlzIGZpbmdlcnByaW50ZXJcbiAgICpcbiAgICogVGhlIGZpbmdlcnByaW50IGlzIGFsd2F5cyBnb2luZyB0byBjb250YWluIHRoZSBGUU4sIGV2ZW4gaWYgdGhlIHR5cGUgZG9lc24ndCBleGlzdFxuICAgKiBpbiB0aGlzIGFzc2VtYmx5LlxuICAgKi9cbiAgcHVibGljIGZpbmdlcnByaW50VHlwZShmcW46IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmRvRmluZ2VycHJpbnQoZnFuLCBuZXcgU2V0KFtmcW5dKSk7XG4gIH1cblxuICBwcml2YXRlIGRvRmluZ2VycHJpbnQoZnFuOiBzdHJpbmcsIHJlY3Vyc2lvbkJyZWFrZXI6IFNldDxzdHJpbmc+KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuY2FjaGUuZ2V0KGZxbik7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICBoYXNoLnVwZGF0ZShmcW4pO1xuXG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmluZFR5cGUoZnFuKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgaGFzaC51cGRhdGUodHlwZS5raW5kKTtcbiAgICAgIHN3aXRjaCAodHlwZS5raW5kKSB7XG4gICAgICAgIGNhc2Ugc3BlYy5UeXBlS2luZC5FbnVtOlxuICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHNvcnRlZEJ5TmFtZSh0eXBlLm1lbWJlcnMpKSB7XG4gICAgICAgICAgICBoYXNoLnVwZGF0ZShtZW1iZXIubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNwZWMuVHlwZUtpbmQuQ2xhc3M6XG4gICAgICAgIGNhc2Ugc3BlYy5UeXBlS2luZC5JbnRlcmZhY2U6XG4gICAgICAgICAgaWYgKHR5cGUua2luZCA9PT0gc3BlYy5UeXBlS2luZC5DbGFzcykge1xuICAgICAgICAgICAgdmlzaXRUeXBlKHR5cGUuYmFzZSk7XG4gICAgICAgICAgICB2aXNpdENhbGxhYmxlKHR5cGUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzb3J0ZWRCeU5hbWUodHlwZS5wcm9wZXJ0aWVzID8/IFtdKSkge1xuICAgICAgICAgICAgaGFzaC51cGRhdGUocHJvcC5uYW1lKTtcbiAgICAgICAgICAgIHZpc2l0Qm9vbHMocHJvcC5pbW11dGFibGUsIHByb3Auc3RhdGljLCBwcm9wLm9wdGlvbmFsLCBwcm9wLnByb3RlY3RlZCk7XG4gICAgICAgICAgICB2aXNpdFR5cGVSZWZlcmVuY2UocHJvcC50eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2Ygc29ydGVkQnlOYW1lKHR5cGUubWV0aG9kcyA/PyBbXSkpIHtcbiAgICAgICAgICAgIGhhc2gudXBkYXRlKG1ldGhvZC5uYW1lKTtcbiAgICAgICAgICAgIHZpc2l0Q2FsbGFibGUobWV0aG9kKTtcbiAgICAgICAgICAgIHZpc2l0Qm9vbHMobWV0aG9kLnJldHVybnM/Lm9wdGlvbmFsKTtcbiAgICAgICAgICAgIHZpc2l0VHlwZVJlZmVyZW5jZShtZXRob2QucmV0dXJucz8udHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgaW1wbGludCBvZiB0eXBlLmludGVyZmFjZXMgPz8gW10pIHtcbiAgICAgICAgICAgIHZpc2l0VHlwZShpbXBsaW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSBoYXNoLmRpZ2VzdCgnaGV4Jyk7XG4gICAgdGhpcy5jYWNoZS5zZXQoZnFuLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG5cbiAgICBmdW5jdGlvbiB2aXNpdFR5cGUoZnFuPzogc3RyaW5nKSB7XG4gICAgICBpZiAoIWZxbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWN1cnNpb25CcmVha2VyLmhhcyhmcW4pKSB7XG4gICAgICAgIGhhc2gudXBkYXRlKCckUkVDVVJTSU9OJCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlY3Vyc2lvbkJyZWFrZXIuYWRkKGZxbik7XG4gICAgICBoYXNoLnVwZGF0ZShzZWxmLmRvRmluZ2VycHJpbnQoZnFuLCByZWN1cnNpb25CcmVha2VyKSk7XG4gICAgICByZWN1cnNpb25CcmVha2VyLmRlbGV0ZShmcW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZpc2l0Q2FsbGFibGUoY2FsbGFibGU/OiBzcGVjLkNhbGxhYmxlKSB7XG4gICAgICBpZiAoIWNhbGxhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmlzaXRCb29scyhjYWxsYWJsZS5wcm90ZWN0ZWQpO1xuICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBjYWxsYWJsZS5wYXJhbWV0ZXJzID8/IFtdKSB7XG4gICAgICAgIHZpc2l0Qm9vbHMocGFyYW0ub3B0aW9uYWwsIHBhcmFtLnZhcmlhZGljKTtcbiAgICAgICAgdmlzaXRUeXBlUmVmZXJlbmNlKHBhcmFtLnR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZpc2l0VHlwZVJlZmVyZW5jZSh0eXBlUmVmPzogc3BlYy5UeXBlUmVmZXJlbmNlKSB7XG4gICAgICBpZiAoIXR5cGVSZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlYy5pc1ByaW1pdGl2ZVR5cGVSZWZlcmVuY2UodHlwZVJlZikpIHtcbiAgICAgICAgaGFzaC51cGRhdGUodHlwZVJlZi5wcmltaXRpdmUpO1xuICAgICAgfVxuICAgICAgaWYgKHNwZWMuaXNOYW1lZFR5cGVSZWZlcmVuY2UodHlwZVJlZikpIHtcbiAgICAgICAgdmlzaXRUeXBlKHR5cGVSZWYuZnFuKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGVjLmlzQ29sbGVjdGlvblR5cGVSZWZlcmVuY2UodHlwZVJlZikpIHtcbiAgICAgICAgaGFzaC51cGRhdGUodHlwZVJlZi5jb2xsZWN0aW9uLmtpbmQpO1xuICAgICAgICB2aXNpdFR5cGVSZWZlcmVuY2UodHlwZVJlZi5jb2xsZWN0aW9uLmVsZW1lbnR0eXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGVjLmlzVW5pb25UeXBlUmVmZXJlbmNlKHR5cGVSZWYpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlUmVmLnVuaW9uLnR5cGVzKSB7XG4gICAgICAgICAgdmlzaXRUeXBlUmVmZXJlbmNlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlzaXRCb29scyguLi52czogQXJyYXk8Ym9vbGVhbiB8IHVuZGVmaW5lZD4pIHtcbiAgICAgIGhhc2gudXBkYXRlKHZzLm1hcCgodikgPT4gKHYgPyAnMScgOiAnMCcpKS5qb2luKCcnKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaW5kVHlwZShmcW46IHN0cmluZykge1xuICAgIGNvbnN0IGFzc2VtYmx5TmFtZSA9IGZxbi5zcGxpdCgnLicpWzBdO1xuICAgIHJldHVybiB0aGlzLmFzc2VtYmxpZXMuZ2V0KGFzc2VtYmx5TmFtZSk/LnR5cGVzPy5bZnFuXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzb3J0ZWRCeU5hbWU8QSBleHRlbmRzIHsgbmFtZTogc3RyaW5nIH0+KHhzOiBBW10pOiBBW10ge1xuICB4cy5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcbiAgcmV0dXJuIHhzO1xufVxuIl19