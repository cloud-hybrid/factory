"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.spanContains = exports.spanInside = exports.trimCompleteSourceToVisible = exports.Spans = void 0;
/**
 * A class representing a set of non-overlapping Spans.
 */
class Spans {
    constructor(_spans) {
        this._spans = _spans;
        _spans.sort((a, b) => a.start - b.start);
        // Merge adjacent spans
        let i = 0;
        while (i < this._spans.length - 1) {
            const current = this._spans[i];
            const next = this._spans[i + 1];
            if (current.end === next.start) {
                // Replace these two with a new, merged one
                this._spans.splice(i, 2, {
                    start: current.start,
                    end: next.end,
                });
            }
            else {
                // Else advance
                i++;
            }
        }
    }
    /**
     * Derive visible spans from marked source (`/// !show` and `/// !hide` directives).
     */
    static visibleSpansFromSource(source) {
        return new Spans(calculateMarkedSpans(source).filter((s) => s.visible));
    }
    get spans() {
        return this._spans;
    }
    /**
     * Whether another span is fully contained within this set of spans
     */
    fullyContainsSpan(span) {
        const candidate = this.findSpan(span.start);
        return !!candidate && spanInside(span, candidate);
    }
    containsPosition(pos) {
        const candidate = this.findSpan(pos);
        return !!candidate && spanContains(candidate, pos);
    }
    /**
     * Return whether the START of the given node is visible
     *
     * For nodes that potentially span many lines (like class declarations)
     * this will check the first line.
     */
    containsStartOfNode(node) {
        return this.containsPosition(node.getStart());
    }
    /**
     * Find the span that would contain the given position, if any
     *
     * Returns the highest span s.t. span.start <= position. Uses the fact that
     * spans are non-overlapping.
     */
    findSpan(position) {
        // For now, using linear search as the amount of spans is rather trivial.
        // Change to binary search if this ever becomes an issue
        if (this.spans.length === 0 || position < this._spans[0].start) {
            return undefined;
        }
        let candidate = this._spans[0];
        let i = 1;
        while (i < this.spans.length && this.spans[i].start <= position) {
            candidate = this._spans[i];
            i++;
        }
        return candidate;
    }
}
exports.Spans = Spans;
function trimCompleteSourceToVisible(source) {
    const spans = Spans.visibleSpansFromSource(source);
    return spans.spans
        .map((span) => source.substring(span.start, span.end))
        .join('')
        .trimRight();
}
exports.trimCompleteSourceToVisible = trimCompleteSourceToVisible;
function calculateMarkedSpans(source) {
    const regEx = /^[ \t]*[/]{3}[ \t]*(!(?:show|hide))[ \t]*$/gm;
    const ret = new Array();
    let match;
    let spanStart;
    let visible = true;
    while ((match = regEx.exec(source)) != null) {
        const directiveStart = match.index;
        const directive = match[1].trim();
        if (['!hide', '!show'].includes(directive)) {
            const isShow = directive === '!show';
            if (spanStart === undefined) {
                // Add a span at the start which is the reverse of the actual first directive
                ret.push({ start: 0, end: directiveStart, visible: !isShow });
            }
            else {
                // Else add a span for the current directive
                ret.push({ start: spanStart, end: directiveStart, visible });
            }
            visible = isShow;
            // A directive eats its trailing newline.
            spanStart = match.index + match[0].length + 1;
        }
    }
    // Add the remainder under the last visibility
    ret.push({ start: spanStart !== null && spanStart !== void 0 ? spanStart : 0, end: source.length, visible });
    // Filter empty spans and return
    return ret.filter((s) => s.start < s.end);
}
/**
 * Whether span a is fully inside span b
 */
function spanInside(a, b) {
    return b.start <= a.start && a.end <= b.end;
}
exports.spanInside = spanInside;
function spanContains(a, position) {
    return a.start <= position && position < a.end;
}
exports.spanContains = spanContains;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlzaWJsZS1zcGFucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZpc2libGUtc3BhbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBSUE7O0dBRUc7QUFDSCxNQUFhLEtBQUs7SUFRaEIsWUFBb0MsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDaEQsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXpDLHVCQUF1QjtRQUN2QixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDakMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvQixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUVoQyxJQUFJLE9BQU8sQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDOUIsMkNBQTJDO2dCQUMzQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUN2QixLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUs7b0JBQ3BCLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztpQkFDZCxDQUFDLENBQUM7YUFDSjtpQkFBTTtnQkFDTCxlQUFlO2dCQUNmLENBQUMsRUFBRSxDQUFDO2FBQ0w7U0FDRjtJQUNILENBQUM7SUEzQkQ7O09BRUc7SUFDSSxNQUFNLENBQUMsc0JBQXNCLENBQUMsTUFBYztRQUNqRCxPQUFPLElBQUksS0FBSyxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxF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SSxRQUFRLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDakQsQ0FBQztBQUZELG9DQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IFNwYW4gfSBmcm9tICcuLi9vLXRyZWUnO1xuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgc2V0IG9mIG5vbi1vdmVybGFwcGluZyBTcGFucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNwYW5zIHtcbiAgLyoqXG4gICAqIERlcml2ZSB2aXNpYmxlIHNwYW5zIGZyb20gbWFya2VkIHNvdXJjZSAoYC8vLyAhc2hvd2AgYW5kIGAvLy8gIWhpZGVgIGRpcmVjdGl2ZXMpLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB2aXNpYmxlU3BhbnNGcm9tU291cmNlKHNvdXJjZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFucyhjYWxjdWxhdGVNYXJrZWRTcGFucyhzb3VyY2UpLmZpbHRlcigocykgPT4gcy52aXNpYmxlKSk7XG4gIH1cblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBfc3BhbnM6IFNwYW5bXSkge1xuICAgIF9zcGFucy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCk7XG5cbiAgICAvLyBNZXJnZSBhZGphY2VudCBzcGFuc1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHRoaXMuX3NwYW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9zcGFuc1tpXTtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl9zcGFuc1tpICsgMV07XG5cbiAgICAgIGlmIChjdXJyZW50LmVuZCA9PT0gbmV4dC5zdGFydCkge1xuICAgICAgICAvLyBSZXBsYWNlIHRoZXNlIHR3byB3aXRoIGEgbmV3LCBtZXJnZWQgb25lXG4gICAgICAgIHRoaXMuX3NwYW5zLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgc3RhcnQ6IGN1cnJlbnQuc3RhcnQsXG4gICAgICAgICAgZW5kOiBuZXh0LmVuZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbHNlIGFkdmFuY2VcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3BhbnMoKTogcmVhZG9ubHkgU3BhbltdIHtcbiAgICByZXR1cm4gdGhpcy5fc3BhbnM7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBhbm90aGVyIHNwYW4gaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiB0aGlzIHNldCBvZiBzcGFuc1xuICAgKi9cbiAgcHVibGljIGZ1bGx5Q29udGFpbnNTcGFuKHNwYW46IFNwYW4pIHtcbiAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLmZpbmRTcGFuKHNwYW4uc3RhcnQpO1xuICAgIHJldHVybiAhIWNhbmRpZGF0ZSAmJiBzcGFuSW5zaWRlKHNwYW4sIGNhbmRpZGF0ZSk7XG4gIH1cblxuICBwdWJsaWMgY29udGFpbnNQb3NpdGlvbihwb3M6IG51bWJlcikge1xuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRoaXMuZmluZFNwYW4ocG9zKTtcbiAgICByZXR1cm4gISFjYW5kaWRhdGUgJiYgc3BhbkNvbnRhaW5zKGNhbmRpZGF0ZSwgcG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgU1RBUlQgb2YgdGhlIGdpdmVuIG5vZGUgaXMgdmlzaWJsZVxuICAgKlxuICAgKiBGb3Igbm9kZXMgdGhhdCBwb3RlbnRpYWxseSBzcGFuIG1hbnkgbGluZXMgKGxpa2UgY2xhc3MgZGVjbGFyYXRpb25zKVxuICAgKiB0aGlzIHdpbGwgY2hlY2sgdGhlIGZpcnN0IGxpbmUuXG4gICAqL1xuICBwdWJsaWMgY29udGFpbnNTdGFydE9mTm9kZShub2RlOiB0cy5Ob2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnNQb3NpdGlvbihub2RlLmdldFN0YXJ0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHNwYW4gdGhhdCB3b3VsZCBjb250YWluIHRoZSBnaXZlbiBwb3NpdGlvbiwgaWYgYW55XG4gICAqXG4gICAqIFJldHVybnMgdGhlIGhpZ2hlc3Qgc3BhbiBzLnQuIHNwYW4uc3RhcnQgPD0gcG9zaXRpb24uIFVzZXMgdGhlIGZhY3QgdGhhdFxuICAgKiBzcGFucyBhcmUgbm9uLW92ZXJsYXBwaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBmaW5kU3Bhbihwb3NpdGlvbjogbnVtYmVyKTogU3BhbiB8IHVuZGVmaW5lZCB7XG4gICAgLy8gRm9yIG5vdywgdXNpbmcgbGluZWFyIHNlYXJjaCBhcyB0aGUgYW1vdW50IG9mIHNwYW5zIGlzIHJhdGhlciB0cml2aWFsLlxuICAgIC8vIENoYW5nZSB0byBiaW5hcnkgc2VhcmNoIGlmIHRoaXMgZXZlciBiZWNvbWVzIGFuIGlzc3VlXG4gICAgaWYgKHRoaXMuc3BhbnMubGVuZ3RoID09PSAwIHx8IHBvc2l0aW9uIDwgdGhpcy5fc3BhbnNbMF0uc3RhcnQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbGV0IGNhbmRpZGF0ZSA9IHRoaXMuX3NwYW5zWzBdO1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IHRoaXMuc3BhbnMubGVuZ3RoICYmIHRoaXMuc3BhbnNbaV0uc3RhcnQgPD0gcG9zaXRpb24pIHtcbiAgICAgIGNhbmRpZGF0ZSA9IHRoaXMuX3NwYW5zW2ldO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmltQ29tcGxldGVTb3VyY2VUb1Zpc2libGUoc291cmNlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBzcGFucyA9IFNwYW5zLnZpc2libGVTcGFuc0Zyb21Tb3VyY2Uoc291cmNlKTtcblxuICByZXR1cm4gc3BhbnMuc3BhbnNcbiAgICAubWFwKChzcGFuKSA9PiBzb3VyY2Uuc3Vic3RyaW5nKHNwYW4uc3RhcnQsIHNwYW4uZW5kKSlcbiAgICAuam9pbignJylcbiAgICAudHJpbVJpZ2h0KCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFya2VkU3BhbiB7XG4gIHN0YXJ0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xuICB2aXNpYmxlOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVNYXJrZWRTcGFucyhzb3VyY2U6IHN0cmluZyk6IE1hcmtlZFNwYW5bXSB7XG4gIGNvbnN0IHJlZ0V4ID0gL15bIFxcdF0qWy9dezN9WyBcXHRdKighKD86c2hvd3xoaWRlKSlbIFxcdF0qJC9nbTtcblxuICBjb25zdCByZXQgPSBuZXcgQXJyYXk8TWFya2VkU3Bhbj4oKTtcbiAgbGV0IG1hdGNoO1xuICBsZXQgc3BhblN0YXJ0O1xuICBsZXQgdmlzaWJsZSA9IHRydWU7XG4gIHdoaWxlICgobWF0Y2ggPSByZWdFeC5leGVjKHNvdXJjZSkpICE9IG51bGwpIHtcbiAgICBjb25zdCBkaXJlY3RpdmVTdGFydCA9IG1hdGNoLmluZGV4O1xuICAgIGNvbnN0IGRpcmVjdGl2ZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoWychaGlkZScsICchc2hvdyddLmluY2x1ZGVzKGRpcmVjdGl2ZSkpIHtcbiAgICAgIGNvbnN0IGlzU2hvdyA9IGRpcmVjdGl2ZSA9PT0gJyFzaG93JztcbiAgICAgIGlmIChzcGFuU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBBZGQgYSBzcGFuIGF0IHRoZSBzdGFydCB3aGljaCBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgYWN0dWFsIGZpcnN0IGRpcmVjdGl2ZVxuICAgICAgICByZXQucHVzaCh7IHN0YXJ0OiAwLCBlbmQ6IGRpcmVjdGl2ZVN0YXJ0LCB2aXNpYmxlOiAhaXNTaG93IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRWxzZSBhZGQgYSBzcGFuIGZvciB0aGUgY3VycmVudCBkaXJlY3RpdmVcbiAgICAgICAgcmV0LnB1c2goeyBzdGFydDogc3BhblN0YXJ0LCBlbmQ6IGRpcmVjdGl2ZVN0YXJ0LCB2aXNpYmxlIH0pO1xuICAgICAgfVxuICAgICAgdmlzaWJsZSA9IGlzU2hvdztcblxuICAgICAgLy8gQSBkaXJlY3RpdmUgZWF0cyBpdHMgdHJhaWxpbmcgbmV3bGluZS5cbiAgICAgIHNwYW5TdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICsgMTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgdGhlIHJlbWFpbmRlciB1bmRlciB0aGUgbGFzdCB2aXNpYmlsaXR5XG4gIHJldC5wdXNoKHsgc3RhcnQ6IHNwYW5TdGFydCA/PyAwLCBlbmQ6IHNvdXJjZS5sZW5ndGgsIHZpc2libGUgfSk7XG5cbiAgLy8gRmlsdGVyIGVtcHR5IHNwYW5zIGFuZCByZXR1cm5cbiAgcmV0dXJuIHJldC5maWx0ZXIoKHMpID0+IHMuc3RhcnQgPCBzLmVuZCk7XG59XG5cbi8qKlxuICogV2hldGhlciBzcGFuIGEgaXMgZnVsbHkgaW5zaWRlIHNwYW4gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Bhbkluc2lkZShhOiBTcGFuLCBiOiBTcGFuKSB7XG4gIHJldHVybiBiLnN0YXJ0IDw9IGEuc3RhcnQgJiYgYS5lbmQgPD0gYi5lbmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGFuQ29udGFpbnMoYTogU3BhbiwgcG9zaXRpb246IG51bWJlcikge1xuICByZXR1cm4gYS5zdGFydCA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8IGEuZW5kO1xufVxuIl19