"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mean = exports.meanLength = exports.shortest = exports.longest = void 0;
class SnippetScore {
    constructor(snippet, score) {
        this.snippet = snippet;
        this.score = score;
    }
}
/**
 * Returns the longest available snippet.
 */
function longest(snippets) {
    if (snippets.length === 0) {
        throw new Error('longest: array cannot be empty');
    }
    const snippetScores = [];
    for (const snippet of snippets) {
        snippetScores.push({ snippet: snippet, score: snippet.originalSource.source.length });
    }
    return getMaxScore(snippetScores).snippet;
}
exports.longest = longest;
/**
 * Returns the shortest available snippet.
 */
function shortest(snippets) {
    if (snippets.length === 0) {
        throw new Error('shortest: array cannot be empty');
    }
    const snippetScores = [];
    for (const snippet of snippets) {
        snippetScores.push({ snippet: snippet, score: snippet.originalSource.source.length });
    }
    return getMinScore(snippetScores).snippet;
}
exports.shortest = shortest;
/**
 * Returns the snippet with the length closest to the mean length of the available snippets.
 */
function meanLength(snippets) {
    if (snippets.length === 0) {
        throw new Error('meanLength: array cannot be empty');
    }
    const mean = snippets.reduce((x, y) => x + y.originalSource.source.length, 0) / snippets.length;
    const snippetScores = [];
    for (const snippet of snippets) {
        snippetScores.push({ snippet: snippet, score: Math.abs(snippet.originalSource.source.length - mean) });
    }
    return getMinScore(snippetScores).snippet;
}
exports.meanLength = meanLength;
/**
 * Finds and returns the mean sparse vector of available snippets for each type.
 */
function mean(snippets) {
    if (snippets.length === 0) {
        throw new Error('mean: array cannot be empty');
    }
    // Find mean counter.
    const counters = [];
    snippets.map((snippet) => {
        var _a;
        counters.push((_a = snippet.snippet.syntaxKindCounter) !== null && _a !== void 0 ? _a : {});
    });
    const meanCounter = findCenter(counters);
    // Find counter with closest euclidian distance.
    const snippetScores = [];
    for (let i = 0; i < snippets.length; i++) {
        snippetScores.push({ snippet: snippets[i], score: euclideanDistance(meanCounter, counters[i]) });
    }
    return getMinScore(snippetScores).snippet;
}
exports.mean = mean;
/**
 * Given a list of Records, outputs a Record that averages all the items in each Record.
 */
function findCenter(counters) {
    var _a;
    const centerCounter = {};
    for (const counter of counters) {
        for (const [key, value] of Object.entries(counter)) {
            centerCounter[key] = value + ((_a = centerCounter[key]) !== null && _a !== void 0 ? _a : 0);
        }
    }
    const total = counters.length;
    Object.entries(centerCounter).map(([key, value]) => {
        centerCounter[key] = value / total;
    });
    return centerCounter;
}
/**
 * Finds the euclidean distance between two sparse vectors.
 * !!! This function assumes that the center parameter is a superset of the counter parameter. !!!
 */
function euclideanDistance(center, counter) {
    const individualDistances = [];
    Object.entries(center).map(([key, value]) => {
        var _a;
        individualDistances.push(value - ((_a = counter[key]) !== null && _a !== void 0 ? _a : 0));
    });
    return individualDistances.reduce((acc, curr) => acc + Math.sqrt(Math.pow(curr, 2)), 0);
}
function getMaxScore(snippetScores) {
    return snippetScores.reduce((x, y) => {
        return x.score >= y.score ? x : y;
    });
}
function getMinScore(snippetScores) {
    return snippetScores.reduce((x, y) => {
        return x.score <= y.score ? x : y;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic25pcHBldC1zZWxlY3RvcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzbmlwcGV0LXNlbGVjdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFJQSxNQUFNLFlBQVk7SUFDaEIsWUFBbUMsT0FBMEIsRUFBa0IsS0FBYTtRQUF6RCxZQUFPLEdBQVAsT0FBTyxDQUFtQjtRQUFrQixVQUFLLEdBQUwsS0FBSyxDQUFRO0lBQUcsQ0FBQztDQUNqRztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLFFBQTZCO0lBQ25ELElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDekIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0tBQ25EO0lBQ0QsTUFBTSxhQUFhLEdBQW1CLEVBQUUsQ0FBQztJQUN6QyxLQUFLLE1BQU0sT0FBTyxJQUFJLFFBQVEsRUFBRTtRQUM5QixhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztLQUN2RjtJQUNELE9BQU8sV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUM1QyxDQUFDO0FBVEQsMEJBU0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLFFBQVEsQ0FBQyxRQUE2QjtJQUNwRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztLQUNwRDtJQUNELE1BQU0sYUFBYSxHQUFtQixFQUFFLENBQUM7SUFDekMsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUU7UUFDOUIsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLE1B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QUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2xhdGVkU25pcHBldCB9IGZyb20gJy4vdGFibGV0cy90YWJsZXRzJztcblxuZXhwb3J0IHR5cGUgU25pcHBldFNlbGVjdG9yID0gKHNuaXBwZXRzOiBUcmFuc2xhdGVkU25pcHBldFtdKSA9PiBUcmFuc2xhdGVkU25pcHBldDtcblxuY2xhc3MgU25pcHBldFNjb3JlIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzbmlwcGV0OiBUcmFuc2xhdGVkU25pcHBldCwgcHVibGljIHJlYWRvbmx5IHNjb3JlOiBudW1iZXIpIHt9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9uZ2VzdCBhdmFpbGFibGUgc25pcHBldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvbmdlc3Qoc25pcHBldHM6IFRyYW5zbGF0ZWRTbmlwcGV0W10pOiBUcmFuc2xhdGVkU25pcHBldCB7XG4gIGlmIChzbmlwcGV0cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvbmdlc3Q6IGFycmF5IGNhbm5vdCBiZSBlbXB0eScpO1xuICB9XG4gIGNvbnN0IHNuaXBwZXRTY29yZXM6IFNuaXBwZXRTY29yZVtdID0gW107XG4gIGZvciAoY29uc3Qgc25pcHBldCBvZiBzbmlwcGV0cykge1xuICAgIHNuaXBwZXRTY29yZXMucHVzaCh7IHNuaXBwZXQ6IHNuaXBwZXQsIHNjb3JlOiBzbmlwcGV0Lm9yaWdpbmFsU291cmNlLnNvdXJjZS5sZW5ndGggfSk7XG4gIH1cbiAgcmV0dXJuIGdldE1heFNjb3JlKHNuaXBwZXRTY29yZXMpLnNuaXBwZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2hvcnRlc3QgYXZhaWxhYmxlIHNuaXBwZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG9ydGVzdChzbmlwcGV0czogVHJhbnNsYXRlZFNuaXBwZXRbXSk6IFRyYW5zbGF0ZWRTbmlwcGV0IHtcbiAgaWYgKHNuaXBwZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2hvcnRlc3Q6IGFycmF5IGNhbm5vdCBiZSBlbXB0eScpO1xuICB9XG4gIGNvbnN0IHNuaXBwZXRTY29yZXM6IFNuaXBwZXRTY29yZVtdID0gW107XG4gIGZvciAoY29uc3Qgc25pcHBldCBvZiBzbmlwcGV0cykge1xuICAgIHNuaXBwZXRTY29yZXMucHVzaCh7IHNuaXBwZXQ6IHNuaXBwZXQsIHNjb3JlOiBzbmlwcGV0Lm9yaWdpbmFsU291cmNlLnNvdXJjZS5sZW5ndGggfSk7XG4gIH1cbiAgcmV0dXJuIGdldE1pblNjb3JlKHNuaXBwZXRTY29yZXMpLnNuaXBwZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc25pcHBldCB3aXRoIHRoZSBsZW5ndGggY2xvc2VzdCB0byB0aGUgbWVhbiBsZW5ndGggb2YgdGhlIGF2YWlsYWJsZSBzbmlwcGV0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYW5MZW5ndGgoc25pcHBldHM6IFRyYW5zbGF0ZWRTbmlwcGV0W10pOiBUcmFuc2xhdGVkU25pcHBldCB7XG4gIGlmIChzbmlwcGV0cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lYW5MZW5ndGg6IGFycmF5IGNhbm5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgY29uc3QgbWVhbiA9IHNuaXBwZXRzLnJlZHVjZSgoeCwgeSkgPT4geCArIHkub3JpZ2luYWxTb3VyY2Uuc291cmNlLmxlbmd0aCwgMCkgLyBzbmlwcGV0cy5sZW5ndGg7XG4gIGNvbnN0IHNuaXBwZXRTY29yZXM6IFNuaXBwZXRTY29yZVtdID0gW107XG4gIGZvciAoY29uc3Qgc25pcHBldCBvZiBzbmlwcGV0cykge1xuICAgIHNuaXBwZXRTY29yZXMucHVzaCh7IHNuaXBwZXQ6IHNuaXBwZXQsIHNjb3JlOiBNYXRoLmFicyhzbmlwcGV0Lm9yaWdpbmFsU291cmNlLnNvdXJjZS5sZW5ndGggLSBtZWFuKSB9KTtcbiAgfVxuICByZXR1cm4gZ2V0TWluU2NvcmUoc25pcHBldFNjb3Jlcykuc25pcHBldDtcbn1cblxuLyoqXG4gKiBGaW5kcyBhbmQgcmV0dXJucyB0aGUgbWVhbiBzcGFyc2UgdmVjdG9yIG9mIGF2YWlsYWJsZSBzbmlwcGV0cyBmb3IgZWFjaCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhbihzbmlwcGV0czogVHJhbnNsYXRlZFNuaXBwZXRbXSk6IFRyYW5zbGF0ZWRTbmlwcGV0IHtcbiAgaWYgKHNuaXBwZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVhbjogYXJyYXkgY2Fubm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICAvLyBGaW5kIG1lYW4gY291bnRlci5cbiAgY29uc3QgY291bnRlcnM6IEFycmF5PFJlY29yZDxzdHJpbmcsIG51bWJlcj4+ID0gW107XG4gIHNuaXBwZXRzLm1hcCgoc25pcHBldCkgPT4ge1xuICAgIGNvdW50ZXJzLnB1c2goc25pcHBldC5zbmlwcGV0LnN5bnRheEtpbmRDb3VudGVyID8/IHt9KTtcbiAgfSk7XG4gIGNvbnN0IG1lYW5Db3VudGVyID0gZmluZENlbnRlcihjb3VudGVycyk7XG4gIC8vIEZpbmQgY291bnRlciB3aXRoIGNsb3Nlc3QgZXVjbGlkaWFuIGRpc3RhbmNlLlxuICBjb25zdCBzbmlwcGV0U2NvcmVzOiBTbmlwcGV0U2NvcmVbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNuaXBwZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc25pcHBldFNjb3Jlcy5wdXNoKHsgc25pcHBldDogc25pcHBldHNbaV0sIHNjb3JlOiBldWNsaWRlYW5EaXN0YW5jZShtZWFuQ291bnRlciwgY291bnRlcnNbaV0pIH0pO1xuICB9XG4gIHJldHVybiBnZXRNaW5TY29yZShzbmlwcGV0U2NvcmVzKS5zbmlwcGV0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBSZWNvcmRzLCBvdXRwdXRzIGEgUmVjb3JkIHRoYXQgYXZlcmFnZXMgYWxsIHRoZSBpdGVtcyBpbiBlYWNoIFJlY29yZC5cbiAqL1xuZnVuY3Rpb24gZmluZENlbnRlcihjb3VudGVyczogQXJyYXk8UmVjb3JkPHN0cmluZywgbnVtYmVyPj4pOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHtcbiAgY29uc3QgY2VudGVyQ291bnRlcjogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICBmb3IgKGNvbnN0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb3VudGVyKSkge1xuICAgICAgY2VudGVyQ291bnRlcltrZXldID0gdmFsdWUgKyAoY2VudGVyQ291bnRlcltrZXldID8/IDApO1xuICAgIH1cbiAgfVxuICBjb25zdCB0b3RhbCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgT2JqZWN0LmVudHJpZXMoY2VudGVyQ291bnRlcikubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjZW50ZXJDb3VudGVyW2tleV0gPSB2YWx1ZSAvIHRvdGFsO1xuICB9KTtcbiAgcmV0dXJuIGNlbnRlckNvdW50ZXI7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzcGFyc2UgdmVjdG9ycy5cbiAqICEhISBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgY2VudGVyIHBhcmFtZXRlciBpcyBhIHN1cGVyc2V0IG9mIHRoZSBjb3VudGVyIHBhcmFtZXRlci4gISEhXG4gKi9cbmZ1bmN0aW9uIGV1Y2xpZGVhbkRpc3RhbmNlKGNlbnRlcjogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgY291bnRlcjogUmVjb3JkPHN0cmluZywgbnVtYmVyPik6IG51bWJlciB7XG4gIGNvbnN0IGluZGl2aWR1YWxEaXN0YW5jZXM6IG51bWJlcltdID0gW107XG4gIE9iamVjdC5lbnRyaWVzKGNlbnRlcikubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpbmRpdmlkdWFsRGlzdGFuY2VzLnB1c2godmFsdWUgLSAoY291bnRlcltrZXldID8/IDApKTtcbiAgfSk7XG4gIHJldHVybiBpbmRpdmlkdWFsRGlzdGFuY2VzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBNYXRoLnNxcnQoTWF0aC5wb3coY3VyciwgMikpLCAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWF4U2NvcmUoc25pcHBldFNjb3JlczogU25pcHBldFNjb3JlW10pOiBTbmlwcGV0U2NvcmUge1xuICByZXR1cm4gc25pcHBldFNjb3Jlcy5yZWR1Y2UoKHgsIHkpID0+IHtcbiAgICByZXR1cm4geC5zY29yZSA+PSB5LnNjb3JlID8geCA6IHk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRNaW5TY29yZShzbmlwcGV0U2NvcmVzOiBTbmlwcGV0U2NvcmVbXSk6IFNuaXBwZXRTY29yZSB7XG4gIHJldHVybiBzbmlwcGV0U2NvcmVzLnJlZHVjZSgoeCwgeSkgPT4ge1xuICAgIHJldHVybiB4LnNjb3JlIDw9IHkuc2NvcmUgPyB4IDogeTtcbiAgfSk7XG59XG4iXX0=