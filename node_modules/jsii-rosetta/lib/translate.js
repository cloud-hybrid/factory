"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _diagnostics;
Object.defineProperty(exports, "__esModule", { value: true });
exports.rosettaDiagFromTypescript = exports.SnippetTranslator = exports.makeRosettaDiagnostic = exports.Translator = exports.translateTypeScript = void 0;
const ts = require("typescript");
const util_1 = require("util");
const languages_1 = require("./languages");
const record_references_1 = require("./languages/record-references");
const logging = require("./logging");
const o_tree_1 = require("./o-tree");
const renderer_1 = require("./renderer");
const snippet_1 = require("./snippet");
const key_1 = require("./tablets/key");
const schema_1 = require("./tablets/schema");
const tablets_1 = require("./tablets/tablets");
const syntax_kind_counter_1 = require("./typescript/syntax-kind-counter");
const ts_compiler_1 = require("./typescript/ts-compiler");
const visible_spans_1 = require("./typescript/visible-spans");
const util_2 = require("./util");
function translateTypeScript(source, visitor, options = {}) {
    const translator = new SnippetTranslator({ visibleSource: source.contents, location: { api: { api: 'file', fileName: source.fileName } } }, options);
    const translated = translator.renderUsing(visitor);
    return {
        translation: translated,
        diagnostics: translator.diagnostics.map(rosettaDiagFromTypescript),
    };
}
exports.translateTypeScript = translateTypeScript;
/**
 * Translate one or more TypeScript snippets into other languages
 *
 * Can be configured to fully typecheck the samples, or perform only syntactical
 * translation.
 */
class Translator {
    constructor(includeCompilerDiagnostics) {
        this.includeCompilerDiagnostics = includeCompilerDiagnostics;
        this.compiler = new ts_compiler_1.TypeScriptCompiler();
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _diagnostics.set(this, []);
    }
    translate(snip, languages = Object.values(languages_1.TargetLanguage)) {
        var _a, _b;
        logging.debug(`Translating ${key_1.snippetKey(snip)} ${util_1.inspect((_a = snip.parameters) !== null && _a !== void 0 ? _a : {})}`);
        const translator = this.translatorFor(snip);
        const translations = util_2.mkDict(languages.map((lang) => {
            const languageConverterFactory = languages_1.TARGET_LANGUAGES[lang];
            const translated = translator.renderUsing(languageConverterFactory.createVisitor());
            return [lang, { source: translated, version: languageConverterFactory.version }];
        }));
        if (((_b = snip.parameters) === null || _b === void 0 ? void 0 : _b.infused) === undefined) {
            __classPrivateFieldGet(this, _diagnostics).push(...translator.diagnostics);
        }
        return tablets_1.TranslatedSnippet.fromSchema({
            translations: {
                ...translations,
                [schema_1.ORIGINAL_SNIPPET_KEY]: { source: snip.visibleSource, version: '0' },
            },
            location: snip.location,
            didCompile: translator.didSuccessfullyCompile,
            fqnsReferenced: translator.fqnsReferenced(),
            fullSource: snippet_1.completeSource(snip),
            syntaxKindCounter: translator.syntaxKindCounter(),
        });
    }
    get diagnostics() {
        return ts.sortAndDeduplicateDiagnostics(__classPrivateFieldGet(this, _diagnostics)).map(rosettaDiagFromTypescript);
    }
    /**
     * Return the snippet translator for the given snippet
     *
     * We used to cache these, but each translator holds on to quite a bit of memory,
     * so we don't do that anymore.
     */
    translatorFor(snippet) {
        const translator = new SnippetTranslator(snippet, {
            compiler: this.compiler,
            includeCompilerDiagnostics: this.includeCompilerDiagnostics,
        });
        return translator;
    }
}
exports.Translator = Translator;
_diagnostics = new WeakMap();
function makeRosettaDiagnostic(isError, formattedMessage) {
    return { isError, formattedMessage, isFromStrictAssembly: false };
}
exports.makeRosettaDiagnostic = makeRosettaDiagnostic;
/**
 * Translate a single TypeScript snippet
 */
class SnippetTranslator {
    constructor(snippet, options = {}) {
        var _a, _b, _c, _d, _e;
        this.options = options;
        this.translateDiagnostics = [];
        this.compileDiagnostics = [];
        const compiler = (_a = options.compiler) !== null && _a !== void 0 ? _a : new ts_compiler_1.TypeScriptCompiler();
        const source = snippet_1.completeSource(snippet);
        const fakeCurrentDirectory = (_c = (_b = snippet.parameters) === null || _b === void 0 ? void 0 : _b[snippet_1.SnippetParameters.$COMPILATION_DIRECTORY]) !== null && _c !== void 0 ? _c : (_d = snippet.parameters) === null || _d === void 0 ? void 0 : _d[snippet_1.SnippetParameters.$PROJECT_DIRECTORY];
        this.compilation = compiler.compileInMemory(removeSlashes(snippet_1.formatLocation(snippet.location)), source, fakeCurrentDirectory);
        // Respect '/// !hide' and '/// !show' directives
        this.visibleSpans = visible_spans_1.Spans.visibleSpansFromSource(source);
        // This makes it about 5x slower, so only do it on demand
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.tryCompile = (_e = (options.includeCompilerDiagnostics || snippet.strict)) !== null && _e !== void 0 ? _e : false;
        if (this.tryCompile) {
            const program = this.compilation.program;
            const diagnostics = [
                ...neverThrowing(program.getGlobalDiagnostics)(),
                ...neverThrowing(program.getSyntacticDiagnostics)(this.compilation.rootFile),
                ...neverThrowing(program.getDeclarationDiagnostics)(this.compilation.rootFile),
                ...neverThrowing(program.getSemanticDiagnostics)(this.compilation.rootFile),
            ];
            if (snippet.strict) {
                // In a strict assembly, so we'll need to brand all diagnostics here...
                diagnostics.forEach(util_2.annotateStrictDiagnostic);
            }
            this.compileDiagnostics.push(...diagnostics);
        }
        /**
         * Intercepts all exceptions thrown by the wrapped call, and logs them to
         * console.error instead of re-throwing, then returns an empty array. This
         * is here to avoid compiler crashes due to broken code examples that cause
         * the TypeScript compiler to hit a "Debug Failure".
         */
        function neverThrowing(call) {
            return (...args) => {
                try {
                    return call(...args);
                }
                catch (err) {
                    const isExpectedTypescriptError = err.message.includes('Debug Failure');
                    if (!isExpectedTypescriptError) {
                        console.error(`Failed to execute ${call.name}: ${err}`);
                    }
                    return [];
                }
            };
        }
    }
    /**
     * Returns a boolean if compilation was attempted, and undefined if it was not.
     */
    get didSuccessfullyCompile() {
        return this.tryCompile ? this.compileDiagnostics.length === 0 : undefined;
    }
    renderUsing(visitor) {
        const converter = new renderer_1.AstRenderer(this.compilation.rootFile, this.compilation.program.getTypeChecker(), visitor, this.options);
        const converted = converter.convert(this.compilation.rootFile);
        this.translateDiagnostics.push(...filterVisibleDiagnostics(converter.diagnostics, this.visibleSpans));
        return o_tree_1.renderTree(converted, { visibleSpans: this.visibleSpans });
    }
    syntaxKindCounter() {
        const kindCounter = new syntax_kind_counter_1.SyntaxKindCounter(this.visibleSpans);
        return kindCounter.countKinds(this.compilation.rootFile);
    }
    fqnsReferenced() {
        const visitor = new record_references_1.RecordReferencesVisitor(this.visibleSpans);
        const converter = new renderer_1.AstRenderer(this.compilation.rootFile, this.compilation.program.getTypeChecker(), visitor, this.options);
        converter.convert(this.compilation.rootFile);
        return visitor.fqnsReferenced();
    }
    get diagnostics() {
        return ts.sortAndDeduplicateDiagnostics(this.compileDiagnostics.concat(this.translateDiagnostics));
    }
}
exports.SnippetTranslator = SnippetTranslator;
/**
 * Hide diagnostics that are rosetta-sourced if they are reported against a non-visible span
 */
function filterVisibleDiagnostics(diags, visibleSpans) {
    return diags.filter((d) => d.source !== 'rosetta' || d.start === undefined || visibleSpans.containsPosition(d.start));
}
/**
 * Turn TypeScript diagnostics into Rosetta diagnostics
 */
function rosettaDiagFromTypescript(diag) {
    return {
        isError: diag.category === ts.DiagnosticCategory.Error,
        isFromStrictAssembly: util_2.hasStrictBranding(diag),
        formattedMessage: ts.formatDiagnosticsWithColorAndContext([diag], DIAG_HOST),
    };
}
exports.rosettaDiagFromTypescript = rosettaDiagFromTypescript;
const DIAG_HOST = {
    getCurrentDirectory() {
        return '.';
    },
    getCanonicalFileName(fileName) {
        return fileName;
    },
    getNewLine() {
        return '\n';
    },
};
/**
 * Remove slashes from a "where" description, as the TS compiler will interpret it as a directory
 * and we can't have that for compiling literate files
 */
function removeSlashes(x) {
    return x.replace(/\/|\\/g, '.');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidHJhbnNsYXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBaUM7QUFDakMsK0JBQStCO0FBRS9CLDJDQUErRDtBQUMvRCxxRUFBd0U7QUFDeEUscUNBQXFDO0FBQ3JDLHFDQUFzQztBQUN0Qyx5Q0FBeUU7QUFDekUsdUNBQWlHO0FBQ2pHLHVDQUEyQztBQUMzQyw2Q0FBd0Q7QUFDeEQsK0NBQXNEO0FBQ3RELDBFQUFxRTtBQUNyRSwwREFBaUY7QUFDakYsOERBQW1EO0FBQ25ELGlDQUFtRjtBQUVuRixTQUFnQixtQkFBbUIsQ0FDakMsTUFBWSxFQUNaLE9BQXdCLEVBQ3hCLFVBQW9DLEVBQUU7SUFFdEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxpQkFBaUIsQ0FDdEMsRUFBRSxhQUFhLEVBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFBRSxFQUNqRyxPQUFPLENBQ1IsQ0FBQztJQUNGLE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFbkQsT0FBTztRQUNMLFdBQVcsRUFBRSxVQUFVO1FBQ3ZCLFdBQVcsRUFBRSxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsQ0FBQztLQUNuRSxDQUFDO0FBQ0osQ0FBQztBQWZELGtEQWVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFhLFVBQVU7SUFLckIsWUFBb0MsMEJBQW1DO1FBQW5DLCtCQUEwQixHQUExQiwwQkFBMEIsQ0FBUztRQUp0RCxhQUFRLEdBQUcsSUFBSSxnQ0FBa0IsRUFBRSxDQUFDO1FBQ3JELDRFQUE0RTtRQUM1RSx1QkFBZ0MsRUFBRSxFQUFDO0lBRXVDLENBQUM7SUFFcEUsU0FBUyxDQUFDLElBQXVCLEVBQUUsWUFBdUMsTUFBTSxDQUFDLE1BQU0sQ0FBQywwQkFBYyxDQUFDOztRQUM1RyxPQUFPLENBQUMsS0FBSyxDQUFDLGVBQWUsZ0JBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxjQUFPLE9BQUMsSUFBSSxDQUFDLFVBQVUsbUNBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25GLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFNUMsTUFBTSxZQUFZLEdBQUcsYUFBTSxDQUN6QixTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDckIsTUFBTSx3QkFBd0IsR0FBRyw0QkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN4RCxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLHdCQUF3QixDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7WUFDcEYsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxDQUFVLENBQUM7UUFDNUYsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUVGLElBQUksT0FBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxPQUFPLE1BQUssU0FBUyxFQUFFO1lBQzFDLDJDQUFrQixJQUFJLENBQUMsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDbkQ7UUFFRCxPQUFPLDJCQUFpQixDQUFDLFVBQVUsQ0FBQztZQUNsQyxZQUFZLEVBQUU7Z0JBQ1osR0FBRyxZQUFZO2dCQUNmLENBQUMsNkJBQW9CLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUU7YUFDckU7WUFDRCxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsVUFBVSxFQUFFLFVBQVUsQ0FBQyxzQkFBc0I7WUFDN0MsY0FBYyxFQUFFLFVBQVUsQ0FBQyxjQUFjLEVBQUU7WUFDM0MsVUFBVSxFQUFFLHdCQUFjLENBQUMsSUFBSSxDQUFDO1lBQ2hDLGlCQUFpQixFQUFFLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRTtTQUNsRCxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsSUFBVyxXQUFXO1FBQ3BCLE9BQU8sRUFBRSxDQUFDLDZCQUE2Qiw0Q0FBbUIsQ0FBQyxHQUFHLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxhQUFhLENBQUMsT0FBMEI7UUFDN0MsTUFBTSxVQUFVLEdBQUcsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLEVBQUU7WUFDaEQsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLDBCQUEwQixFQUFFLElBQUksQ0FBQywwQkFBMEI7U0FDNUQsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztDQUNGO0FBckRELGdDQXFEQzs7QUFtREQsU0FBZ0IscUJBQXFCLENBQUMsT0FBZ0IsRUFBRSxnQkFBd0I7SUFDOUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNwRSxDQUFDO0FBRkQsc0RBRUM7QUFFRDs7R0FFRztBQUNILE1BQWEsaUJBQWlCO0lBTzVCLFlBQW1CLE9BQTBCLEVBQW1CLFVBQW9DLEVBQUU7O1FBQXRDLFlBQU8sR0FBUCxPQUFPLENBQStCO1FBTnRGLHlCQUFvQixHQUFvQixFQUFFLENBQUM7UUFDM0MsdUJBQWtCLEdBQW9CLEVBQUUsQ0FBQztRQU12RCxNQUFNLFFBQVEsU0FBRyxPQUFPLENBQUMsUUFBUSxtQ0FBSSxJQUFJLGdDQUFrQixFQUFFLENBQUM7UUFDOUQsTUFBTSxNQUFNLEdBQUcsd0JBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN2QyxNQUFNLG9CQUFvQixlQUN4QixPQUFPLENBQUMsVUFBVSwwQ0FBRywyQkFBaUIsQ0FBQyxzQkFBc0IsMENBQzdELE9BQU8sQ0FBQyxVQUFVLDBDQUFHLDJCQUFpQixDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDN0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsZUFBZSxDQUN6QyxhQUFhLENBQUMsd0JBQWMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsRUFDL0MsTUFBTSxFQUNOLG9CQUFvQixDQUNyQixDQUFDO1FBRUYsaURBQWlEO1FBQ2pELElBQUksQ0FBQyxZQUFZLEdBQUcscUJBQUssQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV6RCx5REFBeUQ7UUFDekQsd0VBQXdFO1FBQ3hFLElBQUksQ0FBQyxVQUFVLFNBQUcsQ0FBQyxPQUFPLENBQUMsMEJBQTBCLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxtQ0FBSSxLQUFLLENBQUM7UUFDbEYsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ25CLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDO1lBQ3pDLE1BQU0sV0FBVyxHQUFHO2dCQUNsQixHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsRUFBRTtnQkFDaEQsR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUM7Z0JBQzVFLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDO2dCQUM5RSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQzthQUM1RSxDQUFDO1lBQ0YsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO2dCQUNsQix1RUFBdUU7Z0JBQ3ZFLFdBQVcsQ0FBQyxPQUFPLENBQUMsK0JBQXdCLENBQUMsQ0FBQzthQUMvQztZQUNELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQztTQUM5QztRQUVEOzs7OztXQUtHO1FBQ0gsU0FBUyxhQUFhLENBQXlCLElBQWtDO1lBQy9FLE9BQU8sQ0FBQyxHQUFHLElBQU8sRUFBRSxFQUFFO2dCQUNwQixJQUFJO29CQUNGLE9BQU8sSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7aUJBQ3RCO2dCQUFDLE9BQU8sR0FBRyxFQUFFO29CQUNaLE1BQU0seUJBQXlCLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBRXhFLElBQUksQ0FBQyx5QkFBeUIsRUFBRTt3QkFDOUIsT0FBTyxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsSUFBSSxDQUFDLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxDQUFDO3FCQUN6RDtvQkFFRCxPQUFPLEVBQUUsQ0FBQztpQkFDWDtZQUNILENBQUMsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLHNCQUFzQjtRQUMvQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDNUUsQ0FBQztJQUVNLFdBQVcsQ0FBQyxPQUF3QjtRQUN6QyxNQUFNLFNBQVMsR0FBRyxJQUFJLHNCQUFXLENBQy9CLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUN6QixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUUsRUFDekMsT0FBTyxFQUNQLElBQUksQ0FBQyxPQUFPLENBQ2IsQ0FBQztRQUNGLE1BQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMvRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsd0JBQXdCLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztRQUN0RyxPQUFPLG1CQUFVLENBQUMsU0FBUyxFQUFFLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFTSxpQkFBaUI7UUFDdEIsTUFBTSxXQUFXLEdBQUcsSUFBSSx1Q0FBaUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDN0QsT0FBTyxXQUFXLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVNLGNBQWM7UUFDbkIsTUFBTSxPQUFPLEdBQUcsSUFBSSwyQ0FBdUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDL0QsTUFBTSxTQUFTLEdBQUcsSUFBSSxzQkFBVyxDQUMvQixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFDekIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLEVBQ3pDLE9BQU8sRUFDUCxJQUFJLENBQUMsT0FBTyxDQUNiLENBQUM7UUFDRixTQUFTLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDN0MsT0FBTyxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVELElBQVcsV0FBVztRQUNwQixPQUFPLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUM7SUFDckcsQ0FBQztDQUNGO0FBdEdELDhDQXNHQztBQUVEOztHQUVHO0FBQ0gsU0FBUyx3QkFBd0IsQ0FBQyxLQUErQixFQUFFLFlBQW1CO0lBQ3BGLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxTQUFTLElBQUksQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ3hILENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLHlCQUF5QixDQUFDLElBQW1CO0lBQzNELE9BQU87UUFDTCxPQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVEsS0FBSyxFQUFFLENBQUMsa0JBQWtCLENBQUMsS0FBSztRQUN0RCxvQkFBb0IsRUFBRSx3QkFBaUIsQ0FBQyxJQUFJLENBQUM7UUFDN0MsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDLG9DQUFvQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsU0FBUyxDQUFDO0tBQzdFLENBQUM7QUFDSixDQUFDO0FBTkQsOERBTUM7QUFFRCxNQUFNLFNBQVMsR0FBRztJQUNoQixtQkFBbUI7UUFDakIsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBQ0Qsb0JBQW9CLENBQUMsUUFBZ0I7UUFDbkMsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUNELFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7Q0FDRixDQUFDO0FBRUY7OztHQUdHO0FBQ0gsU0FBUyxhQUFhLENBQUMsQ0FBUztJQUM5QixPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2xDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7IGluc3BlY3QgfSBmcm9tICd1dGlsJztcblxuaW1wb3J0IHsgVEFSR0VUX0xBTkdVQUdFUywgVGFyZ2V0TGFuZ3VhZ2UgfSBmcm9tICcuL2xhbmd1YWdlcyc7XG5pbXBvcnQgeyBSZWNvcmRSZWZlcmVuY2VzVmlzaXRvciB9IGZyb20gJy4vbGFuZ3VhZ2VzL3JlY29yZC1yZWZlcmVuY2VzJztcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IHJlbmRlclRyZWUgfSBmcm9tICcuL28tdHJlZSc7XG5pbXBvcnQgeyBBc3RSZW5kZXJlciwgQXN0SGFuZGxlciwgQXN0UmVuZGVyZXJPcHRpb25zIH0gZnJvbSAnLi9yZW5kZXJlcic7XG5pbXBvcnQgeyBUeXBlU2NyaXB0U25pcHBldCwgY29tcGxldGVTb3VyY2UsIFNuaXBwZXRQYXJhbWV0ZXJzLCBmb3JtYXRMb2NhdGlvbiB9IGZyb20gJy4vc25pcHBldCc7XG5pbXBvcnQgeyBzbmlwcGV0S2V5IH0gZnJvbSAnLi90YWJsZXRzL2tleSc7XG5pbXBvcnQgeyBPUklHSU5BTF9TTklQUEVUX0tFWSB9IGZyb20gJy4vdGFibGV0cy9zY2hlbWEnO1xuaW1wb3J0IHsgVHJhbnNsYXRlZFNuaXBwZXQgfSBmcm9tICcuL3RhYmxldHMvdGFibGV0cyc7XG5pbXBvcnQgeyBTeW50YXhLaW5kQ291bnRlciB9IGZyb20gJy4vdHlwZXNjcmlwdC9zeW50YXgta2luZC1jb3VudGVyJztcbmltcG9ydCB7IFR5cGVTY3JpcHRDb21waWxlciwgQ29tcGlsYXRpb25SZXN1bHQgfSBmcm9tICcuL3R5cGVzY3JpcHQvdHMtY29tcGlsZXInO1xuaW1wb3J0IHsgU3BhbnMgfSBmcm9tICcuL3R5cGVzY3JpcHQvdmlzaWJsZS1zcGFucyc7XG5pbXBvcnQgeyBhbm5vdGF0ZVN0cmljdERpYWdub3N0aWMsIEZpbGUsIGhhc1N0cmljdEJyYW5kaW5nLCBta0RpY3QgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlVHlwZVNjcmlwdChcbiAgc291cmNlOiBGaWxlLFxuICB2aXNpdG9yOiBBc3RIYW5kbGVyPGFueT4sXG4gIG9wdGlvbnM6IFNuaXBwZXRUcmFuc2xhdG9yT3B0aW9ucyA9IHt9LFxuKTogVHJhbnNsYXRlUmVzdWx0IHtcbiAgY29uc3QgdHJhbnNsYXRvciA9IG5ldyBTbmlwcGV0VHJhbnNsYXRvcihcbiAgICB7IHZpc2libGVTb3VyY2U6IHNvdXJjZS5jb250ZW50cywgbG9jYXRpb246IHsgYXBpOiB7IGFwaTogJ2ZpbGUnLCBmaWxlTmFtZTogc291cmNlLmZpbGVOYW1lIH0gfSB9LFxuICAgIG9wdGlvbnMsXG4gICk7XG4gIGNvbnN0IHRyYW5zbGF0ZWQgPSB0cmFuc2xhdG9yLnJlbmRlclVzaW5nKHZpc2l0b3IpO1xuXG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRpb246IHRyYW5zbGF0ZWQsXG4gICAgZGlhZ25vc3RpY3M6IHRyYW5zbGF0b3IuZGlhZ25vc3RpY3MubWFwKHJvc2V0dGFEaWFnRnJvbVR5cGVzY3JpcHQpLFxuICB9O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBvbmUgb3IgbW9yZSBUeXBlU2NyaXB0IHNuaXBwZXRzIGludG8gb3RoZXIgbGFuZ3VhZ2VzXG4gKlxuICogQ2FuIGJlIGNvbmZpZ3VyZWQgdG8gZnVsbHkgdHlwZWNoZWNrIHRoZSBzYW1wbGVzLCBvciBwZXJmb3JtIG9ubHkgc3ludGFjdGljYWxcbiAqIHRyYW5zbGF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29tcGlsZXIgPSBuZXcgVHlwZVNjcmlwdENvbXBpbGVyKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbWVtYmVyLWFjY2Vzc2liaWxpdHlcbiAgI2RpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10gPSBbXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljczogYm9vbGVhbikge31cblxuICBwdWJsaWMgdHJhbnNsYXRlKHNuaXA6IFR5cGVTY3JpcHRTbmlwcGV0LCBsYW5ndWFnZXM6IHJlYWRvbmx5IFRhcmdldExhbmd1YWdlW10gPSBPYmplY3QudmFsdWVzKFRhcmdldExhbmd1YWdlKSkge1xuICAgIGxvZ2dpbmcuZGVidWcoYFRyYW5zbGF0aW5nICR7c25pcHBldEtleShzbmlwKX0gJHtpbnNwZWN0KHNuaXAucGFyYW1ldGVycyA/PyB7fSl9YCk7XG4gICAgY29uc3QgdHJhbnNsYXRvciA9IHRoaXMudHJhbnNsYXRvckZvcihzbmlwKTtcblxuICAgIGNvbnN0IHRyYW5zbGF0aW9ucyA9IG1rRGljdChcbiAgICAgIGxhbmd1YWdlcy5tYXAoKGxhbmcpID0+IHtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VDb252ZXJ0ZXJGYWN0b3J5ID0gVEFSR0VUX0xBTkdVQUdFU1tsYW5nXTtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlZCA9IHRyYW5zbGF0b3IucmVuZGVyVXNpbmcobGFuZ3VhZ2VDb252ZXJ0ZXJGYWN0b3J5LmNyZWF0ZVZpc2l0b3IoKSk7XG4gICAgICAgIHJldHVybiBbbGFuZywgeyBzb3VyY2U6IHRyYW5zbGF0ZWQsIHZlcnNpb246IGxhbmd1YWdlQ29udmVydGVyRmFjdG9yeS52ZXJzaW9uIH1dIGFzIGNvbnN0O1xuICAgICAgfSksXG4gICAgKTtcblxuICAgIGlmIChzbmlwLnBhcmFtZXRlcnM/LmluZnVzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy4jZGlhZ25vc3RpY3MucHVzaCguLi50cmFuc2xhdG9yLmRpYWdub3N0aWNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVHJhbnNsYXRlZFNuaXBwZXQuZnJvbVNjaGVtYSh7XG4gICAgICB0cmFuc2xhdGlvbnM6IHtcbiAgICAgICAgLi4udHJhbnNsYXRpb25zLFxuICAgICAgICBbT1JJR0lOQUxfU05JUFBFVF9LRVldOiB7IHNvdXJjZTogc25pcC52aXNpYmxlU291cmNlLCB2ZXJzaW9uOiAnMCcgfSxcbiAgICAgIH0sXG4gICAgICBsb2NhdGlvbjogc25pcC5sb2NhdGlvbixcbiAgICAgIGRpZENvbXBpbGU6IHRyYW5zbGF0b3IuZGlkU3VjY2Vzc2Z1bGx5Q29tcGlsZSxcbiAgICAgIGZxbnNSZWZlcmVuY2VkOiB0cmFuc2xhdG9yLmZxbnNSZWZlcmVuY2VkKCksXG4gICAgICBmdWxsU291cmNlOiBjb21wbGV0ZVNvdXJjZShzbmlwKSxcbiAgICAgIHN5bnRheEtpbmRDb3VudGVyOiB0cmFuc2xhdG9yLnN5bnRheEtpbmRDb3VudGVyKCksXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGRpYWdub3N0aWNzKCk6IHJlYWRvbmx5IFJvc2V0dGFEaWFnbm9zdGljW10ge1xuICAgIHJldHVybiB0cy5zb3J0QW5kRGVkdXBsaWNhdGVEaWFnbm9zdGljcyh0aGlzLiNkaWFnbm9zdGljcykubWFwKHJvc2V0dGFEaWFnRnJvbVR5cGVzY3JpcHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc25pcHBldCB0cmFuc2xhdG9yIGZvciB0aGUgZ2l2ZW4gc25pcHBldFxuICAgKlxuICAgKiBXZSB1c2VkIHRvIGNhY2hlIHRoZXNlLCBidXQgZWFjaCB0cmFuc2xhdG9yIGhvbGRzIG9uIHRvIHF1aXRlIGEgYml0IG9mIG1lbW9yeSxcbiAgICogc28gd2UgZG9uJ3QgZG8gdGhhdCBhbnltb3JlLlxuICAgKi9cbiAgcHVibGljIHRyYW5zbGF0b3JGb3Ioc25pcHBldDogVHlwZVNjcmlwdFNuaXBwZXQpIHtcbiAgICBjb25zdCB0cmFuc2xhdG9yID0gbmV3IFNuaXBwZXRUcmFuc2xhdG9yKHNuaXBwZXQsIHtcbiAgICAgIGNvbXBpbGVyOiB0aGlzLmNvbXBpbGVyLFxuICAgICAgaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3M6IHRoaXMuaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3MsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYW5zbGF0b3I7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbmlwcGV0VHJhbnNsYXRvck9wdGlvbnMgZXh0ZW5kcyBBc3RSZW5kZXJlck9wdGlvbnMge1xuICAvKipcbiAgICogUmUtdXNlIHRoZSBnaXZlbiBjb21waWxlciBpZiBnaXZlblxuICAgKi9cbiAgcmVhZG9ubHkgY29tcGlsZXI/OiBUeXBlU2NyaXB0Q29tcGlsZXI7XG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgY29tcGlsZXIgZXJyb3JzIGluIHJldHVybiBkaWFnbm9zdGljc1xuICAgKlxuICAgKiBJZiBmYWxzZSwgb25seSB0cmFuc2xhdGlvbiBkaWFnbm9zdGljcyB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3M/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0ZVJlc3VsdCB7XG4gIHRyYW5zbGF0aW9uOiBzdHJpbmc7XG4gIGRpYWdub3N0aWNzOiByZWFkb25seSBSb3NldHRhRGlhZ25vc3RpY1tdO1xufVxuXG4vKipcbiAqIEEgdHJhbnNsYXRpb24gb2YgYSBUeXBlU2NyaXB0IGRpYWdub3N0aWMgaW50byBhIGRhdGEtb25seSByZXByZXNlbnRhdGlvbiBmb3IgUm9zZXR0YVxuICpcbiAqIFdlIGNhbm5vdCB1c2UgdGhlIG9yaWdpbmFsIGB0cy5EaWFnbm9zdGljYCBzaW5jZSBpdCBob2xkcyBvbiB0byB3YXkgdG9vIG11Y2hcbiAqIHN0YXRlICh0aGUgc291cmNlIGZpbGUgYW5kIGJ5IGV4dGVuc2lvbiB0aGUgZW50aXJlIHBhcnNlIHRyZWUpLCB3aGljaCBncm93c1xuICogdG9vIGJpZyB0byBiZSBwcm9wZXJseSBzZXJpYWxpemVkIGJ5IGEgd29ya2VyIGFuZCBhbHNvIHRha2VzIHRvbyBtdWNoIG1lbW9yeS5cbiAqXG4gKiBSZWR1Y2UgaXQgZG93biB0byBvbmx5IHRoZSBpbmZvcm1hdGlvbiB3ZSBuZWVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvc2V0dGFEaWFnbm9zdGljIHtcbiAgLyoqXG4gICAqIElmIHRoaXMgaXMgYW4gZXJyb3IgZGlhZ25vc3RpYyBvciBub3RcbiAgICovXG4gIHJlYWRvbmx5IGlzRXJyb3I6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRoZSBkaWFnbm9zdGljIHdhcyBlbWl0dGVkIGZyb20gYW4gYXNzZW1ibHkgdGhhdCBoYXMgaXRzICdzdHJpY3QnIGZsYWcgc2V0XG4gICAqL1xuICByZWFkb25seSBpc0Zyb21TdHJpY3RBc3NlbWJseTogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdHRlZCBtZXNzYWdlLCByZWFkeSB0byBiZSBwcmludGVkICh3aWxsIGhhdmUgY29sb3JzIGFuZCBuZXdsaW5lcyBpbiBpdClcbiAgICpcbiAgICogRW5kcyBpbiBhIG5ld2xpbmUuXG4gICAqL1xuICByZWFkb25seSBmb3JtYXR0ZWRNZXNzYWdlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUm9zZXR0YURpYWdub3N0aWMoaXNFcnJvcjogYm9vbGVhbiwgZm9ybWF0dGVkTWVzc2FnZTogc3RyaW5nKTogUm9zZXR0YURpYWdub3N0aWMge1xuICByZXR1cm4geyBpc0Vycm9yLCBmb3JtYXR0ZWRNZXNzYWdlLCBpc0Zyb21TdHJpY3RBc3NlbWJseTogZmFsc2UgfTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBzaW5nbGUgVHlwZVNjcmlwdCBzbmlwcGV0XG4gKi9cbmV4cG9ydCBjbGFzcyBTbmlwcGV0VHJhbnNsYXRvciB7XG4gIHB1YmxpYyByZWFkb25seSB0cmFuc2xhdGVEaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdID0gW107XG4gIHB1YmxpYyByZWFkb25seSBjb21waWxlRGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IHZpc2libGVTcGFuczogU3BhbnM7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29tcGlsYXRpb24hOiBDb21waWxhdGlvblJlc3VsdDtcbiAgcHJpdmF0ZSByZWFkb25seSB0cnlDb21waWxlOiBib29sZWFuO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzbmlwcGV0OiBUeXBlU2NyaXB0U25pcHBldCwgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBTbmlwcGV0VHJhbnNsYXRvck9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbXBpbGVyID0gb3B0aW9ucy5jb21waWxlciA/PyBuZXcgVHlwZVNjcmlwdENvbXBpbGVyKCk7XG4gICAgY29uc3Qgc291cmNlID0gY29tcGxldGVTb3VyY2Uoc25pcHBldCk7XG4gICAgY29uc3QgZmFrZUN1cnJlbnREaXJlY3RvcnkgPVxuICAgICAgc25pcHBldC5wYXJhbWV0ZXJzPy5bU25pcHBldFBhcmFtZXRlcnMuJENPTVBJTEFUSU9OX0RJUkVDVE9SWV0gPz9cbiAgICAgIHNuaXBwZXQucGFyYW1ldGVycz8uW1NuaXBwZXRQYXJhbWV0ZXJzLiRQUk9KRUNUX0RJUkVDVE9SWV07XG4gICAgdGhpcy5jb21waWxhdGlvbiA9IGNvbXBpbGVyLmNvbXBpbGVJbk1lbW9yeShcbiAgICAgIHJlbW92ZVNsYXNoZXMoZm9ybWF0TG9jYXRpb24oc25pcHBldC5sb2NhdGlvbikpLFxuICAgICAgc291cmNlLFxuICAgICAgZmFrZUN1cnJlbnREaXJlY3RvcnksXG4gICAgKTtcblxuICAgIC8vIFJlc3BlY3QgJy8vLyAhaGlkZScgYW5kICcvLy8gIXNob3cnIGRpcmVjdGl2ZXNcbiAgICB0aGlzLnZpc2libGVTcGFucyA9IFNwYW5zLnZpc2libGVTcGFuc0Zyb21Tb3VyY2Uoc291cmNlKTtcblxuICAgIC8vIFRoaXMgbWFrZXMgaXQgYWJvdXQgNXggc2xvd2VyLCBzbyBvbmx5IGRvIGl0IG9uIGRlbWFuZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgIHRoaXMudHJ5Q29tcGlsZSA9IChvcHRpb25zLmluY2x1ZGVDb21waWxlckRpYWdub3N0aWNzIHx8IHNuaXBwZXQuc3RyaWN0KSA/PyBmYWxzZTtcbiAgICBpZiAodGhpcy50cnlDb21waWxlKSB7XG4gICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5jb21waWxhdGlvbi5wcm9ncmFtO1xuICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSBbXG4gICAgICAgIC4uLm5ldmVyVGhyb3dpbmcocHJvZ3JhbS5nZXRHbG9iYWxEaWFnbm9zdGljcykoKSxcbiAgICAgICAgLi4ubmV2ZXJUaHJvd2luZyhwcm9ncmFtLmdldFN5bnRhY3RpY0RpYWdub3N0aWNzKSh0aGlzLmNvbXBpbGF0aW9uLnJvb3RGaWxlKSxcbiAgICAgICAgLi4ubmV2ZXJUaHJvd2luZyhwcm9ncmFtLmdldERlY2xhcmF0aW9uRGlhZ25vc3RpY3MpKHRoaXMuY29tcGlsYXRpb24ucm9vdEZpbGUpLFxuICAgICAgICAuLi5uZXZlclRocm93aW5nKHByb2dyYW0uZ2V0U2VtYW50aWNEaWFnbm9zdGljcykodGhpcy5jb21waWxhdGlvbi5yb290RmlsZSksXG4gICAgICBdO1xuICAgICAgaWYgKHNuaXBwZXQuc3RyaWN0KSB7XG4gICAgICAgIC8vIEluIGEgc3RyaWN0IGFzc2VtYmx5LCBzbyB3ZSdsbCBuZWVkIHRvIGJyYW5kIGFsbCBkaWFnbm9zdGljcyBoZXJlLi4uXG4gICAgICAgIGRpYWdub3N0aWNzLmZvckVhY2goYW5ub3RhdGVTdHJpY3REaWFnbm9zdGljKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29tcGlsZURpYWdub3N0aWNzLnB1c2goLi4uZGlhZ25vc3RpY3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVyY2VwdHMgYWxsIGV4Y2VwdGlvbnMgdGhyb3duIGJ5IHRoZSB3cmFwcGVkIGNhbGwsIGFuZCBsb2dzIHRoZW0gdG9cbiAgICAgKiBjb25zb2xlLmVycm9yIGluc3RlYWQgb2YgcmUtdGhyb3dpbmcsIHRoZW4gcmV0dXJucyBhbiBlbXB0eSBhcnJheS4gVGhpc1xuICAgICAqIGlzIGhlcmUgdG8gYXZvaWQgY29tcGlsZXIgY3Jhc2hlcyBkdWUgdG8gYnJva2VuIGNvZGUgZXhhbXBsZXMgdGhhdCBjYXVzZVxuICAgICAqIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIHRvIGhpdCBhIFwiRGVidWcgRmFpbHVyZVwiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5ldmVyVGhyb3dpbmc8QSBleHRlbmRzIHVua25vd25bXSwgUj4oY2FsbDogKC4uLmFyZ3M6IEEpID0+IHJlYWRvbmx5IFJbXSk6ICguLi5hcmdzOiBBKSA9PiByZWFkb25seSBSW10ge1xuICAgICAgcmV0dXJuICguLi5hcmdzOiBBKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGwoLi4uYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnN0IGlzRXhwZWN0ZWRUeXBlc2NyaXB0RXJyb3IgPSBlcnIubWVzc2FnZS5pbmNsdWRlcygnRGVidWcgRmFpbHVyZScpO1xuXG4gICAgICAgICAgaWYgKCFpc0V4cGVjdGVkVHlwZXNjcmlwdEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAke2NhbGwubmFtZX06ICR7ZXJyfWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaWYgY29tcGlsYXRpb24gd2FzIGF0dGVtcHRlZCwgYW5kIHVuZGVmaW5lZCBpZiBpdCB3YXMgbm90LlxuICAgKi9cbiAgcHVibGljIGdldCBkaWRTdWNjZXNzZnVsbHlDb21waWxlKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUNvbXBpbGUgPyB0aGlzLmNvbXBpbGVEaWFnbm9zdGljcy5sZW5ndGggPT09IDAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyVXNpbmcodmlzaXRvcjogQXN0SGFuZGxlcjxhbnk+KSB7XG4gICAgY29uc3QgY29udmVydGVyID0gbmV3IEFzdFJlbmRlcmVyKFxuICAgICAgdGhpcy5jb21waWxhdGlvbi5yb290RmlsZSxcbiAgICAgIHRoaXMuY29tcGlsYXRpb24ucHJvZ3JhbS5nZXRUeXBlQ2hlY2tlcigpLFxuICAgICAgdmlzaXRvcixcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICApO1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IGNvbnZlcnRlci5jb252ZXJ0KHRoaXMuY29tcGlsYXRpb24ucm9vdEZpbGUpO1xuICAgIHRoaXMudHJhbnNsYXRlRGlhZ25vc3RpY3MucHVzaCguLi5maWx0ZXJWaXNpYmxlRGlhZ25vc3RpY3MoY29udmVydGVyLmRpYWdub3N0aWNzLCB0aGlzLnZpc2libGVTcGFucykpO1xuICAgIHJldHVybiByZW5kZXJUcmVlKGNvbnZlcnRlZCwgeyB2aXNpYmxlU3BhbnM6IHRoaXMudmlzaWJsZVNwYW5zIH0pO1xuICB9XG5cbiAgcHVibGljIHN5bnRheEtpbmRDb3VudGVyKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIGNvbnN0IGtpbmRDb3VudGVyID0gbmV3IFN5bnRheEtpbmRDb3VudGVyKHRoaXMudmlzaWJsZVNwYW5zKTtcbiAgICByZXR1cm4ga2luZENvdW50ZXIuY291bnRLaW5kcyh0aGlzLmNvbXBpbGF0aW9uLnJvb3RGaWxlKTtcbiAgfVxuXG4gIHB1YmxpYyBmcW5zUmVmZXJlbmNlZCgpIHtcbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IFJlY29yZFJlZmVyZW5jZXNWaXNpdG9yKHRoaXMudmlzaWJsZVNwYW5zKTtcbiAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgQXN0UmVuZGVyZXIoXG4gICAgICB0aGlzLmNvbXBpbGF0aW9uLnJvb3RGaWxlLFxuICAgICAgdGhpcy5jb21waWxhdGlvbi5wcm9ncmFtLmdldFR5cGVDaGVja2VyKCksXG4gICAgICB2aXNpdG9yLFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICk7XG4gICAgY29udmVydGVyLmNvbnZlcnQodGhpcy5jb21waWxhdGlvbi5yb290RmlsZSk7XG4gICAgcmV0dXJuIHZpc2l0b3IuZnFuc1JlZmVyZW5jZWQoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGlhZ25vc3RpY3MoKTogcmVhZG9ubHkgdHMuRGlhZ25vc3RpY1tdIHtcbiAgICByZXR1cm4gdHMuc29ydEFuZERlZHVwbGljYXRlRGlhZ25vc3RpY3ModGhpcy5jb21waWxlRGlhZ25vc3RpY3MuY29uY2F0KHRoaXMudHJhbnNsYXRlRGlhZ25vc3RpY3MpKTtcbiAgfVxufVxuXG4vKipcbiAqIEhpZGUgZGlhZ25vc3RpY3MgdGhhdCBhcmUgcm9zZXR0YS1zb3VyY2VkIGlmIHRoZXkgYXJlIHJlcG9ydGVkIGFnYWluc3QgYSBub24tdmlzaWJsZSBzcGFuXG4gKi9cbmZ1bmN0aW9uIGZpbHRlclZpc2libGVEaWFnbm9zdGljcyhkaWFnczogcmVhZG9ubHkgdHMuRGlhZ25vc3RpY1tdLCB2aXNpYmxlU3BhbnM6IFNwYW5zKTogdHMuRGlhZ25vc3RpY1tdIHtcbiAgcmV0dXJuIGRpYWdzLmZpbHRlcigoZCkgPT4gZC5zb3VyY2UgIT09ICdyb3NldHRhJyB8fCBkLnN0YXJ0ID09PSB1bmRlZmluZWQgfHwgdmlzaWJsZVNwYW5zLmNvbnRhaW5zUG9zaXRpb24oZC5zdGFydCkpO1xufVxuXG4vKipcbiAqIFR1cm4gVHlwZVNjcmlwdCBkaWFnbm9zdGljcyBpbnRvIFJvc2V0dGEgZGlhZ25vc3RpY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvc2V0dGFEaWFnRnJvbVR5cGVzY3JpcHQoZGlhZzogdHMuRGlhZ25vc3RpYyk6IFJvc2V0dGFEaWFnbm9zdGljIHtcbiAgcmV0dXJuIHtcbiAgICBpc0Vycm9yOiBkaWFnLmNhdGVnb3J5ID09PSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IsXG4gICAgaXNGcm9tU3RyaWN0QXNzZW1ibHk6IGhhc1N0cmljdEJyYW5kaW5nKGRpYWcpLFxuICAgIGZvcm1hdHRlZE1lc3NhZ2U6IHRzLmZvcm1hdERpYWdub3N0aWNzV2l0aENvbG9yQW5kQ29udGV4dChbZGlhZ10sIERJQUdfSE9TVCksXG4gIH07XG59XG5cbmNvbnN0IERJQUdfSE9TVCA9IHtcbiAgZ2V0Q3VycmVudERpcmVjdG9yeSgpIHtcbiAgICByZXR1cm4gJy4nO1xuICB9LFxuICBnZXRDYW5vbmljYWxGaWxlTmFtZShmaWxlTmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZpbGVOYW1lO1xuICB9LFxuICBnZXROZXdMaW5lKCkge1xuICAgIHJldHVybiAnXFxuJztcbiAgfSxcbn07XG5cbi8qKlxuICogUmVtb3ZlIHNsYXNoZXMgZnJvbSBhIFwid2hlcmVcIiBkZXNjcmlwdGlvbiwgYXMgdGhlIFRTIGNvbXBpbGVyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgZGlyZWN0b3J5XG4gKiBhbmQgd2UgY2FuJ3QgaGF2ZSB0aGF0IGZvciBjb21waWxpbmcgbGl0ZXJhdGUgZmlsZXNcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU2xhc2hlcyh4OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHgucmVwbGFjZSgvXFwvfFxcXFwvZywgJy4nKTtcbn1cbiJdfQ==