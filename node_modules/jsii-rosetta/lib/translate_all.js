"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateAll = void 0;
const os = require("os");
const path = require("path");
const workerpool = require("workerpool");
const logging = require("./logging");
const tablets_1 = require("./tablets/tablets");
/**
 * Divide the work evenly over all processors by running 'translate_all_worker' in Worker Threads, then combine results
 *
 * The workers are fed small queues of work each. We used to divide the entire queue into N
 * but since the work is divided unevenly that led to some workers stopping early, idling while
 * waiting for more work.
 *
 * Never include 'translate_all_worker' directly, only do TypeScript type references (so that in
 * the script we may assume that 'worker_threads' successfully imports).
 */
async function translateAll(snippets, includeCompilerDiagnostics) {
    var _a;
    // Use about half the advertised cores because hyperthreading doesn't seem to
    // help that much, or we become I/O-bound at some point. On my machine, using
    // more than half the cores actually makes it slower.
    // Cap to a reasonable top-level limit to prevent thrash on machines with many, many cores.
    const maxWorkers = parseInt((_a = process.env.JSII_ROSETTA_MAX_WORKER_COUNT) !== null && _a !== void 0 ? _a : '16');
    const N = Math.min(maxWorkers, Math.max(1, Math.ceil(os.cpus().length / 2)));
    const snippetArr = Array.from(snippets);
    logging.info(`Translating ${snippetArr.length} snippets using ${N} workers`);
    const pool = workerpool.pool(path.join(__dirname, 'translate_all_worker.js'), {
        maxWorkers: N,
    });
    try {
        const requests = batchSnippets(snippetArr, includeCompilerDiagnostics);
        const responses = await Promise.all(requests.map((request) => pool.exec('translateBatch', [request])));
        const diagnostics = new Array();
        const translatedSnippets = new Array();
        // Combine results
        for (const response of responses) {
            diagnostics.push(...response.diagnostics);
            translatedSnippets.push(...response.translatedSchemas.map(tablets_1.TranslatedSnippet.fromSchema));
        }
        return { diagnostics, translatedSnippets };
    }
    finally {
        // Not waiting on purpose
        void pool.terminate();
    }
}
exports.translateAll = translateAll;
function batchSnippets(snippets, includeCompilerDiagnostics, batchSize = 10) {
    const ret = [];
    for (let i = 0; i < snippets.length; i += batchSize) {
        ret.push({
            snippets: snippets.slice(i, i + batchSize),
            includeCompilerDiagnostics,
        });
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlX2FsbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRyYW5zbGF0ZV9hbGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3Qix5Q0FBeUM7QUFFekMscUNBQXFDO0FBRXJDLCtDQUFzRDtBQUl0RDs7Ozs7Ozs7O0dBU0c7QUFDSSxLQUFLLFVBQVUsWUFBWSxDQUNoQyxRQUE2QixFQUM3QiwwQkFBbUM7O0lBRW5DLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UscURBQXFEO0lBQ3JELDJGQUEyRjtJQUMzRixNQUFNLFVBQVUsR0FBRyxRQUFRLE9BQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsbUNBQUksSUFBSSxDQUFDLENBQUM7SUFDL0UsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3RSxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxVQUFVLENBQUMsTUFBTSxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUU3RSxNQUFNLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLHlCQUF5QixDQUFDLEVBQUU7UUFDNUUsVUFBVSxFQUFFLENBQUM7S0FDZCxDQUFDLENBQUM7SUFFSCxJQUFJO1FBQ0YsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLFVBQVUsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO1FBRXZFLE1BQU0sU0FBUyxHQUE2QixNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQzNELFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQ2xFLENBQUM7UUFFRixNQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssRUFBcUIsQ0FBQztRQUNuRCxNQUFNLGtCQUFrQixHQUFHLElBQUksS0FBSyxFQUFxQixDQUFDO1FBRTFELGtCQUFrQjtRQUNsQixLQUFLLE1BQU0sUUFBUSxJQUFJLFNBQVMsRUFBRTtZQUNoQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsMkJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUMxRjtRQUNELE9BQU8sRUFBRSxXQUFXLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQztLQUM1QztZQUFTO1FBQ1IseUJBQXlCO1FBQ3pCLEtBQUssSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0tBQ3ZCO0FBQ0gsQ0FBQztBQXJDRCxvQ0FxQ0M7QUFFRCxTQUFTLGFBQWEsQ0FDcEIsUUFBNkIsRUFDN0IsMEJBQW1DLEVBQ25DLFNBQVMsR0FBRyxFQUFFO0lBRWQsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBRWYsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLFNBQVMsRUFBRTtRQUNuRCxHQUFHLENBQUMsSUFBSSxDQUFDO1lBQ1AsUUFBUSxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUM7WUFDMUMsMEJBQTBCO1NBQzNCLENBQUMsQ0FBQztLQUNKO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHdvcmtlcnBvb2wgZnJvbSAnd29ya2VycG9vbCc7XG5cbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IFR5cGVTY3JpcHRTbmlwcGV0IH0gZnJvbSAnLi9zbmlwcGV0JztcbmltcG9ydCB7IFRyYW5zbGF0ZWRTbmlwcGV0IH0gZnJvbSAnLi90YWJsZXRzL3RhYmxldHMnO1xuaW1wb3J0IHsgUm9zZXR0YURpYWdub3N0aWMgfSBmcm9tICcuL3RyYW5zbGF0ZSc7XG5pbXBvcnQgdHlwZSB7IFRyYW5zbGF0ZUJhdGNoUmVxdWVzdCwgVHJhbnNsYXRlQmF0Y2hSZXNwb25zZSB9IGZyb20gJy4vdHJhbnNsYXRlX2FsbF93b3JrZXInO1xuXG4vKipcbiAqIERpdmlkZSB0aGUgd29yayBldmVubHkgb3ZlciBhbGwgcHJvY2Vzc29ycyBieSBydW5uaW5nICd0cmFuc2xhdGVfYWxsX3dvcmtlcicgaW4gV29ya2VyIFRocmVhZHMsIHRoZW4gY29tYmluZSByZXN1bHRzXG4gKlxuICogVGhlIHdvcmtlcnMgYXJlIGZlZCBzbWFsbCBxdWV1ZXMgb2Ygd29yayBlYWNoLiBXZSB1c2VkIHRvIGRpdmlkZSB0aGUgZW50aXJlIHF1ZXVlIGludG8gTlxuICogYnV0IHNpbmNlIHRoZSB3b3JrIGlzIGRpdmlkZWQgdW5ldmVubHkgdGhhdCBsZWQgdG8gc29tZSB3b3JrZXJzIHN0b3BwaW5nIGVhcmx5LCBpZGxpbmcgd2hpbGVcbiAqIHdhaXRpbmcgZm9yIG1vcmUgd29yay5cbiAqXG4gKiBOZXZlciBpbmNsdWRlICd0cmFuc2xhdGVfYWxsX3dvcmtlcicgZGlyZWN0bHksIG9ubHkgZG8gVHlwZVNjcmlwdCB0eXBlIHJlZmVyZW5jZXMgKHNvIHRoYXQgaW5cbiAqIHRoZSBzY3JpcHQgd2UgbWF5IGFzc3VtZSB0aGF0ICd3b3JrZXJfdGhyZWFkcycgc3VjY2Vzc2Z1bGx5IGltcG9ydHMpLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhbnNsYXRlQWxsKFxuICBzbmlwcGV0czogVHlwZVNjcmlwdFNuaXBwZXRbXSxcbiAgaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3M6IGJvb2xlYW4sXG4pOiBQcm9taXNlPFRyYW5zbGF0ZUFsbFJlc3VsdD4ge1xuICAvLyBVc2UgYWJvdXQgaGFsZiB0aGUgYWR2ZXJ0aXNlZCBjb3JlcyBiZWNhdXNlIGh5cGVydGhyZWFkaW5nIGRvZXNuJ3Qgc2VlbSB0b1xuICAvLyBoZWxwIHRoYXQgbXVjaCwgb3Igd2UgYmVjb21lIEkvTy1ib3VuZCBhdCBzb21lIHBvaW50LiBPbiBteSBtYWNoaW5lLCB1c2luZ1xuICAvLyBtb3JlIHRoYW4gaGFsZiB0aGUgY29yZXMgYWN0dWFsbHkgbWFrZXMgaXQgc2xvd2VyLlxuICAvLyBDYXAgdG8gYSByZWFzb25hYmxlIHRvcC1sZXZlbCBsaW1pdCB0byBwcmV2ZW50IHRocmFzaCBvbiBtYWNoaW5lcyB3aXRoIG1hbnksIG1hbnkgY29yZXMuXG4gIGNvbnN0IG1heFdvcmtlcnMgPSBwYXJzZUludChwcm9jZXNzLmVudi5KU0lJX1JPU0VUVEFfTUFYX1dPUktFUl9DT1VOVCA/PyAnMTYnKTtcbiAgY29uc3QgTiA9IE1hdGgubWluKG1heFdvcmtlcnMsIE1hdGgubWF4KDEsIE1hdGguY2VpbChvcy5jcHVzKCkubGVuZ3RoIC8gMikpKTtcbiAgY29uc3Qgc25pcHBldEFyciA9IEFycmF5LmZyb20oc25pcHBldHMpO1xuICBsb2dnaW5nLmluZm8oYFRyYW5zbGF0aW5nICR7c25pcHBldEFyci5sZW5ndGh9IHNuaXBwZXRzIHVzaW5nICR7Tn0gd29ya2Vyc2ApO1xuXG4gIGNvbnN0IHBvb2wgPSB3b3JrZXJwb29sLnBvb2wocGF0aC5qb2luKF9fZGlybmFtZSwgJ3RyYW5zbGF0ZV9hbGxfd29ya2VyLmpzJyksIHtcbiAgICBtYXhXb3JrZXJzOiBOLFxuICB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gYmF0Y2hTbmlwcGV0cyhzbmlwcGV0QXJyLCBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljcyk7XG5cbiAgICBjb25zdCByZXNwb25zZXM6IFRyYW5zbGF0ZUJhdGNoUmVzcG9uc2VbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgcmVxdWVzdHMubWFwKChyZXF1ZXN0KSA9PiBwb29sLmV4ZWMoJ3RyYW5zbGF0ZUJhdGNoJywgW3JlcXVlc3RdKSksXG4gICAgKTtcblxuICAgIGNvbnN0IGRpYWdub3N0aWNzID0gbmV3IEFycmF5PFJvc2V0dGFEaWFnbm9zdGljPigpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZWRTbmlwcGV0cyA9IG5ldyBBcnJheTxUcmFuc2xhdGVkU25pcHBldD4oKTtcblxuICAgIC8vIENvbWJpbmUgcmVzdWx0c1xuICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICBkaWFnbm9zdGljcy5wdXNoKC4uLnJlc3BvbnNlLmRpYWdub3N0aWNzKTtcbiAgICAgIHRyYW5zbGF0ZWRTbmlwcGV0cy5wdXNoKC4uLnJlc3BvbnNlLnRyYW5zbGF0ZWRTY2hlbWFzLm1hcChUcmFuc2xhdGVkU25pcHBldC5mcm9tU2NoZW1hKSk7XG4gICAgfVxuICAgIHJldHVybiB7IGRpYWdub3N0aWNzLCB0cmFuc2xhdGVkU25pcHBldHMgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBOb3Qgd2FpdGluZyBvbiBwdXJwb3NlXG4gICAgdm9pZCBwb29sLnRlcm1pbmF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhdGNoU25pcHBldHMoXG4gIHNuaXBwZXRzOiBUeXBlU2NyaXB0U25pcHBldFtdLFxuICBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljczogYm9vbGVhbixcbiAgYmF0Y2hTaXplID0gMTAsXG4pOiBUcmFuc2xhdGVCYXRjaFJlcXVlc3RbXSB7XG4gIGNvbnN0IHJldCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc25pcHBldHMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xuICAgIHJldC5wdXNoKHtcbiAgICAgIHNuaXBwZXRzOiBzbmlwcGV0cy5zbGljZShpLCBpICsgYmF0Y2hTaXplKSxcbiAgICAgIGluY2x1ZGVDb21waWxlckRpYWdub3N0aWNzLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGVBbGxSZXN1bHQge1xuICB0cmFuc2xhdGVkU25pcHBldHM6IFRyYW5zbGF0ZWRTbmlwcGV0W107XG4gIGRpYWdub3N0aWNzOiBSb3NldHRhRGlhZ25vc3RpY1tdO1xufVxuIl19