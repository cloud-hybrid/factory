"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("@jsii/check-node/run");
const fs = require("fs-extra");
const path = require("path");
const yargs = require("yargs");
const lib_1 = require("../lib");
const convert_1 = require("../lib/commands/convert");
const extract_1 = require("../lib/commands/extract");
const infuse_1 = require("../lib/commands/infuse");
const read_1 = require("../lib/commands/read");
const transliterate_1 = require("../lib/commands/transliterate");
const trim_cache_1 = require("../lib/commands/trim-cache");
const languages_1 = require("../lib/languages");
const python_1 = require("../lib/languages/python");
const visualize_1 = require("../lib/languages/visualize");
const logging = require("../lib/logging");
const util_1 = require("../lib/util");
function main() {
    const argv = yargs
        .usage('$0 <cmd> [args]')
        .option('verbose', {
        alias: 'v',
        type: 'boolean',
        desc: 'Increase logging verbosity',
        count: true,
        default: 0,
    })
        .command('snippet FILE', 'Translate a single snippet', (command) => command
        .positional('FILE', {
        type: 'string',
        describe: 'The file to translate (leave out for stdin)',
    })
        .option('python', {
        alias: 'p',
        boolean: true,
        description: 'Translate snippets to Python',
    }), wrapHandler(async (args) => {
        var _a;
        const result = lib_1.translateTypeScript(await makeFileSource((_a = args.FILE) !== null && _a !== void 0 ? _a : '-', 'stdin.ts'), makeVisitor(args));
        handleSingleResult(result);
    }))
        .command('markdown FILE', 'Translate a MarkDown file', (command) => command
        .positional('FILE', {
        type: 'string',
        describe: 'The file to translate (leave out for stdin)',
    })
        .option('python', {
        alias: 'p',
        boolean: true,
        description: 'Translate snippets to Python',
    }), wrapHandler(async (args) => {
        var _a;
        const result = convert_1.translateMarkdown(await makeFileSource((_a = args.FILE) !== null && _a !== void 0 ? _a : '-', 'stdin.md'), makeVisitor(args));
        handleSingleResult(result);
    }))
        .command('infuse [ASSEMBLY..]', '(EXPERIMENTAL) mutates one or more assemblies by adding documentation examples to top-level types', (command) => command
        .positional('ASSEMBLY', {
        type: 'string',
        string: true,
        default: new Array(),
        describe: 'Assembly or directory to mutate',
    })
        .option('log-file', {
        alias: 'l',
        type: 'string',
        describe: 'Output file to store logging results. Ignored if -log is not true',
        default: infuse_1.DEFAULT_INFUSION_RESULTS_NAME,
    })
        .option('cache-from', {
        alias: 'C',
        type: 'string',
        // eslint-disable-next-line prettier/prettier
        describe: 'Reuse translations from the given tablet file if the snippet and type definitions did not change',
        requiresArg: true,
        default: undefined,
    })
        .option('cache-to', {
        alias: 'o',
        type: 'string',
        describe: 'Append all translated snippets to the given tablet file',
        requiresArg: true,
        default: undefined,
    })
        .option('cache', {
        alias: 'k',
        type: 'string',
        describe: 'Alias for --cache-from and --cache-to together',
        requiresArg: true,
        default: undefined,
    })
        .conflicts('cache', 'cache-from')
        .conflicts('cache', 'cache-to'), wrapHandler(async (args) => {
        var _a, _b;
        const absAssemblies = (args.ASSEMBLY.length > 0 ? args.ASSEMBLY : ['.']).map((x) => path.resolve(x));
        const absCacheFrom = util_1.fmap((_a = args.cache) !== null && _a !== void 0 ? _a : args['cache-from'], path.resolve);
        const absCacheTo = util_1.fmap((_b = args.cache) !== null && _b !== void 0 ? _b : args['cache-to'], path.resolve);
        const result = await infuse_1.infuse(absAssemblies, {
            logFile: args['log-file'],
            cacheToFile: absCacheTo,
            cacheFromFile: absCacheFrom,
        });
        let totalTypes = 0;
        let insertedExamples = 0;
        for (const [directory, map] of Object.entries(result.coverageResults)) {
            const commonName = directory.split('/').pop();
            const newCoverage = roundPercentage(map.typesWithInsertedExamples / map.types);
            process.stdout.write(`${commonName}: Added ${map.typesWithInsertedExamples} examples to ${map.types} types.\n`);
            process.stdout.write(`${commonName}: New coverage: ${newCoverage}%.\n`);
            insertedExamples += map.typesWithInsertedExamples;
            totalTypes += map.types;
        }
        const newCoverage = roundPercentage(insertedExamples / totalTypes);
        process.stdout.write(`\n\nFinal Stats:\nNew coverage: ${newCoverage}%.\n`);
    }))
        .command(['extract [ASSEMBLY..]', '$0 [ASSEMBLY..]'], 'Extract code snippets from one or more assemblies into language tablets', (command) => command
        .positional('ASSEMBLY', {
        type: 'string',
        string: true,
        default: new Array(),
        describe: 'Assembly or directory to extract from',
    })
        .option('output', {
        type: 'string',
        describe: 'Additional output file where to store translated samples (deprecated, alias for --cache-to)',
        requiresArg: true,
        default: undefined,
    })
        .option('compile', {
        alias: 'c',
        type: 'boolean',
        describe: 'Try compiling (on by default, use --no-compile to switch off)',
        default: true,
    })
        .option('directory', {
        alias: 'd',
        type: 'string',
        describe: 'Working directory (for require() etc)',
    })
        .option('include', {
        alias: 'i',
        type: 'array',
        describe: 'Extract only snippets with given ids',
        default: new Array(),
    })
        .option('infuse', {
        type: 'boolean',
        describe: 'bundle this command with the infuse command',
        default: false,
    })
        .option('fail', {
        alias: 'f',
        type: 'boolean',
        describe: 'Fail if there are compilation errors',
        default: false,
    })
        .option('validate-assemblies', {
        type: 'boolean',
        describe: 'Whether to validate loaded assemblies or not (this can be slow)',
        default: false,
    })
        .option('cache-from', {
        alias: 'C',
        type: 'string',
        // eslint-disable-next-line prettier/prettier
        describe: 'Reuse translations from the given tablet file if the snippet and type definitions did not change',
        requiresArg: true,
        default: undefined,
    })
        .option('cache-to', {
        alias: 'o',
        type: 'string',
        describe: 'Append all translated snippets to the given tablet file',
        requiresArg: true,
        default: undefined,
    })
        .conflicts('cache-to', 'output')
        .option('cache', {
        alias: 'k',
        type: 'string',
        describe: 'Alias for --cache-from and --cache-to together',
        requiresArg: true,
        default: undefined,
    })
        .conflicts('cache', 'cache-from')
        .conflicts('cache', 'cache-to')
        .option('trim-cache', {
        alias: 'T',
        type: 'boolean',
        describe: 'Remove translations that are not referenced by any of the assemblies anymore from the cache',
    })
        .option('strict', {
        alias: 'S',
        type: 'boolean',
        describe: 'Require all code samples compile, and fail if one does not. Strict mode always enables --compile and --fail',
        default: false,
    }), wrapHandler(async (args) => {
        var _a, _b, _c;
        // `--strict` is short for `--compile --fail`, and we'll override those even if they're set to `false`, such as
        // using `--no-(compile|fail)`, because yargs does not quite give us a better option that does not hurt CX.
        if (args.strict) {
            args.compile = args.c = true;
            args.fail = args.f = true;
        }
        // Easiest way to get a fixed working directory (for sources) in is to
        // chdir, since underneath the in-memory layer we're using a regular TS
        // compilerhost. Have to make all file references absolute before we chdir
        // though.
        const absAssemblies = (args.ASSEMBLY.length > 0 ? args.ASSEMBLY : ['.']).map((x) => path.resolve(x));
        const absCacheFrom = util_1.fmap((_a = args.cache) !== null && _a !== void 0 ? _a : args['cache-from'], path.resolve);
        const absCacheTo = util_1.fmap((_c = (_b = args.cache) !== null && _b !== void 0 ? _b : args['cache-to']) !== null && _c !== void 0 ? _c : args.output, path.resolve);
        if (args.directory) {
            process.chdir(args.directory);
        }
        const extractOptions = {
            includeCompilerDiagnostics: !!args.compile,
            validateAssemblies: args['validate-assemblies'],
            only: args.include,
            cacheFromFile: absCacheFrom,
            cacheToFile: absCacheTo,
            trimCache: args['trim-cache'],
        };
        const result = args.infuse
            ? await extract_1.extractAndInfuse(absAssemblies, extractOptions)
            : await extract_1.extractSnippets(absAssemblies, extractOptions);
        handleDiagnostics(result.diagnostics, args.fail, result.tablet.count);
    }))
        .command('transliterate [ASSEMBLY..]', '(EXPERIMENTAL) Transliterates the designated assemblies', (command) => command
        .positional('ASSEMBLY', {
        type: 'string',
        string: true,
        default: new Array(),
        required: true,
        describe: 'Assembly to transliterate',
    })
        .option('language', {
        alias: 'l',
        type: 'string',
        string: true,
        default: new Array(),
        describe: 'Language ID to transliterate to',
    })
        .options('strict', {
        alias: 's',
        conflicts: 'loose',
        describe: 'Fail if an example that needs live transliteration fails to compile (which could cause incorrect transpilation results)',
        type: 'boolean',
    })
        .options('loose', {
        alias: 'l',
        conflicts: 'strict',
        describe: 'Ignore missing fixtures and literate markdown files instead of failing',
        type: 'boolean',
    })
        .option('tablet', {
        alias: 't',
        type: 'string',
        describe: 'Language tablet containing pre-translated code examples to use (these are generated by the `extract` command)',
    }), wrapHandler((args) => {
        const assemblies = (args.ASSEMBLY.length > 0 ? args.ASSEMBLY : ['.']).map((dir) => path.resolve(process.cwd(), dir));
        const languages = args.language.length > 0
            ? args.language.map((lang) => {
                var _a;
                const target = (_a = Object.entries(languages_1.TargetLanguage).find(([k]) => k === lang)) === null || _a === void 0 ? void 0 : _a[1];
                if (target == null) {
                    throw new Error(`Unknown target language: ${lang}. Expected one of ${Object.keys(languages_1.TargetLanguage).join(', ')}`);
                }
                return target;
            })
            : Object.values(languages_1.TargetLanguage);
        return transliterate_1.transliterateAssembly(assemblies, languages, args);
    }))
        .command('trim-cache <TABLET> [ASSEMBLY..]', 'Retain only those snippets in the cache which occur in one of the given assemblies', (command) => command
        .positional('TABLET', {
        type: 'string',
        required: true,
        describe: 'Language tablet to trim',
    })
        .positional('ASSEMBLY', {
        type: 'string',
        string: true,
        default: new Array(),
        describe: 'Assembly or directory to search',
    })
        .demandOption('TABLET'), wrapHandler(async (args) => {
        await trim_cache_1.trimCache({
            cacheFile: args.TABLET,
            assemblyLocations: args.ASSEMBLY,
        });
    }))
        .command('read <TABLET> [KEY] [LANGUAGE]', 'Display snippets in a language tablet file', (command) => command
        .positional('TABLET', {
        type: 'string',
        required: true,
        describe: 'Language tablet to read',
    })
        .positional('KEY', {
        type: 'string',
        describe: 'Snippet key to read',
    })
        .positional('LANGUAGE', {
        type: 'string',
        describe: 'Language ID to read',
    })
        .demandOption('TABLET'), wrapHandler(async (args) => {
        await read_1.readTablet(args.TABLET, args.KEY, args.LANGUAGE);
    }))
        .command('configure-strict [PACKAGE]', "Enables strict mode for a package's assembly", (command) => command.positional('PACKAGE', {
        type: 'string',
        describe: 'The path to the package to configure',
        required: false,
        default: '.',
        normalize: true,
    }), wrapHandler(async (args) => {
        var _a, _b, _c, _d, _e, _f;
        const packageJsonPath = (await fs.stat(args.PACKAGE)).isDirectory()
            ? path.join(args.PACKAGE, 'package.json')
            : args.PACKAGE;
        const packageJson = await fs.readJson(packageJsonPath);
        if (packageJson.jsii == null) {
            console.error(`The package in ${args.PACKAGE} does not have a jsii configuration! You can set it up using jsii-config.`);
            process.exitCode = 1;
            return Promise.resolve();
        }
        if ((_c = (_b = (_a = packageJson.jsii.metadata) === null || _a === void 0 ? void 0 : _a.jsii) === null || _b === void 0 ? void 0 : _b.rosetta) === null || _c === void 0 ? void 0 : _c.strict) {
            // Nothing to do - it's already configured, so we assert idempotent success!
            return Promise.resolve();
        }
        const md = (packageJson.jsii.metadata = (_d = packageJson.jsii.metadata) !== null && _d !== void 0 ? _d : {});
        const mdJsii = (md.jsii = (_e = md.jsii) !== null && _e !== void 0 ? _e : {});
        const mdRosetta = (mdJsii.rosetta = (_f = mdJsii.rosetta) !== null && _f !== void 0 ? _f : {});
        mdRosetta.strict = true;
        return fs.writeJson(packageJsonPath, packageJson, { spaces: 2 });
    }))
        .demandCommand()
        .help()
        .strict() // Error on wrong command
        // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires
        .version(require('../package.json').version)
        .showHelpOnFail(false).argv;
    // Evaluating .argv triggers the parsing but the command gets implicitly executed,
    // so we don't need the output.
    Array.isArray(argv);
}
/**
 * Wrap a command's handler with standard pre- and post-work
 */
function wrapHandler(handler) {
    return (argv) => {
        logging.configure({ level: argv.verbose !== undefined ? argv.verbose : 0 });
        handler(argv).catch((e) => {
            logging.error(e.message);
            logging.error(e.stack);
            process.exitCode = 1;
        });
    };
}
function makeVisitor(args) {
    if (args.python) {
        return new python_1.PythonVisitor();
    }
    // Default to visualizing AST, including nodes we don't recognize yet
    return new visualize_1.VisualizeAstVisitor();
}
async function makeFileSource(fileName, stdinName) {
    if (fileName === '-') {
        return {
            contents: await readStdin(),
            fileName: stdinName,
        };
    }
    return {
        contents: await fs.readFile(fileName, { encoding: 'utf-8' }),
        fileName: fileName,
    };
}
async function readStdin() {
    process.stdin.setEncoding('utf8');
    const parts = [];
    return new Promise((resolve, reject) => {
        process.stdin.on('readable', () => {
            const chunk = process.stdin.read();
            if (chunk !== null) {
                parts.push(Buffer.from(chunk));
            }
        });
        process.stdin.on('error', reject);
        process.stdin.on('end', () => resolve(Buffer.concat(parts).toString('utf-8')));
    });
}
function handleSingleResult(result) {
    process.stdout.write(`${result.translation}\n`);
    // For a single result, we always request implicit failure.
    handleDiagnostics(result.diagnostics, 'implicit');
}
/**
 * Print diagnostics and set exit code
 *
 * 'fail' is whether or not the user passed '--fail' for commands that accept
 * it, or 'implicit' for commands that should always fail. 'implicit' will be
 * treated as 'fail=true, but will not print to the user that the '--fail' is
 * set (because for this particular command that switch does not exist and so it
 * would be confusing).
 */
function handleDiagnostics(diagnostics, fail, snippetCount = 1) {
    if (fail !== false) {
        // Fail on any diagnostic
        if (diagnostics.length > 0) {
            util_1.printDiagnostics(diagnostics, process.stderr);
            logging.error([
                `${diagnostics.length} diagnostics encountered in ${snippetCount} snippets`,
                ...(fail === true ? ["(running with '--fail')"] : []),
            ].join(' '));
            process.exitCode = 1;
        }
        return;
    }
    // Otherwise fail only on strict diagnostics. If we have strict diagnostics, print only those
    // (so it's very clear what is failing the build), otherwise print everything.
    const strictDiagnostics = diagnostics.filter((diag) => diag.isFromStrictAssembly);
    if (strictDiagnostics.length > 0) {
        util_1.printDiagnostics(strictDiagnostics, process.stderr);
        const remaining = diagnostics.length - strictDiagnostics.length;
        logging.warn([
            `${strictDiagnostics.length} diagnostics from assemblies with 'strict' mode on`,
            ...(remaining > 0 ? [`(and ${remaining} more non-strict diagnostics)`] : []),
        ].join(' '));
        process.exitCode = 1;
        return;
    }
    if (diagnostics.length > 0) {
        util_1.printDiagnostics(diagnostics, process.stderr);
        logging.warn(`${diagnostics.length} diagnostics encountered in ${snippetCount} snippets`);
    }
}
/**
 * Rounds a decimal number to two decimal points.
 * The function is useful for fractions that need to be outputted as percentages.
 */
function roundPercentage(num) {
    return Math.round(10000 * num) / 100;
}
main();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNpaS1yb3NldHRhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsianNpaS1yb3NldHRhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsZ0NBQThCO0FBRTlCLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBRS9CLGdDQUFpRjtBQUNqRixxREFBNEQ7QUFDNUQscURBQTRGO0FBQzVGLG1EQUErRTtBQUMvRSwrQ0FBa0Q7QUFDbEQsaUVBQXNFO0FBQ3RFLDJEQUF1RDtBQUN2RCxnREFBa0Q7QUFDbEQsb0RBQXdEO0FBQ3hELDBEQUFpRTtBQUNqRSwwQ0FBMEM7QUFDMUMsc0NBQTJEO0FBRTNELFNBQVMsSUFBSTtJQUNYLE1BQU0sSUFBSSxHQUFHLEtBQUs7U0FDZixLQUFLLENBQUMsaUJBQWlCLENBQUM7U0FDeEIsTUFBTSxDQUFDLFNBQVMsRUFBRTtRQUNqQixLQUFLLEVBQUUsR0FBRztRQUNWLElBQUksRUFBRSxTQUFTO1FBQ2YsSUFBSSxFQUFFLDRCQUE0QjtRQUNsQyxLQUFLLEVBQUUsSUFBSTtRQUNYLE9BQU8sRUFBRSxDQUFDO0tBQ1gsQ0FBQztTQUNELE9BQU8sQ0FDTixjQUFjLEVBQ2QsNEJBQTRCLEVBQzVCLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FDVixPQUFPO1NBQ0osVUFBVSxDQUFDLE1BQU0sRUFBRTtRQUNsQixJQUFJLEVBQUUsUUFBUTtRQUNkLFFBQVEsRUFBRSw2Q0FBNkM7S0FDeEQsQ0FBQztTQUNELE1BQU0sQ0FBQyxRQUFRLEVBQUU7UUFDaEIsS0FBSyxFQUFFLEdBQUc7UUFDVixPQUFPLEVBQUUsSUFBSTtRQUNiLFdBQVcsRUFBRSw4QkFBOEI7S0FDNUMsQ0FBQyxFQUNOLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUU7O1FBQ3pCLE1BQU0sTUFBTSxHQUFHLHlCQUFtQixDQUFDLE1BQU0sY0FBYyxPQUFDLElBQUksQ0FBQyxJQUFJLG1DQUFJLEdBQUcsRUFBRSxVQUFVLENBQUMs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Q0FBQztBQUVEOzs7R0FHRztBQUNILFNBQVMsZUFBZSxDQUFDLEdBQVc7SUFDbEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDdkMsQ0FBQztBQUVELElBQUksRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdAanNpaS9jaGVjay1ub2RlL3J1bic7XG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB5YXJncyBmcm9tICd5YXJncyc7XG5cbmltcG9ydCB7IFRyYW5zbGF0ZVJlc3VsdCwgdHJhbnNsYXRlVHlwZVNjcmlwdCwgUm9zZXR0YURpYWdub3N0aWMgfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgdHJhbnNsYXRlTWFya2Rvd24gfSBmcm9tICcuLi9saWIvY29tbWFuZHMvY29udmVydCc7XG5pbXBvcnQgeyBleHRyYWN0QW5kSW5mdXNlLCBleHRyYWN0U25pcHBldHMsIEV4dHJhY3RPcHRpb25zIH0gZnJvbSAnLi4vbGliL2NvbW1hbmRzL2V4dHJhY3QnO1xuaW1wb3J0IHsgaW5mdXNlLCBERUZBVUxUX0lORlVTSU9OX1JFU1VMVFNfTkFNRSB9IGZyb20gJy4uL2xpYi9jb21tYW5kcy9pbmZ1c2UnO1xuaW1wb3J0IHsgcmVhZFRhYmxldCB9IGZyb20gJy4uL2xpYi9jb21tYW5kcy9yZWFkJztcbmltcG9ydCB7IHRyYW5zbGl0ZXJhdGVBc3NlbWJseSB9IGZyb20gJy4uL2xpYi9jb21tYW5kcy90cmFuc2xpdGVyYXRlJztcbmltcG9ydCB7IHRyaW1DYWNoZSB9IGZyb20gJy4uL2xpYi9jb21tYW5kcy90cmltLWNhY2hlJztcbmltcG9ydCB7IFRhcmdldExhbmd1YWdlIH0gZnJvbSAnLi4vbGliL2xhbmd1YWdlcyc7XG5pbXBvcnQgeyBQeXRob25WaXNpdG9yIH0gZnJvbSAnLi4vbGliL2xhbmd1YWdlcy9weXRob24nO1xuaW1wb3J0IHsgVmlzdWFsaXplQXN0VmlzaXRvciB9IGZyb20gJy4uL2xpYi9sYW5ndWFnZXMvdmlzdWFsaXplJztcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnLi4vbGliL2xvZ2dpbmcnO1xuaW1wb3J0IHsgRmlsZSwgZm1hcCwgcHJpbnREaWFnbm9zdGljcyB9IGZyb20gJy4uL2xpYi91dGlsJztcblxuZnVuY3Rpb24gbWFpbigpIHtcbiAgY29uc3QgYXJndiA9IHlhcmdzXG4gICAgLnVzYWdlKCckMCA8Y21kPiBbYXJnc10nKVxuICAgIC5vcHRpb24oJ3ZlcmJvc2UnLCB7XG4gICAgICBhbGlhczogJ3YnLFxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVzYzogJ0luY3JlYXNlIGxvZ2dpbmcgdmVyYm9zaXR5JyxcbiAgICAgIGNvdW50OiB0cnVlLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9KVxuICAgIC5jb21tYW5kKFxuICAgICAgJ3NuaXBwZXQgRklMRScsXG4gICAgICAnVHJhbnNsYXRlIGEgc2luZ2xlIHNuaXBwZXQnLFxuICAgICAgKGNvbW1hbmQpID0+XG4gICAgICAgIGNvbW1hbmRcbiAgICAgICAgICAucG9zaXRpb25hbCgnRklMRScsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdUaGUgZmlsZSB0byB0cmFuc2xhdGUgKGxlYXZlIG91dCBmb3Igc3RkaW4pJyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb24oJ3B5dGhvbicsIHtcbiAgICAgICAgICAgIGFsaWFzOiAncCcsXG4gICAgICAgICAgICBib29sZWFuOiB0cnVlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUcmFuc2xhdGUgc25pcHBldHMgdG8gUHl0aG9uJyxcbiAgICAgICAgICB9KSxcbiAgICAgIHdyYXBIYW5kbGVyKGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZVR5cGVTY3JpcHQoYXdhaXQgbWFrZUZpbGVTb3VyY2UoYXJncy5GSUxFID8/ICctJywgJ3N0ZGluLnRzJyksIG1ha2VWaXNpdG9yKGFyZ3MpKTtcbiAgICAgICAgaGFuZGxlU2luZ2xlUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9KSxcbiAgICApXG4gICAgLmNvbW1hbmQoXG4gICAgICAnbWFya2Rvd24gRklMRScsXG4gICAgICAnVHJhbnNsYXRlIGEgTWFya0Rvd24gZmlsZScsXG4gICAgICAoY29tbWFuZCkgPT5cbiAgICAgICAgY29tbWFuZFxuICAgICAgICAgIC5wb3NpdGlvbmFsKCdGSUxFJywge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkZXNjcmliZTogJ1RoZSBmaWxlIHRvIHRyYW5zbGF0ZSAobGVhdmUgb3V0IGZvciBzdGRpbiknLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbigncHl0aG9uJywge1xuICAgICAgICAgICAgYWxpYXM6ICdwJyxcbiAgICAgICAgICAgIGJvb2xlYW46IHRydWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RyYW5zbGF0ZSBzbmlwcGV0cyB0byBQeXRob24nLFxuICAgICAgICAgIH0pLFxuICAgICAgd3JhcEhhbmRsZXIoYXN5bmMgKGFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlTWFya2Rvd24oYXdhaXQgbWFrZUZpbGVTb3VyY2UoYXJncy5GSUxFID8/ICctJywgJ3N0ZGluLm1kJyksIG1ha2VWaXNpdG9yKGFyZ3MpKTtcbiAgICAgICAgaGFuZGxlU2luZ2xlUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9KSxcbiAgICApXG4gICAgLmNvbW1hbmQoXG4gICAgICAnaW5mdXNlIFtBU1NFTUJMWS4uXScsXG4gICAgICAnKEVYUEVSSU1FTlRBTCkgbXV0YXRlcyBvbmUgb3IgbW9yZSBhc3NlbWJsaWVzIGJ5IGFkZGluZyBkb2N1bWVudGF0aW9uIGV4YW1wbGVzIHRvIHRvcC1sZXZlbCB0eXBlcycsXG4gICAgICAoY29tbWFuZCkgPT5cbiAgICAgICAgY29tbWFuZFxuICAgICAgICAgIC5wb3NpdGlvbmFsKCdBU1NFTUJMWScsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgc3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdDogbmV3IEFycmF5PHN0cmluZz4oKSxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnQXNzZW1ibHkgb3IgZGlyZWN0b3J5IHRvIG11dGF0ZScsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub3B0aW9uKCdsb2ctZmlsZScsIHtcbiAgICAgICAgICAgIGFsaWFzOiAnbCcsXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnT3V0cHV0IGZpbGUgdG8gc3RvcmUgbG9nZ2luZyByZXN1bHRzLiBJZ25vcmVkIGlmIC1sb2cgaXMgbm90IHRydWUnLFxuICAgICAgICAgICAgZGVmYXVsdDogREVGQVVMVF9JTkZVU0lPTl9SRVNVTFRTX05BTUUsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub3B0aW9uKCdjYWNoZS1mcm9tJywge1xuICAgICAgICAgICAgYWxpYXM6ICdDJyxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZXR0aWVyL3ByZXR0aWVyXG4gICAgICAgICAgICBkZXNjcmliZTpcbiAgICAgICAgICAgICAgJ1JldXNlIHRyYW5zbGF0aW9ucyBmcm9tIHRoZSBnaXZlbiB0YWJsZXQgZmlsZSBpZiB0aGUgc25pcHBldCBhbmQgdHlwZSBkZWZpbml0aW9ucyBkaWQgbm90IGNoYW5nZScsXG4gICAgICAgICAgICByZXF1aXJlc0FyZzogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb24oJ2NhY2hlLXRvJywge1xuICAgICAgICAgICAgYWxpYXM6ICdvJyxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdBcHBlbmQgYWxsIHRyYW5zbGF0ZWQgc25pcHBldHMgdG8gdGhlIGdpdmVuIHRhYmxldCBmaWxlJyxcbiAgICAgICAgICAgIHJlcXVpcmVzQXJnOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbignY2FjaGUnLCB7XG4gICAgICAgICAgICBhbGlhczogJ2snLFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkZXNjcmliZTogJ0FsaWFzIGZvciAtLWNhY2hlLWZyb20gYW5kIC0tY2FjaGUtdG8gdG9nZXRoZXInLFxuICAgICAgICAgICAgcmVxdWlyZXNBcmc6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY29uZmxpY3RzKCdjYWNoZScsICdjYWNoZS1mcm9tJylcbiAgICAgICAgICAuY29uZmxpY3RzKCdjYWNoZScsICdjYWNoZS10bycpLFxuICAgICAgd3JhcEhhbmRsZXIoYXN5bmMgKGFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgYWJzQXNzZW1ibGllcyA9IChhcmdzLkFTU0VNQkxZLmxlbmd0aCA+IDAgPyBhcmdzLkFTU0VNQkxZIDogWycuJ10pLm1hcCgoeCkgPT4gcGF0aC5yZXNvbHZlKHgpKTtcbiAgICAgICAgY29uc3QgYWJzQ2FjaGVGcm9tID0gZm1hcChhcmdzLmNhY2hlID8/IGFyZ3NbJ2NhY2hlLWZyb20nXSwgcGF0aC5yZXNvbHZlKTtcbiAgICAgICAgY29uc3QgYWJzQ2FjaGVUbyA9IGZtYXAoYXJncy5jYWNoZSA/PyBhcmdzWydjYWNoZS10byddLCBwYXRoLnJlc29sdmUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpbmZ1c2UoYWJzQXNzZW1ibGllcywge1xuICAgICAgICAgIGxvZ0ZpbGU6IGFyZ3NbJ2xvZy1maWxlJ10sXG4gICAgICAgICAgY2FjaGVUb0ZpbGU6IGFic0NhY2hlVG8sXG4gICAgICAgICAgY2FjaGVGcm9tRmlsZTogYWJzQ2FjaGVGcm9tLFxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgdG90YWxUeXBlcyA9IDA7XG4gICAgICAgIGxldCBpbnNlcnRlZEV4YW1wbGVzID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBbZGlyZWN0b3J5LCBtYXBdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdC5jb3ZlcmFnZVJlc3VsdHMpKSB7XG4gICAgICAgICAgY29uc3QgY29tbW9uTmFtZSA9IGRpcmVjdG9yeS5zcGxpdCgnLycpLnBvcCgpITtcbiAgICAgICAgICBjb25zdCBuZXdDb3ZlcmFnZSA9IHJvdW5kUGVyY2VudGFnZShtYXAudHlwZXNXaXRoSW5zZXJ0ZWRFeGFtcGxlcyAvIG1hcC50eXBlcyk7XG4gICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgICAgICAgICBgJHtjb21tb25OYW1lfTogQWRkZWQgJHttYXAudHlwZXNXaXRoSW5zZXJ0ZWRFeGFtcGxlc30gZXhhbXBsZXMgdG8gJHttYXAudHlwZXN9IHR5cGVzLlxcbmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtjb21tb25OYW1lfTogTmV3IGNvdmVyYWdlOiAke25ld0NvdmVyYWdlfSUuXFxuYCk7XG5cbiAgICAgICAgICBpbnNlcnRlZEV4YW1wbGVzICs9IG1hcC50eXBlc1dpdGhJbnNlcnRlZEV4YW1wbGVzO1xuICAgICAgICAgIHRvdGFsVHlwZXMgKz0gbWFwLnR5cGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NvdmVyYWdlID0gcm91bmRQZXJjZW50YWdlKGluc2VydGVkRXhhbXBsZXMgLyB0b3RhbFR5cGVzKTtcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYFxcblxcbkZpbmFsIFN0YXRzOlxcbk5ldyBjb3ZlcmFnZTogJHtuZXdDb3ZlcmFnZX0lLlxcbmApO1xuICAgICAgfSksXG4gICAgKVxuICAgIC5jb21tYW5kKFxuICAgICAgWydleHRyYWN0IFtBU1NFTUJMWS4uXScsICckMCBbQVNTRU1CTFkuLl0nXSxcbiAgICAgICdFeHRyYWN0IGNvZGUgc25pcHBldHMgZnJvbSBvbmUgb3IgbW9yZSBhc3NlbWJsaWVzIGludG8gbGFuZ3VhZ2UgdGFibGV0cycsXG4gICAgICAoY29tbWFuZCkgPT5cbiAgICAgICAgY29tbWFuZFxuICAgICAgICAgIC5wb3NpdGlvbmFsKCdBU1NFTUJMWScsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgc3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdDogbmV3IEFycmF5PHN0cmluZz4oKSxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnQXNzZW1ibHkgb3IgZGlyZWN0b3J5IHRvIGV4dHJhY3QgZnJvbScsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub3B0aW9uKCdvdXRwdXQnLCB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnQWRkaXRpb25hbCBvdXRwdXQgZmlsZSB3aGVyZSB0byBzdG9yZSB0cmFuc2xhdGVkIHNhbXBsZXMgKGRlcHJlY2F0ZWQsIGFsaWFzIGZvciAtLWNhY2hlLXRvKScsXG4gICAgICAgICAgICByZXF1aXJlc0FyZzogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb24oJ2NvbXBpbGUnLCB7XG4gICAgICAgICAgICBhbGlhczogJ2MnLFxuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdUcnkgY29tcGlsaW5nIChvbiBieSBkZWZhdWx0LCB1c2UgLS1uby1jb21waWxlIHRvIHN3aXRjaCBvZmYpJyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub3B0aW9uKCdkaXJlY3RvcnknLCB7XG4gICAgICAgICAgICBhbGlhczogJ2QnLFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkZXNjcmliZTogJ1dvcmtpbmcgZGlyZWN0b3J5IChmb3IgcmVxdWlyZSgpIGV0YyknLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbignaW5jbHVkZScsIHtcbiAgICAgICAgICAgIGFsaWFzOiAnaScsXG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdFeHRyYWN0IG9ubHkgc25pcHBldHMgd2l0aCBnaXZlbiBpZHMnLFxuICAgICAgICAgICAgZGVmYXVsdDogbmV3IEFycmF5PHN0cmluZz4oKSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb24oJ2luZnVzZScsIHtcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnYnVuZGxlIHRoaXMgY29tbWFuZCB3aXRoIHRoZSBpbmZ1c2UgY29tbWFuZCcsXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb24oJ2ZhaWwnLCB7XG4gICAgICAgICAgICBhbGlhczogJ2YnLFxuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdGYWlsIGlmIHRoZXJlIGFyZSBjb21waWxhdGlvbiBlcnJvcnMnLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub3B0aW9uKCd2YWxpZGF0ZS1hc3NlbWJsaWVzJywge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdXaGV0aGVyIHRvIHZhbGlkYXRlIGxvYWRlZCBhc3NlbWJsaWVzIG9yIG5vdCAodGhpcyBjYW4gYmUgc2xvdyknLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub3B0aW9uKCdjYWNoZS1mcm9tJywge1xuICAgICAgICAgICAgYWxpYXM6ICdDJyxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZXR0aWVyL3ByZXR0aWVyXG4gICAgICAgICAgICBkZXNjcmliZTpcbiAgICAgICAgICAgICAgJ1JldXNlIHRyYW5zbGF0aW9ucyBmcm9tIHRoZSBnaXZlbiB0YWJsZXQgZmlsZSBpZiB0aGUgc25pcHBldCBhbmQgdHlwZSBkZWZpbml0aW9ucyBkaWQgbm90IGNoYW5nZScsXG4gICAgICAgICAgICByZXF1aXJlc0FyZzogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb24oJ2NhY2hlLXRvJywge1xuICAgICAgICAgICAgYWxpYXM6ICdvJyxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdBcHBlbmQgYWxsIHRyYW5zbGF0ZWQgc25pcHBldHMgdG8gdGhlIGdpdmVuIHRhYmxldCBmaWxlJyxcbiAgICAgICAgICAgIHJlcXVpcmVzQXJnOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNvbmZsaWN0cygnY2FjaGUtdG8nLCAnb3V0cHV0JylcbiAgICAgICAgICAub3B0aW9uKCdjYWNoZScsIHtcbiAgICAgICAgICAgIGFsaWFzOiAnaycsXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnQWxpYXMgZm9yIC0tY2FjaGUtZnJvbSBhbmQgLS1jYWNoZS10byB0b2dldGhlcicsXG4gICAgICAgICAgICByZXF1aXJlc0FyZzogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jb25mbGljdHMoJ2NhY2hlJywgJ2NhY2hlLWZyb20nKVxuICAgICAgICAgIC5jb25mbGljdHMoJ2NhY2hlJywgJ2NhY2hlLXRvJylcbiAgICAgICAgICAub3B0aW9uKCd0cmltLWNhY2hlJywge1xuICAgICAgICAgICAgYWxpYXM6ICdUJyxcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnUmVtb3ZlIHRyYW5zbGF0aW9ucyB0aGF0IGFyZSBub3QgcmVmZXJlbmNlZCBieSBhbnkgb2YgdGhlIGFzc2VtYmxpZXMgYW55bW9yZSBmcm9tIHRoZSBjYWNoZScsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub3B0aW9uKCdzdHJpY3QnLCB7XG4gICAgICAgICAgICBhbGlhczogJ1MnLFxuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVzY3JpYmU6XG4gICAgICAgICAgICAgICdSZXF1aXJlIGFsbCBjb2RlIHNhbXBsZXMgY29tcGlsZSwgYW5kIGZhaWwgaWYgb25lIGRvZXMgbm90LiBTdHJpY3QgbW9kZSBhbHdheXMgZW5hYmxlcyAtLWNvbXBpbGUgYW5kIC0tZmFpbCcsXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICB9KSxcbiAgICAgIHdyYXBIYW5kbGVyKGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIC8vIGAtLXN0cmljdGAgaXMgc2hvcnQgZm9yIGAtLWNvbXBpbGUgLS1mYWlsYCwgYW5kIHdlJ2xsIG92ZXJyaWRlIHRob3NlIGV2ZW4gaWYgdGhleSdyZSBzZXQgdG8gYGZhbHNlYCwgc3VjaCBhc1xuICAgICAgICAvLyB1c2luZyBgLS1uby0oY29tcGlsZXxmYWlsKWAsIGJlY2F1c2UgeWFyZ3MgZG9lcyBub3QgcXVpdGUgZ2l2ZSB1cyBhIGJldHRlciBvcHRpb24gdGhhdCBkb2VzIG5vdCBodXJ0IENYLlxuICAgICAgICBpZiAoYXJncy5zdHJpY3QpIHtcbiAgICAgICAgICBhcmdzLmNvbXBpbGUgPSBhcmdzLmMgPSB0cnVlO1xuICAgICAgICAgIGFyZ3MuZmFpbCA9IGFyZ3MuZiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFYXNpZXN0IHdheSB0byBnZXQgYSBmaXhlZCB3b3JraW5nIGRpcmVjdG9yeSAoZm9yIHNvdXJjZXMpIGluIGlzIHRvXG4gICAgICAgIC8vIGNoZGlyLCBzaW5jZSB1bmRlcm5lYXRoIHRoZSBpbi1tZW1vcnkgbGF5ZXIgd2UncmUgdXNpbmcgYSByZWd1bGFyIFRTXG4gICAgICAgIC8vIGNvbXBpbGVyaG9zdC4gSGF2ZSB0byBtYWtlIGFsbCBmaWxlIHJlZmVyZW5jZXMgYWJzb2x1dGUgYmVmb3JlIHdlIGNoZGlyXG4gICAgICAgIC8vIHRob3VnaC5cbiAgICAgICAgY29uc3QgYWJzQXNzZW1ibGllcyA9IChhcmdzLkFTU0VNQkxZLmxlbmd0aCA+IDAgPyBhcmdzLkFTU0VNQkxZIDogWycuJ10pLm1hcCgoeCkgPT4gcGF0aC5yZXNvbHZlKHgpKTtcblxuICAgICAgICBjb25zdCBhYnNDYWNoZUZyb20gPSBmbWFwKGFyZ3MuY2FjaGUgPz8gYXJnc1snY2FjaGUtZnJvbSddLCBwYXRoLnJlc29sdmUpO1xuICAgICAgICBjb25zdCBhYnNDYWNoZVRvID0gZm1hcChhcmdzLmNhY2hlID8/IGFyZ3NbJ2NhY2hlLXRvJ10gPz8gYXJncy5vdXRwdXQsIHBhdGgucmVzb2x2ZSk7XG5cbiAgICAgICAgaWYgKGFyZ3MuZGlyZWN0b3J5KSB7XG4gICAgICAgICAgcHJvY2Vzcy5jaGRpcihhcmdzLmRpcmVjdG9yeSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHRyYWN0T3B0aW9uczogRXh0cmFjdE9wdGlvbnMgPSB7XG4gICAgICAgICAgaW5jbHVkZUNvbXBpbGVyRGlhZ25vc3RpY3M6ICEhYXJncy5jb21waWxlLFxuICAgICAgICAgIHZhbGlkYXRlQXNzZW1ibGllczogYXJnc1sndmFsaWRhdGUtYXNzZW1ibGllcyddLFxuICAgICAgICAgIG9ubHk6IGFyZ3MuaW5jbHVkZSxcbiAgICAgICAgICBjYWNoZUZyb21GaWxlOiBhYnNDYWNoZUZyb20sXG4gICAgICAgICAgY2FjaGVUb0ZpbGU6IGFic0NhY2hlVG8sXG4gICAgICAgICAgdHJpbUNhY2hlOiBhcmdzWyd0cmltLWNhY2hlJ10sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXJncy5pbmZ1c2VcbiAgICAgICAgICA/IGF3YWl0IGV4dHJhY3RBbmRJbmZ1c2UoYWJzQXNzZW1ibGllcywgZXh0cmFjdE9wdGlvbnMpXG4gICAgICAgICAgOiBhd2FpdCBleHRyYWN0U25pcHBldHMoYWJzQXNzZW1ibGllcywgZXh0cmFjdE9wdGlvbnMpO1xuXG4gICAgICAgIGhhbmRsZURpYWdub3N0aWNzKHJlc3VsdC5kaWFnbm9zdGljcywgYXJncy5mYWlsLCByZXN1bHQudGFibGV0LmNvdW50KTtcbiAgICAgIH0pLFxuICAgIClcbiAgICAuY29tbWFuZChcbiAgICAgICd0cmFuc2xpdGVyYXRlIFtBU1NFTUJMWS4uXScsXG4gICAgICAnKEVYUEVSSU1FTlRBTCkgVHJhbnNsaXRlcmF0ZXMgdGhlIGRlc2lnbmF0ZWQgYXNzZW1ibGllcycsXG4gICAgICAoY29tbWFuZCkgPT5cbiAgICAgICAgY29tbWFuZFxuICAgICAgICAgIC5wb3NpdGlvbmFsKCdBU1NFTUJMWScsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgc3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdDogbmV3IEFycmF5PHN0cmluZz4oKSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdBc3NlbWJseSB0byB0cmFuc2xpdGVyYXRlJyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb24oJ2xhbmd1YWdlJywge1xuICAgICAgICAgICAgYWxpYXM6ICdsJyxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgc3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdDogbmV3IEFycmF5PHN0cmluZz4oKSxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnTGFuZ3VhZ2UgSUQgdG8gdHJhbnNsaXRlcmF0ZSB0bycsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub3B0aW9ucygnc3RyaWN0Jywge1xuICAgICAgICAgICAgYWxpYXM6ICdzJyxcbiAgICAgICAgICAgIGNvbmZsaWN0czogJ2xvb3NlJyxcbiAgICAgICAgICAgIGRlc2NyaWJlOlxuICAgICAgICAgICAgICAnRmFpbCBpZiBhbiBleGFtcGxlIHRoYXQgbmVlZHMgbGl2ZSB0cmFuc2xpdGVyYXRpb24gZmFpbHMgdG8gY29tcGlsZSAod2hpY2ggY291bGQgY2F1c2UgaW5jb3JyZWN0IHRyYW5zcGlsYXRpb24gcmVzdWx0cyknLFxuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbnMoJ2xvb3NlJywge1xuICAgICAgICAgICAgYWxpYXM6ICdsJyxcbiAgICAgICAgICAgIGNvbmZsaWN0czogJ3N0cmljdCcsXG4gICAgICAgICAgICBkZXNjcmliZTogJ0lnbm9yZSBtaXNzaW5nIGZpeHR1cmVzIGFuZCBsaXRlcmF0ZSBtYXJrZG93biBmaWxlcyBpbnN0ZWFkIG9mIGZhaWxpbmcnLFxuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbigndGFibGV0Jywge1xuICAgICAgICAgICAgYWxpYXM6ICd0JyxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpYmU6XG4gICAgICAgICAgICAgICdMYW5ndWFnZSB0YWJsZXQgY29udGFpbmluZyBwcmUtdHJhbnNsYXRlZCBjb2RlIGV4YW1wbGVzIHRvIHVzZSAodGhlc2UgYXJlIGdlbmVyYXRlZCBieSB0aGUgYGV4dHJhY3RgIGNvbW1hbmQpJyxcbiAgICAgICAgICB9KSxcbiAgICAgIHdyYXBIYW5kbGVyKChhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFzc2VtYmxpZXMgPSAoYXJncy5BU1NFTUJMWS5sZW5ndGggPiAwID8gYXJncy5BU1NFTUJMWSA6IFsnLiddKS5tYXAoKGRpcikgPT5cbiAgICAgICAgICBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgZGlyKSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VzID1cbiAgICAgICAgICBhcmdzLmxhbmd1YWdlLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gYXJncy5sYW5ndWFnZS5tYXAoKGxhbmcpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuZW50cmllcyhUYXJnZXRMYW5ndWFnZSkuZmluZCgoW2tdKSA9PiBrID09PSBsYW5nKT8uWzFdO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgVW5rbm93biB0YXJnZXQgbGFuZ3VhZ2U6ICR7bGFuZ30uIEV4cGVjdGVkIG9uZSBvZiAke09iamVjdC5rZXlzKFRhcmdldExhbmd1YWdlKS5qb2luKCcsICcpfWAsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBPYmplY3QudmFsdWVzKFRhcmdldExhbmd1YWdlKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGl0ZXJhdGVBc3NlbWJseShhc3NlbWJsaWVzLCBsYW5ndWFnZXMsIGFyZ3MpO1xuICAgICAgfSksXG4gICAgKVxuICAgIC5jb21tYW5kKFxuICAgICAgJ3RyaW0tY2FjaGUgPFRBQkxFVD4gW0FTU0VNQkxZLi5dJyxcbiAgICAgICdSZXRhaW4gb25seSB0aG9zZSBzbmlwcGV0cyBpbiB0aGUgY2FjaGUgd2hpY2ggb2NjdXIgaW4gb25lIG9mIHRoZSBnaXZlbiBhc3NlbWJsaWVzJyxcbiAgICAgIChjb21tYW5kKSA9PlxuICAgICAgICBjb21tYW5kXG4gICAgICAgICAgLnBvc2l0aW9uYWwoJ1RBQkxFVCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICBkZXNjcmliZTogJ0xhbmd1YWdlIHRhYmxldCB0byB0cmltJyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5wb3NpdGlvbmFsKCdBU1NFTUJMWScsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgc3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdDogbmV3IEFycmF5PHN0cmluZz4oKSxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnQXNzZW1ibHkgb3IgZGlyZWN0b3J5IHRvIHNlYXJjaCcsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZGVtYW5kT3B0aW9uKCdUQUJMRVQnKSxcbiAgICAgIHdyYXBIYW5kbGVyKGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIGF3YWl0IHRyaW1DYWNoZSh7XG4gICAgICAgICAgY2FjaGVGaWxlOiBhcmdzLlRBQkxFVCxcbiAgICAgICAgICBhc3NlbWJseUxvY2F0aW9uczogYXJncy5BU1NFTUJMWSxcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICApXG4gICAgLmNvbW1hbmQoXG4gICAgICAncmVhZCA8VEFCTEVUPiBbS0VZXSBbTEFOR1VBR0VdJyxcbiAgICAgICdEaXNwbGF5IHNuaXBwZXRzIGluIGEgbGFuZ3VhZ2UgdGFibGV0IGZpbGUnLFxuICAgICAgKGNvbW1hbmQpID0+XG4gICAgICAgIGNvbW1hbmRcbiAgICAgICAgICAucG9zaXRpb25hbCgnVEFCTEVUJywge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIGRlc2NyaWJlOiAnTGFuZ3VhZ2UgdGFibGV0IHRvIHJlYWQnLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnBvc2l0aW9uYWwoJ0tFWScsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdTbmlwcGV0IGtleSB0byByZWFkJyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5wb3NpdGlvbmFsKCdMQU5HVUFHRScsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpYmU6ICdMYW5ndWFnZSBJRCB0byByZWFkJyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5kZW1hbmRPcHRpb24oJ1RBQkxFVCcpLFxuICAgICAgd3JhcEhhbmRsZXIoYXN5bmMgKGFyZ3MpID0+IHtcbiAgICAgICAgYXdhaXQgcmVhZFRhYmxldChhcmdzLlRBQkxFVCwgYXJncy5LRVksIGFyZ3MuTEFOR1VBR0UpO1xuICAgICAgfSksXG4gICAgKVxuICAgIC5jb21tYW5kKFxuICAgICAgJ2NvbmZpZ3VyZS1zdHJpY3QgW1BBQ0tBR0VdJyxcbiAgICAgIFwiRW5hYmxlcyBzdHJpY3QgbW9kZSBmb3IgYSBwYWNrYWdlJ3MgYXNzZW1ibHlcIixcbiAgICAgIChjb21tYW5kKSA9PlxuICAgICAgICBjb21tYW5kLnBvc2l0aW9uYWwoJ1BBQ0tBR0UnLCB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVzY3JpYmU6ICdUaGUgcGF0aCB0byB0aGUgcGFja2FnZSB0byBjb25maWd1cmUnLFxuICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICBkZWZhdWx0OiAnLicsXG4gICAgICAgICAgbm9ybWFsaXplOiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgIHdyYXBIYW5kbGVyKGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IChhd2FpdCBmcy5zdGF0KGFyZ3MuUEFDS0FHRSkpLmlzRGlyZWN0b3J5KClcbiAgICAgICAgICA/IHBhdGguam9pbihhcmdzLlBBQ0tBR0UsICdwYWNrYWdlLmpzb24nKVxuICAgICAgICAgIDogYXJncy5QQUNLQUdFO1xuICAgICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IGF3YWl0IGZzLnJlYWRKc29uKHBhY2thZ2VKc29uUGF0aCk7XG4gICAgICAgIGlmIChwYWNrYWdlSnNvbi5qc2lpID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFRoZSBwYWNrYWdlIGluICR7YXJncy5QQUNLQUdFfSBkb2VzIG5vdCBoYXZlIGEganNpaSBjb25maWd1cmF0aW9uISBZb3UgY2FuIHNldCBpdCB1cCB1c2luZyBqc2lpLWNvbmZpZy5gLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcHJvY2Vzcy5leGl0Q29kZSA9IDE7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWNrYWdlSnNvbi5qc2lpLm1ldGFkYXRhPy5qc2lpPy5yb3NldHRhPy5zdHJpY3QpIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIC0gaXQncyBhbHJlYWR5IGNvbmZpZ3VyZWQsIHNvIHdlIGFzc2VydCBpZGVtcG90ZW50IHN1Y2Nlc3MhXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1kID0gKHBhY2thZ2VKc29uLmpzaWkubWV0YWRhdGEgPSBwYWNrYWdlSnNvbi5qc2lpLm1ldGFkYXRhID8/IHt9KTtcbiAgICAgICAgY29uc3QgbWRKc2lpID0gKG1kLmpzaWkgPSBtZC5qc2lpID8/IHt9KTtcbiAgICAgICAgY29uc3QgbWRSb3NldHRhID0gKG1kSnNpaS5yb3NldHRhID0gbWRKc2lpLnJvc2V0dGEgPz8ge30pO1xuICAgICAgICBtZFJvc2V0dGEuc3RyaWN0ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZnMud3JpdGVKc29uKHBhY2thZ2VKc29uUGF0aCwgcGFja2FnZUpzb24sIHsgc3BhY2VzOiAyIH0pO1xuICAgICAgfSksXG4gICAgKVxuICAgIC5kZW1hbmRDb21tYW5kKClcbiAgICAuaGVscCgpXG4gICAgLnN0cmljdCgpIC8vIEVycm9yIG9uIHdyb25nIGNvbW1hbmRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgLnZlcnNpb24ocmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbilcbiAgICAuc2hvd0hlbHBPbkZhaWwoZmFsc2UpLmFyZ3Y7XG5cbiAgLy8gRXZhbHVhdGluZyAuYXJndiB0cmlnZ2VycyB0aGUgcGFyc2luZyBidXQgdGhlIGNvbW1hbmQgZ2V0cyBpbXBsaWNpdGx5IGV4ZWN1dGVkLFxuICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRoZSBvdXRwdXQuXG4gIEFycmF5LmlzQXJyYXkoYXJndik7XG59XG5cbi8qKlxuICogV3JhcCBhIGNvbW1hbmQncyBoYW5kbGVyIHdpdGggc3RhbmRhcmQgcHJlLSBhbmQgcG9zdC13b3JrXG4gKi9cbmZ1bmN0aW9uIHdyYXBIYW5kbGVyPEEgZXh0ZW5kcyB7IHZlcmJvc2U/OiBudW1iZXIgfSwgUj4oaGFuZGxlcjogKHg6IEEpID0+IFByb21pc2U8Uj4pIHtcbiAgcmV0dXJuIChhcmd2OiBBKSA9PiB7XG4gICAgbG9nZ2luZy5jb25maWd1cmUoeyBsZXZlbDogYXJndi52ZXJib3NlICE9PSB1bmRlZmluZWQgPyBhcmd2LnZlcmJvc2UgOiAwIH0pO1xuICAgIGhhbmRsZXIoYXJndikuY2F0Y2goKGUpID0+IHtcbiAgICAgIGxvZ2dpbmcuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgIGxvZ2dpbmcuZXJyb3IoZS5zdGFjayk7XG4gICAgICBwcm9jZXNzLmV4aXRDb2RlID0gMTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZVZpc2l0b3IoYXJnczogeyBweXRob24/OiBib29sZWFuIH0pIHtcbiAgaWYgKGFyZ3MucHl0aG9uKSB7XG4gICAgcmV0dXJuIG5ldyBQeXRob25WaXNpdG9yKCk7XG4gIH1cbiAgLy8gRGVmYXVsdCB0byB2aXN1YWxpemluZyBBU1QsIGluY2x1ZGluZyBub2RlcyB3ZSBkb24ndCByZWNvZ25pemUgeWV0XG4gIHJldHVybiBuZXcgVmlzdWFsaXplQXN0VmlzaXRvcigpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtYWtlRmlsZVNvdXJjZShmaWxlTmFtZTogc3RyaW5nLCBzdGRpbk5hbWU6IHN0cmluZyk6IFByb21pc2U8RmlsZT4ge1xuICBpZiAoZmlsZU5hbWUgPT09ICctJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50czogYXdhaXQgcmVhZFN0ZGluKCksXG4gICAgICBmaWxlTmFtZTogc3RkaW5OYW1lLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb250ZW50czogYXdhaXQgZnMucmVhZEZpbGUoZmlsZU5hbWUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSksXG4gICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkU3RkaW4oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcHJvY2Vzcy5zdGRpbi5zZXRFbmNvZGluZygndXRmOCcpO1xuXG4gIGNvbnN0IHBhcnRzOiBCdWZmZXJbXSA9IFtdO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcHJvY2Vzcy5zdGRpbi5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjaHVuayA9IHByb2Nlc3Muc3RkaW4ucmVhZCgpO1xuICAgICAgaWYgKGNodW5rICE9PSBudWxsKSB7XG4gICAgICAgIHBhcnRzLnB1c2goQnVmZmVyLmZyb20oY2h1bmspKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHByb2Nlc3Muc3RkaW4ub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICBwcm9jZXNzLnN0ZGluLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKEJ1ZmZlci5jb25jYXQocGFydHMpLnRvU3RyaW5nKCd1dGYtOCcpKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVSZXN1bHQocmVzdWx0OiBUcmFuc2xhdGVSZXN1bHQpIHtcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7cmVzdWx0LnRyYW5zbGF0aW9ufVxcbmApO1xuXG4gIC8vIEZvciBhIHNpbmdsZSByZXN1bHQsIHdlIGFsd2F5cyByZXF1ZXN0IGltcGxpY2l0IGZhaWx1cmUuXG4gIGhhbmRsZURpYWdub3N0aWNzKHJlc3VsdC5kaWFnbm9zdGljcywgJ2ltcGxpY2l0Jyk7XG59XG5cbi8qKlxuICogUHJpbnQgZGlhZ25vc3RpY3MgYW5kIHNldCBleGl0IGNvZGVcbiAqXG4gKiAnZmFpbCcgaXMgd2hldGhlciBvciBub3QgdGhlIHVzZXIgcGFzc2VkICctLWZhaWwnIGZvciBjb21tYW5kcyB0aGF0IGFjY2VwdFxuICogaXQsIG9yICdpbXBsaWNpdCcgZm9yIGNvbW1hbmRzIHRoYXQgc2hvdWxkIGFsd2F5cyBmYWlsLiAnaW1wbGljaXQnIHdpbGwgYmVcbiAqIHRyZWF0ZWQgYXMgJ2ZhaWw9dHJ1ZSwgYnV0IHdpbGwgbm90IHByaW50IHRvIHRoZSB1c2VyIHRoYXQgdGhlICctLWZhaWwnIGlzXG4gKiBzZXQgKGJlY2F1c2UgZm9yIHRoaXMgcGFydGljdWxhciBjb21tYW5kIHRoYXQgc3dpdGNoIGRvZXMgbm90IGV4aXN0IGFuZCBzbyBpdFxuICogd291bGQgYmUgY29uZnVzaW5nKS5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRGlhZ25vc3RpY3MoZGlhZ25vc3RpY3M6IHJlYWRvbmx5IFJvc2V0dGFEaWFnbm9zdGljW10sIGZhaWw6IGJvb2xlYW4gfCAnaW1wbGljaXQnLCBzbmlwcGV0Q291bnQgPSAxKSB7XG4gIGlmIChmYWlsICE9PSBmYWxzZSkge1xuICAgIC8vIEZhaWwgb24gYW55IGRpYWdub3N0aWNcbiAgICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoID4gMCkge1xuICAgICAgcHJpbnREaWFnbm9zdGljcyhkaWFnbm9zdGljcywgcHJvY2Vzcy5zdGRlcnIpO1xuICAgICAgbG9nZ2luZy5lcnJvcihcbiAgICAgICAgW1xuICAgICAgICAgIGAke2RpYWdub3N0aWNzLmxlbmd0aH0gZGlhZ25vc3RpY3MgZW5jb3VudGVyZWQgaW4gJHtzbmlwcGV0Q291bnR9IHNuaXBwZXRzYCxcbiAgICAgICAgICAuLi4oZmFpbCA9PT0gdHJ1ZSA/IFtcIihydW5uaW5nIHdpdGggJy0tZmFpbCcpXCJdIDogW10pLFxuICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICk7XG4gICAgICBwcm9jZXNzLmV4aXRDb2RlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPdGhlcndpc2UgZmFpbCBvbmx5IG9uIHN0cmljdCBkaWFnbm9zdGljcy4gSWYgd2UgaGF2ZSBzdHJpY3QgZGlhZ25vc3RpY3MsIHByaW50IG9ubHkgdGhvc2VcbiAgLy8gKHNvIGl0J3MgdmVyeSBjbGVhciB3aGF0IGlzIGZhaWxpbmcgdGhlIGJ1aWxkKSwgb3RoZXJ3aXNlIHByaW50IGV2ZXJ5dGhpbmcuXG4gIGNvbnN0IHN0cmljdERpYWdub3N0aWNzID0gZGlhZ25vc3RpY3MuZmlsdGVyKChkaWFnKSA9PiBkaWFnLmlzRnJvbVN0cmljdEFzc2VtYmx5KTtcbiAgaWYgKHN0cmljdERpYWdub3N0aWNzLmxlbmd0aCA+IDApIHtcbiAgICBwcmludERpYWdub3N0aWNzKHN0cmljdERpYWdub3N0aWNzLCBwcm9jZXNzLnN0ZGVycik7XG4gICAgY29uc3QgcmVtYWluaW5nID0gZGlhZ25vc3RpY3MubGVuZ3RoIC0gc3RyaWN0RGlhZ25vc3RpY3MubGVuZ3RoO1xuICAgIGxvZ2dpbmcud2FybihcbiAgICAgIFtcbiAgICAgICAgYCR7c3RyaWN0RGlhZ25vc3RpY3MubGVuZ3RofSBkaWFnbm9zdGljcyBmcm9tIGFzc2VtYmxpZXMgd2l0aCAnc3RyaWN0JyBtb2RlIG9uYCxcbiAgICAgICAgLi4uKHJlbWFpbmluZyA+IDAgPyBbYChhbmQgJHtyZW1haW5pbmd9IG1vcmUgbm9uLXN0cmljdCBkaWFnbm9zdGljcylgXSA6IFtdKSxcbiAgICAgIF0uam9pbignICcpLFxuICAgICk7XG4gICAgcHJvY2Vzcy5leGl0Q29kZSA9IDE7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aCA+IDApIHtcbiAgICBwcmludERpYWdub3N0aWNzKGRpYWdub3N0aWNzLCBwcm9jZXNzLnN0ZGVycik7XG4gICAgbG9nZ2luZy53YXJuKGAke2RpYWdub3N0aWNzLmxlbmd0aH0gZGlhZ25vc3RpY3MgZW5jb3VudGVyZWQgaW4gJHtzbmlwcGV0Q291bnR9IHNuaXBwZXRzYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSb3VuZHMgYSBkZWNpbWFsIG51bWJlciB0byB0d28gZGVjaW1hbCBwb2ludHMuXG4gKiBUaGUgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciBmcmFjdGlvbnMgdGhhdCBuZWVkIHRvIGJlIG91dHB1dHRlZCBhcyBwZXJjZW50YWdlcy5cbiAqL1xuZnVuY3Rpb24gcm91bmRQZXJjZW50YWdlKG51bTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoMTAwMDAgKiBudW0pIC8gMTAwO1xufVxuXG5tYWluKCk7XG4iXX0=