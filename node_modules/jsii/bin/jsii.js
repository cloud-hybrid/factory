"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("@jsii/check-node/run");
const log4js = require("log4js");
const path = require("path");
const util = require("util");
const yargs = require("yargs");
const compiler_1 = require("../lib/compiler");
const jsii_diagnostic_1 = require("../lib/jsii-diagnostic");
const project_info_1 = require("../lib/project-info");
const utils = require("../lib/utils");
const version_1 = require("../lib/version");
const warnings_1 = require("../lib/warnings");
const warningTypes = Object.keys(warnings_1.enabledWarnings);
(async () => {
    var _a;
    const argv = yargs
        .env('JSII')
        .command(['$0 [PROJECT_ROOT]', 'compile [PROJECT_ROOT]'], 'Compiles a jsii/TypeScript project', (argv) => argv
        .positional('PROJECT_ROOT', {
        type: 'string',
        desc: 'The root of the project to be compiled',
        default: '.',
        normalize: true,
    })
        .option('watch', {
        alias: 'w',
        type: 'boolean',
        desc: 'Watch for file changes and recompile automatically',
    })
        .option('project-references', {
        alias: 'r',
        type: 'boolean',
        desc: 'Generate TypeScript project references (also [package.json].jsii.projectReferences)',
    })
        .option('fix-peer-dependencies', {
        type: 'boolean',
        default: true,
        desc: 'This option no longer has any effect.',
        hidden: true,
    })
        .options('fail-on-warnings', {
        alias: 'Werr',
        type: 'boolean',
        desc: 'Treat warnings as errors',
    })
        .option('silence-warnings', {
        type: 'array',
        default: [],
        desc: `List of warnings to silence (warnings: ${warningTypes.join(',')})`,
    })
        .option('strip-deprecated', {
        type: 'string',
        desc: '[EXPERIMENTAL] Hides all @deprecated members from the API (implementations remain). If an optional file name is given, only FQNs present in the file will be stripped.',
    })
        .option('add-deprecation-warnings', {
        type: 'boolean',
        default: false,
        desc: '[EXPERIMENTAL] Injects warning statements for all deprecated elements, to be printed at runtime',
    })
        .option('generate-tsconfig', {
        type: 'string',
        default: 'tsconfig.json',
        desc: 'Name of the typescript configuration file to generate with compiler settings',
    }))
        .option('verbose', {
        alias: 'v',
        type: 'count',
        desc: 'Increase the verbosity of output',
        global: true,
    })
        .help()
        .version(
    // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires
    `${version_1.VERSION}, typescript ${require('typescript/package.json').version}`).argv;
    _configureLog4js(argv.verbose);
    const projectRoot = path.normalize(path.resolve(process.cwd(), argv.PROJECT_ROOT));
    const { projectInfo, diagnostics: projectInfoDiagnostics } = await project_info_1.loadProjectInfo(projectRoot);
    // disable all silenced warnings
    for (const key of argv['silence-warnings']) {
        if (!(key in warnings_1.enabledWarnings)) {
            throw new Error(`Unknown warning type ${key}. Must be one of: ${warningTypes.join(', ')}`);
        }
        warnings_1.enabledWarnings[key] = false;
    }
    jsii_diagnostic_1.configureCategories((_a = projectInfo.diagnostics) !== null && _a !== void 0 ? _a : {});
    const compiler = new compiler_1.Compiler({
        projectInfo,
        projectReferences: argv['project-references'],
        failOnWarnings: argv['fail-on-warnings'],
        stripDeprecated: !!argv['strip-deprecated'],
        stripDeprecatedAllowListFile: argv['strip-deprecated'],
        addDeprecationWarnings: argv['add-deprecation-warnings'],
        generateTypeScriptConfig: argv['generate-tsconfig'],
    });
    const emitResult = await (argv.watch ? compiler.watch() : compiler.emit());
    const allDiagnostics = [...projectInfoDiagnostics, ...emitResult.diagnostics];
    for (const diagnostic of allDiagnostics) {
        utils.logDiagnostic(diagnostic, projectRoot);
    }
    if (emitResult.emitSkipped) {
        process.exitCode = 1;
    }
})().catch((e) => {
    console.error(`Error: ${e.stack}`);
    process.exitCode = -1;
});
function _configureLog4js(verbosity) {
    const stderrColor = !!process.stderr.isTTY;
    const stdoutColor = !!process.stdout.isTTY;
    log4js.addLayout('passThroughNoColor', () => {
        return (loggingEvent) => stripAnsi(util.format(...loggingEvent.data));
    });
    log4js.configure({
        appenders: {
            console: {
                type: 'stderr',
                layout: { type: stderrColor ? 'colored' : 'basic' },
            },
            [utils.DIAGNOSTICS]: {
                type: 'stdout',
                layout: {
                    type: stdoutColor
                        ? 'messagePassThrough'
                        : 'passThroughNoColor',
                },
            },
        },
        categories: {
            default: { appenders: ['console'], level: _logLevel() },
            // The diagnostics logger must be set to INFO or more verbose, or watch won't show important messages
            [utils.DIAGNOSTICS]: {
                appenders: ['diagnostics'],
                level: _logLevel(Math.max(verbosity, 1)),
            },
        },
    });
    function _logLevel(verbosityLevel = verbosity) {
        switch (verbosityLevel) {
            case 0:
                return 'WARN';
            case 1:
                return 'INFO';
            case 2:
                return 'DEBUG';
            case 3:
                return 'TRACE';
            default:
                return 'ALL';
        }
    }
}
const ANSI_REGEX = 
// eslint-disable-next-line no-control-regex
/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
function stripAnsi(x) {
    return x.replace(ANSI_REGEX, '');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNpaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImpzaWkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxnQ0FBOEI7QUFFOUIsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBRS9CLDhDQUEyQztBQUMzQyw0REFBNkQ7QUFDN0Qsc0RBQXNEO0FBQ3RELHNDQUFzQztBQUN0Qyw0Q0FBeUM7QUFDekMsOENBQWtEO0FBRWxELE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsMEJBQWUsQ0FBQyxDQUFDO0FBRWxELENBQUMsS0FBSyxJQUFJLEVBQUU7O0lBQ1YsTUFBTSxJQUFJLEdBQUcsS0FBSztTQUNmLEdBQUcsQ0FBQyxNQUFNLENBQUM7U0FDWCxPQUFPLENBQ04sQ0FBQyxtQkFBbUIsRUFBRSx3QkFBd0IsQ0FBQyxFQUMvQyxvQ0FBb0MsRUFDcEMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUNQLElBQUk7U0FDRCxVQUFVLENBQUMsY0FBYyxFQUFFO1FBQzFCLElBQUksRUFBRSxRQUFRO1FBQ2QsSUFBSSxFQUFFLHdDQUF3QztRQUM5QyxPQUFPLEVBQUUsR0FBRztRQUNaLFNBQVMsRUFBRSxJQUFJO0tBQ2hCLENBQUM7U0FDRCxNQUFNLENBQUMsT0FBTyxFQUFFO1FBQ2YsS0FBSyxFQUFFLEdBQUc7UUFDVixJQUFJLEVBQUUsU0FBUztRQUNmLElBQUksRUFBRSxvREFBb0Q7S0FDM0QsQ0FBQztTQUNELE1BQU0sQ0FBQyxvQkFBb0IsRUFBRTtRQUM1QixLQUFLLEVBQUUsR0FBRztRQUNWLElBQUksRUFBRSxTQUFTO1FBQ2YsSUFBSSxFQUFFLHFGQUFxRjtLQUM1RixDQUFDO1NBQ0QsTUFBTSxDQUFDLHVCQUF1QixFQUFFO1FBQy9CLElBQUksRUFBRSxTQUFTO1FBQ2YsT0FBTyxFQUFFLElBQUk7UUFDYixJQUFJLEVBQUUsdUNBQXVDO1FBQzdDLE1BQU0sRUFBRSxJQUFJO0tBQ2IsQ0FB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RSxRQUFRO2dCQUNkLE1BQU0sRUFBRTtvQkFDTixJQUFJLEVBQUUsV0FBVzt3QkFDZixDQUFDLENBQUMsb0JBQW9CO3dCQUN0QixDQUFDLENBQUUsb0JBQTRCO2lCQUNsQzthQUNGO1NBQ0Y7UUFDRCxVQUFVLEVBQUU7WUFDVixPQUFPLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQUU7WUFDdkQscUdBQXFHO1lBQ3JHLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUNuQixTQUFTLEVBQUUsQ0FBQyxhQUFhLENBQUM7Z0JBQzFCLEtBQUssRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDekM7U0FDRjtLQUNGLENBQUMsQ0FBQztJQUVILFNBQVMsU0FBUyxDQUFDLGNBQWMsR0FBRyxTQUFTO1FBQzNDLFFBQVEsY0FBYyxFQUFFO1lBQ3RCLEtBQUssQ0FBQztnQkFDSixPQUFPLE1BQU0sQ0FBQztZQUNoQixLQUFLLENBQUM7Z0JBQ0osT0FBTyxNQUFNLENBQUM7WUFDaEIsS0FBSyxDQUFDO2dCQUNKLE9BQU8sT0FBTyxDQUFDO1lBQ2pCLEtBQUssQ0FBQztnQkFDSixPQUFPLE9BQU8sQ0FBQztZQUNqQjtnQkFDRSxPQUFPLEtBQUssQ0FBQztTQUNoQjtJQUNILENBQUM7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVO0FBQ2QsNENBQTRDO0FBQzVDLDZFQUE2RSxDQUFDO0FBRWhGLFNBQVMsU0FBUyxDQUFDLENBQVM7SUFDMUIsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNuQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdAanNpaS9jaGVjay1ub2RlL3J1bic7XG5cbmltcG9ydCAqIGFzIGxvZzRqcyBmcm9tICdsb2c0anMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyB5YXJncyBmcm9tICd5YXJncyc7XG5cbmltcG9ydCB7IENvbXBpbGVyIH0gZnJvbSAnLi4vbGliL2NvbXBpbGVyJztcbmltcG9ydCB7IGNvbmZpZ3VyZUNhdGVnb3JpZXMgfSBmcm9tICcuLi9saWIvanNpaS1kaWFnbm9zdGljJztcbmltcG9ydCB7IGxvYWRQcm9qZWN0SW5mbyB9IGZyb20gJy4uL2xpYi9wcm9qZWN0LWluZm8nO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vbGliL3V0aWxzJztcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tICcuLi9saWIvdmVyc2lvbic7XG5pbXBvcnQgeyBlbmFibGVkV2FybmluZ3MgfSBmcm9tICcuLi9saWIvd2FybmluZ3MnO1xuXG5jb25zdCB3YXJuaW5nVHlwZXMgPSBPYmplY3Qua2V5cyhlbmFibGVkV2FybmluZ3MpO1xuXG4oYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhcmd2ID0geWFyZ3NcbiAgICAuZW52KCdKU0lJJylcbiAgICAuY29tbWFuZChcbiAgICAgIFsnJDAgW1BST0pFQ1RfUk9PVF0nLCAnY29tcGlsZSBbUFJPSkVDVF9ST09UXSddLFxuICAgICAgJ0NvbXBpbGVzIGEganNpaS9UeXBlU2NyaXB0IHByb2plY3QnLFxuICAgICAgKGFyZ3YpID0+XG4gICAgICAgIGFyZ3ZcbiAgICAgICAgICAucG9zaXRpb25hbCgnUFJPSkVDVF9ST09UJywge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkZXNjOiAnVGhlIHJvb3Qgb2YgdGhlIHByb2plY3QgdG8gYmUgY29tcGlsZWQnLFxuICAgICAgICAgICAgZGVmYXVsdDogJy4nLFxuICAgICAgICAgICAgbm9ybWFsaXplOiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbignd2F0Y2gnLCB7XG4gICAgICAgICAgICBhbGlhczogJ3cnLFxuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVzYzogJ1dhdGNoIGZvciBmaWxlIGNoYW5nZXMgYW5kIHJlY29tcGlsZSBhdXRvbWF0aWNhbGx5JyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb24oJ3Byb2plY3QtcmVmZXJlbmNlcycsIHtcbiAgICAgICAgICAgIGFsaWFzOiAncicsXG4gICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICBkZXNjOiAnR2VuZXJhdGUgVHlwZVNjcmlwdCBwcm9qZWN0IHJlZmVyZW5jZXMgKGFsc28gW3BhY2thZ2UuanNvbl0uanNpaS5wcm9qZWN0UmVmZXJlbmNlcyknLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbignZml4LXBlZXItZGVwZW5kZW5jaWVzJywge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgIGRlc2M6ICdUaGlzIG9wdGlvbiBubyBsb25nZXIgaGFzIGFueSBlZmZlY3QuJyxcbiAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vcHRpb25zKCdmYWlsLW9uLXdhcm5pbmdzJywge1xuICAgICAgICAgICAgYWxpYXM6ICdXZXJyJyxcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlc2M6ICdUcmVhdCB3YXJuaW5ncyBhcyBlcnJvcnMnLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbignc2lsZW5jZS13YXJuaW5ncycsIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBkZWZhdWx0OiBbXSxcbiAgICAgICAgICAgIGRlc2M6IGBMaXN0IG9mIHdhcm5pbmdzIHRvIHNpbGVuY2UgKHdhcm5pbmdzOiAke3dhcm5pbmdUeXBlcy5qb2luKFxuICAgICAgICAgICAgICAnLCcsXG4gICAgICAgICAgICApfSlgLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbignc3RyaXAtZGVwcmVjYXRlZCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzYzogJ1tFWFBFUklNRU5UQUxdIEhpZGVzIGFsbCBAZGVwcmVjYXRlZCBtZW1iZXJzIGZyb20gdGhlIEFQSSAoaW1wbGVtZW50YXRpb25zIHJlbWFpbikuIElmIGFuIG9wdGlvbmFsIGZpbGUgbmFtZSBpcyBnaXZlbiwgb25seSBGUU5zIHByZXNlbnQgaW4gdGhlIGZpbGUgd2lsbCBiZSBzdHJpcHBlZC4nLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbignYWRkLWRlcHJlY2F0aW9uLXdhcm5pbmdzJywge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICBkZXNjOiAnW0VYUEVSSU1FTlRBTF0gSW5qZWN0cyB3YXJuaW5nIHN0YXRlbWVudHMgZm9yIGFsbCBkZXByZWNhdGVkIGVsZW1lbnRzLCB0byBiZSBwcmludGVkIGF0IHJ1bnRpbWUnLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9wdGlvbignZ2VuZXJhdGUtdHNjb25maWcnLCB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd0c2NvbmZpZy5qc29uJyxcbiAgICAgICAgICAgIGRlc2M6ICdOYW1lIG9mIHRoZSB0eXBlc2NyaXB0IGNvbmZpZ3VyYXRpb24gZmlsZSB0byBnZW5lcmF0ZSB3aXRoIGNvbXBpbGVyIHNldHRpbmdzJyxcbiAgICAgICAgICB9KSxcbiAgICApXG4gICAgLm9wdGlvbigndmVyYm9zZScsIHtcbiAgICAgIGFsaWFzOiAndicsXG4gICAgICB0eXBlOiAnY291bnQnLFxuICAgICAgZGVzYzogJ0luY3JlYXNlIHRoZSB2ZXJib3NpdHkgb2Ygb3V0cHV0JyxcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICB9KVxuICAgIC5oZWxwKClcbiAgICAudmVyc2lvbihcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICAgIGAke1ZFUlNJT059LCB0eXBlc2NyaXB0ICR7cmVxdWlyZSgndHlwZXNjcmlwdC9wYWNrYWdlLmpzb24nKS52ZXJzaW9ufWAsXG4gICAgKS5hcmd2O1xuXG4gIF9jb25maWd1cmVMb2c0anMoYXJndi52ZXJib3NlKTtcblxuICBjb25zdCBwcm9qZWN0Um9vdCA9IHBhdGgubm9ybWFsaXplKFxuICAgIHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBhcmd2LlBST0pFQ1RfUk9PVCksXG4gICk7XG5cbiAgY29uc3QgeyBwcm9qZWN0SW5mbywgZGlhZ25vc3RpY3M6IHByb2plY3RJbmZvRGlhZ25vc3RpY3MgfSA9XG4gICAgYXdhaXQgbG9hZFByb2plY3RJbmZvKHByb2plY3RSb290KTtcblxuICAvLyBkaXNhYmxlIGFsbCBzaWxlbmNlZCB3YXJuaW5nc1xuICBmb3IgKGNvbnN0IGtleSBvZiBhcmd2WydzaWxlbmNlLXdhcm5pbmdzJ10pIHtcbiAgICBpZiAoIShrZXkgaW4gZW5hYmxlZFdhcm5pbmdzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVW5rbm93biB3YXJuaW5nIHR5cGUgJHtcbiAgICAgICAgICBrZXkgYXMgYW55XG4gICAgICAgIH0uIE11c3QgYmUgb25lIG9mOiAke3dhcm5pbmdUeXBlcy5qb2luKCcsICcpfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGVuYWJsZWRXYXJuaW5nc1trZXldID0gZmFsc2U7XG4gIH1cblxuICBjb25maWd1cmVDYXRlZ29yaWVzKHByb2plY3RJbmZvLmRpYWdub3N0aWNzID8/IHt9KTtcblxuICBjb25zdCBjb21waWxlciA9IG5ldyBDb21waWxlcih7XG4gICAgcHJvamVjdEluZm8sXG4gICAgcHJvamVjdFJlZmVyZW5jZXM6IGFyZ3ZbJ3Byb2plY3QtcmVmZXJlbmNlcyddLFxuICAgIGZhaWxPbldhcm5pbmdzOiBhcmd2WydmYWlsLW9uLXdhcm5pbmdzJ10sXG4gICAgc3RyaXBEZXByZWNhdGVkOiAhIWFyZ3ZbJ3N0cmlwLWRlcHJlY2F0ZWQnXSxcbiAgICBzdHJpcERlcHJlY2F0ZWRBbGxvd0xpc3RGaWxlOiBhcmd2WydzdHJpcC1kZXByZWNhdGVkJ10sXG4gICAgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogYXJndlsnYWRkLWRlcHJlY2F0aW9uLXdhcm5pbmdzJ10sXG4gICAgZ2VuZXJhdGVUeXBlU2NyaXB0Q29uZmlnOiBhcmd2WydnZW5lcmF0ZS10c2NvbmZpZyddLFxuICB9KTtcblxuICBjb25zdCBlbWl0UmVzdWx0ID0gYXdhaXQgKGFyZ3Yud2F0Y2ggPyBjb21waWxlci53YXRjaCgpIDogY29tcGlsZXIuZW1pdCgpKTtcblxuICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IFsuLi5wcm9qZWN0SW5mb0RpYWdub3N0aWNzLCAuLi5lbWl0UmVzdWx0LmRpYWdub3N0aWNzXTtcblxuICBmb3IgKGNvbnN0IGRpYWdub3N0aWMgb2YgYWxsRGlhZ25vc3RpY3MpIHtcbiAgICB1dGlscy5sb2dEaWFnbm9zdGljKGRpYWdub3N0aWMsIHByb2plY3RSb290KTtcbiAgfVxuICBpZiAoZW1pdFJlc3VsdC5lbWl0U2tpcHBlZCkge1xuICAgIHByb2Nlc3MuZXhpdENvZGUgPSAxO1xuICB9XG59KSgpLmNhdGNoKChlKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYEVycm9yOiAke2Uuc3RhY2t9YCk7XG4gIHByb2Nlc3MuZXhpdENvZGUgPSAtMTtcbn0pO1xuXG5mdW5jdGlvbiBfY29uZmlndXJlTG9nNGpzKHZlcmJvc2l0eTogbnVtYmVyKSB7XG4gIGNvbnN0IHN0ZGVyckNvbG9yID0gISFwcm9jZXNzLnN0ZGVyci5pc1RUWTtcbiAgY29uc3Qgc3Rkb3V0Q29sb3IgPSAhIXByb2Nlc3Muc3Rkb3V0LmlzVFRZO1xuXG4gIGxvZzRqcy5hZGRMYXlvdXQoJ3Bhc3NUaHJvdWdoTm9Db2xvcicsICgpID0+IHtcbiAgICByZXR1cm4gKGxvZ2dpbmdFdmVudCkgPT4gc3RyaXBBbnNpKHV0aWwuZm9ybWF0KC4uLmxvZ2dpbmdFdmVudC5kYXRhKSk7XG4gIH0pO1xuXG4gIGxvZzRqcy5jb25maWd1cmUoe1xuICAgIGFwcGVuZGVyczoge1xuICAgICAgY29uc29sZToge1xuICAgICAgICB0eXBlOiAnc3RkZXJyJyxcbiAgICAgICAgbGF5b3V0OiB7IHR5cGU6IHN0ZGVyckNvbG9yID8gJ2NvbG9yZWQnIDogJ2Jhc2ljJyB9LFxuICAgICAgfSxcbiAgICAgIFt1dGlscy5ESUFHTk9TVElDU106IHtcbiAgICAgICAgdHlwZTogJ3N0ZG91dCcsXG4gICAgICAgIGxheW91dDoge1xuICAgICAgICAgIHR5cGU6IHN0ZG91dENvbG9yXG4gICAgICAgICAgICA/ICdtZXNzYWdlUGFzc1Rocm91Z2gnXG4gICAgICAgICAgICA6ICgncGFzc1Rocm91Z2hOb0NvbG9yJyBhcyBhbnkpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIGNhdGVnb3JpZXM6IHtcbiAgICAgIGRlZmF1bHQ6IHsgYXBwZW5kZXJzOiBbJ2NvbnNvbGUnXSwgbGV2ZWw6IF9sb2dMZXZlbCgpIH0sXG4gICAgICAvLyBUaGUgZGlhZ25vc3RpY3MgbG9nZ2VyIG11c3QgYmUgc2V0IHRvIElORk8gb3IgbW9yZSB2ZXJib3NlLCBvciB3YXRjaCB3b24ndCBzaG93IGltcG9ydGFudCBtZXNzYWdlc1xuICAgICAgW3V0aWxzLkRJQUdOT1NUSUNTXToge1xuICAgICAgICBhcHBlbmRlcnM6IFsnZGlhZ25vc3RpY3MnXSxcbiAgICAgICAgbGV2ZWw6IF9sb2dMZXZlbChNYXRoLm1heCh2ZXJib3NpdHksIDEpKSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gX2xvZ0xldmVsKHZlcmJvc2l0eUxldmVsID0gdmVyYm9zaXR5KToga2V5b2YgbG9nNGpzLkxldmVscyB7XG4gICAgc3dpdGNoICh2ZXJib3NpdHlMZXZlbCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gJ1dBUk4nO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJ0lORk8nO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gJ0RFQlVHJztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuICdUUkFDRSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ0FMTCc7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IEFOU0lfUkVHRVggPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1PUlpjZi1ucXJ5PT48XS9nO1xuXG5mdW5jdGlvbiBzdHJpcEFuc2koeDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHgucmVwbGFjZShBTlNJX1JFR0VYLCAnJyk7XG59XG4iXX0=