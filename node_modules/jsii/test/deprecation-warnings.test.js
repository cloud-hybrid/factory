"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line import/no-extraneous-dependencies
const fs = require("fs");
const path = require("path");
const lib_1 = require("../lib");
const compiler_1 = require("../lib/compiler");
const project_info_1 = require("../lib/project-info");
const DEPRECATED = '/** @deprecated Use something else */';
describe('Function generation', () => {
    test('generates the print function', async () => {
        const result = await lib_1.compileJsiiForTest(``, undefined /* callback */, {
            addDeprecationWarnings: true,
        });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function print(name, deprecationMessage) {
    const deprecated = process.env.JSII_DEPRECATED;
    const deprecationMode = ["warn", "fail", "quiet"].includes(deprecated) ? deprecated : "warn";
    const message = \`\${name} is deprecated.\\n  \${deprecationMessage}\\n  This API will be removed in the next major release.\`;
    switch (deprecationMode) {
        case "fail":
            throw new DeprecationError(message);
        case "warn":
            console.warn("[WARNING]", message);
            break;
    }
}
const visitedObjects = new Set();
class DeprecationError extends Error {
}
module.exports = { print };
module.exports.DeprecationError = DeprecationError;
`);
    });
    test('generates a function for each type', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Foo {}
        export interface Bar {}
        export interface Baz {}
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Foo(p) {
}
function testpkg_Bar(p) {
}
function testpkg_Baz(p) {
}`);
    });
    test('generates metadata', async () => {
        var _a, _b;
        const result = await lib_1.compileJsiiForTest(`
        export interface Foo {}
        export interface Bar {}
        export interface Baz {}
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect((_b = (_a = result.assembly.metadata) === null || _a === void 0 ? void 0 : _a.jsii) === null || _b === void 0 ? void 0 : _b.compiledWithDeprecationWarnings).toBe(true);
    });
    test('for each non-primitive property, generates a call', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Foo {}
        export interface Bar {}
        export interface Baz {
          readonly foo: Foo;
          readonly bar: Bar;
          readonly x: string;
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Baz(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if (!visitedObjects.has(p.bar))
        testpkg_Bar(p.bar);
    if (!visitedObjects.has(p.foo))
        testpkg_Foo(p.foo);
    visitedObjects.delete(p);
}`);
    });
    test('generates empty functions for interfaces', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface IFoo {
          bar(): string;
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_IFoo(p) {
}`);
    });
    test('generates empty functions for classes', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export class Foo {
          bar() {return 0};
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Foo(p) {
}`);
    });
    test('generates calls for recursive types', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Bar {readonly bar?: Bar}
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Bar(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if (!visitedObjects.has(p.bar))
        testpkg_Bar(p.bar);
    visitedObjects.delete(p);
}`);
    });
    test('generates exports for all the functions', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Foo {}
        export interface Bar {}
        export interface Baz {}
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`module.exports = { print, testpkg_Foo, testpkg_Bar, testpkg_Baz };`);
    });
    test('generates functions for enums', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export enum State {
          ON,

          ${DEPRECATED}
          OFF
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii'))
            .toMatch(`function testpkg_State(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    const ns = require("./index.js");
    if (Object.values(ns.State).filter(x => x === p).length > 1)
        return;
    if (p === ns.State.OFF)
        print("testpkg.State#OFF", "Use something else");
    visitedObjects.delete(p);
}
`);
    });
    test('generates calls for deprecated inherited properties', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Baz {
          /** @deprecated message from Baz */
          readonly x: string;          
        }
        export interface Bar {
          /** @deprecated message from Bar */
          readonly x: string;          
        }
        export interface Foo extends Bar, Baz {
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        const warningsFileContent = jsFile(result, '.warnings.jsii');
        // For each supertype, its corresponding function should be generated, as usual
        expect(warningsFileContent).toMatch(`function testpkg_Baz(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("x" in p)
        print("testpkg.Baz#x", "message from Baz");
    visitedObjects.delete(p);
}`);
        expect(warningsFileContent).toMatch(`function testpkg_Bar(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("x" in p)
        print("testpkg.Bar#x", "message from Bar");
    visitedObjects.delete(p);
}`);
        // But a call for one of the instances of the property should also be generated in the base function
        expect(warningsFileContent).toMatch(`function testpkg_Foo(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("x" in p)
        print("testpkg.Baz#x", "message from Baz");
    visitedObjects.delete(p);
}`);
    });
    test('skips properties that are deprecated in one supertype but not the other', async () => {
        const result = await lib_1.compileJsiiForTest(`
        export interface Baz {
          readonly x: string;          
        }
        export interface Bar {
          /** @deprecated message from Bar */
          readonly x: string;          
        }
        export interface Foo extends Bar, Baz {
        }
        `, undefined /* callback */, { addDeprecationWarnings: true });
        const warningsFileContent = jsFile(result, '.warnings.jsii');
        expect(warningsFileContent).toMatch(`function testpkg_Foo(p) {
}`);
    });
    test('generates calls for types with deprecated properties', async () => {
        const result = await lib_1.compileJsiiForTest(`
      export interface Bar {
        readonly x: string;
      }

      export interface Foo {
        readonly y: string;

        /** @deprecated kkkkkkkk */
        readonly bar: Bar;
      }
      `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Foo(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("bar" in p)
        print("testpkg.Foo#bar", "kkkkkkkk");
    if (!visitedObjects.has(p.bar))
        testpkg_Bar(p.bar);
    visitedObjects.delete(p);
}
`);
    });
    test('generates calls for each property of a deprecated type', async () => {
        const result = await lib_1.compileJsiiForTest(`
      /** @deprecated use Bar instead */
      export interface Foo {
        readonly bar: string;
        readonly baz: number;
      }
      `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result, '.warnings.jsii')).toMatch(`function testpkg_Foo(p) {
    if (p == null)
        return;
    visitedObjects.add(p);
    if ("bar" in p)
        print("testpkg.Foo#bar", "use Bar instead");
    if ("baz" in p)
        print("testpkg.Foo#baz", "use Bar instead");
    visitedObjects.delete(p);
}
`);
    });
    test('generates calls for types in other assemblies', async () => {
        const calcBaseOfBaseRoot = resolveModuleDir('@scope/jsii-calc-base-of-base');
        const calcBaseRoot = resolveModuleDir('@scope/jsii-calc-base');
        const calcLibRoot = resolveModuleDir('@scope/jsii-calc-lib');
        await compile(calcBaseOfBaseRoot, false);
        await compile(calcBaseRoot, true);
        await compile(calcLibRoot, true);
        const warningsFile = loadWarningsFile(calcBaseRoot);
        // jsii-calc-base was compiled with warnings. So we expect to see handlers for its types in the warnings file
        expect(warningsFile).toMatch('_scope_jsii_calc_base');
        // jsii-calc-base-of-base was not compiled with warnings. Its types shouldn't be in the warnings file
        expect(warningsFile).not.toMatch('_scope_jsii_calc_base_of_base');
        // Recompiling without deprecation warning to leave the packages in a clean state
        await compile(calcBaseRoot, false);
        await compile(calcLibRoot, false);
    }, 50000);
});
describe('Call injections', () => {
    test('does not add warnings by default', async () => {
        var _a, _b;
        const result = await lib_1.compileJsiiForTest(`
    export class Foo {
      ${DEPRECATED}
      public bar(){}
    }
  `);
        expect(jsFile(result)).toMatch('bar() { }');
        expect((_b = (_a = result.assembly.metadata) === null || _a === void 0 ? void 0 : _a.jsii) === null || _b === void 0 ? void 0 : _b.compiledWithDeprecationWarnings).toBeFalsy();
    });
    test('generates a require statement', async () => {
        const result = await lib_1.compileJsiiForTest({
            'index.ts': `export * from './some/folder/source'`,
            'some/folder/source.ts': `
          export class Foo {
            ${DEPRECATED}
            public bar(){}
          }
        `,
        }, undefined /* callback */, { addDeprecationWarnings: true });
        const expectedPath = ['..', '..', '.warnings.jsii.js'].join('/');
        const content = jsFile(result, 'some/folder/source');
        expect(content).toContain(`const jsiiDeprecationWarnings = require("${expectedPath}")`);
    });
    test('does not generate a require statement when no calls were injected', async () => {
        const result = await lib_1.compileJsiiForTest({
            'index.ts': `export * from './some/folder/handler'`,
            'some/folder/handler.ts': `
          export function handler(event: any) { return event; }
        `,
        }, undefined /* callback */, { addDeprecationWarnings: true });
        const expectedPath = ['..', '..', '.warnings.jsii.js'].join('/');
        const content = jsFile(result, 'some/folder/handler');
        expect(content).not.toContain(`const jsiiDeprecationWarnings = require("${expectedPath}")`);
    });
    test('deprecated methods', async () => {
        const result = await lib_1.compileJsiiForTest(`
    export class Foo {
      ${DEPRECATED}
      public bar(){}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('bar() { jsiiDeprecationWarnings.print("testpkg.Foo#bar", "Use something else"); }');
    });
    test('methods with parameters', async () => {
        const result = await lib_1.compileJsiiForTest(`
    export interface A {readonly x: number;}
    export class Foo {
      public bar(a: A, b: number){return a.x + b;}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('bar(a, b) { jsiiDeprecationWarnings.testpkg_A(a); return a.x + b; }');
    });
    test('deprecated getters', async () => {
        const result = await lib_1.compileJsiiForTest(`
    export class Foo {
      private _x = 0;
      ${DEPRECATED}
      public get x(){return this._x}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('get x() { jsiiDeprecationWarnings.print("testpkg.Foo#x", "Use something else"); return this._x; }');
    });
    test('deprecated setters', async () => {
        const result = await lib_1.compileJsiiForTest(`
    export class Foo {
      private _x = 0;
      public get x(){return this._x}

      ${DEPRECATED}
      public set x(_x: number) {this._x = _x;}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('set x(_x) { jsiiDeprecationWarnings.print("testpkg.Foo#x", "Use something else"); this._x = _x; }');
    });
    test('deprecated classes', async () => {
        const result = await lib_1.compileJsiiForTest(`
    ${DEPRECATED}
    export class Foo {
      constructor(){}
    }
  `, undefined /* callback */, { addDeprecationWarnings: true });
        expect(jsFile(result)).toMatch('constructor() { jsiiDeprecationWarnings.print("testpkg.Foo", "Use something else"); }');
    });
});
function jsFile(result, baseName = 'index') {
    const file = Object.entries(result.files).find(([name]) => name === `${baseName}.js`);
    return file[1];
}
function resolveModuleDir(name) {
    return path.dirname(require.resolve(`${name}/package.json`));
}
async function compile(projectRoot, addDeprecationWarnings) {
    const { projectInfo } = await project_info_1.loadProjectInfo(projectRoot);
    const compiler = new compiler_1.Compiler({
        projectInfo,
        addDeprecationWarnings,
    });
    await compiler.emit();
}
function loadWarningsFile(projectRoot) {
    return fs
        .readFileSync(path.join(projectRoot, '.warnings.jsii.js'))
        .toString();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwcmVjYXRpb24td2FybmluZ3MudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlcHJlY2F0aW9uLXdhcm5pbmdzLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSw2REFBNkQ7QUFDN0QseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUU3QixnQ0FBcUU7QUFDckUsOENBQTJDO0FBQzNDLHNEQUFzRDtBQUV0RCxNQUFNLFVBQVUsR0FBRyx1Q0FBdUMsQ0FBQztBQUUzRCxRQUFRLENBQUMscUJBQXFCLEVBQUUsR0FBRyxFQUFFO0lBQ25DLElBQUksQ0FBQyw4QkFBOEIsRUFBRSxLQUFLLElBQUksRUFBRTtRQUM5QyxNQUFNLE1BQU0sR0FBRyxNQUFNLHdCQUFrQixDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsY0FBYyxFQUFFO1lBQ3BFLHNCQUFzQixFQUFFLElBQUk7U0FDN0IsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FDOUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJMLENBQ0ksQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLG9DQUFvQyxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ3BELE1BQU0sTUFBTSxHQUFHLE1BQU0sd0JBQWtCLENBQ3JDOzs7O1NBSUcsRUFDSCxTQUFTLENBQUMsY0FBYyxFQUN4QixFQUFFLHNCQUFzQixFQUFFLElBQUksRUFBRSxDQUNqQyxDQUFDO1FBRUYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FDOUM7Ozs7O0VBS0osQ0FDRyxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsb0JBQW9CLEVBQUUsS0FBSyxJQUFJLEVBQUU7O1FBQ3BDLE1BQU0sTUFBTSxHQUFHLE1BQU0sd0JBQWtCLENBQ3JDOzs7O1NB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LEdBQUcsT0FBTztJQUNqRSxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQzVDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLEdBQUcsUUFBUSxLQUFLLENBQ3RDLENBQUM7SUFFRixPQUFPLElBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQixDQUFDO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFZO0lBQ3BDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxlQUFlLENBQUMsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFFRCxLQUFLLFVBQVUsT0FBTyxDQUFDLFdBQW1CLEVBQUUsc0JBQStCO0lBQ3pFLE1BQU0sRUFBRSxXQUFXLEVBQUUsR0FBRyxNQUFNLDhCQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFM0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxtQkFBUSxDQUFDO1FBQzVCLFdBQVc7UUFDWCxzQkFBc0I7S0FDdkIsQ0FBQyxDQUFDO0lBRUgsTUFBTSxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDeEIsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsV0FBbUI7SUFDM0MsT0FBTyxFQUFFO1NBQ04sWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLG1CQUFtQixDQUFDLENBQUM7U0FDekQsUUFBUSxFQUFFLENBQUM7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IGNvbXBpbGVKc2lpRm9yVGVzdCwgSGVscGVyQ29tcGlsYXRpb25SZXN1bHQgfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgQ29tcGlsZXIgfSBmcm9tICcuLi9saWIvY29tcGlsZXInO1xuaW1wb3J0IHsgbG9hZFByb2plY3RJbmZvIH0gZnJvbSAnLi4vbGliL3Byb2plY3QtaW5mbyc7XG5cbmNvbnN0IERFUFJFQ0FURUQgPSAnLyoqIEBkZXByZWNhdGVkIFVzZSBzb21ldGhpbmcgZWxzZSAqLyc7XG5cbmRlc2NyaWJlKCdGdW5jdGlvbiBnZW5lcmF0aW9uJywgKCkgPT4ge1xuICB0ZXN0KCdnZW5lcmF0ZXMgdGhlIHByaW50IGZ1bmN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChgYCwgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLCB7XG4gICAgICBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQsICcud2FybmluZ3MuanNpaScpKS50b01hdGNoKFxuICAgICAgYGZ1bmN0aW9uIHByaW50KG5hbWUsIGRlcHJlY2F0aW9uTWVzc2FnZSkge1xuICAgIGNvbnN0IGRlcHJlY2F0ZWQgPSBwcm9jZXNzLmVudi5KU0lJX0RFUFJFQ0FURUQ7XG4gICAgY29uc3QgZGVwcmVjYXRpb25Nb2RlID0gW1wid2FyblwiLCBcImZhaWxcIiwgXCJxdWlldFwiXS5pbmNsdWRlcyhkZXByZWNhdGVkKSA/IGRlcHJlY2F0ZWQgOiBcIndhcm5cIjtcbiAgICBjb25zdCBtZXNzYWdlID0gXFxgXFwke25hbWV9IGlzIGRlcHJlY2F0ZWQuXFxcXG4gIFxcJHtkZXByZWNhdGlvbk1lc3NhZ2V9XFxcXG4gIFRoaXMgQVBJIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxcYDtcbiAgICBzd2l0Y2ggKGRlcHJlY2F0aW9uTW9kZSkge1xuICAgICAgICBjYXNlIFwiZmFpbFwiOlxuICAgICAgICAgICAgdGhyb3cgbmV3IERlcHJlY2F0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGNhc2UgXCJ3YXJuXCI6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR11cIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5jb25zdCB2aXNpdGVkT2JqZWN0cyA9IG5ldyBTZXQoKTtcbmNsYXNzIERlcHJlY2F0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHsgcHJpbnQgfTtcbm1vZHVsZS5leHBvcnRzLkRlcHJlY2F0aW9uRXJyb3IgPSBEZXByZWNhdGlvbkVycm9yO1xuYCxcbiAgICApO1xuICB9KTtcblxuICB0ZXN0KCdnZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgZWFjaCB0eXBlJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGb28ge31cbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBCYXIge31cbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBCYXoge31cbiAgICAgICAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCwgJy53YXJuaW5ncy5qc2lpJykpLnRvTWF0Y2goXG4gICAgICBgZnVuY3Rpb24gdGVzdHBrZ19Gb28ocCkge1xufVxuZnVuY3Rpb24gdGVzdHBrZ19CYXIocCkge1xufVxuZnVuY3Rpb24gdGVzdHBrZ19CYXoocCkge1xufWAsXG4gICAgKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIG1ldGFkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGb28ge31cbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBCYXIge31cbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBCYXoge31cbiAgICAgICAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG4gICAgZXhwZWN0KFxuICAgICAgcmVzdWx0LmFzc2VtYmx5Lm1ldGFkYXRhPy5qc2lpPy5jb21waWxlZFdpdGhEZXByZWNhdGlvbldhcm5pbmdzLFxuICAgICkudG9CZSh0cnVlKTtcbiAgfSk7XG5cbiAgdGVzdCgnZm9yIGVhY2ggbm9uLXByaW1pdGl2ZSBwcm9wZXJ0eSwgZ2VuZXJhdGVzIGEgY2FsbCcsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRm9vIHt9XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmFyIHt9XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmF6IHtcbiAgICAgICAgICByZWFkb25seSBmb286IEZvbztcbiAgICAgICAgICByZWFkb25seSBiYXI6IEJhcjtcbiAgICAgICAgICByZWFkb25seSB4OiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCwgJy53YXJuaW5ncy5qc2lpJykpLnRvTWF0Y2goYGZ1bmN0aW9uIHRlc3Rwa2dfQmF6KHApIHtcbiAgICBpZiAocCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgdmlzaXRlZE9iamVjdHMuYWRkKHApO1xuICAgIGlmICghdmlzaXRlZE9iamVjdHMuaGFzKHAuYmFyKSlcbiAgICAgICAgdGVzdHBrZ19CYXIocC5iYXIpO1xuICAgIGlmICghdmlzaXRlZE9iamVjdHMuaGFzKHAuZm9vKSlcbiAgICAgICAgdGVzdHBrZ19Gb28ocC5mb28pO1xuICAgIHZpc2l0ZWRPYmplY3RzLmRlbGV0ZShwKTtcbn1gKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGVtcHR5IGZ1bmN0aW9ucyBmb3IgaW50ZXJmYWNlcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgSUZvbyB7XG4gICAgICAgICAgYmFyKCk6IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0LCAnLndhcm5pbmdzLmpzaWknKSkudG9NYXRjaChgZnVuY3Rpb24gdGVzdHBrZ19JRm9vKHApIHtcbn1gKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGVtcHR5IGZ1bmN0aW9ucyBmb3IgY2xhc3NlcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgICAgICAgIGJhcigpIHtyZXR1cm4gMH07XG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCwgJy53YXJuaW5ncy5qc2lpJykpLnRvTWF0Y2goYGZ1bmN0aW9uIHRlc3Rwa2dfRm9vKHApIHtcbn1gKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGNhbGxzIGZvciByZWN1cnNpdmUgdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJhciB7cmVhZG9ubHkgYmFyPzogQmFyfVxuICAgICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0LCAnLndhcm5pbmdzLmpzaWknKSkudG9NYXRjaChcbiAgICAgIGBmdW5jdGlvbiB0ZXN0cGtnX0JhcihwKSB7XG4gICAgaWYgKHAgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpc2l0ZWRPYmplY3RzLmFkZChwKTtcbiAgICBpZiAoIXZpc2l0ZWRPYmplY3RzLmhhcyhwLmJhcikpXG4gICAgICAgIHRlc3Rwa2dfQmFyKHAuYmFyKTtcbiAgICB2aXNpdGVkT2JqZWN0cy5kZWxldGUocCk7XG59YCxcbiAgICApO1xuICB9KTtcblxuICB0ZXN0KCdnZW5lcmF0ZXMgZXhwb3J0cyBmb3IgYWxsIHRoZSBmdW5jdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEZvbyB7fVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJhciB7fVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJheiB7fVxuICAgICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0LCAnLndhcm5pbmdzLmpzaWknKSkudG9NYXRjaChcbiAgICAgIGBtb2R1bGUuZXhwb3J0cyA9IHsgcHJpbnQsIHRlc3Rwa2dfRm9vLCB0ZXN0cGtnX0JhciwgdGVzdHBrZ19CYXogfTtgLFxuICAgICk7XG4gIH0pO1xuXG4gIHRlc3QoJ2dlbmVyYXRlcyBmdW5jdGlvbnMgZm9yIGVudW1zJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICAgICAgZXhwb3J0IGVudW0gU3RhdGUge1xuICAgICAgICAgIE9OLFxuXG4gICAgICAgICAgJHtERVBSRUNBVEVEfVxuICAgICAgICAgIE9GRlxuICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQsICcud2FybmluZ3MuanNpaScpKVxuICAgICAgLnRvTWF0Y2goYGZ1bmN0aW9uIHRlc3Rwa2dfU3RhdGUocCkge1xuICAgIGlmIChwID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICB2aXNpdGVkT2JqZWN0cy5hZGQocCk7XG4gICAgY29uc3QgbnMgPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhucy5TdGF0ZSkuZmlsdGVyKHggPT4geCA9PT0gcCkubGVuZ3RoID4gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChwID09PSBucy5TdGF0ZS5PRkYpXG4gICAgICAgIHByaW50KFwidGVzdHBrZy5TdGF0ZSNPRkZcIiwgXCJVc2Ugc29tZXRoaW5nIGVsc2VcIik7XG4gICAgdmlzaXRlZE9iamVjdHMuZGVsZXRlKHApO1xufVxuYCk7XG4gIH0pO1xuXG4gIHRlc3QoJ2dlbmVyYXRlcyBjYWxscyBmb3IgZGVwcmVjYXRlZCBpbmhlcml0ZWQgcHJvcGVydGllcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmF6IHtcbiAgICAgICAgICAvKiogQGRlcHJlY2F0ZWQgbWVzc2FnZSBmcm9tIEJheiAqL1xuICAgICAgICAgIHJlYWRvbmx5IHg6IHN0cmluZzsgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBCYXIge1xuICAgICAgICAgIC8qKiBAZGVwcmVjYXRlZCBtZXNzYWdlIGZyb20gQmFyICovXG4gICAgICAgICAgcmVhZG9ubHkgeDogc3RyaW5nOyAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEZvbyBleHRlbmRzIEJhciwgQmF6IHtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IHdhcm5pbmdzRmlsZUNvbnRlbnQgPSBqc0ZpbGUocmVzdWx0LCAnLndhcm5pbmdzLmpzaWknKTtcblxuICAgIC8vIEZvciBlYWNoIHN1cGVydHlwZSwgaXRzIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb24gc2hvdWxkIGJlIGdlbmVyYXRlZCwgYXMgdXN1YWxcbiAgICBleHBlY3Qod2FybmluZ3NGaWxlQ29udGVudCkudG9NYXRjaChgZnVuY3Rpb24gdGVzdHBrZ19CYXoocCkge1xuICAgIGlmIChwID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICB2aXNpdGVkT2JqZWN0cy5hZGQocCk7XG4gICAgaWYgKFwieFwiIGluIHApXG4gICAgICAgIHByaW50KFwidGVzdHBrZy5CYXojeFwiLCBcIm1lc3NhZ2UgZnJvbSBCYXpcIik7XG4gICAgdmlzaXRlZE9iamVjdHMuZGVsZXRlKHApO1xufWApO1xuICAgIGV4cGVjdCh3YXJuaW5nc0ZpbGVDb250ZW50KS50b01hdGNoKGBmdW5jdGlvbiB0ZXN0cGtnX0JhcihwKSB7XG4gICAgaWYgKHAgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpc2l0ZWRPYmplY3RzLmFkZChwKTtcbiAgICBpZiAoXCJ4XCIgaW4gcClcbiAgICAgICAgcHJpbnQoXCJ0ZXN0cGtnLkJhciN4XCIsIFwibWVzc2FnZSBmcm9tIEJhclwiKTtcbiAgICB2aXNpdGVkT2JqZWN0cy5kZWxldGUocCk7XG59YCk7XG5cbiAgICAvLyBCdXQgYSBjYWxsIGZvciBvbmUgb2YgdGhlIGluc3RhbmNlcyBvZiB0aGUgcHJvcGVydHkgc2hvdWxkIGFsc28gYmUgZ2VuZXJhdGVkIGluIHRoZSBiYXNlIGZ1bmN0aW9uXG4gICAgZXhwZWN0KHdhcm5pbmdzRmlsZUNvbnRlbnQpLnRvTWF0Y2goYGZ1bmN0aW9uIHRlc3Rwa2dfRm9vKHApIHtcbiAgICBpZiAocCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgdmlzaXRlZE9iamVjdHMuYWRkKHApO1xuICAgIGlmIChcInhcIiBpbiBwKVxuICAgICAgICBwcmludChcInRlc3Rwa2cuQmF6I3hcIiwgXCJtZXNzYWdlIGZyb20gQmF6XCIpO1xuICAgIHZpc2l0ZWRPYmplY3RzLmRlbGV0ZShwKTtcbn1gKTtcbiAgfSk7XG5cbiAgdGVzdCgnc2tpcHMgcHJvcGVydGllcyB0aGF0IGFyZSBkZXByZWNhdGVkIGluIG9uZSBzdXBlcnR5cGUgYnV0IG5vdCB0aGUgb3RoZXInLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJheiB7XG4gICAgICAgICAgcmVhZG9ubHkgeDogc3RyaW5nOyAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJhciB7XG4gICAgICAgICAgLyoqIEBkZXByZWNhdGVkIG1lc3NhZ2UgZnJvbSBCYXIgKi9cbiAgICAgICAgICByZWFkb25seSB4OiBzdHJpbmc7ICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRm9vIGV4dGVuZHMgQmFyLCBCYXoge1xuICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgY29uc3Qgd2FybmluZ3NGaWxlQ29udGVudCA9IGpzRmlsZShyZXN1bHQsICcud2FybmluZ3MuanNpaScpO1xuXG4gICAgZXhwZWN0KHdhcm5pbmdzRmlsZUNvbnRlbnQpLnRvTWF0Y2goYGZ1bmN0aW9uIHRlc3Rwa2dfRm9vKHApIHtcbn1gKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGNhbGxzIGZvciB0eXBlcyB3aXRoIGRlcHJlY2F0ZWQgcHJvcGVydGllcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEJhciB7XG4gICAgICAgIHJlYWRvbmx5IHg6IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IGludGVyZmFjZSBGb28ge1xuICAgICAgICByZWFkb25seSB5OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIGtra2tra2trICovXG4gICAgICAgIHJlYWRvbmx5IGJhcjogQmFyO1xuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCwgJy53YXJuaW5ncy5qc2lpJykpLnRvTWF0Y2goYGZ1bmN0aW9uIHRlc3Rwa2dfRm9vKHApIHtcbiAgICBpZiAocCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgdmlzaXRlZE9iamVjdHMuYWRkKHApO1xuICAgIGlmIChcImJhclwiIGluIHApXG4gICAgICAgIHByaW50KFwidGVzdHBrZy5Gb28jYmFyXCIsIFwia2tra2tra2tcIik7XG4gICAgaWYgKCF2aXNpdGVkT2JqZWN0cy5oYXMocC5iYXIpKVxuICAgICAgICB0ZXN0cGtnX0JhcihwLmJhcik7XG4gICAgdmlzaXRlZE9iamVjdHMuZGVsZXRlKHApO1xufVxuYCk7XG4gIH0pO1xuXG4gIHRlc3QoJ2dlbmVyYXRlcyBjYWxscyBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBhIGRlcHJlY2F0ZWQgdHlwZScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICBgXG4gICAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIEJhciBpbnN0ZWFkICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZvbyB7XG4gICAgICAgIHJlYWRvbmx5IGJhcjogc3RyaW5nO1xuICAgICAgICByZWFkb25seSBiYXo6IG51bWJlcjtcbiAgICAgIH1cbiAgICAgIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQsICcud2FybmluZ3MuanNpaScpKS50b01hdGNoKGBmdW5jdGlvbiB0ZXN0cGtnX0ZvbyhwKSB7XG4gICAgaWYgKHAgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpc2l0ZWRPYmplY3RzLmFkZChwKTtcbiAgICBpZiAoXCJiYXJcIiBpbiBwKVxuICAgICAgICBwcmludChcInRlc3Rwa2cuRm9vI2JhclwiLCBcInVzZSBCYXIgaW5zdGVhZFwiKTtcbiAgICBpZiAoXCJiYXpcIiBpbiBwKVxuICAgICAgICBwcmludChcInRlc3Rwa2cuRm9vI2JhelwiLCBcInVzZSBCYXIgaW5zdGVhZFwiKTtcbiAgICB2aXNpdGVkT2JqZWN0cy5kZWxldGUocCk7XG59XG5gKTtcbiAgfSk7XG5cbiAgdGVzdCgnZ2VuZXJhdGVzIGNhbGxzIGZvciB0eXBlcyBpbiBvdGhlciBhc3NlbWJsaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNhbGNCYXNlT2ZCYXNlUm9vdCA9IHJlc29sdmVNb2R1bGVEaXIoXG4gICAgICAnQHNjb3BlL2pzaWktY2FsYy1iYXNlLW9mLWJhc2UnLFxuICAgICk7XG4gICAgY29uc3QgY2FsY0Jhc2VSb290ID0gcmVzb2x2ZU1vZHVsZURpcignQHNjb3BlL2pzaWktY2FsYy1iYXNlJyk7XG4gICAgY29uc3QgY2FsY0xpYlJvb3QgPSByZXNvbHZlTW9kdWxlRGlyKCdAc2NvcGUvanNpaS1jYWxjLWxpYicpO1xuXG4gICAgYXdhaXQgY29tcGlsZShjYWxjQmFzZU9mQmFzZVJvb3QsIGZhbHNlKTtcbiAgICBhd2FpdCBjb21waWxlKGNhbGNCYXNlUm9vdCwgdHJ1ZSk7XG4gICAgYXdhaXQgY29tcGlsZShjYWxjTGliUm9vdCwgdHJ1ZSk7XG4gICAgY29uc3Qgd2FybmluZ3NGaWxlID0gbG9hZFdhcm5pbmdzRmlsZShjYWxjQmFzZVJvb3QpO1xuXG4gICAgLy8ganNpaS1jYWxjLWJhc2Ugd2FzIGNvbXBpbGVkIHdpdGggd2FybmluZ3MuIFNvIHdlIGV4cGVjdCB0byBzZWUgaGFuZGxlcnMgZm9yIGl0cyB0eXBlcyBpbiB0aGUgd2FybmluZ3MgZmlsZVxuICAgIGV4cGVjdCh3YXJuaW5nc0ZpbGUpLnRvTWF0Y2goJ19zY29wZV9qc2lpX2NhbGNfYmFzZScpO1xuXG4gICAgLy8ganNpaS1jYWxjLWJhc2Utb2YtYmFzZSB3YXMgbm90IGNvbXBpbGVkIHdpdGggd2FybmluZ3MuIEl0cyB0eXBlcyBzaG91bGRuJ3QgYmUgaW4gdGhlIHdhcm5pbmdzIGZpbGVcbiAgICBleHBlY3Qod2FybmluZ3NGaWxlKS5ub3QudG9NYXRjaCgnX3Njb3BlX2pzaWlfY2FsY19iYXNlX29mX2Jhc2UnKTtcblxuICAgIC8vIFJlY29tcGlsaW5nIHdpdGhvdXQgZGVwcmVjYXRpb24gd2FybmluZyB0byBsZWF2ZSB0aGUgcGFja2FnZXMgaW4gYSBjbGVhbiBzdGF0ZVxuICAgIGF3YWl0IGNvbXBpbGUoY2FsY0Jhc2VSb290LCBmYWxzZSk7XG4gICAgYXdhaXQgY29tcGlsZShjYWxjTGliUm9vdCwgZmFsc2UpO1xuICB9LCA1MDAwMCk7XG59KTtcblxuZGVzY3JpYmUoJ0NhbGwgaW5qZWN0aW9ucycsICgpID0+IHtcbiAgdGVzdCgnZG9lcyBub3QgYWRkIHdhcm5pbmdzIGJ5IGRlZmF1bHQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgICAgJHtERVBSRUNBVEVEfVxuICAgICAgcHVibGljIGJhcigpe31cbiAgICB9XG4gIGAsXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0KSkudG9NYXRjaCgnYmFyKCkgeyB9Jyk7XG4gICAgZXhwZWN0KFxuICAgICAgcmVzdWx0LmFzc2VtYmx5Lm1ldGFkYXRhPy5qc2lpPy5jb21waWxlZFdpdGhEZXByZWNhdGlvbldhcm5pbmdzLFxuICAgICkudG9CZUZhbHN5KCk7XG4gIH0pO1xuXG4gIHRlc3QoJ2dlbmVyYXRlcyBhIHJlcXVpcmUgc3RhdGVtZW50JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIHtcbiAgICAgICAgJ2luZGV4LnRzJzogYGV4cG9ydCAqIGZyb20gJy4vc29tZS9mb2xkZXIvc291cmNlJ2AsXG4gICAgICAgICdzb21lL2ZvbGRlci9zb3VyY2UudHMnOiBgXG4gICAgICAgICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICAgICAgICAke0RFUFJFQ0FURUR9XG4gICAgICAgICAgICBwdWJsaWMgYmFyKCl7fVxuICAgICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgIH0sXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgY29uc3QgZXhwZWN0ZWRQYXRoID0gWycuLicsICcuLicsICcud2FybmluZ3MuanNpaS5qcyddLmpvaW4oJy8nKTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBqc0ZpbGUocmVzdWx0LCAnc29tZS9mb2xkZXIvc291cmNlJyk7XG4gICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbihcbiAgICAgIGBjb25zdCBqc2lpRGVwcmVjYXRpb25XYXJuaW5ncyA9IHJlcXVpcmUoXCIke2V4cGVjdGVkUGF0aH1cIilgLFxuICAgICk7XG4gIH0pO1xuXG4gIHRlc3QoJ2RvZXMgbm90IGdlbmVyYXRlIGEgcmVxdWlyZSBzdGF0ZW1lbnQgd2hlbiBubyBjYWxscyB3ZXJlIGluamVjdGVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIHtcbiAgICAgICAgJ2luZGV4LnRzJzogYGV4cG9ydCAqIGZyb20gJy4vc29tZS9mb2xkZXIvaGFuZGxlcidgLFxuICAgICAgICAnc29tZS9mb2xkZXIvaGFuZGxlci50cyc6IGBcbiAgICAgICAgICBleHBvcnQgZnVuY3Rpb24gaGFuZGxlcihldmVudDogYW55KSB7IHJldHVybiBldmVudDsgfVxuICAgICAgICBgLFxuICAgICAgfSxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBjb25zdCBleHBlY3RlZFBhdGggPSBbJy4uJywgJy4uJywgJy53YXJuaW5ncy5qc2lpLmpzJ10uam9pbignLycpO1xuXG4gICAgY29uc3QgY29udGVudCA9IGpzRmlsZShyZXN1bHQsICdzb21lL2ZvbGRlci9oYW5kbGVyJyk7XG4gICAgZXhwZWN0KGNvbnRlbnQpLm5vdC50b0NvbnRhaW4oXG4gICAgICBgY29uc3QganNpaURlcHJlY2F0aW9uV2FybmluZ3MgPSByZXF1aXJlKFwiJHtleHBlY3RlZFBhdGh9XCIpYCxcbiAgICApO1xuICB9KTtcblxuICB0ZXN0KCdkZXByZWNhdGVkIG1ldGhvZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgIGV4cG9ydCBjbGFzcyBGb28ge1xuICAgICAgJHtERVBSRUNBVEVEfVxuICAgICAgcHVibGljIGJhcigpe31cbiAgICB9XG4gIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQpKS50b01hdGNoKFxuICAgICAgJ2JhcigpIHsganNpaURlcHJlY2F0aW9uV2FybmluZ3MucHJpbnQoXCJ0ZXN0cGtnLkZvbyNiYXJcIiwgXCJVc2Ugc29tZXRoaW5nIGVsc2VcIik7IH0nLFxuICAgICk7XG4gIH0pO1xuXG4gIHRlc3QoJ21ldGhvZHMgd2l0aCBwYXJhbWV0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICBleHBvcnQgaW50ZXJmYWNlIEEge3JlYWRvbmx5IHg6IG51bWJlcjt9XG4gICAgZXhwb3J0IGNsYXNzIEZvbyB7XG4gICAgICBwdWJsaWMgYmFyKGE6IEEsIGI6IG51bWJlcil7cmV0dXJuIGEueCArIGI7fVxuICAgIH1cbiAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCkpLnRvTWF0Y2goXG4gICAgICAnYmFyKGEsIGIpIHsganNpaURlcHJlY2F0aW9uV2FybmluZ3MudGVzdHBrZ19BKGEpOyByZXR1cm4gYS54ICsgYjsgfScsXG4gICAgKTtcbiAgfSk7XG5cbiAgdGVzdCgnZGVwcmVjYXRlZCBnZXR0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgIHByaXZhdGUgX3ggPSAwO1xuICAgICAgJHtERVBSRUNBVEVEfVxuICAgICAgcHVibGljIGdldCB4KCl7cmV0dXJuIHRoaXMuX3h9XG4gICAgfVxuICBgLFxuICAgICAgdW5kZWZpbmVkIC8qIGNhbGxiYWNrICovLFxuICAgICAgeyBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChqc0ZpbGUocmVzdWx0KSkudG9NYXRjaChcbiAgICAgICdnZXQgeCgpIHsganNpaURlcHJlY2F0aW9uV2FybmluZ3MucHJpbnQoXCJ0ZXN0cGtnLkZvbyN4XCIsIFwiVXNlIHNvbWV0aGluZyBlbHNlXCIpOyByZXR1cm4gdGhpcy5feDsgfScsXG4gICAgKTtcbiAgfSk7XG5cbiAgdGVzdCgnZGVwcmVjYXRlZCBzZXR0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgIGBcbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgIHByaXZhdGUgX3ggPSAwO1xuICAgICAgcHVibGljIGdldCB4KCl7cmV0dXJuIHRoaXMuX3h9XG5cbiAgICAgICR7REVQUkVDQVRFRH1cbiAgICAgIHB1YmxpYyBzZXQgeChfeDogbnVtYmVyKSB7dGhpcy5feCA9IF94O31cbiAgICB9XG4gIGAsXG4gICAgICB1bmRlZmluZWQgLyogY2FsbGJhY2sgKi8sXG4gICAgICB7IGFkZERlcHJlY2F0aW9uV2FybmluZ3M6IHRydWUgfSxcbiAgICApO1xuXG4gICAgZXhwZWN0KGpzRmlsZShyZXN1bHQpKS50b01hdGNoKFxuICAgICAgJ3NldCB4KF94KSB7IGpzaWlEZXByZWNhdGlvbldhcm5pbmdzLnByaW50KFwidGVzdHBrZy5Gb28jeFwiLCBcIlVzZSBzb21ldGhpbmcgZWxzZVwiKTsgdGhpcy5feCA9IF94OyB9JyxcbiAgICApO1xuICB9KTtcblxuICB0ZXN0KCdkZXByZWNhdGVkIGNsYXNzZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcGlsZUpzaWlGb3JUZXN0KFxuICAgICAgYFxuICAgICR7REVQUkVDQVRFRH1cbiAgICBleHBvcnQgY2xhc3MgRm9vIHtcbiAgICAgIGNvbnN0cnVjdG9yKCl7fVxuICAgIH1cbiAgYCxcbiAgICAgIHVuZGVmaW5lZCAvKiBjYWxsYmFjayAqLyxcbiAgICAgIHsgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogdHJ1ZSB9LFxuICAgICk7XG5cbiAgICBleHBlY3QoanNGaWxlKHJlc3VsdCkpLnRvTWF0Y2goXG4gICAgICAnY29uc3RydWN0b3IoKSB7IGpzaWlEZXByZWNhdGlvbldhcm5pbmdzLnByaW50KFwidGVzdHBrZy5Gb29cIiwgXCJVc2Ugc29tZXRoaW5nIGVsc2VcIik7IH0nLFxuICAgICk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGpzRmlsZShyZXN1bHQ6IEhlbHBlckNvbXBpbGF0aW9uUmVzdWx0LCBiYXNlTmFtZSA9ICdpbmRleCcpOiBzdHJpbmcge1xuICBjb25zdCBmaWxlID0gT2JqZWN0LmVudHJpZXMocmVzdWx0LmZpbGVzKS5maW5kKFxuICAgIChbbmFtZV0pID0+IG5hbWUgPT09IGAke2Jhc2VOYW1lfS5qc2AsXG4gICk7XG5cbiAgcmV0dXJuIGZpbGUhWzFdO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kdWxlRGlyKG5hbWU6IHN0cmluZykge1xuICByZXR1cm4gcGF0aC5kaXJuYW1lKHJlcXVpcmUucmVzb2x2ZShgJHtuYW1lfS9wYWNrYWdlLmpzb25gKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbXBpbGUocHJvamVjdFJvb3Q6IHN0cmluZywgYWRkRGVwcmVjYXRpb25XYXJuaW5nczogYm9vbGVhbikge1xuICBjb25zdCB7IHByb2plY3RJbmZvIH0gPSBhd2FpdCBsb2FkUHJvamVjdEluZm8ocHJvamVjdFJvb3QpO1xuXG4gIGNvbnN0IGNvbXBpbGVyID0gbmV3IENvbXBpbGVyKHtcbiAgICBwcm9qZWN0SW5mbyxcbiAgICBhZGREZXByZWNhdGlvbldhcm5pbmdzLFxuICB9KTtcblxuICBhd2FpdCBjb21waWxlci5lbWl0KCk7XG59XG5cbmZ1bmN0aW9uIGxvYWRXYXJuaW5nc0ZpbGUocHJvamVjdFJvb3Q6IHN0cmluZykge1xuICByZXR1cm4gZnNcbiAgICAucmVhZEZpbGVTeW5jKHBhdGguam9pbihwcm9qZWN0Um9vdCwgJy53YXJuaW5ncy5qc2lpLmpzJykpXG4gICAgLnRvU3RyaW5nKCk7XG59XG4iXX0=