"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lib_1 = require("../lib");
test('submodules loaded from directories can have a README', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper({
        'index.ts': 'export * as submodule from "./subdir"',
        'subdir/index.ts': 'export class Foo { }',
        'subdir/README.md': 'This is the README',
    });
    expect(assembly.submodules['testpkg.submodule']).toEqual(expect.objectContaining({
        readme: {
            markdown: 'This is the README',
        },
    }));
});
test('submodules loaded from files can have a README', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper({
        'index.ts': 'export * as submodule from "./submod"',
        'submod.ts': 'export class Foo { }',
        'submod.README.md': 'This is the README',
    });
    expect(assembly.submodules['testpkg.submodule']).toEqual(expect.objectContaining({
        readme: {
            markdown: 'This is the README',
        },
    }));
});
test('submodules loaded from directories can have targets', async () => {
    const assembly = await lib_1.sourceToAssemblyHelper({
        'index.ts': 'export * as submodule from "./subdir"',
        'subdir/index.ts': 'export class Foo { }',
        'subdir/.jsiirc.json': JSON.stringify({
            targets: {
                python: 'fun',
            },
        }),
    });
    expect(assembly.submodules['testpkg.submodule']).toEqual(expect.objectContaining({
        targets: {
            python: 'fun',
        },
    }));
});
test.each(['directly', 'as namespace', 'with alias'])('can reference submodule types, importing %s', (importStyle) => lib_1.TestWorkspace.withWorkspace(async (ws) => {
    // There are 2 import styles:
    //
    // import { submodule } from 'lib';
    // import * as submodule from 'lib/submodule';
    //
    // We need to support both import styles.
    var _a, _b, _c;
    // Dependency that exports a submodule
    await ws.addDependency(await lib_1.compileJsiiForTest({
        'index.ts': 'export * as submodule from "./subdir"',
        'subdir/index.ts': [
            'export class Foo { };',
            'export interface FooInterface { readonly value?: string }',
            'export interface IProtocol { readonly value?: string; }',
        ].join('\n'),
        'subdir/README.md': 'This is the README',
    }));
    let importStatement;
    let prefix;
    switch (importStyle) {
        case 'directly':
            importStatement =
                "import { Foo, FooInterface, IProtocol } from 'testpkg/subdir'";
            prefix = '';
            break;
        case 'as namespace':
            importStatement = "import { submodule } from 'testpkg'";
            prefix = 'submodule.';
            break;
        case 'with alias':
            importStatement = "import { submodule as sub } from 'testpkg'";
            prefix = 'sub.';
            break;
    }
    // Main library that imports the submodule class directly
    // Use the type in all possible positions
    const result = await lib_1.compileJsiiForTest({
        'index.ts': `
        ${importStatement};

        export interface BarProps {
          readonly foo?: ${prefix}Foo;
        }

        export class Bar {
          constructor(public readonly foo: ${prefix}Foo, props: BarProps = {}) {
            Array.isArray(props);
          }

          public returnValue(): ${prefix}Foo {
            return new ${prefix}Foo();
          }
        }

        export class SubFoo extends ${prefix}Foo {}
        export interface SubInterface extends ${prefix}FooInterface {}
        export class Implementor implements ${prefix}IProtocol {}
      `,
    }, {
        packageJson: {
            // Must be a different name from the dependency
            name: 'consumerpkg',
            peerDependencies: { testpkg: '*' },
        },
        compilationDirectory: ws.rootDirectory,
    });
    expect((_c = (_b = (_a = result.assembly.types) === null || _a === void 0 ? void 0 : _a['consumerpkg.Bar']) === null || _b === void 0 ? void 0 : _b.initializer) === null || _c === void 0 ? void 0 : _c.parameters).toEqual([
        {
            name: 'foo',
            type: { fqn: 'testpkg.submodule.Foo' },
        },
        {
            name: 'props',
            optional: true,
            type: { fqn: 'consumerpkg.BarProps' },
        },
    ]);
}));
test.each(['directly', 'as namespace', 'with alias'])('can reference nested types in submodules, importing %s', (importStyle) => lib_1.TestWorkspace.withWorkspace(async (ws) => {
    // There are 2 import styles:
    //
    // import { submodule } from 'lib';
    // import * as submodule from 'lib/submodule';
    //
    // We need to support both import styles.
    var _a, _b, _c;
    // Dependency that exports a submodule
    await ws.addDependency(await lib_1.compileJsiiForTest({
        'index.ts': 'export * as submodule from "./subdir"',
        'subdir/index.ts': [
            'export class Namespace {};',
            'export namespace Namespace {',
            '  export class Foo { };',
            '  export interface FooInterface { readonly value?: string }',
            '  export interface IProtocol { readonly value?: string; }',
            '}',
        ].join('\n'),
        'subdir/README.md': 'This is the README',
    }));
    let importStatement;
    let prefix;
    switch (importStyle) {
        case 'directly':
            importStatement = "import { Namespace } from 'testpkg/subdir'";
            prefix = 'Namespace.';
            break;
        case 'as namespace':
            importStatement = "import { submodule } from 'testpkg'";
            prefix = 'submodule.Namespace.';
            break;
        case 'with alias':
            importStatement = "import { submodule as sub } from 'testpkg'";
            prefix = 'sub.Namespace.';
            break;
    }
    // Main library that imports the submodule class directly
    // Use the type in all possible positions
    const result = await lib_1.compileJsiiForTest({
        'index.ts': `
        ${importStatement};

        export interface BarProps {
          readonly foo?: ${prefix}Foo;
        }

        export class Bar {
          constructor(public readonly foo: ${prefix}Foo, props: BarProps = {}) {
            Array.isArray(props);
          }

          public returnValue(): ${prefix}Foo {
            return new ${prefix}Foo();
          }
        }

        export class SubFoo extends ${prefix}Foo {}
        export interface SubInterface extends ${prefix}FooInterface {}
        export class Implementor implements ${prefix}IProtocol {}
      `,
    }, {
        packageJson: {
            // Must be a different name from the dependency
            name: 'consumerpkg',
            peerDependencies: { testpkg: '*' },
        },
        compilationDirectory: ws.rootDirectory,
    });
    expect((_c = (_b = (_a = result.assembly.types) === null || _a === void 0 ? void 0 : _a['consumerpkg.Bar']) === null || _b === void 0 ? void 0 : _b.initializer) === null || _c === void 0 ? void 0 : _c.parameters).toEqual([
        {
            name: 'foo',
            type: { fqn: 'testpkg.submodule.Namespace.Foo' },
        },
        {
            name: 'props',
            optional: true,
            type: { fqn: 'consumerpkg.BarProps' },
        },
    ]);
}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VibW9kdWxlcy50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3VibW9kdWxlcy50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsZ0NBSWdCO0FBRWhCLElBQUksQ0FBQyxzREFBc0QsRUFBRSxLQUFLLElBQUksRUFBRTtJQUN0RSxNQUFNLFFBQVEsR0FBRyxNQUFNLDRCQUFzQixDQUFDO1FBQzVDLFVBQVUsRUFBRSx1Q0FBdUM7UUFDbkQsaUJBQWlCLEVBQUUsc0JBQXNCO1FBQ3pDLGtCQUFrQixFQUFFLG9CQUFvQjtLQUN6QyxDQUFDLENBQUM7SUFFSCxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUN2RCxNQUFNLENBQUMsZ0JBQWdCLENBQUM7UUFDdEIsTUFBTSxFQUFFO1lBQ04sUUFBUSxFQUFFLG9CQUFvQjtTQUMvQjtLQUNGLENBQUMsQ0FDSCxDQUFDO0FBQ0osQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMsZ0RBQWdELEVBQUUsS0FBSyxJQUFJLEVBQUU7SUFDaEUsTUFBTSxRQUFRLEdBQUcsTUFBTSw0QkFBc0IsQ0FBQztRQUM1QyxVQUFVLEVBQUUsdUNBQXVDO1FBQ25ELFdBQVcsRUFBRSxzQkFBc0I7UUFDbkMsa0JBQWtCLEVBQUUsb0JBQW9CO0tBQ3pDLENBQUMsQ0FBQztJQUVILE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQ3ZELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztRQUN0QixNQUFNLEVBQUU7WUFDTixRQUFRLEVBQUUsb0JBQW9CO1NBQy9CO0tBQ0YsQ0FBQyxDQUNILENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQztBQUVILElBQUksQ0FBQyxxREFBcUQsRUFBRSxLQUFLLElBQUksRUFBRTtJQUNyRSxNQUFNLFFBQVEsR0FBRyxNQUFNLDRCQUFzQixDQUFDO1FBQzVDLFVB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RSxFQUNEO1FBQ0UsV0FBVyxFQUFFO1lBQ1gsK0NBQStDO1lBQy9DLElBQUksRUFBRSxhQUFhO1lBQ25CLGdCQUFnQixFQUFFLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRTtTQUNuQztRQUNELG9CQUFvQixFQUFFLEVBQUUsQ0FBQyxhQUFhO0tBQ3ZDLENBQ0YsQ0FBQztJQUVGLE1BQU0sYUFDSCxNQUFBLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSywwQ0FBRyxpQkFBaUIsQ0FBb0IsMENBQzFELFdBQVcsMENBQUUsVUFBVSxDQUM1QixDQUFDLE9BQU8sQ0FBQztRQUNSO1lBQ0UsSUFBSSxFQUFFLEtBQUs7WUFDWCxJQUFJLEVBQUUsRUFBRSxHQUFHLEVBQUUsaUNBQWlDLEVBQUU7U0FDakQ7UUFDRDtZQUNFLElBQUksRUFBRSxPQUFPO1lBQ2IsUUFBUSxFQUFFLElBQUk7WUFDZCxJQUFJLEVBQUUsRUFBRSxHQUFHLEVBQUUsc0JBQXNCLEVBQUU7U0FDdEM7S0FDRixDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3BlYyBmcm9tICdAanNpaS9zcGVjJztcblxuaW1wb3J0IHtcbiAgc291cmNlVG9Bc3NlbWJseUhlbHBlcixcbiAgVGVzdFdvcmtzcGFjZSxcbiAgY29tcGlsZUpzaWlGb3JUZXN0LFxufSBmcm9tICcuLi9saWInO1xuXG50ZXN0KCdzdWJtb2R1bGVzIGxvYWRlZCBmcm9tIGRpcmVjdG9yaWVzIGNhbiBoYXZlIGEgUkVBRE1FJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHNvdXJjZVRvQXNzZW1ibHlIZWxwZXIoe1xuICAgICdpbmRleC50cyc6ICdleHBvcnQgKiBhcyBzdWJtb2R1bGUgZnJvbSBcIi4vc3ViZGlyXCInLFxuICAgICdzdWJkaXIvaW5kZXgudHMnOiAnZXhwb3J0IGNsYXNzIEZvbyB7IH0nLFxuICAgICdzdWJkaXIvUkVBRE1FLm1kJzogJ1RoaXMgaXMgdGhlIFJFQURNRScsXG4gIH0pO1xuXG4gIGV4cGVjdChhc3NlbWJseS5zdWJtb2R1bGVzIVsndGVzdHBrZy5zdWJtb2R1bGUnXSkudG9FcXVhbChcbiAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICByZWFkbWU6IHtcbiAgICAgICAgbWFya2Rvd246ICdUaGlzIGlzIHRoZSBSRUFETUUnLFxuICAgICAgfSxcbiAgICB9KSxcbiAgKTtcbn0pO1xuXG50ZXN0KCdzdWJtb2R1bGVzIGxvYWRlZCBmcm9tIGZpbGVzIGNhbiBoYXZlIGEgUkVBRE1FJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHNvdXJjZVRvQXNzZW1ibHlIZWxwZXIoe1xuICAgICdpbmRleC50cyc6ICdleHBvcnQgKiBhcyBzdWJtb2R1bGUgZnJvbSBcIi4vc3VibW9kXCInLFxuICAgICdzdWJtb2QudHMnOiAnZXhwb3J0IGNsYXNzIEZvbyB7IH0nLFxuICAgICdzdWJtb2QuUkVBRE1FLm1kJzogJ1RoaXMgaXMgdGhlIFJFQURNRScsXG4gIH0pO1xuXG4gIGV4cGVjdChhc3NlbWJseS5zdWJtb2R1bGVzIVsndGVzdHBrZy5zdWJtb2R1bGUnXSkudG9FcXVhbChcbiAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICByZWFkbWU6IHtcbiAgICAgICAgbWFya2Rvd246ICdUaGlzIGlzIHRoZSBSRUFETUUnLFxuICAgICAgfSxcbiAgICB9KSxcbiAgKTtcbn0pO1xuXG50ZXN0KCdzdWJtb2R1bGVzIGxvYWRlZCBmcm9tIGRpcmVjdG9yaWVzIGNhbiBoYXZlIHRhcmdldHMnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgc291cmNlVG9Bc3NlbWJseUhlbHBlcih7XG4gICAgJ2luZGV4LnRzJzogJ2V4cG9ydCAqIGFzIHN1Ym1vZHVsZSBmcm9tIFwiLi9zdWJkaXJcIicsXG4gICAgJ3N1YmRpci9pbmRleC50cyc6ICdleHBvcnQgY2xhc3MgRm9vIHsgfScsXG4gICAgJ3N1YmRpci8uanNpaXJjLmpzb24nOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0YXJnZXRzOiB7XG4gICAgICAgIHB5dGhvbjogJ2Z1bicsXG4gICAgICB9LFxuICAgIH0pLFxuICB9KTtcblxuICBleHBlY3QoYXNzZW1ibHkuc3VibW9kdWxlcyFbJ3Rlc3Rwa2cuc3VibW9kdWxlJ10pLnRvRXF1YWwoXG4gICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgdGFyZ2V0czoge1xuICAgICAgICBweXRob246ICdmdW4nLFxuICAgICAgfSxcbiAgICB9KSxcbiAgKTtcbn0pO1xuXG50eXBlIEltcG9ydFN0eWxlID0gJ2RpcmVjdGx5JyB8ICdhcyBuYW1lc3BhY2UnIHwgJ3dpdGggYWxpYXMnO1xuXG50ZXN0LmVhY2goWydkaXJlY3RseScsICdhcyBuYW1lc3BhY2UnLCAnd2l0aCBhbGlhcyddIGFzIEltcG9ydFN0eWxlW10pKFxuICAnY2FuIHJlZmVyZW5jZSBzdWJtb2R1bGUgdHlwZXMsIGltcG9ydGluZyAlcycsXG4gIChpbXBvcnRTdHlsZSkgPT5cbiAgICBUZXN0V29ya3NwYWNlLndpdGhXb3Jrc3BhY2UoYXN5bmMgKHdzKSA9PiB7XG4gICAgICAvLyBUaGVyZSBhcmUgMiBpbXBvcnQgc3R5bGVzOlxuICAgICAgLy9cbiAgICAgIC8vIGltcG9ydCB7IHN1Ym1vZHVsZSB9IGZyb20gJ2xpYic7XG4gICAgICAvLyBpbXBvcnQgKiBhcyBzdWJtb2R1bGUgZnJvbSAnbGliL3N1Ym1vZHVsZSc7XG4gICAgICAvL1xuICAgICAgLy8gV2UgbmVlZCB0byBzdXBwb3J0IGJvdGggaW1wb3J0IHN0eWxlcy5cblxuICAgICAgLy8gRGVwZW5kZW5jeSB0aGF0IGV4cG9ydHMgYSBzdWJtb2R1bGVcbiAgICAgIGF3YWl0IHdzLmFkZERlcGVuZGVuY3koXG4gICAgICAgIGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdCh7XG4gICAgICAgICAgJ2luZGV4LnRzJzogJ2V4cG9ydCAqIGFzIHN1Ym1vZHVsZSBmcm9tIFwiLi9zdWJkaXJcIicsXG4gICAgICAgICAgJ3N1YmRpci9pbmRleC50cyc6IFtcbiAgICAgICAgICAgICdleHBvcnQgY2xhc3MgRm9vIHsgfTsnLFxuICAgICAgICAgICAgJ2V4cG9ydCBpbnRlcmZhY2UgRm9vSW50ZXJmYWNlIHsgcmVhZG9ubHkgdmFsdWU/OiBzdHJpbmcgfScsXG4gICAgICAgICAgICAnZXhwb3J0IGludGVyZmFjZSBJUHJvdG9jb2wgeyByZWFkb25seSB2YWx1ZT86IHN0cmluZzsgfScsXG4gICAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAnc3ViZGlyL1JFQURNRS5tZCc6ICdUaGlzIGlzIHRoZSBSRUFETUUnLFxuICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICAgIGxldCBpbXBvcnRTdGF0ZW1lbnQ7XG4gICAgICBsZXQgcHJlZml4O1xuICAgICAgc3dpdGNoIChpbXBvcnRTdHlsZSkge1xuICAgICAgICBjYXNlICdkaXJlY3RseSc6XG4gICAgICAgICAgaW1wb3J0U3RhdGVtZW50ID1cbiAgICAgICAgICAgIFwiaW1wb3J0IHsgRm9vLCBGb29JbnRlcmZhY2UsIElQcm90b2NvbCB9IGZyb20gJ3Rlc3Rwa2cvc3ViZGlyJ1wiO1xuICAgICAgICAgIHByZWZpeCA9ICcnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcyBuYW1lc3BhY2UnOlxuICAgICAgICAgIGltcG9ydFN0YXRlbWVudCA9IFwiaW1wb3J0IHsgc3VibW9kdWxlIH0gZnJvbSAndGVzdHBrZydcIjtcbiAgICAgICAgICBwcmVmaXggPSAnc3VibW9kdWxlLic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dpdGggYWxpYXMnOlxuICAgICAgICAgIGltcG9ydFN0YXRlbWVudCA9IFwiaW1wb3J0IHsgc3VibW9kdWxlIGFzIHN1YiB9IGZyb20gJ3Rlc3Rwa2cnXCI7XG4gICAgICAgICAgcHJlZml4ID0gJ3N1Yi4nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWluIGxpYnJhcnkgdGhhdCBpbXBvcnRzIHRoZSBzdWJtb2R1bGUgY2xhc3MgZGlyZWN0bHlcbiAgICAgIC8vIFVzZSB0aGUgdHlwZSBpbiBhbGwgcG9zc2libGUgcG9zaXRpb25zXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb21waWxlSnNpaUZvclRlc3QoXG4gICAgICAgIHtcbiAgICAgICAgICAnaW5kZXgudHMnOiBgXG4gICAgICAgICR7aW1wb3J0U3RhdGVtZW50fTtcblxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEJhclByb3BzIHtcbiAgICAgICAgICByZWFkb25seSBmb28/OiAke3ByZWZpeH1Gb287XG4gICAgICAgIH1cblxuICAgICAgICBleHBvcnQgY2xhc3MgQmFyIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgZm9vOiAke3ByZWZpeH1Gb28sIHByb3BzOiBCYXJQcm9wcyA9IHt9KSB7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByb3BzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdWJsaWMgcmV0dXJuVmFsdWUoKTogJHtwcmVmaXh9Rm9vIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgJHtwcmVmaXh9Rm9vKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwb3J0IGNsYXNzIFN1YkZvbyBleHRlbmRzICR7cHJlZml4fUZvbyB7fVxuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIFN1YkludGVyZmFjZSBleHRlbmRzICR7cHJlZml4fUZvb0ludGVyZmFjZSB7fVxuICAgICAgICBleHBvcnQgY2xhc3MgSW1wbGVtZW50b3IgaW1wbGVtZW50cyAke3ByZWZpeH1JUHJvdG9jb2wge31cbiAgICAgIGAsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwYWNrYWdlSnNvbjoge1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBhIGRpZmZlcmVudCBuYW1lIGZyb20gdGhlIGRlcGVuZGVuY3lcbiAgICAgICAgICAgIG5hbWU6ICdjb25zdW1lcnBrZycsXG4gICAgICAgICAgICBwZWVyRGVwZW5kZW5jaWVzOiB7IHRlc3Rwa2c6ICcqJyB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGlsYXRpb25EaXJlY3Rvcnk6IHdzLnJvb3REaXJlY3RvcnksXG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoXG4gICAgICAgIChyZXN1bHQuYXNzZW1ibHkudHlwZXM/LlsnY29uc3VtZXJwa2cuQmFyJ10gYXMgc3BlYy5DbGFzc1R5cGUpXG4gICAgICAgICAgPy5pbml0aWFsaXplcj8ucGFyYW1ldGVycyxcbiAgICAgICkudG9FcXVhbChbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnZm9vJyxcbiAgICAgICAgICB0eXBlOiB7IGZxbjogJ3Rlc3Rwa2cuc3VibW9kdWxlLkZvbycgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcm9wcycsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgdHlwZTogeyBmcW46ICdjb25zdW1lcnBrZy5CYXJQcm9wcycgfSxcbiAgICAgICAgfSxcbiAgICAgIF0pO1xuICAgIH0pLFxuKTtcblxudGVzdC5lYWNoKFsnZGlyZWN0bHknLCAnYXMgbmFtZXNwYWNlJywgJ3dpdGggYWxpYXMnXSBhcyBJbXBvcnRTdHlsZVtdKShcbiAgJ2NhbiByZWZlcmVuY2UgbmVzdGVkIHR5cGVzIGluIHN1Ym1vZHVsZXMsIGltcG9ydGluZyAlcycsXG4gIChpbXBvcnRTdHlsZSkgPT5cbiAgICBUZXN0V29ya3NwYWNlLndpdGhXb3Jrc3BhY2UoYXN5bmMgKHdzKSA9PiB7XG4gICAgICAvLyBUaGVyZSBhcmUgMiBpbXBvcnQgc3R5bGVzOlxuICAgICAgLy9cbiAgICAgIC8vIGltcG9ydCB7IHN1Ym1vZHVsZSB9IGZyb20gJ2xpYic7XG4gICAgICAvLyBpbXBvcnQgKiBhcyBzdWJtb2R1bGUgZnJvbSAnbGliL3N1Ym1vZHVsZSc7XG4gICAgICAvL1xuICAgICAgLy8gV2UgbmVlZCB0byBzdXBwb3J0IGJvdGggaW1wb3J0IHN0eWxlcy5cblxuICAgICAgLy8gRGVwZW5kZW5jeSB0aGF0IGV4cG9ydHMgYSBzdWJtb2R1bGVcbiAgICAgIGF3YWl0IHdzLmFkZERlcGVuZGVuY3koXG4gICAgICAgIGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdCh7XG4gICAgICAgICAgJ2luZGV4LnRzJzogJ2V4cG9ydCAqIGFzIHN1Ym1vZHVsZSBmcm9tIFwiLi9zdWJkaXJcIicsXG4gICAgICAgICAgJ3N1YmRpci9pbmRleC50cyc6IFtcbiAgICAgICAgICAgICdleHBvcnQgY2xhc3MgTmFtZXNwYWNlIHt9OycsXG4gICAgICAgICAgICAnZXhwb3J0IG5hbWVzcGFjZSBOYW1lc3BhY2UgeycsXG4gICAgICAgICAgICAnICBleHBvcnQgY2xhc3MgRm9vIHsgfTsnLFxuICAgICAgICAgICAgJyAgZXhwb3J0IGludGVyZmFjZSBGb29JbnRlcmZhY2UgeyByZWFkb25seSB2YWx1ZT86IHN0cmluZyB9JyxcbiAgICAgICAgICAgICcgIGV4cG9ydCBpbnRlcmZhY2UgSVByb3RvY29sIHsgcmVhZG9ubHkgdmFsdWU/OiBzdHJpbmc7IH0nLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgICAgJ3N1YmRpci9SRUFETUUubWQnOiAnVGhpcyBpcyB0aGUgUkVBRE1FJyxcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICBsZXQgaW1wb3J0U3RhdGVtZW50O1xuICAgICAgbGV0IHByZWZpeDtcbiAgICAgIHN3aXRjaCAoaW1wb3J0U3R5bGUpIHtcbiAgICAgICAgY2FzZSAnZGlyZWN0bHknOlxuICAgICAgICAgIGltcG9ydFN0YXRlbWVudCA9IFwiaW1wb3J0IHsgTmFtZXNwYWNlIH0gZnJvbSAndGVzdHBrZy9zdWJkaXInXCI7XG4gICAgICAgICAgcHJlZml4ID0gJ05hbWVzcGFjZS4nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcyBuYW1lc3BhY2UnOlxuICAgICAgICAgIGltcG9ydFN0YXRlbWVudCA9IFwiaW1wb3J0IHsgc3VibW9kdWxlIH0gZnJvbSAndGVzdHBrZydcIjtcbiAgICAgICAgICBwcmVmaXggPSAnc3VibW9kdWxlLk5hbWVzcGFjZS4nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3aXRoIGFsaWFzJzpcbiAgICAgICAgICBpbXBvcnRTdGF0ZW1lbnQgPSBcImltcG9ydCB7IHN1Ym1vZHVsZSBhcyBzdWIgfSBmcm9tICd0ZXN0cGtnJ1wiO1xuICAgICAgICAgIHByZWZpeCA9ICdzdWIuTmFtZXNwYWNlLic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIE1haW4gbGlicmFyeSB0aGF0IGltcG9ydHMgdGhlIHN1Ym1vZHVsZSBjbGFzcyBkaXJlY3RseVxuICAgICAgLy8gVXNlIHRoZSB0eXBlIGluIGFsbCBwb3NzaWJsZSBwb3NpdGlvbnNcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVKc2lpRm9yVGVzdChcbiAgICAgICAge1xuICAgICAgICAgICdpbmRleC50cyc6IGBcbiAgICAgICAgJHtpbXBvcnRTdGF0ZW1lbnR9O1xuXG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQmFyUHJvcHMge1xuICAgICAgICAgIHJlYWRvbmx5IGZvbz86ICR7cHJlZml4fUZvbztcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cG9ydCBjbGFzcyBCYXIge1xuICAgICAgICAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBmb286ICR7cHJlZml4fUZvbywgcHJvcHM6IEJhclByb3BzID0ge30pIHtcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB1YmxpYyByZXR1cm5WYWx1ZSgpOiAke3ByZWZpeH1Gb28ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAke3ByZWZpeH1Gb28oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBvcnQgY2xhc3MgU3ViRm9vIGV4dGVuZHMgJHtwcmVmaXh9Rm9vIHt9XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgU3ViSW50ZXJmYWNlIGV4dGVuZHMgJHtwcmVmaXh9Rm9vSW50ZXJmYWNlIHt9XG4gICAgICAgIGV4cG9ydCBjbGFzcyBJbXBsZW1lbnRvciBpbXBsZW1lbnRzICR7cHJlZml4fUlQcm90b2NvbCB7fVxuICAgICAgYCxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHBhY2thZ2VKc29uOiB7XG4gICAgICAgICAgICAvLyBNdXN0IGJlIGEgZGlmZmVyZW50IG5hbWUgZnJvbSB0aGUgZGVwZW5kZW5jeVxuICAgICAgICAgICAgbmFtZTogJ2NvbnN1bWVycGtnJyxcbiAgICAgICAgICAgIHBlZXJEZXBlbmRlbmNpZXM6IHsgdGVzdHBrZzogJyonIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21waWxhdGlvbkRpcmVjdG9yeTogd3Mucm9vdERpcmVjdG9yeSxcbiAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChcbiAgICAgICAgKHJlc3VsdC5hc3NlbWJseS50eXBlcz8uWydjb25zdW1lcnBrZy5CYXInXSBhcyBzcGVjLkNsYXNzVHlwZSlcbiAgICAgICAgICA/LmluaXRpYWxpemVyPy5wYXJhbWV0ZXJzLFxuICAgICAgKS50b0VxdWFsKFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdmb28nLFxuICAgICAgICAgIHR5cGU6IHsgZnFuOiAndGVzdHBrZy5zdWJtb2R1bGUuTmFtZXNwYWNlLkZvbycgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcm9wcycsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgdHlwZTogeyBmcW46ICdjb25zdW1lcnBrZy5CYXJQcm9wcycgfSxcbiAgICAgICAgfSxcbiAgICAgIF0pO1xuICAgIH0pLFxuKTtcbiJdfQ==