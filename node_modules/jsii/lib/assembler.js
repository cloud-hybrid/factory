"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assembler = void 0;
const spec = require("@jsii/spec");
const Case = require("case");
const colors = require("colors/safe");
const crypto = require("crypto");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const deepEqual = require("deep-equal");
const fs = require("fs-extra");
const log4js = require("log4js");
const path = require("path");
const ts = require("typescript");
const docs_1 = require("./docs");
const jsii_diagnostic_1 = require("./jsii-diagnostic");
const literate = require("./literate");
const bindings = require("./node-bindings");
const reserved_words_1 = require("./reserved-words");
const symbol_id_1 = require("./symbol-id");
const deprecated_remover_1 = require("./transforms/deprecated-remover");
const deprecation_warnings_1 = require("./transforms/deprecation-warnings");
const runtime_info_1 = require("./transforms/runtime-info");
const ts_comment_replacer_1 = require("./transforms/ts-comment-replacer");
const utils_1 = require("./transforms/utils");
const validator_1 = require("./validator");
const version_1 = require("./version");
const warnings_1 = require("./warnings");
// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
const sortJson = require('sort-json');
const LOG = log4js.getLogger('jsii/assembler');
/**
 * The JSII Assembler consumes a ``ts.Program`` instance and emits a JSII assembly.
 */
class Assembler {
    /**
     * @param projectInfo information about the package being assembled
     * @param program     the TypeScript program to be assembled from
     * @param stdlib      the directory where the TypeScript stdlib is rooted
     */
    constructor(projectInfo, program, stdlib, options = {}) {
        var _a;
        this.projectInfo = projectInfo;
        this.program = program;
        this.stdlib = stdlib;
        this.commentReplacer = new ts_comment_replacer_1.TsCommentReplacer();
        this._diagnostics = new Array();
        this._deferred = new Array();
        this._types = {};
        /** Map of Symbol to namespace export Symbol */
        this._submoduleMap = new Map();
        /**
         * Submodule information
         *
         * Contains submodule information for all namespaces that have been seen
         * across all assemblies (this and dependencies).
         *
         * Filtered to local submodules only at time of writing the assembly out to disk.
         */
        this._submodules = new Map();
        if (options.stripDeprecated) {
            let allowlistedDeprecations;
            if (options.stripDeprecatedAllowListFile) {
                if (!fs.existsSync(options.stripDeprecatedAllowListFile)) {
                    throw new Error(`--strip-deprecated file not found: ${options.stripDeprecatedAllowListFile}`);
                }
                allowlistedDeprecations = new Set(fs
                    .readFileSync(options.stripDeprecatedAllowListFile, 'utf8')
                    .split('\n'));
            }
            this.deprecatedRemover = new deprecated_remover_1.DeprecatedRemover(this._typeChecker, allowlistedDeprecations);
        }
        if (options.addDeprecationWarnings) {
            this.warningsInjector = new deprecation_warnings_1.DeprecationWarningsInjector(this._typeChecker);
        }
        const dts = projectInfo.types;
        let mainFile = dts.replace(/\.d\.ts(x?)$/, '.ts$1');
        // If out-of-source build was configured (tsc's outDir and rootDir), the
        // main file's path needs to be re-rooted from the outDir into the rootDir.
        const tscOutDir = program.getCompilerOptions().outDir;
        if (tscOutDir != null) {
            mainFile = path.relative(tscOutDir, mainFile);
            // rootDir may be set explicitly or not. If not, inferRootDir replicates
            // tsc's behavior of using the longest prefix of all built source files.
            this.tscRootDir = (_a = program.getCompilerOptions().rootDir) !== null && _a !== void 0 ? _a : inferRootDir(program);
            if (this.tscRootDir != null) {
                mainFile = path.join(this.tscRootDir, mainFile);
            }
        }
        this.mainFile = path.resolve(projectInfo.projectRoot, mainFile);
        this.runtimeTypeInfoInjector = new runtime_info_1.RuntimeTypeInfoInjector(projectInfo.version);
    }
    get customTransformers() {
        var _a, _b, _c, _d;
        return utils_1.combinedTransformers((_b = (_a = this.deprecatedRemover) === null || _a === void 0 ? void 0 : _a.customTransformers) !== null && _b !== void 0 ? _b : {}, this.runtimeTypeInfoInjector.makeTransformers(), this.commentReplacer.makeTransformers(), (_d = (_c = this.warningsInjector) === null || _c === void 0 ? void 0 : _c.customTransformers) !== null && _d !== void 0 ? _d : {});
    }
    get _typeChecker() {
        return this.program.getTypeChecker();
    }
    /**
     * Attempt emitting the JSII assembly for the program.
     *
     * @return the result of the assembly emission.
     */
    async emit() {
        var _a, _b, _c, _d;
        this._diagnostics = [];
        if (!this.projectInfo.description) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0001_PKG_MISSING_DESCRIPTION.createDetached());
        }
        if (!this.projectInfo.homepage) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0002_PKG_MISSING_HOMEPAGE.createDetached());
        }
        const readme = await _loadReadme.call(this);
        if (readme == null) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0003_MISSING_README.createDetached());
        }
        const docs = _loadDocs.call(this);
        this._types = {};
        this._deferred = [];
        const visitPromises = new Array();
        const sourceFile = this.program.getSourceFile(this.mainFile);
        if (sourceFile == null) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0004_COULD_NOT_FIND_ENTRYPOINT.createDetached(this.mainFile));
        }
        else {
            await this._registerDependenciesNamespaces(sourceFile);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Processing source file: ${colors.blue(path.relative(this.projectInfo.projectRoot, sourceFile.fileName))}`);
            }
            const symbol = this._typeChecker.getSymbolAtLocation(sourceFile);
            if (symbol) {
                const moduleExports = this._typeChecker.getExportsOfModule(symbol);
                await Promise.all(moduleExports.map((item) => this._registerNamespaces(item, this.projectInfo.projectRoot)));
                for (const node of moduleExports) {
                    visitPromises.push(this._visitNode(node.declarations[0], new EmitContext([], this.projectInfo.stability)));
                }
            }
        }
        await Promise.all(visitPromises);
        this.callDeferredsInOrder();
        // Skip emitting if any diagnostic message is an error
        if (this._diagnostics.find((diag) => diag.category === ts.DiagnosticCategory.Error) != null) {
            LOG.debug('Skipping emit due to errors.');
            // Clearing ``this._types`` to allow contents to be garbage-collected.
            delete this._types;
            try {
                return { diagnostics: this._diagnostics, emitSkipped: true };
            }
            finally {
                // Clearing ``this._diagnostics`` to allow contents to be garbage-collected.
                delete this._diagnostics;
            }
        }
        const jsiiVersion = this.projectInfo.jsiiVersionFormat === 'short' ? version_1.SHORT_VERSION : version_1.VERSION;
        const assembly = {
            schema: spec.SchemaVersion.LATEST,
            name: this.projectInfo.name,
            version: this.projectInfo.version,
            description: (_a = this.projectInfo.description) !== null && _a !== void 0 ? _a : this.projectInfo.name,
            license: this.projectInfo.license,
            keywords: this.projectInfo.keywords,
            homepage: (_b = this.projectInfo.homepage) !== null && _b !== void 0 ? _b : this.projectInfo.repository.url,
            author: this.projectInfo.author,
            contributors: this.projectInfo.contributors && [
                ...this.projectInfo.contributors,
            ],
            repository: this.projectInfo.repository,
            dependencies: noEmptyDict({
                ...this.projectInfo.dependencies,
                ...this.projectInfo.peerDependencies,
            }),
            dependencyClosure: noEmptyDict(toDependencyClosure(this.projectInfo.dependencyClosure)),
            bundled: this.projectInfo.bundleDependencies,
            types: this._types,
            submodules: noEmptyDict(toSubmoduleDeclarations(this.mySubmodules())),
            targets: this.projectInfo.targets,
            metadata: {
                ...this.projectInfo.metadata,
                // Downstream consumers need this to map a symbolId in the outDir to a
                // symbolId in the rootDir.
                tscRootDir: this.tscRootDir,
            },
            docs,
            readme,
            jsiiVersion,
            bin: this.projectInfo.bin,
            fingerprint: '<TBD>',
        };
        if (this.deprecatedRemover) {
            this._diagnostics.push(...this.deprecatedRemover.removeFrom(assembly));
        }
        if (this.warningsInjector) {
            const jsiiMetadata = {
                ...((_d = (_c = assembly.metadata) === null || _c === void 0 ? void 0 : _c.jsii) !== null && _d !== void 0 ? _d : {}),
                ...{ compiledWithDeprecationWarnings: true },
            };
            if (assembly.metadata) {
                assembly.metadata.jsii = jsiiMetadata;
            }
            else {
                assembly.metadata = { jsii: jsiiMetadata };
            }
            this.warningsInjector.process(assembly, this.projectInfo);
        }
        const validator = new validator_1.Validator(this.projectInfo, assembly);
        const validationResult = await validator.emit();
        if (!validationResult.emitSkipped) {
            const assemblyPath = path.join(this.projectInfo.projectRoot, '.jsii');
            LOG.trace(`Emitting assembly: ${colors.blue(assemblyPath)}`);
            await fs.writeJson(assemblyPath, _fingerprint(assembly), {
                encoding: 'utf8',
                spaces: 2,
            });
        }
        try {
            return {
                diagnostics: [...this._diagnostics, ...validationResult.diagnostics],
                emitSkipped: validationResult.emitSkipped,
            };
        }
        finally {
            // Clearing ``this._types`` to allow contents to be garbage-collected.
            delete this._types;
            // Clearing ``this._diagnostics`` to allow contents to be garbage-collected.
            delete this._diagnostics;
        }
        async function _loadReadme() {
            // Search for `README.md` in a case-insensitive way
            const fileName = (await fs.readdir(this.projectInfo.projectRoot)).find((file) => file.toLocaleLowerCase() === 'readme.md');
            if (fileName == null) {
                return undefined;
            }
            const readmePath = path.join(this.projectInfo.projectRoot, fileName);
            const renderedLines = await literate.includeAndRenderExamples(await literate.loadFromFile(readmePath), literate.fileSystemLoader(this.projectInfo.projectRoot));
            return { markdown: renderedLines.join('\n') };
        }
        function _loadDocs() {
            if (!this.projectInfo.stability && !this.projectInfo.deprecated) {
                return undefined;
            }
            const deprecated = this.projectInfo.deprecated;
            const stability = this.projectInfo.stability;
            return { deprecated, stability };
        }
    }
    /**
     * Defer a callback until a (set of) types are available
     *
     * This is a helper function around _defer() which encapsulates the _dereference
     * action (which is basically the majority use case for _defer anyway).
     *
     * Will not invoke the function with any 'undefined's; an error will already have been emitted in
     * that case anyway.
     *
     * @param fqn FQN of the current type (the type that has a dependency on baseTypes)
     * @param baseTypes Array of type references to be looked up
     * @param referencingNode Node to report a diagnostic on if we fail to look up a t ype
     * @param cb Callback to be invoked with the Types corresponding to the TypeReferences in baseTypes
     */
    _deferUntilTypesAvailable(fqn, baseTypes, referencingNode, cb) {
        // We can do this one eagerly
        if (baseTypes.length === 0) {
            cb();
            return;
        }
        const baseFqns = baseTypes.map((bt) => typeof bt === 'string' ? bt : bt.fqn);
        this._defer(fqn, baseFqns, () => {
            const resolved = baseFqns
                .map((x) => this._dereference(x, referencingNode))
                .filter((x) => x !== undefined);
            if (resolved.length > 0) {
                cb(...resolved);
            }
        });
    }
    /**
     * Defer checks for after the program has been entirely processed; useful for verifying type references that may not
     * have been discovered yet, and verifying properties about them.
     *
     * The callback is guaranteed to be executed only after all deferreds for all types in 'dependedFqns' have
     * been executed.
     *
     * @param fqn FQN of the current type.
     * @param dependedFqns List of FQNs of types this callback depends on. All deferreds for all
     * @param cb the function to be called in a deferred way. It will be bound with ``this``, so it can depend on using
     *           ``this``.
     */
    _defer(fqn, dependedFqns, cb) {
        this._deferred.push({ fqn, dependedFqns, cb: cb.bind(this) });
    }
    /**
     * Obtains the ``spec.Type`` for a given ``spec.NamedTypeReference``.
     *
     * @param ref the type reference to be de-referenced
     *
     * @returns the de-referenced type, if it was found, otherwise ``undefined``.
     */
    _dereference(ref, referencingNode) {
        var _a;
        if (typeof ref !== 'string') {
            ref = ref.fqn;
        }
        const [assm] = ref.split('.');
        let type;
        if (assm === this.projectInfo.name) {
            type = this._types[ref];
        }
        else {
            const assembly = this.projectInfo.dependencyClosure.find((dep) => dep.name === assm);
            type = (_a = assembly === null || assembly === void 0 ? void 0 : assembly.types) === null || _a === void 0 ? void 0 : _a[ref];
            // since we are exposing a type of this assembly in this module's public API,
            // we expect it to appear as a peer dependency instead of a normal dependency.
            if (assembly) {
                if (!(assembly.name in this.projectInfo.peerDependencies)) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0005_MISSING_PEER_DEPENDENCY.create(referencingNode, // Cheating here for now, until the referencingNode can be made required
                    assembly.name, ref));
                }
            }
        }
        if (!type) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9002_UNRESOLVEABLE_TYPE.create(referencingNode, // Cheating here for now, until the referencingNode can be made required
            ref));
        }
        return type;
    }
    /**
     * Compute the JSII fully qualified name corresponding to a ``ts.Type`` instance. If for any reason a name cannot be
     * computed for the type, a marker is returned instead, and an ``ts.DiagnosticCategory.Error`` diagnostic is
     * inserted in the assembler context.
     *
     * @param type the type for which a JSII fully qualified name is needed.
     * @param typeAnnotationNode the type annotation for which this FQN is generated. This is used for attaching the error
     *                           marker. When there is no explicit type annotation (e.g: inferred method return type), the
     *                           preferred substitute is the "type-inferred" element's name.
     * @param typeUse the reason why this type was resolved (e.g: "return type")
     * @param isThisType whether this type was specified or inferred as "this" or not
     *
     * @returns the FQN of the type, or some "unknown" marker.
     */
    async _getFQN(type, typeAnnotationNode, typeUse, isThisType) {
        var _a, _b, _c;
        const sym = symbolFromType(type, this._typeChecker);
        const typeDeclaration = (_a = sym.valueDeclaration) !== null && _a !== void 0 ? _a : (_b = sym.declarations) === null || _b === void 0 ? void 0 : _b[0];
        // Set to true to prevent further adding of Error diagnostics for known-bad reference
        let hasError = false;
        if (this._isPrivateOrInternal(sym)) {
            // Check if this type is "this" (explicit or inferred method return type).
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3001_EXPOSED_INTERNAL_TYPE.create(typeAnnotationNode, sym, isThisType, typeUse).addRelatedInformation(typeDeclaration, `The referenced type is declared here`));
            hasError = true;
        }
        const tsName = this._typeChecker.getFullyQualifiedName(sym);
        const groups = /^"([^"]+)"\.(.*)$/.exec(tsName);
        if (!groups) {
            if (!hasError) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3001_EXPOSED_INTERNAL_TYPE.create(typeAnnotationNode, sym, isThisType, typeUse).addRelatedInformation(typeDeclaration, `The referenced type is declared here`));
                hasError = true;
            }
            return tsName;
        }
        const [, modulePath, typeName] = groups;
        const pkg = await findPackageInfo(modulePath);
        if (!pkg) {
            if (!hasError) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9003_UNRESOLVEABLE_MODULE.create(typeAnnotationNode, modulePath).addRelatedInformation(typeDeclaration, `The referenced type is declared here`));
                hasError = true;
            }
            return `unknown.${typeName}`;
        }
        // If the symbol comes from the current assembly or an assembly whose
        // submodules we've already spidered, look up in the tables we are currently building
        if (pkg.name === this.projectInfo.name) {
            const submodule = this._submoduleMap.get(sym);
            if (submodule != null) {
                const submoduleNs = this._submodules.get(submodule).fqnResolutionPrefix;
                return `${submoduleNs}.${typeName}`;
            }
            return `${this.projectInfo.name}.${typeName}`;
        }
        // This is the fallback: in case we can't find a symbolId for the given
        // type, we're return this value. This is for backwards compatibility with
        // modules that haven't been compiled to have symbolId support. Those also
        // most likely won't be using submodules so this legacy guess will be correct.
        const fallbackFqn = `${pkg.name}.${typeName}`;
        // Otherwise look up the symbol identifier in the dependency assemblies
        const dep = this.projectInfo.dependencyClosure.find((d) => d.name === pkg.name);
        if (!dep) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9000_UNKNOWN_MODULE.createDetached(pkg.name));
            return fallbackFqn;
        }
        const symbolId = symbol_id_1.symbolIdentifier(this._typeChecker, sym, {
            assembly: dep,
        });
        const fqn = (_c = (dep && symbolId ? symbolIdIndex(dep)[symbolId] : undefined)) !== null && _c !== void 0 ? _c : fallbackFqn;
        if (!fqn || !this._dereference({ fqn }, sym.valueDeclaration)) {
            if (!hasError) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3002_USE_OF_UNEXPORTED_FOREIGN_TYPE.create(typeAnnotationNode, fqn !== null && fqn !== void 0 ? fqn : tsName, typeUse, pkg).addRelatedInformation(typeDeclaration, `The referenced type is declared here`));
                hasError = true;
            }
        }
        return fqn;
    }
    /**
     * For all modules in the dependency closure, crawl their exports to register
     * the submodules they contain.
     *
     * @param entryPoint the main source file for the currently compiled module.
     */
    async _registerDependenciesNamespaces(entryPoint) {
        for (const assm of this.projectInfo.dependencyClosure) {
            const resolved = ts.resolveModuleName(assm.name, entryPoint.fileName, this.program.getCompilerOptions(), ts.sys);
            // If we can't resolve the module name, simply ignore it (TypeScript compilation likely failed)
            if (resolved.resolvedModule == null) {
                continue;
            }
            const source = this.program.getSourceFile(resolved.resolvedModule.resolvedFileName);
            const depMod = source && this._typeChecker.getSymbolAtLocation(source);
            // It's unlikely, but if we can't get the SourceFile here, ignore it (TypeScript compilation probably failed)
            if (depMod == null) {
                continue;
            }
            const depRoot = packageRoot(resolved.resolvedModule.resolvedFileName);
            for (const symbol of this._typeChecker.getExportsOfModule(depMod)) {
                // eslint-disable-next-line no-await-in-loop
                await this._registerNamespaces(symbol, depRoot);
            }
        }
        function packageRoot(file) {
            const parent = path.dirname(file);
            if (path.basename(parent) === 'node_modules' || parent === file) {
                return file;
            }
            return packageRoot(parent);
        }
    }
    async _registerNamespaces(symbol, packageRoot) {
        var _a;
        const declaration = (_a = symbol.valueDeclaration) !== null && _a !== void 0 ? _a : symbol.declarations[0];
        if (declaration == null) {
            // Nothing to do here...
            return;
        }
        if (ts.isModuleDeclaration(declaration)) {
            // Looks like:
            //
            //    export some_namespace {
            //       ...
            //    }
            //
            // No way to configure targets
            const { fqn, fqnResolutionPrefix } = await qualifiedNameOf.call(this, symbol, true);
            this._submodules.set(symbol, {
                fqn,
                fqnResolutionPrefix,
                symbolId: symbol_id_1.symbolIdentifier(this._typeChecker, symbol),
                locationInModule: this.declarationLocation(declaration),
            });
            await this._addToSubmodule(symbol, symbol, packageRoot);
            return;
        }
        if (!ts.isNamespaceExport(declaration)) {
            // Nothing to do here...
            return;
        }
        const moduleSpecifier = declaration.parent.moduleSpecifier;
        if (moduleSpecifier == null || !ts.isStringLiteral(moduleSpecifier)) {
            // There is a grammar error here, so we'll let tsc report this for us.
            return;
        }
        const resolution = ts.resolveModuleName(moduleSpecifier.text, declaration.getSourceFile().fileName, this.program.getCompilerOptions(), ts.sys);
        if (resolution.resolvedModule == null) {
            // Unresolvable module... We'll let tsc report this for us.
            return;
        }
        // Normalize the path so the correct separator is in use (Looking at you, Windows)
        resolution.resolvedModule.resolvedFileName = path.normalize(resolution.resolvedModule.resolvedFileName);
        if (
        // We're not looking into a dependency's namespace exports, and the resolution says it's external
        (packageRoot === this.projectInfo.projectRoot &&
            resolution.resolvedModule.isExternalLibraryImport) ||
            // Or the module resolves outside of the current dependency's tree entirely
            !resolution.resolvedModule.resolvedFileName.startsWith(packageRoot) ||
            // Or the module is under one the current dependency's node_modules subtree
            resolution.resolvedModule.resolvedFileName
                .split(path.sep)
                .filter((entry) => entry === 'node_modules').length !==
                packageRoot.split(path.sep).filter((entry) => entry === 'node_modules')
                    .length) {
            // External re-exports are "pure-javascript" sugar; they need not be
            // represented in the jsii Assembly since the types in there will be
            // resolved through dependencies.
            return;
        }
        const sourceFile = this.program.getSourceFile(resolution.resolvedModule.resolvedFileName);
        const sourceModule = this._typeChecker.getSymbolAtLocation(sourceFile);
        // If there's no module, it's a syntax error, and tsc will have reported it for us.
        if (sourceModule) {
            if (symbol.name !== Case.camel(symbol.name) &&
                symbol.name !== Case.snake(symbol.name)) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_8004_SUBMOULE_NAME_CASING.create(declaration.name, symbol.name));
            }
            const { fqn, fqnResolutionPrefix } = await qualifiedNameOf.call(this, symbol);
            const targets = await loadSubmoduleTargetConfig(sourceFile.fileName);
            const readme = await loadSubmoduleReadMe(sourceFile.fileName);
            this._submodules.set(symbol, {
                fqn,
                fqnResolutionPrefix,
                targets,
                readme,
                symbolId: symbol_id_1.symbolIdentifier(this._typeChecker, symbol),
                locationInModule: this.declarationLocation(declaration),
            });
            await this._addToSubmodule(symbol, sourceModule, packageRoot);
        }
        async function qualifiedNameOf(sym, inlineNamespace = false) {
            var _a, _b, _c, _d;
            if (this._submoduleMap.has(sym)) {
                const parent = this._submodules.get(this._submoduleMap.get(sym));
                const fqn = `${parent.fqn}.${sym.name}`;
                return {
                    fqn,
                    fqnResolutionPrefix: inlineNamespace
                        ? parent.fqnResolutionPrefix
                        : fqn,
                };
            }
            const symbolLocation = (_c = (_b = (_a = sym
                .getDeclarations()) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getSourceFile()) === null || _c === void 0 ? void 0 : _c.fileName;
            const pkgInfo = symbolLocation
                ? await findPackageInfo(symbolLocation)
                : undefined;
            const assemblyName = (_d = pkgInfo === null || pkgInfo === void 0 ? void 0 : pkgInfo.name) !== null && _d !== void 0 ? _d : this.projectInfo.name;
            const fqn = `${assemblyName}.${sym.name}`;
            return {
                fqn,
                fqnResolutionPrefix: inlineNamespace ? this.projectInfo.name : fqn,
            };
        }
        async function loadSubmoduleTargetConfig(submoduleMain) {
            const jsiirc = path.resolve(submoduleMain, '..', '.jsiirc.json');
            if (!(await fs.pathExists(jsiirc))) {
                return undefined;
            }
            const data = await fs.readJson(jsiirc);
            return data.targets;
        }
        /**
         * Load the README for the given submodule
         *
         * If the submodule is loaded from a complete directory (determined by the 'main'
         * file ending in `index.[d.]ts`, then we load `README.md` in that same directory.
         *
         * If the submodule is loaded from a file, like `mymodule.[d.]ts`, we will load
         * `mymodule.README.md`.
         */
        async function loadSubmoduleReadMe(submoduleMain) {
            const fileBase = path.basename(submoduleMain).replace(/(\.d)?\.ts$/, '');
            const readMeName = fileBase === 'index' ? `README.md` : `${fileBase}.README.md`;
            const fullPath = path.join(path.dirname(submoduleMain), readMeName);
            if (!(await fs.pathExists(fullPath))) {
                return undefined;
            }
            return {
                markdown: await fs.readFile(fullPath, { encoding: 'utf-8' }),
            };
        }
    }
    /**
     * Registers Symbols to a particular submodule. This is used to associate
     * declarations exported by an `export * as ns from 'moduleLike';` statement
     * so that they can subsequently be correctly namespaced.
     *
     * @param ns          the symbol that identifies the submodule.
     * @param moduleLike  the module-like symbol bound to the submodule.
     * @param packageRoot the root of the package being traversed.
     */
    async _addToSubmodule(ns, moduleLike, packageRoot) {
        var _a, _b, _c;
        // For each symbol exported by the moduleLike, map it to the ns submodule.
        for (const symbol of this._typeChecker.getExportsOfModule(moduleLike)) {
            if (this._submoduleMap.has(symbol)) {
                const currNs = this._submoduleMap.get(symbol);
                // Checking if there's been two submodules exporting the same symbol,
                // which is illegal. We can tell if the currently registered symbol has
                // a different name than the one we're currently trying to register in.
                if (currNs.name !== ns.name) {
                    const currNsDecl = (_a = currNs.valueDeclaration) !== null && _a !== void 0 ? _a : currNs.declarations[0];
                    const nsDecl = (_b = ns.valueDeclaration) !== null && _b !== void 0 ? _b : ns.declarations[0];
                    // Make sure the error message always lists causes in the same order
                    const refs = [
                        { decl: currNsDecl, name: currNs.name },
                        { decl: nsDecl, name: ns.name },
                    ].sort(({ name: l }, { name: r }) => l.localeCompare(r));
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3003_SYMBOL_IS_EXPORTED_TWICE.create(_nameOrDeclarationNode(symbol), refs[0].name, refs[1].name)
                        .addRelatedInformation(refs[0].decl, `Symbol is exported under the "${refs[0].name}" submodule`)
                        .addRelatedInformation(refs[1].decl, `Symbol is exported under the "${refs[1].name}" submodule`));
                }
                // Found two re-exports, which is odd, but they use the same submodule,
                // so it's probably okay? That's likely a tsc error, which will have
                // been reported for us already anyway.
                continue;
            }
            this._submoduleMap.set(symbol, ns);
            // If the exported symbol has any declaration, and that delcaration is of
            // an entity that can have nested declarations of interest to jsii
            // (classes, interfaces, enums, modules), we need to also associate those
            // nested symbols to the submodule (or they won't be named correctly!)
            const decl = (_c = symbol.declarations) === null || _c === void 0 ? void 0 : _c[0];
            if (decl != null) {
                if (ts.isClassDeclaration(decl) ||
                    ts.isInterfaceDeclaration(decl) ||
                    ts.isEnumDeclaration(decl)) {
                    const type = this._typeChecker.getTypeAtLocation(decl);
                    if (isSingleValuedEnum(type, this._typeChecker)) {
                        // type.symbol !== symbol, because symbol is the enum itself, but
                        // since it's single-valued, the TypeChecker will only show us the
                        // value's symbol later on.
                        this._submoduleMap.set(type.symbol, ns);
                    }
                    if (type.symbol.exports) {
                        // eslint-disable-next-line no-await-in-loop
                        await this._addToSubmodule(ns, symbol, packageRoot);
                    }
                }
                else if (ts.isModuleDeclaration(decl)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._registerNamespaces(symbol, packageRoot);
                }
                else if (ts.isNamespaceExport(decl)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._registerNamespaces(symbol, packageRoot);
                }
            }
        }
    }
    /**
     * Register exported types in ``this.types``.
     *
     * @param node       a node found in a module
     * @param namePrefix the prefix for the types' namespaces
     */
    // eslint-disable-next-line complexity
    async _visitNode(node, context) {
        var _a, _b, _c, _d;
        if (ts.isNamespaceExport(node)) {
            // export * as ns from 'module';
            // Note: the "ts.NamespaceExport" refers to the "export * as ns" part of
            // the statement only. We must refer to `node.parent` in order to be able
            // to access the module specifier ("from 'module'") part.
            const symbol = this._typeChecker.getSymbolAtLocation(node.parent.moduleSpecifier);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Entering submodule: ${colors.cyan([...context.namespace, symbol.name].join('.'))}`);
            }
            const nsContext = context.appendNamespace(node.name.text);
            const promises = new Array();
            for (const child of this._typeChecker.getExportsOfModule(symbol)) {
                promises.push(this._visitNode(child.declarations[0], nsContext));
            }
            const allTypes = flattenPromises(promises);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Leaving submodule: ${colors.cyan([...context.namespace, symbol.name].join('.'))}`);
            }
            return allTypes;
        }
        if (ts.isExportSpecifier(node)) {
            // This is what happens when one does `export { Symbol } from "./location";`
            //                   ExportSpecifier:           ~~~~~~
            const resolvedSymbol = this._typeChecker.getExportSpecifierLocalTargetSymbol(node);
            if (!resolvedSymbol) {
                // A grammar error, compilation will already have failed
                return [];
            }
            return this._visitNode((_a = resolvedSymbol.valueDeclaration) !== null && _a !== void 0 ? _a : resolvedSymbol.declarations[0], context);
        }
        if ((ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) === 0) {
            return [];
        }
        let jsiiType;
        if (ts.isClassDeclaration(node) && _isExported(node)) {
            // export class Name { ... }
            this._validateHeritageClauses(node.heritageClauses);
            jsiiType = await this._visitClass(this._typeChecker.getTypeAtLocation(node), context);
            if (jsiiType) {
                this.registerExportedClassFqn(node, jsiiType.fqn);
            }
        }
        else if (ts.isInterfaceDeclaration(node) && _isExported(node)) {
            // export interface Name { ... }
            this._validateHeritageClauses(node.heritageClauses);
            jsiiType = await this._visitInterface(this._typeChecker.getTypeAtLocation(node), context);
        }
        else if (ts.isEnumDeclaration(node) && _isExported(node)) {
            // export enum Name { ... }
            jsiiType = await this._visitEnum(this._typeChecker.getTypeAtLocation(node), context);
        }
        else if (ts.isModuleDeclaration(node)) {
            // export namespace name { ... }
            const name = node.name.getText();
            const symbol = this._typeChecker.getSymbolAtLocation(node.name);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Entering namespace: ${colors.cyan([...context.namespace, name].join('.'))}`);
            }
            const allTypesPromises = new Array();
            for (const prop of this._typeChecker.getExportsOfModule(symbol)) {
                allTypesPromises.push(this._visitNode(prop.declarations[0], context.appendNamespace(node.name.getText())));
            }
            const allTypes = await flattenPromises(allTypesPromises);
            if (LOG.isTraceEnabled()) {
                LOG.trace(`Leaving namespace:  ${colors.cyan([...context.namespace, name].join('.'))}`);
            }
            return allTypes;
        }
        else {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9998_UNSUPPORTED_NODE.create((_b = ts.getNameOfDeclaration(node)) !== null && _b !== void 0 ? _b : node, node.kind));
        }
        if (!jsiiType) {
            return [];
        }
        // If symbolId hasn't been set yet, set it here
        if (!jsiiType.symbolId) {
            jsiiType.symbolId = this.getSymbolId(node);
        }
        // Let's quickly verify the declaration does not collide with a submodule. Submodules get case-adjusted for each
        // target language separately, so names cannot collide with case-variations.
        for (const submodule of this._submodules.keys()) {
            const candidates = Array.from(new Set([
                submodule.name,
                Case.camel(submodule.name),
                Case.pascal(submodule.name),
                Case.snake(submodule.name),
            ]));
            const colliding = candidates.find((name) => `${this.projectInfo.name}.${name}` === jsiiType.fqn);
            if (colliding != null) {
                const submoduleDeclName = _nameOrDeclarationNode(submodule);
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5011_SUBMODULE_NAME_CONFLICT.create((_c = ts.getNameOfDeclaration(node)) !== null && _c !== void 0 ? _c : node, submodule.name, jsiiType.name, candidates).addRelatedInformation(submoduleDeclName, `This is the conflicting submodule declaration`));
            }
        }
        if (LOG.isInfoEnabled()) {
            LOG.info(`Registering JSII ${colors.magenta(jsiiType.kind)}: ${colors.green(jsiiType.fqn)}`);
        }
        this._types[jsiiType.fqn] = jsiiType;
        jsiiType.locationInModule = this.declarationLocation(node);
        const type = this._typeChecker.getTypeAtLocation(node);
        if (type.symbol.exports) {
            const nestedContext = context.appendNamespace(type.symbol.name);
            const visitedNodes = this._typeChecker
                .getExportsOfModule(type.symbol)
                .filter((s) => s.declarations)
                .map((exportedNode) => this._visitNode(exportedNode.declarations[0], nestedContext));
            for (const nestedTypes of await Promise.all(visitedNodes)) {
                for (const nestedType of nestedTypes) {
                    if (nestedType.namespace !== nestedContext.namespace.join('.')) {
                        this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5012_NAMESPACE_IN_TYPE.create((_d = ts.getNameOfDeclaration(node)) !== null && _d !== void 0 ? _d : node, jsiiType.fqn, nestedType.namespace));
                    }
                }
            }
        }
        return [jsiiType];
    }
    getSymbolId(node) {
        return symbol_id_1.symbolIdentifier(this._typeChecker, this._typeChecker.getTypeAtLocation(node).symbol);
    }
    _validateHeritageClauses(clauses) {
        if (clauses == null || clauses.length === 0) {
            // Nothing to do.
            return;
        }
        for (const clause of clauses) {
            for (const node of clause.types) {
                const parentType = this._typeChecker.getTypeAtLocation(node);
                if (parentType.symbol == null) {
                    // The parent type won't have a symbol if it's an "error type" inserted by the type checker when the original
                    // code contains a compilation error. In such cases, the TypeScript compiler will already have reported about
                    // the incoherent declarations, so we'll just not re-validate it there (we'd fail anyway).
                    continue;
                }
                // For some reason, we cannot trust parentType.isClassOrInterface()
                const badDecl = parentType.symbol.declarations.find((decl) => !ts.isClassDeclaration(decl) && // <-- local classes
                    !ts.isInterfaceDeclaration(decl) && // <-- local interfaces
                    !ts.isModuleDeclaration(decl));
                if (badDecl != null) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3004_INVALID_SUPERTYPE.create(node, clause, badDecl).addRelatedInformation(badDecl, `The invalid super type is declared here.`));
                }
            }
        }
    }
    declarationLocation(node) {
        const file = node.getSourceFile();
        const line = ts.getLineAndCharacterOfPosition(file, node.getStart()).line;
        const filename = path
            .normalize(path.relative(this.projectInfo.projectRoot, file.fileName))
            .replace(/\\/g, '/');
        return {
            filename,
            line: line + 1,
        };
    }
    async _processBaseInterfaces(fqn, baseTypes) {
        const erasedBases = new Array();
        if (!baseTypes) {
            return { erasedBases };
        }
        const result = new Array();
        const baseInterfaces = new Set();
        const processBaseTypes = (types) => {
            for (const iface of types) {
                // base is private/internal, so we continue recursively with it's own bases
                if (this._isPrivateOrInternal(iface.symbol)) {
                    erasedBases.push(iface);
                    const bases = iface.getBaseTypes();
                    if (bases) {
                        processBaseTypes(bases);
                    }
                    continue;
                }
                baseInterfaces.add(iface);
            }
        };
        processBaseTypes(baseTypes);
        const typeRefs = Array.from(baseInterfaces).map(async (iface) => {
            const decl = iface.symbol.valueDeclaration;
            const typeRef = await this._typeReference(iface, decl, 'base interface');
            return { decl, typeRef };
        });
        for (const { decl, typeRef } of await Promise.all(typeRefs)) {
            if (!spec.isNamedTypeReference(typeRef)) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3005_TYPE_USED_AS_INTERFACE.create(decl, typeRef));
                continue;
            }
            this._deferUntilTypesAvailable(fqn, [typeRef], decl, (deref) => {
                if (!spec.isInterfaceType(deref)) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3005_TYPE_USED_AS_INTERFACE.create(decl, typeRef));
                }
            });
            result.push(typeRef);
        }
        return {
            interfaces: result.length === 0 ? undefined : result,
            erasedBases,
        };
    }
    // eslint-disable-next-line complexity
    async _visitClass(type, ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing class: ${colors.gray(ctx.namespace.join('.'))}.${colors.cyan(type.symbol.name)}`);
        }
        if (_hasInternalJsDocTag(type.symbol)) {
            return undefined;
        }
        this._warnAboutReservedWords(type.symbol);
        const fqn = `${[this.projectInfo.name, ...ctx.namespace].join('.')}.${type.symbol.name}`;
        const jsiiType = bindings.setClassRelatedNode({
            assembly: this.projectInfo.name,
            fqn,
            kind: spec.TypeKind.Class,
            name: type.symbol.name,
            namespace: ctx.namespace.length > 0 ? ctx.namespace.join('.') : undefined,
            docs: this._visitDocumentation(type.symbol, ctx).docs,
        }, type.symbol.valueDeclaration);
        if (_isAbstract(type.symbol, jsiiType)) {
            jsiiType.abstract = true;
        }
        const erasedBases = new Array();
        for (let base of (_a = type.getBaseTypes()) !== null && _a !== void 0 ? _a : []) {
            if (jsiiType.base) {
                // Ignoring this - there has already been a compilation error generated by tsc here.
                continue;
            }
            //
            // base classes ("extends foo")
            // Crawl up the inheritance tree if the current base type is not exported, so we identify the type(s) to be
            // erased, and identify the closest exported base class, should there be one.
            while (base && this._isPrivateOrInternal(base.symbol)) {
                LOG.debug(`Base class of ${colors.green(jsiiType.fqn)} named ${colors.green(base.symbol.name)} is not exported, erasing it...`);
                erasedBases.push(base);
                base = ((_b = base.getBaseTypes()) !== null && _b !== void 0 ? _b : [])[0];
            }
            if (!base) {
                // There is no exported base class to be found, pretend this class has no base class.
                continue;
            }
            // eslint-disable-next-line no-await-in-loop
            const ref = await this._typeReference(base, type.symbol.valueDeclaration, 'base class');
            if (!spec.isNamedTypeReference(ref)) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3006_TYPE_USED_AS_CLASS.create((_c = base.symbol.valueDeclaration) !== null && _c !== void 0 ? _c : base.symbol.declarations[0], ref));
                continue;
            }
            this._deferUntilTypesAvailable(fqn, [ref], base.symbol.valueDeclaration, (deref) => {
                var _a;
                if (!spec.isClassType(deref)) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3006_TYPE_USED_AS_CLASS.create((_a = base.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : base.symbol.declarations[0], ref));
                }
            });
            jsiiType.base = ref.fqn;
        }
        //
        // base interfaces ("implements foo")
        // collect all "implements" declarations from the current type and all
        // erased base types (because otherwise we lose them, see jsii#487)
        const implementsClauses = new Array();
        for (const heritage of [type, ...erasedBases].map((t) => { var _a; return (_a = t.symbol.valueDeclaration.heritageClauses) !== null && _a !== void 0 ? _a : []; })) {
            for (const clause of heritage) {
                if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
                    // Handled by `getBaseTypes`
                    continue;
                }
                else if (clause.token !== ts.SyntaxKind.ImplementsKeyword) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9998_UNSUPPORTED_NODE.create(clause, `Ignoring ${ts.SyntaxKind[clause.token]} heritage clause`));
                    continue;
                }
                implementsClauses.push(clause);
            }
        }
        // process all "implements" clauses
        const allInterfaces = new Set();
        const baseInterfaces = implementsClauses.map((clause) => this._processBaseInterfaces(fqn, clause.types.map((t) => this._getTypeFromTypeNode(t))));
        for (const { interfaces } of await Promise.all(baseInterfaces)) {
            for (const ifc of interfaces !== null && interfaces !== void 0 ? interfaces : []) {
                allInterfaces.add(ifc.fqn);
            }
            if (interfaces) {
                this._deferUntilTypesAvailable(jsiiType.fqn, interfaces, type.symbol.valueDeclaration, (...ifaces) => {
                    var _a;
                    for (const iface of ifaces) {
                        if (spec.isInterfaceType(iface) && iface.datatype) {
                            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3007_ILLEGAL_STRUCT_EXTENSION.create((_a = type.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : type.symbol.declarations[0], jsiiType, iface));
                        }
                    }
                });
            }
        }
        if (allInterfaces.size > 0) {
            jsiiType.interfaces = Array.from(allInterfaces);
        }
        if (!type.isClass()) {
            throw new Error('Oh no');
        }
        const allDeclarations = type.symbol.declarations.map((decl) => ({ decl, type }));
        // Considering erased bases' declarations, too, so they are "blended in"
        for (const base of erasedBases) {
            allDeclarations.push(...base.symbol.declarations.map((decl) => ({ decl, type: base })));
        }
        for (const { decl, type: declaringType } of allDeclarations) {
            const classDecl = decl;
            if (!classDecl.members) {
                continue;
            }
            for (const memberDecl of classDecl.members) {
                if (ts.isSemicolonClassElement(memberDecl)) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9996_UNNECESSARY_TOKEN.create(memberDecl));
                    continue;
                }
                const member = ts.isConstructorDeclaration(memberDecl)
                    ? memberDecl.symbol
                    : this._typeChecker.getSymbolAtLocation(ts.getNameOfDeclaration(memberDecl));
                if (!((_d = declaringType.symbol.getDeclarations()) !== null && _d !== void 0 ? _d : []).find((d) => d === memberDecl.parent)) {
                    continue;
                }
                if (this._isPrivateOrInternal(member, memberDecl)) {
                    continue;
                }
                // constructors are handled later
                if (ts.isConstructorDeclaration(memberDecl)) {
                    continue;
                }
                // eslint-disable-next-line no-await-in-loop
                if (ts.isMethodDeclaration(memberDecl) ||
                    ts.isMethodSignature(memberDecl)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._visitMethod(member, jsiiType, ctx.replaceStability((_e = jsiiType.docs) === null || _e === void 0 ? void 0 : _e.stability), classDecl);
                }
                else if (ts.isPropertyDeclaration(memberDecl) ||
                    ts.isPropertySignature(memberDecl) ||
                    ts.isAccessor(memberDecl)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._visitProperty(member, jsiiType, ctx.replaceStability((_f = jsiiType.docs) === null || _f === void 0 ? void 0 : _f.stability), classDecl);
                }
                else {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9998_UNSUPPORTED_NODE.create((_g = ts.getNameOfDeclaration(memberDecl)) !== null && _g !== void 0 ? _g : memberDecl, memberDecl.kind));
                }
                /* eslint-enable no-await-in-loop */
            }
        }
        const memberEmitContext = ctx.replaceStability(jsiiType.docs && jsiiType.docs.stability);
        // Find the first defined constructor in this class, or it's erased bases
        const constructor = [type, ...erasedBases]
            .map(getConstructor)
            .find((ctor) => ctor != null);
        const ctorDeclaration = constructor && constructor.declarations[0];
        if (constructor && ctorDeclaration) {
            const signature = this._typeChecker.getSignatureFromDeclaration(ctorDeclaration);
            if ((ts.getCombinedModifierFlags(ctorDeclaration) &
                ts.ModifierFlags.Private) ===
                0) {
                jsiiType.initializer = {
                    locationInModule: this.declarationLocation(ctorDeclaration),
                };
                if (signature) {
                    for (const param of signature.getParameters()) {
                        jsiiType.initializer.parameters = (_h = jsiiType.initializer.parameters) !== null && _h !== void 0 ? _h : [];
                        jsiiType.initializer.parameters.push(
                        // eslint-disable-next-line no-await-in-loop
                        await this._toParameter(param, ctx.replaceStability((_j = jsiiType.docs) === null || _j === void 0 ? void 0 : _j.stability)));
                        jsiiType.initializer.variadic =
                            ((_l = (_k = jsiiType.initializer) === null || _k === void 0 ? void 0 : _k.parameters) === null || _l === void 0 ? void 0 : _l.some((p) => !!p.variadic)) ||
                                undefined;
                        jsiiType.initializer.protected =
                            (ts.getCombinedModifierFlags(ctorDeclaration) &
                                ts.ModifierFlags.Protected) !==
                                0 || undefined;
                    }
                }
                this._verifyConsecutiveOptionals(ctorDeclaration, jsiiType.initializer.parameters);
                jsiiType.initializer.docs = this._visitDocumentation(constructor, memberEmitContext).docs;
                this.overrideDocComment(constructor, jsiiType.initializer.docs, paramDocs(jsiiType.initializer.parameters));
            }
            // Process constructor-based property declarations even if constructor is private
            if (signature) {
                for (const param of signature.getParameters()) {
                    if (ts.isParameterPropertyDeclaration(param.valueDeclaration, param.valueDeclaration.parent) &&
                        !this._isPrivateOrInternal(param)) {
                        // eslint-disable-next-line no-await-in-loop
                        await this._visitProperty(param, jsiiType, memberEmitContext, ctorDeclaration.parent);
                    }
                }
            }
        }
        else if (jsiiType.base) {
            this._deferUntilTypesAvailable(fqn, [jsiiType.base], type.symbol.valueDeclaration, (baseType) => {
                var _a;
                if (spec.isClassType(baseType)) {
                    jsiiType.initializer = baseType.initializer;
                }
                else {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3999_INCOHERENT_TYPE_MODEL.create((_a = type.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : type.symbol.declarations[0], `Base type of ${jsiiType.fqn} (${jsiiType.base}) is not a class`));
                }
            });
        }
        else {
            jsiiType.initializer = {
                docs: ctx.stability && { stability: ctx.stability },
            };
        }
        this._verifyNoStaticMixing(jsiiType, type.symbol.valueDeclaration);
        this.overrideDocComment(type.getSymbol(), jsiiType === null || jsiiType === void 0 ? void 0 : jsiiType.docs);
        return _sortMembers(jsiiType);
    }
    /**
     * Use the TypeChecker's getTypeFromTypeNode, but throw a descriptive error if it fails
     */
    _getTypeFromTypeNode(t) {
        const type = this._typeChecker.getTypeFromTypeNode(t);
        if (isErrorType(type)) {
            throw new Error(`Unable to resolve type: ${t.getFullText()}. This typically happens if something is wrong with your dependency closure.`);
        }
        return type;
    }
    /**
     * Check that this class doesn't declare any members that are of different staticness in itself or any of its bases
     */
    _verifyNoStaticMixing(klass, decl) {
        var _a, _b, _c, _d;
        // Check class itself--may have two methods/props with the same name, so check the arrays
        const statics = new Set(((_a = klass.methods) !== null && _a !== void 0 ? _a : [])
            .concat((_b = klass.properties) !== null && _b !== void 0 ? _b : [])
            .filter((x) => x.static)
            .map((x) => x.name));
        const nonStatics = new Set(((_c = klass.methods) !== null && _c !== void 0 ? _c : [])
            .concat((_d = klass.properties) !== null && _d !== void 0 ? _d : [])
            .filter((x) => !x.static)
            .map((x) => x.name));
        // Intersect
        for (const member of intersect(statics, nonStatics)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5013_STATIC_INSTANCE_CONFLICT.create(decl, member, klass));
        }
        // Check against base classes. They will not contain duplicate member names so we can load
        // the members into a map.
        const classMembers = typeMembers(klass);
        this._withBaseClass(klass, decl, (base, recurse) => {
            for (const [name, baseMember] of Object.entries(typeMembers(base))) {
                const member = classMembers[name];
                if (!member) {
                    continue;
                }
                if (!!baseMember.static !== !!member.static) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5014_INHERITED_STATIC_CONFLICT.create(decl, member, klass, baseMember, base));
                }
            }
            recurse();
        });
    }
    /**
     * Wrapper around _deferUntilTypesAvailable, invoke the callback with the given classes' base type
     *
     * Does nothing if the given class doesn't have a base class.
     *
     * The second argument will be a `recurse` function for easy recursion up the inheritance tree
     * (no messing around with binding 'self' and 'this' and doing multiple calls to _withBaseClass.)
     */
    _withBaseClass(klass, decl, cb) {
        if (klass.base) {
            this._deferUntilTypesAvailable(klass.fqn, [klass.base], decl, (base) => {
                if (!spec.isClassType(base)) {
                    throw new Error('Oh no');
                }
                cb(base, () => this._withBaseClass(base, decl, cb));
            });
        }
    }
    /**
     * @returns true if this member is internal and should be omitted from the type manifest
     */
    _isPrivateOrInternal(symbol, validateDeclaration) {
        var _a, _b;
        const hasInternalJsDocTag = _hasInternalJsDocTag(symbol);
        const hasUnderscorePrefix = symbol.name !== '__constructor' && symbol.name.startsWith('_');
        if (_isPrivate(symbol)) {
            LOG.trace(`${colors.cyan(symbol.name)} is marked "private", or is an unexported type declaration`);
            return true;
        }
        if (!hasInternalJsDocTag && !hasUnderscorePrefix) {
            return false;
        }
        // we only validate if we have a declaration
        if (validateDeclaration) {
            if (!hasUnderscorePrefix) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_8005_INTERNAL_UNDERSCORE.create((_a = ts.getNameOfDeclaration(validateDeclaration)) !== null && _a !== void 0 ? _a : validateDeclaration, symbol.name));
            }
            if (!hasInternalJsDocTag) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_8006_UNDERSCORE_INTERNAL.create((_b = ts.getNameOfDeclaration(validateDeclaration)) !== null && _b !== void 0 ? _b : validateDeclaration, symbol.name));
            }
        }
        return true;
    }
    async _visitEnum(type, ctx) {
        var _a, _b;
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing enum: ${colors.gray(ctx.namespace.join('.'))}.${colors.cyan(type.symbol.name)}`);
        }
        // Forcefully resolving to the EnumDeclaration symbol for single-valued enums
        let decl = type.symbol.declarations[0];
        let symbol;
        if (ts.isEnumMember(decl)) {
            decl = decl === null || decl === void 0 ? void 0 : decl.parent;
        }
        if (ts.isEnumDeclaration(decl)) {
            symbol = getSymbolFromDeclaration(decl, this._typeChecker);
        }
        if (!decl || !symbol || !ts.isEnumDeclaration(decl)) {
            throw new Error(`Unable to resolve enum declaration for ${type.symbol.name}!`);
        }
        if (_hasInternalJsDocTag(symbol)) {
            return Promise.resolve(undefined);
        }
        this._warnAboutReservedWords(symbol);
        const flags = ts.getCombinedModifierFlags(decl);
        if (flags & ts.ModifierFlags.Const) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1000_NO_CONST_ENUM.create((_b = (_a = decl.modifiers) === null || _a === void 0 ? void 0 : _a.find((mod) => mod.kind === ts.SyntaxKind.ConstKeyword)) !== null && _b !== void 0 ? _b : decl));
        }
        const { docs } = this._visitDocumentation(symbol, ctx);
        const typeContext = ctx.replaceStability(docs === null || docs === void 0 ? void 0 : docs.stability);
        const members = type.isUnion() ? type.types : [type];
        const jsiiType = bindings.setEnumRelatedNode({
            assembly: this.projectInfo.name,
            fqn: `${[this.projectInfo.name, ...ctx.namespace].join('.')}.${symbol.name}`,
            kind: spec.TypeKind.Enum,
            members: members.map((m) => {
                const { docs } = this._visitDocumentation(m.symbol, typeContext);
                this.overrideDocComment(m.symbol, docs);
                return { name: m.symbol.name, docs };
            }),
            name: symbol.name,
            namespace: ctx.namespace.length > 0 ? ctx.namespace.join('.') : undefined,
            docs,
            // Set SymbolId here instead of later, as by default TS will pick single-enum members
            // as the target symbol if possible.
            symbolId: symbol_id_1.symbolIdentifier(this._typeChecker, symbol),
        }, decl);
        this.overrideDocComment(type.getSymbol(), jsiiType === null || jsiiType === void 0 ? void 0 : jsiiType.docs);
        return Promise.resolve(jsiiType);
    }
    /**
     * Return docs for a symbol
     */
    _visitDocumentation(sym, context) {
        var _a, _b, _c, _d;
        const result = docs_1.parseSymbolDocumentation(sym, this._typeChecker);
        for (const diag of (_a = result.diagnostics) !== null && _a !== void 0 ? _a : []) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_7999_DOCUMENTATION_ERROR.create((_b = sym.valueDeclaration) !== null && _b !== void 0 ? _b : sym.declarations[0], diag));
        }
        const decl = (_c = sym.valueDeclaration) !== null && _c !== void 0 ? _c : sym.declarations[0];
        // The @struct hint is only valid for interface declarations
        if (!ts.isInterfaceDeclaration(decl) && result.hints.struct) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_7001_ILLEGAL_HINT.create(_findHint(decl, 'struct'), 'struct', 'interfaces with only readonly properties')
                .addRelatedInformation((_d = ts.getNameOfDeclaration(decl)) !== null && _d !== void 0 ? _d : decl, 'The annotated declaration is here')
                .preformat(this.projectInfo.projectRoot));
            // Clean up the bad hint...
            delete result.hints.struct;
        }
        // Apply the current context's stability if none was specified locally.
        if (result.docs.stability == null) {
            result.docs.stability = context.stability;
        }
        const allUndefined = Object.values(result.docs).every((v) => v === undefined);
        return {
            docs: !allUndefined ? result.docs : undefined,
            hints: result.hints,
        };
    }
    /**
     * Check that all parameters the doc block refers to with a @param declaration actually exist
     */
    _validateReferencedDocParams(method, methodSym) {
        var _a, _b;
        const params = docs_1.getReferencedDocParams(methodSym);
        const actualNames = new Set(((_a = method.parameters) !== null && _a !== void 0 ? _a : []).map((p) => p.name));
        for (const param of params) {
            if (!actualNames.has(param)) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_7000_NON_EXISTENT_PARAMETER.create((_b = methodSym.valueDeclaration) !== null && _b !== void 0 ? _b : methodSym.declarations[0], method, param));
            }
        }
    }
    async _visitInterface(type, ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing interface: ${colors.gray(ctx.namespace.join('.'))}.${colors.cyan(type.symbol.name)}`);
        }
        if (_hasInternalJsDocTag(type.symbol)) {
            return undefined;
        }
        this._warnAboutReservedWords(type.symbol);
        const fqn = `${[this.projectInfo.name, ...ctx.namespace].join('.')}.${type.symbol.name}`;
        const { docs, hints } = this._visitDocumentation(type.symbol, ctx);
        const jsiiType = bindings.setInterfaceRelatedNode({
            assembly: this.projectInfo.name,
            fqn,
            kind: spec.TypeKind.Interface,
            name: type.symbol.name,
            namespace: ctx.namespace.length > 0 ? ctx.namespace.join('.') : undefined,
            docs,
        }, type.symbol.declarations[0]);
        const { interfaces, erasedBases } = await this._processBaseInterfaces(fqn, type.getBaseTypes());
        jsiiType.interfaces = apply(interfaces, (arr) => arr.map((i) => i.fqn));
        for (const declaringType of [type, ...erasedBases]) {
            for (const member of declaringType.getProperties()) {
                if (!((_a = declaringType.symbol.getDeclarations()) !== null && _a !== void 0 ? _a : []).find((decl) => { var _a; return decl === ((_a = member.valueDeclaration) === null || _a === void 0 ? void 0 : _a.parent); })) {
                    continue;
                }
                if (this._isPrivateOrInternal(member, member.valueDeclaration)) {
                    continue;
                }
                if (ts.isMethodDeclaration(member.valueDeclaration) ||
                    ts.isMethodSignature(member.valueDeclaration)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._visitMethod(member, jsiiType, ctx.replaceStability((_b = jsiiType.docs) === null || _b === void 0 ? void 0 : _b.stability), ((_c = type.symbol.valueDeclaration) !== null && _c !== void 0 ? _c : type.symbol.declarations[0]));
                }
                else if (ts.isPropertyDeclaration(member.valueDeclaration) ||
                    ts.isPropertySignature(member.valueDeclaration) ||
                    ts.isAccessor(member.valueDeclaration)) {
                    // eslint-disable-next-line no-await-in-loop
                    await this._visitProperty(member, jsiiType, ctx.replaceStability((_d = jsiiType.docs) === null || _d === void 0 ? void 0 : _d.stability), ((_e = type.symbol.valueDeclaration) !== null && _e !== void 0 ? _e : type.symbol.declarations[0]));
                }
                else {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9998_UNSUPPORTED_NODE.create(_nameOrDeclarationNode(member), ((_f = member.valueDeclaration) !== null && _f !== void 0 ? _f : member.declarations[0]).kind));
                }
            }
        }
        // Calculate datatype based on the datatypeness of this interface and all of its parents
        // To keep the spec minimal the actual values of the attribute are "true" or "undefined" (to represent "false").
        const declaration = (_g = type.symbol.valueDeclaration) !== null && _g !== void 0 ? _g : type.symbol.declarations[0];
        this._deferUntilTypesAvailable(fqn, (_h = jsiiType.interfaces) !== null && _h !== void 0 ? _h : [], declaration, (...bases) => {
            var _a, _b, _c, _d, _e;
            if (((_a = jsiiType.methods) !== null && _a !== void 0 ? _a : []).length === 0) {
                jsiiType.datatype = true;
            }
            else if (hints.struct) {
                this._diagnostics.push(jsiiType.methods.reduce((diag, mthod) => {
                    var _a;
                    const node = bindings.getMethodRelatedNode(mthod);
                    return node
                        ? diag.addRelatedInformation((_a = ts.getNameOfDeclaration(node)) !== null && _a !== void 0 ? _a : node, `A method is declared here`)
                        : diag;
                }, jsii_diagnostic_1.JsiiDiagnostic.JSII_7001_ILLEGAL_HINT.create(_findHint(declaration, 'struct'), 'struct', 'interfaces with only readonly properties')
                    .addRelatedInformation((_b = ts.getNameOfDeclaration(declaration)) !== null && _b !== void 0 ? _b : declaration, 'The annotated declartion is here')
                    .preformat(this.projectInfo.projectRoot)));
            }
            for (const base of bases) {
                if (spec.isInterfaceType(base) && !base.datatype) {
                    jsiiType.datatype = undefined;
                }
            }
            const interfaceName = isInterfaceName(jsiiType.name);
            // If it's not a datatype the name must start with an "I".
            if (!jsiiType.datatype && !interfaceName) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_8007_BEHAVIORAL_INTERFACE_NAME.create((_c = ts.getNameOfDeclaration(declaration)) !== null && _c !== void 0 ? _c : declaration, jsiiType.name));
            }
            // If the name starts with an "I" it is not intended as a datatype, so switch that off,
            // unless a TSDoc hint was set to force this to be considered a behavioral interface.
            if (jsiiType.datatype && interfaceName && !hints.struct) {
                delete jsiiType.datatype;
            }
            // Okay, this is a data type, check that all properties are readonly
            if (jsiiType.datatype) {
                for (const prop of (_d = jsiiType.properties) !== null && _d !== void 0 ? _d : []) {
                    if (!prop.immutable) {
                        const p = type.getProperty(prop.name);
                        this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3008_STRUCT_PROPS_MUST_BE_READONLY.create(_nameOrDeclarationNode(p), p.name, jsiiType));
                        // force property to be "readonly" since jsii languages will pass this by-value
                        prop.immutable = true;
                    }
                }
            }
            else {
                // This is *NOT* a data type, so it may not extend something that is one.
                for (const base of bases) {
                    if (!spec.isInterfaceType(base)) {
                        // Invalid type we already warned about earlier, just ignoring it here..
                        continue;
                    }
                    if (base.datatype) {
                        this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3007_ILLEGAL_STRUCT_EXTENSION.create((_e = type.symbol.valueDeclaration) !== null && _e !== void 0 ? _e : type.symbol.declarations[0], jsiiType, base));
                    }
                }
            }
        });
        // Check that no interface declares a member that's already declared
        // in a base type (not allowed in C#).
        const names = memberNames(jsiiType);
        const checkNoIntersection = (...bases) => {
            var _a, _b;
            for (const base of bases) {
                if (!spec.isInterfaceType(base)) {
                    continue;
                }
                const baseMembers = memberNames(base);
                for (const memberName of names) {
                    if (baseMembers.includes(memberName)) {
                        this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5015_REDECLARED_INTERFACE_MEMBER.create((_a = type.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : type.symbol.declarations[0], memberName, jsiiType));
                    }
                }
                // Recurse upwards
                this._deferUntilTypesAvailable(fqn, (_b = base.interfaces) !== null && _b !== void 0 ? _b : [], type.symbol.valueDeclaration, checkNoIntersection);
            }
        };
        this._deferUntilTypesAvailable(fqn, (_j = jsiiType.interfaces) !== null && _j !== void 0 ? _j : [], type.symbol.valueDeclaration, checkNoIntersection);
        this.overrideDocComment(type.getSymbol(), jsiiType === null || jsiiType === void 0 ? void 0 : jsiiType.docs);
        return _sortMembers(jsiiType);
    }
    async _visitMethod(symbol, type, ctx, declaringTypeDecl) {
        var _a, _b, _c;
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing method: ${colors.green(type.fqn)}#${colors.cyan(symbol.name)}`);
        }
        const declaration = symbol.valueDeclaration;
        const signature = this._typeChecker.getSignatureFromDeclaration(declaration);
        if (!signature) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9004_UNABLE_TO_COMPUTE_SIGNATURE.create(declaration, symbol.name, type));
            return;
        }
        if (Case.pascal(type.name) === Case.pascal(symbol.name)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5019_MEMBER_TYPE_NAME_CONFLICT.create(declaration.name, 'method', symbol, type).addRelatedInformation((_a = declaringTypeDecl.name) !== null && _a !== void 0 ? _a : declaringTypeDecl, `The declaring ${type.kind} is introduced here`));
        }
        if (isProhibitedMemberName(symbol.name)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5016_PROHIBITED_MEMBER_NAME.create(declaration.name, symbol.name));
            return;
        }
        this._warnAboutReservedWords(symbol);
        const parameters = await Promise.all(signature.getParameters().map((p) => this._toParameter(p, ctx)));
        const returnType = signature.getReturnType();
        const method = bindings.setMethodRelatedNode({
            abstract: _isAbstract(symbol, type) || undefined,
            name: symbol.name,
            parameters: parameters.length > 0 ? parameters : undefined,
            protected: _isProtected(symbol) || undefined,
            returns: _isVoid(returnType)
                ? undefined
                : await this._optionalValue(returnType, declaration.name, 'return type'),
            async: _isPromise(returnType) || undefined,
            static: _isStatic(symbol) || undefined,
            locationInModule: this.declarationLocation(declaration),
        }, declaration);
        method.variadic =
            ((_b = method.parameters) === null || _b === void 0 ? void 0 : _b.some((p) => !!p.variadic)) === true ? true : undefined;
        this._verifyConsecutiveOptionals(declaration, method.parameters);
        method.docs = this._visitDocumentation(symbol, ctx).docs;
        // If the last parameter is a datatype, verify that it does not share any field names with
        // other function arguments, so that it can be turned into keyword arguments by jsii frontends
        // that support such.
        const lastParamTypeRef = apply(last(parameters), (x) => x.type);
        const lastParamSymbol = last(signature.getParameters());
        if (lastParamTypeRef && spec.isNamedTypeReference(lastParamTypeRef)) {
            this._deferUntilTypesAvailable(symbol.name, [lastParamTypeRef], lastParamSymbol.declarations[0], (lastParamType) => {
                if (!spec.isInterfaceType(lastParamType) || !lastParamType.datatype) {
                    return;
                }
                // Liftable datatype, make sure no parameter names match any of the properties in the datatype
                const propNames = this.allProperties(lastParamType);
                const paramNames = new Set(parameters.slice(0, parameters.length - 1).map((x) => x.name));
                const sharedNames = intersection(propNames, paramNames);
                for (const badName of sharedNames) {
                    this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5017_POSITIONAL_KEYWORD_CONFLICT.create(declaration, badName));
                }
            });
        }
        this._validateReferencedDocParams(method, symbol);
        type.methods = (_c = type.methods) !== null && _c !== void 0 ? _c : [];
        if (type.methods.find((m) => m.name === method.name && m.static === method.static) != null) {
            LOG.trace(`Dropping re-declaration of ${colors.green(type.fqn)}#${colors.cyan(method.name)}`);
            return;
        }
        type.methods.push(method);
        this.overrideDocComment(symbol, method.docs, paramDocs(method.parameters));
    }
    _warnAboutReservedWords(symbol) {
        if (!warnings_1.enabledWarnings['reserved-word']) {
            return;
        }
        const reservingLanguages = reserved_words_1.isReservedName(symbol.name);
        if (reservingLanguages) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5018_RESERVED_WORD.create(_nameOrDeclarationNode(symbol), symbol.name, reservingLanguages));
        }
    }
    async _visitProperty(symbol, type, ctx, declaringTypeDecl) {
        var _a, _b, _c, _d, _e, _f;
        if ((_a = type.properties) === null || _a === void 0 ? void 0 : _a.find((p) => p.name === symbol.name)) {
            /*
             * Second declaration of the same property. For example, if code specifies a getter & setter signature,
             * there will be one pass for each of the signatures, but we can process only the first encountered. The
             * typescript compiler will take care of making sure we don't have conflicting declarations, anyway.
             */
            return;
        }
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing property: ${colors.green(type.fqn)}#${colors.cyan(symbol.name)}`);
        }
        const declaration = (_b = symbol.valueDeclaration) !== null && _b !== void 0 ? _b : symbol.declarations[0];
        const signature = declaration;
        if (Case.pascal(type.name) === Case.pascal(symbol.name)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5019_MEMBER_TYPE_NAME_CONFLICT.create(signature.name, 'property', symbol, type).addRelatedInformation((_c = declaringTypeDecl.name) !== null && _c !== void 0 ? _c : declaringTypeDecl, `The declaring ${type.kind} is introduced here`));
        }
        if (isProhibitedMemberName(symbol.name)) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_5016_PROHIBITED_MEMBER_NAME.create((_d = symbol.valueDeclaration) !== null && _d !== void 0 ? _d : symbol.declarations[0], symbol.name));
            return;
        }
        this._warnAboutReservedWords(symbol);
        const property = bindings.setPropertyRelatedNode({
            ...(await this._optionalValue(this._typeChecker.getTypeOfSymbolAtLocation(symbol, signature), signature.name, 'property type')),
            abstract: _isAbstract(symbol, type) || undefined,
            name: symbol.name,
            protected: _isProtected(symbol) || undefined,
            static: _isStatic(symbol) || undefined,
            locationInModule: this.declarationLocation(signature),
        }, signature);
        if (ts.isGetAccessor(signature)) {
            const decls = (_e = symbol.getDeclarations()) !== null && _e !== void 0 ? _e : [];
            property.immutable =
                !decls.some((decl) => ts.isSetAccessor(decl)) || undefined;
        }
        else {
            property.immutable =
                (ts.getCombinedModifierFlags(signature) & ts.ModifierFlags.Readonly) !==
                    0 || undefined;
        }
        if (signature.questionToken) {
            property.optional = true;
        }
        if (property.static &&
            property.immutable &&
            ts.isPropertyDeclaration(signature) &&
            signature.initializer) {
            property.const = true;
        }
        property.docs = this._visitDocumentation(symbol, ctx).docs;
        type.properties = (_f = type.properties) !== null && _f !== void 0 ? _f : [];
        if (type.properties.find((prop) => prop.name === property.name && prop.static === property.static) != null) {
            LOG.trace(`Dropping re-declaration of ${colors.green(type.fqn)}#${colors.cyan(property.name)}`);
            return;
        }
        type.properties.push(property);
        this.overrideDocComment(symbol, property.docs);
    }
    async _toParameter(paramSymbol, ctx) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(`Processing parameter: ${colors.cyan(paramSymbol.name)}`);
        }
        const paramDeclaration = paramSymbol.valueDeclaration;
        this._warnAboutReservedWords(paramSymbol);
        const parameter = bindings.setParameterRelatedNode({
            ...(await this._optionalValue(this._typeChecker.getTypeAtLocation(paramDeclaration), paramDeclaration.name, 'parameter type')),
            name: paramSymbol.name,
            variadic: paramDeclaration.dotDotDotToken && true,
        }, paramDeclaration);
        if (parameter.variadic && spec.isCollectionTypeReference(parameter.type)) {
            // TypeScript types variadic parameters as an array, but JSII uses the item-type instead.
            parameter.type = parameter.type.collection.elementtype;
        }
        else if (paramDeclaration.initializer || paramDeclaration.questionToken) {
            // Optional parameters have an inherently null-able type.
            parameter.optional = true;
        }
        parameter.docs = this._visitDocumentation(paramSymbol, ctx.removeStability()).docs;
        // Don't rewrite doc comment here on purpose -- instead, we add them as '@param'
        // into the parent's doc comment.
        return parameter;
    }
    async _typeReference(type, declaration, purpose) {
        const optionalValue = await this._optionalValue(type, declaration, purpose);
        if (optionalValue.optional) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3999_INCOHERENT_TYPE_MODEL.create(declaration, 'Encountered optional value in location where a plain type reference is expected'));
        }
        return optionalValue.type;
    }
    async _optionalValue(type, declaration, purpose) {
        const isThisType = _isThisType(type, this._typeChecker);
        if (type.isLiteral() && _isEnumLike(type)) {
            type = this._typeChecker.getBaseTypeOfLiteralType(type);
        }
        else {
            type = this._typeChecker.getApparentType(type);
        }
        const primitiveType = _tryMakePrimitiveType.call(this);
        if (primitiveType) {
            return { type: primitiveType };
        }
        if (type.isUnion() && !_isEnumLike(type)) {
            return _unionType.call(this);
        }
        if (!type.symbol) {
            this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1001_TYPE_HAS_NO_SYMBOL.create(declaration));
            return { type: spec.CANONICAL_ANY };
        }
        if (type.symbol.name === 'Array') {
            return { type: await _arrayType.call(this) };
        }
        if (type.symbol.name === '__type' && type.symbol.members) {
            return { type: await _mapType.call(this) };
        }
        if (type.symbol.escapedName === 'Promise') {
            const typeRef = type;
            if (!typeRef.typeArguments || typeRef.typeArguments.length !== 1) {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1002_UNSPECIFIED_PROMISE.create(declaration));
                return { type: spec.CANONICAL_ANY };
            }
            return {
                type: await this._typeReference(typeRef.typeArguments[0], declaration, purpose),
            };
        }
        return {
            type: { fqn: await this._getFQN(type, declaration, purpose, isThisType) },
        };
        async function _arrayType() {
            var _a;
            const typeRef = type;
            let elementtype;
            if (((_a = typeRef.typeArguments) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                elementtype = await this._typeReference(typeRef.typeArguments[0], declaration, 'list element type');
            }
            else {
                const count = typeRef.typeArguments
                    ? typeRef.typeArguments.length
                    : 'none';
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1003_UNSUPPORTED_TYPE.create(declaration, `Array references must have exactly one type argument (found ${count})`));
                elementtype = spec.CANONICAL_ANY;
            }
            return {
                collection: {
                    elementtype,
                    kind: spec.CollectionKind.Array,
                },
            };
        }
        async function _mapType() {
            let elementtype;
            const objectType = type.getStringIndexType();
            if (objectType) {
                elementtype = await this._typeReference(objectType, declaration, 'map element type');
            }
            else {
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_1003_UNSUPPORTED_TYPE.create(declaration, 'Only string-indexed map types are supported'));
                elementtype = spec.CANONICAL_ANY;
            }
            return {
                collection: {
                    elementtype,
                    kind: spec.CollectionKind.Map,
                },
            };
        }
        function _tryMakePrimitiveType() {
            if (!type.symbol) {
                if (type.flags & ts.TypeFlags.Object) {
                    return { primitive: spec.PrimitiveType.Json };
                }
                if (type.flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
                    return spec.CANONICAL_ANY;
                }
            }
            else if (type.symbol.valueDeclaration &&
                isUnder(type.symbol.valueDeclaration.getSourceFile().fileName, this.stdlib)) {
                switch (type.symbol.name) {
                    case 'Boolean':
                        return { primitive: spec.PrimitiveType.Boolean };
                    case 'Date':
                        return { primitive: spec.PrimitiveType.Date };
                    case 'Number':
                        return { primitive: spec.PrimitiveType.Number };
                    case 'String':
                        return { primitive: spec.PrimitiveType.String };
                }
            }
            // Not a primitive type!
            return undefined;
            function isUnder(file, dir) {
                const relative = path.relative(dir, file);
                return !relative.startsWith(path.sep) && !relative.startsWith('..');
            }
        }
        async function _unionType() {
            const types = new Array();
            let optional;
            for (const subType of type.types) {
                if (subType.flags & ts.TypeFlags.Undefined) {
                    optional = true;
                    continue;
                }
                // eslint-disable-next-line no-await-in-loop
                const resolvedType = await this._typeReference(subType, declaration, purpose);
                if (types.find((ref) => deepEqual(ref, resolvedType)) != null) {
                    continue;
                }
                types.push(resolvedType);
            }
            return types.length === 1
                ? { optional, type: types[0] }
                : { optional, type: { union: { types } } };
        }
    }
    callDeferredsInOrder() {
        // Do a topological call order of all deferreds.
        while (this._deferred.length > 0) {
            // All fqns in dependency lists that don't have any pending
            // deferreds themselves can be executed now, so are removed from
            // dependency lists.
            const pendingFqns = new Set(this._deferred.map((x) => x.fqn));
            for (const deferred of this._deferred) {
                restrictDependenciesTo(deferred, pendingFqns);
            }
            // Invoke all deferreds with no more dependencies and remove them from the list.
            let invoked = false;
            for (let i = 0; i < this._deferred.length; i++) {
                if (this._deferred[i].dependedFqns.length === 0) {
                    const deferred = this._deferred.splice(i, 1)[0];
                    deferred.cb();
                    invoked = true;
                }
            }
            if (!invoked) {
                // Apparently we're stuck. Complain loudly.
                throw new Error(`Could not invoke any more deferreds, cyclic dependency? Remaining: ${JSON.stringify(this._deferred, undefined, 2)}`);
            }
        }
        /**
         * Retain only elements in the dependencyfqn that are also in the set
         */
        function restrictDependenciesTo(def, fqns) {
            def.dependedFqns = def.dependedFqns.filter(fqns.has.bind(fqns));
        }
    }
    /**
     * Return the set of all (inherited) properties of an interface
     */
    allProperties(root) {
        const ret = new Set();
        recurse.call(this, root);
        return ret;
        function recurse(int) {
            var _a, _b;
            for (const property of (_a = int.properties) !== null && _a !== void 0 ? _a : []) {
                ret.add(property.name);
            }
            for (const baseRef of (_b = int.interfaces) !== null && _b !== void 0 ? _b : []) {
                const base = this._dereference(baseRef, undefined);
                if (!base) {
                    throw new Error('Impossible to have unresolvable base in allProperties()');
                }
                if (!spec.isInterfaceType(base)) {
                    throw new Error('Impossible to have non-interface base in allProperties()');
                }
                recurse.call(this, base);
            }
        }
    }
    _verifyConsecutiveOptionals(node, parameters) {
        if (!parameters) {
            return;
        }
        const remaining = [...parameters].reverse();
        while (remaining.length > 0) {
            const current = remaining.pop();
            if (current.optional) {
                const offender = remaining.find((p) => !p.optional && !p.variadic);
                if (offender == null) {
                    continue;
                }
                this._diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_3009_OPTIONAL_PARAMETER_BEFORE_REQUIRED.create(node, current, offender));
                delete current.optional;
            }
        }
    }
    /**
     * Updates the runtime type info with the fully-qualified name for the current class definition.
     * Used by the runtime type info injector to add this information to the compiled file.
     */
    registerExportedClassFqn(clazz, fqn) {
        this.runtimeTypeInfoInjector.registerClassFqn(clazz, fqn);
    }
    /**
     * From the given JSIIDocs, re-render the TSDoc comment for the Node
     *
     * We may change the documentation a little, so that the doc comment that gets
     * written is not necessarily exactly the same as the docs that go into the
     * JSII manifest.
     *
     * This makes it possible for the code doc comments to highlight things
     * slighly differently from the API Reference, and makes sure we don't
     * duplicate information.
     *
     * Unless the docs got changed, this yields the same output back as the one that
     * we originally saw (modulo whitespace changes).
     */
    overrideDocComment(symbol, docs, parameters) {
        var _a;
        if (!docs || !symbol) {
            return;
        }
        docs = this.docCommentDocs(docs);
        // Some symbols have multiple declarations (for example, a class + interface
        // mixins, or a property declartaion + constructor argument).
        //
        // We DON'T wwant to put the doc comment on the constructor argument, because it
        // looks silly there.
        for (const decl of (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : []) {
            if (ts.isParameter(decl)) {
                continue;
            }
            this.commentReplacer.overrideNodeDocComment(decl, docs_1.renderSymbolDocumentation(docs, parameters));
        }
    }
    /**
     * Return a potentially new set of Docs, for rendering back to a TypeScript doc comment
     *
     * We put the "(experimental)"/"(deprecated)" status into the doc
     * comment summary, so that it's presented front and center.
     */
    docCommentDocs(docs) {
        // Modify the summary if this API element has a special stability
        if (docs.stability === spec.Stability.Experimental && docs.summary) {
            return {
                ...docs,
                summary: `(experimental) ${docs.summary}`,
            };
        }
        if (docs.stability === spec.Stability.Deprecated && docs.summary) {
            return {
                ...docs,
                summary: `(deprecated) ${docs.summary}`,
            };
        }
        return docs;
    }
    /**
     * Return only those submodules from the submodules list that are submodules inside this
     * assembly.
     */
    mySubmodules() {
        return Array.from(this._submodules.values()).filter((m) => m.fqn.startsWith(`${this.projectInfo.name}.`));
    }
}
exports.Assembler = Assembler;
function _fingerprint(assembly) {
    delete assembly.fingerprint;
    assembly = sortJson(assembly);
    const fingerprint = crypto
        .createHash('sha256')
        .update(JSON.stringify(assembly))
        .digest('base64');
    return { ...assembly, fingerprint };
}
function _isAbstract(symbol, declaringType) {
    // everything is abstract in interfaces
    if (declaringType.kind === spec.TypeKind.Interface) {
        return true;
    }
    return (!!symbol.valueDeclaration &&
        (ts.getCombinedModifierFlags(symbol.valueDeclaration) &
            ts.ModifierFlags.Abstract) !==
            0);
}
function _isEnumLike(type) {
    return (type.flags & ts.TypeFlags.EnumLike) !== 0;
}
function _isExported(node) {
    return (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0;
}
/**
 * Members with names starting with `_` (and marked as @internal) and members
 * that are private are hidden.
 *
 * @param symbol the symbol which should be assessed
 *
 * @return `true` if the symbol should be hidden
 */
function _isPrivate(symbol) {
    const TYPE_DECLARATION_KINDS = new Set([
        ts.SyntaxKind.ClassDeclaration,
        ts.SyntaxKind.InterfaceDeclaration,
        ts.SyntaxKind.EnumDeclaration,
    ]);
    // if the symbol doesn't have a value declaration, we are assuming it's a type (enum/interface/class)
    // and check that it has an "export" modifier
    if (!symbol.valueDeclaration ||
        TYPE_DECLARATION_KINDS.has(symbol.valueDeclaration.kind)) {
        let hasExport = false;
        for (const decl of symbol.declarations) {
            if (ts.getCombinedModifierFlags(decl) & ts.ModifierFlags.Export) {
                hasExport = true;
                break;
            }
            // Handle nested classes from project references
            if (ts.isModuleBlock(decl.parent)) {
                const moduleDeclaration = decl.parent.parent;
                const modifiers = ts.getCombinedModifierFlags(moduleDeclaration);
                // The trick is the module is declared as ambient & exported
                if ((modifiers & ts.ModifierFlags.Ambient) !== 0 &&
                    (modifiers & ts.ModifierFlags.Export) !== 0) {
                    hasExport = true;
                    break;
                }
            }
        }
        return !hasExport;
    }
    return (symbol.valueDeclaration &&
        (ts.getCombinedModifierFlags(symbol.valueDeclaration) &
            ts.ModifierFlags.Private) !==
            0);
}
function _hasInternalJsDocTag(symbol) {
    return symbol.getJsDocTags().some((t) => t.name === 'internal');
}
function _isProtected(symbol) {
    return (!!symbol.valueDeclaration &&
        (ts.getCombinedModifierFlags(symbol.valueDeclaration) &
            ts.ModifierFlags.Protected) !==
            0);
}
function _isStatic(symbol) {
    return (!!symbol.valueDeclaration &&
        (ts.getCombinedModifierFlags(symbol.valueDeclaration) &
            ts.ModifierFlags.Static) !==
            0);
}
function _isVoid(type) {
    return (type.flags & ts.TypeFlags.Void) !== 0;
}
function _isPromise(type) {
    var _a;
    return ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.escapedName) === 'Promise';
}
function _sortMembers(type) {
    type.methods = type.methods && _sort(type.methods);
    type.properties = type.properties && _sort(type.properties);
    return type;
    /**
     * Sorts a member array such that:
     * 1. Static members appear first
     * 2. Immutable members appear first
     * 3. Non-optional members appear first
     * 4. Members appear in lexicographical order
     *
     * @param values the array of members to be sorted
     *
     * @return a sorted copy of ``values``
     */
    function _sort(values) {
        if (!values) {
            return values;
        }
        return values.sort(_comparator);
        function _comparator(lval, rval) {
            return _format(lval).localeCompare(_format(rval));
            function _format(val) {
                return [
                    val.static ? '0' : '1',
                    val.immutable ? '0' : '1',
                    !val.optional ? '0' : '1',
                    val.name,
                ].join('|');
            }
        }
    }
}
/**
 * Return the last element from a list
 */
function last(xs) {
    return xs.length > 0 ? xs[xs.length - 1] : undefined;
}
/**
 * Apply a function to a value if it's not equal to undefined
 */
function apply(x, fn) {
    return x !== undefined ? fn(x) : undefined;
}
/**
 * Return the intersection of two sets
 */
function intersection(xs, ys) {
    const ret = new Set();
    for (const x of xs) {
        if (ys.has(x)) {
            ret.add(x);
        }
    }
    return ret;
}
/**
 * Return all members names of a JSII interface type
 *
 * Returns empty string for a non-interface type.
 */
function memberNames(jsiiType) {
    return Object.keys(typeMembers(jsiiType)).filter((n) => n !== '');
}
function typeMembers(jsiiType) {
    var _a, _b, _c;
    const ret = {};
    for (const prop of (_a = jsiiType.properties) !== null && _a !== void 0 ? _a : []) {
        ret[prop.name] = prop;
    }
    for (const method of (_b = jsiiType.methods) !== null && _b !== void 0 ? _b : []) {
        ret[(_c = method.name) !== null && _c !== void 0 ? _c : ''] = method;
    }
    return ret;
}
/**
 * Whether or not the given name is conventionally an interface name
 *
 * It's an interface name if it starts with I and has another capital
 * (so we don't mark IonicColumnProps as an interface).
 */
function isInterfaceName(name) {
    return (name.length >= 2 &&
        name.startsWith('I') &&
        name.charAt(1).toUpperCase() === name.charAt(1));
}
function getConstructor(type) {
    var _a;
    return (_a = type.symbol.members) === null || _a === void 0 ? void 0 : _a.get(ts.InternalSymbolName.Constructor);
}
function* intersect(xs, ys) {
    for (const x of xs) {
        if (ys.has(x)) {
            yield x;
        }
    }
}
function noEmptyDict(xs) {
    if (xs == null || Object.keys(xs).length === 0) {
        return undefined;
    }
    return xs;
}
function toDependencyClosure(assemblies) {
    const result = {};
    for (const assembly of assemblies) {
        if (!assembly.targets) {
            continue;
        }
        result[assembly.name] = {
            submodules: cleanUp(assembly.submodules),
            targets: assembly.targets,
        };
    }
    return result;
    /**
     * Removes unneeded fields from the entries part of the `dependencyClosure`
     * property. Fields such as `readme` are not necessary and can bloat up the
     * assembly object.
     *
     * This removes the `readme` and `locationInModule` fields from the submodule
     * descriptios if present.
     *
     * @param submodules the submodules list to clean up.
     *
     * @returns the cleaned up submodules list.
     */
    function cleanUp(submodules) {
        if (submodules == null) {
            return submodules;
        }
        const result = {};
        for (const [fqn, { targets }] of Object.entries(submodules)) {
            result[fqn] = { targets };
        }
        return result;
    }
}
function toSubmoduleDeclarations(submodules) {
    const result = {};
    for (const submodule of submodules) {
        result[submodule.fqn] = {
            locationInModule: submodule.locationInModule,
            targets: submodule.targets,
            readme: submodule.readme,
            symbolId: submodule.symbolId,
        };
    }
    return result;
}
/**
 * Check whether this type is the intrinsic TypeScript "error type"
 *
 * This type is returned if type lookup fails. Unfortunately no public
 * accessors for it are exposed.
 */
function isErrorType(t) {
    return t.intrinsicName === 'error';
}
/**
 * Those have specific semantics in certain languages that don't always translate cleanly in others
 * (like how equals/hashCode are not a thing in Javascript, but carry meaning in Java and C#). The
 * `build` name is reserved for generated code (Java builders use that).
 */
const PROHIBITED_MEMBER_NAMES = ['build', 'equals', 'hashcode'];
/**
 * Whether the given name is prohibited
 */
function isProhibitedMemberName(name) {
    return PROHIBITED_MEMBER_NAMES.includes(name.toLowerCase());
}
/**
 * Information about the context in which a declaration is emitted.
 */
class EmitContext {
    constructor(namespace, stability) {
        this.namespace = namespace;
        this.stability = stability;
    }
    /**
     * Create a new EmitContext by appending a namespace entry at the end.
     * @param element the new namespace entry.
     */
    appendNamespace(element) {
        return new EmitContext([...this.namespace, element], this.stability);
    }
    /**
     * Create a new EmitContext by replacing the stability.
     * @param stability the new stability, if available.
     */
    replaceStability(stability) {
        if (!stability) {
            return this;
        }
        return new EmitContext(this.namespace, stability);
    }
    /**
     * Create a new EmitContext without stability.
     */
    removeStability() {
        return new EmitContext(this.namespace, undefined);
    }
}
async function flattenPromises(promises) {
    const result = new Array();
    for (const subset of await Promise.all(promises)) {
        result.push(...subset);
    }
    return result;
}
function inferRootDir(program) {
    const directories = program
        .getRootFileNames()
        .filter((fileName) => {
        const sourceFile = program.getSourceFile(fileName);
        return (sourceFile != null &&
            !program.isSourceFileFromExternalLibrary(sourceFile) &&
            !program.isSourceFileDefaultLibrary(sourceFile));
    })
        .map((fileName) => path.relative(program.getCurrentDirectory(), path.dirname(fileName)))
        .map(segmentPath);
    const maxPrefix = Math.min(...directories.map((segments) => segments.length - 1));
    let commonIndex = -1;
    while (commonIndex < maxPrefix &&
        new Set(directories.map((segments) => segments[commonIndex + 1])).size === 1) {
        commonIndex++;
    }
    if (commonIndex < 0) {
        return undefined;
    }
    return directories[0][commonIndex];
    function segmentPath(fileName) {
        const result = new Array();
        for (let parent = fileName; parent !== path.dirname(parent); parent = path.dirname(parent)) {
            result.unshift(parent);
        }
        return result;
    }
}
/**
 * Determines whether the provided type is a single-valued enum. It is necessary
 * to check as enums are union-like in the type model, and single-valued enum
 * types are actually reduced to the only available literal, which can trip
 * the assembler.
 *
 * @param type        the type being checked.
 * @param typeChecker the type checker to use to get more information.
 *
 * @return `true` if `type` is a single-valued enum type.
 */
function isSingleValuedEnum(type, typeChecker) {
    if (type.isLiteral() && _isEnumLike(type)) {
        // Single-Valued enums are reduced to the only literal available.
        return type === typeChecker.getBaseTypeOfLiteralType(type);
    }
    return false;
}
async function findPackageInfo(fromDir) {
    const filePath = path.join(fromDir, 'package.json');
    if (await fs.pathExists(filePath)) {
        return fs.readJson(filePath);
    }
    const parent = path.dirname(fromDir);
    if (parent === fromDir) {
        return undefined;
    }
    return findPackageInfo(parent);
}
function paramDocs(params) {
    const ret = {};
    for (const param of params !== null && params !== void 0 ? params : []) {
        if (param.docs) {
            ret[param.name] = param.docs;
        }
    }
    return ret;
}
/**
 * Checks is the provided type is "this" (as a type annotation).
 *
 * @param type        the validated type.
 * @param typeChecker the type checker.
 *
 * @returns `true` iif the type is `this`
 */
function _isThisType(type, typeChecker) {
    var _a;
    return ((_a = typeChecker.typeToTypeNode(type)) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.ThisKeyword;
}
/**
 * Gets the name node for a given symbol; or it's first declaration if no name can be found. This is
 * intended for use in placing problem markers on the right location.
 *
 * @param symbol the symbol for which the name node is needed.
 *
 * @returns the name node for the symbol, or the symbol's first declaration.
 */
function _nameOrDeclarationNode(symbol) {
    var _a, _b;
    const declaration = (_a = symbol.valueDeclaration) !== null && _a !== void 0 ? _a : symbol.declarations[0];
    return (_b = ts.getNameOfDeclaration(declaration)) !== null && _b !== void 0 ? _b : declaration;
}
function _findHint(decl, hint) {
    const [node] = ts.getAllJSDocTags(decl, (tag) => tag.tagName.text === hint);
    return node;
}
/**
 * Resolve a Type to Symbol, taking into account single-valued enums which have a bug
 *
 * Bug reference: https://github.com/microsoft/TypeScript/issues/46755
 */
function symbolFromType(type, typeChecker) {
    var _a, _b;
    if ((type.flags & ts.TypeFlags.EnumLiteral) === 0) {
        return type.symbol;
    }
    const decl = (_a = type.symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
    if (!decl) {
        return type.symbol;
    }
    if (!ts.isEnumMember(decl)) {
        return type.symbol;
    }
    const parentDecl = decl.parent;
    if (!parentDecl || !ts.isEnumDeclaration(parentDecl)) {
        return type.symbol;
    }
    const name = ts.getNameOfDeclaration(parentDecl);
    if (!name) {
        return type.symbol;
    }
    return (_b = typeChecker.getSymbolAtLocation(name)) !== null && _b !== void 0 ? _b : type.symbol;
}
const SYMBOLID_CACHE = new WeakMap();
/**
 * Build and return an index of { symbolId -> fqn }
 *
 * Uses a cache for performance reasons.
 */
function symbolIdIndex(asm) {
    const existing = SYMBOLID_CACHE.get(asm);
    if (existing) {
        return existing;
    }
    const ret = buildIndex();
    SYMBOLID_CACHE.set(asm, ret);
    return ret;
    function buildIndex() {
        var _a;
        const ret = {};
        for (const [fqn, type] of Object.entries((_a = asm.types) !== null && _a !== void 0 ? _a : {})) {
            if (type.symbolId) {
                ret[type.symbolId] = fqn;
            }
        }
        return ret;
    }
}
function getSymbolFromDeclaration(decl, typeChecker) {
    const name = ts.getNameOfDeclaration(decl);
    return name ? typeChecker.getSymbolAtLocation(name) : undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZW1ibGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXNzZW1ibGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUVuQyw2QkFBNkI7QUFDN0Isc0NBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQyxpRUFBaUU7QUFDakUsd0NBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUVqQyxpQ0FLZ0I7QUFFaEIsdURBQW1EO0FBQ25ELHVDQUF1QztBQUN2Qyw0Q0FBNEM7QUFFNUMscURBQWtEO0FBQ2xELDJDQUErQztBQUMvQyx3RUFBb0U7QUFDcEUsNEVBQWdGO0FBQ2hGLDREQUFvRTtBQUNwRSwwRUFBcUU7QUFDckUsOENBQTBEO0FBQzFELDJDQUF3QztBQUN4Qyx1Q0FBbUQ7QUFDbkQseUNBQTZDO0FBRTdDLHFHQUFxRztBQUNyRyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFdEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBRS9DOztHQUVHO0FBQ0gsTUFBYSxTQUFTO0lBMEJwQjs7OztPQUlHO0lBQ0gsWUFDa0IsV0FBd0IsRUFDeEIsT0FBbUIsRUFDbkIsTUFBYyxFQUM5QixVQUE0QixFQUFFOztRQUhkLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFDbkIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQWpDZixvQkFBZSxHQUFHLElBQUksdUNBQWlCLEVBQUUsQ0FBQztRQVFuRCxpQkFBWSxHQUFHLElBQUksS0FBSyxFQUFrQixDQUFDO1FBQzNDLGNBQVMsR0FBRyxJQUFJLEtBQUssRUFBa0IsQ0FBQztRQUN4QyxXQUFNLEdBQWlDLEVBQUUsQ0FBQztRQUVsRCwrQ0FBK0M7UUFDOUIsa0JBQWEsR0FBRyxJQUFJLEdBQUcsRUFBd0IsQ0FBQztRQUVqRTs7Ozs7OztXQU9HO1FBQ2MsZ0JBQVcsR0FBRyxJQUFJLEdBQUcsRUFBNEIsQ0FBQztRQWFqRSxJQUFJLE9BQU8sQ0FBQyxlQUFlLEVBQUU7WUFDM0IsSUFBSSx1QkFBZ0QsQ0FBQztZQUNyRCxJQUFJLE9BQU8sQ0FBQyw0QkFBNEIsRUFBRTtnQkFDeEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLDRCQUE0QixDQUFDLEVBQUU7b0JBQ3hELE1BQU0sSUFBSSxLQUFLLENBQ2Isc0NBQXNDLE9BQU8sQ0FBQyw0QkFBNEIsRUFBRSxDQUM3RSxDQUFDO2lCQUNIO2dCQUNELHVCQUF1QixHQUFHLElBQUksR0FBRyxDQUMvQixFQUFFO3FCQUNDLFlBQVksQ0FBQyxPQUFPLENBQUMsNEJBQTRCLEVBQUUsTUFBTSxDQUFDO3FCQUMxRCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQ2YsQ0FBQzthQUNIO1lBRUQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksc0NBQWlCLENBQzVDLElBQUksQ0FBQyxZQUFZLEVBQ2pCLHVCQUF1QixDQUN4QixDQUFDO1NBQ0g7UUFFRCxJQUFJLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRTtZQUNsQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxrREFBMkIsQ0FDckQsSUFBSSxDQUFDLFlBQVksQ0FDbEIsQ0FBQztTQUNIO1FBRUQsTUFBTSxHQUFHLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQztRQUM5QixJQUFJLFFBQVEsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVwRCx3RUFBd0U7UUFDeEUsMkVBQTJFO1FBQzNFLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLE1BQU0sQ0FBQztRQUN0RCxJQUFJLFNBQVMsSUFBSSxJQUFJLEVBQUU7WUFDckIsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRTlDLHdFQUF3RTtZQUN4RSx3RUFBd0U7WUFDeEUsSUFBSSxDQUFDLFVBQVUsU0FDYixPQUFPLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxPQUFPLG1DQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoRSxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxFQUFFO2dCQUMzQixRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQ2pEO1NBQ0Y7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUMsdUJBQXVCLEdBQUcsSUFBSSxzQ0FBdUIsQ0FDeEQsV0FBVyxDQUFDLE9BQU8sQ0FDcEIsQ0FBQztJQUNKLENBQUM7SUFFRCxJQUFXLGtCQUFrQjs7UUFDM0IsT0FBTyw0QkFBb0IsYUFDekIsSUFBSSxDQUFDLGlCQUFpQiwwQ0FBRSxrQkFBa0IsbUNBQUksRUFBRSxFQUNoRCxJQUFJLENBQUMsdUJBQXVCLENBQUMsZ0JBQWdCLEVBQUUsRUFDL0MsSUFBSSxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsRUFBRSxjQUN2QyxJQUFJLENBQUMsZ0JBQWdCLDBDQUFFLGtCQUFrQixtQ0FBSSxFQUFFLENBQ2hELENBQUM7SUFDSixDQUFDO0lBRUQsSUFBWSxZQUFZO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEtBQUssQ0FBQyxJQUFJOztRQUNmLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRTtZQUNqQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQyxpQ0FBaUMsQ0FBQyxjQUFjLEVBQUUsQ0FDbEUsQ0FBQztTQUNIO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFO1lBQzlCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDhCQUE4QixDQUFDLGNBQWMsRUFBRSxDQUMvRCxDQUFDO1NBQ0g7UUFDRCxNQUFNLE1BQU0sR0FBRyxNQUFNLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUMsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1lBQ2xCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLHdCQUF3QixDQUFDLGNBQWMsRUFBRSxDQUN6RCxDQUFDO1NBQ0g7UUFDRCxNQUFNLElBQUksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWxDLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLE1BQU0sYUFBYSxHQUFHLElBQUksS0FBSyxFQUFnQixDQUFDO1FBRWhELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU3RCxJQUFJLFVBQVUsSUFBSSxJQUFJLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsbUNBQW1DLENBQUMsY0FBYyxDQUMvRCxJQUFJLENBQUMsUUFBUSxDQUNkLENBQ0YsQ0FBQztTQUNIO2FBQU07WUFDTCxNQUFNLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUV2RCxJQUFJLEdBQUcsQ0FBQyxjQUFjLEVBQUUsRUFBRTtnQkFDeEIsR0FBRyxDQUFDLEtBQUssQ0FDUCwyQkFBMkIsTUFBTSxDQUFDLElBQUksQ0FDcEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsUUFBUSxDQUFDLENBQ2pFLEVBQUUsQ0FDSixDQUFDO2FBQ0g7WUFDRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2pFLElBQUksTUFBTSxFQUFFO2dCQUNWLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ25FLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FDZixhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FDekIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUM3RCxDQUNGLENBQUM7Z0JBQ0YsS0FBSyxNQUFNLElBQUksSUFBSSxhQUFhLEVBQUU7b0JBQ2hDLGFBQWEsQ0FBQyxJQUFJLENBQ2hCLElBQUksQ0FBQyxVQUFVLENBQ2IsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFDcEIsSUFBSSxXQUFXLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQ2hELENBQ0YsQ0FBQztpQkFDSDthQUNGO1NBQ0Y7UUFFRCxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFakMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFFNUIsc0RBQXNEO1FBQ3RELElBQ0UsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQ3hELElBQUksSUFBSSxFQUNUO1lBQ0EsR0FBRyxDQUFDLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1lBQzFDLHNFQUFzRTtZQUN0RSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDbkIsSUFBSTtnQkFDRixPQUFPLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO2FBQzlEO29CQUFTO2dCQUNSLDRFQUE0RTtnQkFDNUUsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO2FBQzFCO1NBQ0Y7UUFFRCxNQUFNLFdBQVcsR0FDZixJQUFJLENBQUMsV0FBVyxDQUFDLGlCQUFpQixLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUMsdUJBQWEsQ0FBQyxDQUFDLENBQUMsaUJBQU8sQ0FBQztRQUUzRSxNQUFNLFFBQVEsR0FBa0I7WUFDOUIsTUFBTSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTTtZQUNqQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJO1lBQzNCLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU87WUFDakMsV0FBVyxRQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxtQ0FBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUk7WUFDbEUsT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTztZQUNqQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRO1lBQ25DLFFBQVEsUUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsbUNBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsR0FBRztZQUN0RSxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNO1lBQy9CLFlBQVksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksSUFBSTtnQkFDN0MsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVk7YUFDakM7WUFDRCxVQUFVLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVO1lBQ3ZDLFlBQVksRUFBRSxXQUFXLENBQUM7Z0JBQ3hCLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZO2dCQUNoQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCO2FBQ3JDLENBQUM7WUFDRixpQkFBaUIsRUFBRSxXQUFXLENBQzVCLG1CQUFtQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsaUJBQWlCLENBQUMsQ0FDeEQ7WUFDRCxPQUFPLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0I7WUFDNUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ2xCLFVBQVUsRUFBRSxXQUFXLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7WUFDckUsT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTztZQUNqQyxRQUFRLEVBQUU7Z0JBQ1IsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVE7Z0JBRTVCLHNFQUFzRTtnQkFDdEUsMkJBQTJCO2dCQUMzQixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVU7YUFDNUI7WUFDRCxJQUFJO1lBQ0osTUFBTTtZQUNOLFdBQVc7WUFDWCxHQUFHLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHO1lBQ3pCLFdBQVcsRUFBRSxPQUFPO1NBQ3JCLENBQUM7UUFFRixJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUMxQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztTQUN4RTtRQUVELElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ3pCLE1BQU0sWUFBWSxHQUFHO2dCQUNuQixHQUFHLGFBQUMsUUFBUSxDQUFDLFFBQVEsMENBQUUsSUFBSSxtQ0FBSSxFQUFFLENBQUM7Z0JBQ2xDLEdBQUcsRUFBRSwrQkFBK0IsRUFBRSxJQUFJLEVBQUU7YUFDN0MsQ0FBQztZQUVGLElBQUksUUFBUSxDQUFDLFFBQVEsRUFBRTtnQkFDckIsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsWUFBWSxDQUFDO2FBQ3ZDO2lCQUFNO2dCQUNMLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLENBQUM7YUFDNUM7WUFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDM0Q7UUFFRCxNQUFNLFNBQVMsR0FBRyxJQUFJLHFCQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUM1RCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2hELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUU7WUFDakMsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUN0RSxHQUFHLENBQUMsS0FBSyxDQUFDLHNCQUFzQixNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM3RCxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDdkQsUUFBUSxFQUFFLE1BQU07Z0JBQ2hCLE1BQU0sRUFBRSxDQUFDO2FBQ1YsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxJQUFJO1lBQ0YsT0FBTztnQkFDTCxXQUFXLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUM7Z0JBQ3BFLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxXQUFXO2FBQzFDLENBQUM7U0FDSDtnQkFBUztZQUNSLHNFQUFzRTtZQUN0RSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7WUFFbkIsNEVBQTRFO1lBQzVFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztTQUMxQjtRQUVELEtBQUssVUFBVSxXQUFXO1lBQ3hCLG1EQUFtRDtZQUNuRCxNQUFNLFFBQVEsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNwRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEtBQUssV0FBVyxDQUNuRCxDQUFDO1lBQ0YsSUFBSSxRQUFRLElBQUksSUFBSSxFQUFFO2dCQUNwQixPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDckUsTUFBTSxhQUFhLEdBQUcsTUFBTSxRQUFRLENBQUMsd0JBQXdCLENBQzNELE1BQU0sUUFBUSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsRUFDdkMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQ3hELENBQUM7WUFDRixPQUFPLEVBQUUsUUFBUSxFQUFFLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUNoRCxDQUFDO1FBRUQsU0FBUyxTQUFTO1lBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFO2dCQUMvRCxPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDO1lBQy9DLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDO1lBQzdDLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLENBQUM7UUFDbkMsQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0sseUJBQXlCLENBQy9CLEdBQVcsRUFDWCxTQUFrRCxFQUNsRCxlQUF3QixFQUN4QixFQUFnQztRQUVoQyw2QkFBNkI7UUFDN0IsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQixFQUFFLEVBQUUsQ0FBQztZQUNMLE9BQU87U0FDUjtRQUNELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUNwQyxPQUFPLEVBQUUsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FDckMsQ0FBQztRQUVGLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUU7WUFDOUIsTUFBTSxRQUFRLEdBQUcsUUFBUTtpQkFDdEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxlQUFlLENBQUMsQ0FBQztpQkFDakQsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUM7WUFDbEMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDdkIsRUFBRSxDQUFDLEdBQUksUUFBd0IsQ0FBQyxDQUFDO2FBQ2xDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSyxNQUFNLENBQUMsR0FBVyxFQUFFLFlBQXNCLEVBQUUsRUFBYztRQUNoRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxZQUFZLENBQ2xCLEdBQXFDLEVBQ3JDLGVBQW9DOztRQUVwQyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtZQUMzQixHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQztTQUNmO1FBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUIsSUFBSSxJQUFJLENBQUM7UUFDVCxJQUFJLElBQUksS0FBSyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRTtZQUNsQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN6QjthQUFNO1lBQ0wsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQ3RELENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLElBQUksQ0FDM0IsQ0FBQztZQUNGLElBQUksU0FBRyxRQUFRLGFBQVIsUUFBUSx1QkFBUixRQUFRLENBQUUsS0FBSywwQ0FBRyxHQUFHLENBQUMsQ0FBQztZQUU5Qiw2RUFBNkU7WUFDN0UsOEVBQThFO1lBQzlFLElBQUksUUFBUSxFQUFFO2dCQUNaLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO29CQUN6RCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQyxpQ0FBaUMsQ0FBQyxNQUFNLENBQ3JELGVBQWdCLEVBQUUsd0VBQXdFO29CQUMxRixRQUFRLENBQUMsSUFBSSxFQUNiLEdBQUcsQ0FDSixDQUNGLENBQUM7aUJBQ0g7YUFDRjtTQUNGO1FBRUQsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDRCQUE0QixDQUFDLE1BQU0sQ0FDaEQsZUFBZ0IsRUFBRSx3RUFBd0U7WUFDMUYsR0FBRyxDQUNKLENBQ0YsQ0FBQztTQUNIO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNLLEtBQUssQ0FBQyxPQUFPLENBQ25CLElBQWEsRUFDYixrQkFBMkIsRUFDM0IsT0FBb0IsRUFDcEIsVUFBbUI7O1FBRW5CLE1BQU0sR0FBRyxHQUFHLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXBELE1BQU0sZUFBZSxTQUFHLEdBQUcsQ0FBQyxnQkFBZ0IseUNBQUksR0FBRyxDQUFDLFlBQVksMENBQUcsQ0FBQyxDQUFDLENBQUM7UUFFdEUscUZBQXFGO1FBQ3JGLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUVyQixJQUFJLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNsQywwRUFBMEU7WUFDMUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsK0JBQStCLENBQUMsTUFBTSxDQUNuRCxrQkFBa0IsRUFDbEIsR0FBRyxFQUNILFVBQVUsRUFDVixPQUFPLENBQ1IsQ0FBQyxxQkFBcUIsQ0FDckIsZUFBZSxFQUNmLHNDQUFzQyxDQUN2QyxDQUNGLENBQUM7WUFFRixRQUFRLEdBQUcsSUFBSSxDQUFDO1NBQ2pCO1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM1RCxNQUFNLE1BQU0sR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2IsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsK0JBQStCLENBQUMsTUFBTSxDQUNuRCxrQkFBa0IsRUFDbEIsR0FBRyxFQUNILFVBQVUsRUFDVixPQUFPLENBQ1IsQ0FBQyxxQkFBcUIsQ0FDckIsZUFBZSxFQUNmLHNDQUFzQyxDQUN2QyxDQUNGLENBQUM7Z0JBQ0YsUUFBUSxHQUFHLElBQUksQ0FBQzthQUNqQjtZQUNELE9BQU8sTUFBTSxDQUFDO1NBQ2Y7UUFDRCxNQUFNLENBQUMsRUFBRSxVQUFVLEVBQUUsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBQ3hDLE1BQU0sR0FBRyxHQUFHLE1BQU0sZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDUixJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNiLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDhCQUE4QixDQUFDLE1BQU0sQ0FDbEQsa0JBQWtCLEVBQ2xCLFVBQVUsQ0FDWCxDQUFDLHFCQUFxQixDQUNyQixlQUFlLEVBQ2Ysc0NBQXNDLENBQ3ZDLENBQ0YsQ0FBQztnQkFDRixRQUFRLEdBQUcsSUFBSSxDQUFDO2FBQ2pCO1lBQ0QsT0FBTyxXQUFXLFFBQVEsRUFBRSxDQUFDO1NBQzlCO1FBRUQscUVBQXFFO1FBQ3JFLHFGQUFxRjtRQUNyRixJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUU7WUFDdEMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDOUMsSUFBSSxTQUFTLElBQUksSUFBSSxFQUFFO2dCQUNyQixNQUFNLFdBQVcsR0FDZixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUUsQ0FBQyxtQkFBbUIsQ0FBQztnQkFDdkQsT0FBTyxHQUFHLFdBQVcsSUFBSSxRQUFRLEVBQUUsQ0FBQzthQUNyQztZQUVELE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxRQUFRLEVBQUUsQ0FBQztTQUMvQztRQUVELHVFQUF1RTtRQUN2RSwwRUFBMEU7UUFDMUUsMEVBQTBFO1FBQzFFLDhFQUE4RTtRQUM5RSxNQUFNLFdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLElBQUksUUFBUSxFQUFFLENBQUM7UUFFOUMsdUVBQXVFO1FBQ3ZFLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUNqRCxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxDQUMzQixDQUFDO1FBQ0YsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLHdCQUF3QixDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQ2pFLENBQUM7WUFDRixPQUFPLFdBQVcsQ0FBQztTQUNwQjtRQUNELE1BQU0sUUFBUSxHQUFHLDRCQUFnQixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFO1lBQ3hELFFBQVEsRUFBRSxHQUFHO1NBQ2QsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxHQUFHLFNBQ1AsQ0FBQyxHQUFHLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxtQ0FDNUQsV0FBVyxDQUFDO1FBRWQsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUM3RCxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNiLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLHdDQUF3QyxDQUFDLE1BQU0sQ0FDNUQsa0JBQWtCLEVBQ2xCLEdBQUcsYUFBSCxHQUFHLGNBQUgsR0FBRyxHQUFJLE1BQU0sRUFDYixPQUFPLEVBQ1AsR0FBRyxDQUNKLENBQUMscUJBQXFCLENBQ3JCLGVBQWUsRUFDZixzQ0FBc0MsQ0FDdkMsQ0FDRixDQUFDO2dCQUNGLFFBQVEsR0FBRyxJQUFJLENBQUM7YUFDakI7U0FDRjtRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssS0FBSyxDQUFDLCtCQUErQixDQUFDLFVBQXlCO1FBQ3JFLEtBQUssTUFBTSxJQUFJLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRTtZQUNyRCxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQ25DLElBQUksQ0FBQyxJQUFJLEVBQ1QsVUFBVSxDQUFDLFFBQVEsRUFDbkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxFQUNqQyxFQUFFLENBQUMsR0FBRyxDQUNQLENBQUM7WUFDRiwrRkFBK0Y7WUFDL0YsSUFBSSxRQUFRLENBQUMsY0FBYyxJQUFJLElBQUksRUFBRTtnQkFDbkMsU0FBUzthQUNWO1lBQ0QsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQ3ZDLFFBQVEsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQ3pDLENBQUM7WUFDRixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN2RSw2R0FBNkc7WUFDN0csSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO2dCQUNsQixTQUFTO2FBQ1Y7WUFFRCxNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBRXRFLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDakUsNENBQTRDO2dCQUM1QyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDakQ7U0FDRjtRQUVELFNBQVMsV0FBVyxDQUFDLElBQVk7WUFDL0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssY0FBYyxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUU7Z0JBQy9ELE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFDRCxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QixDQUFDO0lBQ0gsQ0FBQztJQUVPLEtBQUssQ0FBQyxtQkFBbUIsQ0FDL0IsTUFBaUIsRUFDakIsV0FBbUI7O1FBRW5CLE1BQU0sV0FBVyxTQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsbUNBQUksTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0RSxJQUFJLFdBQVcsSUFBSSxJQUFJLEVBQUU7WUFDdkIsd0JBQXdCO1lBQ3hCLE9BQU87U0FDUjtRQUNELElBQUksRUFBRSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQ3ZDLGNBQWM7WUFDZCxFQUFFO1lBQ0YsNkJBQTZCO1lBQzdCLFlBQVk7WUFDWixPQUFPO1lBQ1AsRUFBRTtZQUNGLDhCQUE4QjtZQUU5QixNQUFNLEVBQUUsR0FBRyxFQUFFLG1CQUFtQixFQUFFLEdBQUcsTUFBTSxlQUFlLENBQUMsSUFBSSxDQUM3RCxJQUFJLEVBQ0osTUFBTSxFQUNOLElBQUksQ0FDTCxDQUFDO1lBRUYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFO2dCQUMzQixHQUFHO2dCQUNILG1CQUFtQjtnQkFDbkIsUUFBUSxFQUFFLDRCQUFnQixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDO2dCQUNyRCxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsV0FBVyxDQUFDO2FBQ3hELENBQUMsQ0FBQztZQUNILE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ3hELE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDdEMsd0JBQXdCO1lBQ3hCLE9BQU87U0FDUjtRQUVELE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDO1FBQzNELElBQUksZUFBZSxJQUFJLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDbkUsc0VBQXNFO1lBQ3RFLE9BQU87U0FDUjtRQUNELE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FDckMsZUFBZSxDQUFDLElBQUksRUFDcEIsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDLFFBQVEsRUFDcEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxFQUNqQyxFQUFFLENBQUMsR0FBRyxDQUNQLENBQUM7UUFDRixJQUFJLFVBQVUsQ0FBQyxjQUFjLElBQUksSUFBSSxFQUFFO1lBQ3JDLDJEQUEyRDtZQUMzRCxPQUFPO1NBQ1I7UUFFRCxrRkFBa0Y7UUFDbEYsVUFBVSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUN6RCxVQUFVLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUMzQyxDQUFDO1FBQ0Y7UUFDRSxpR0FBaUc7UUFDakcsQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXO1lBQzNDLFVBQVUsQ0FBQyxjQUFjLENBQUMsdUJBQXVCLENBQUM7WUFDcEQsMkVBQTJFO1lBQzNFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDO1lBQ25FLDJFQUEyRTtZQUMzRSxVQUFVLENBQUMsY0FBYyxDQUFDLGdCQUFnQjtpQkFDdkMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7aUJBQ2YsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssY0FBYyxDQUFDLENBQUMsTUFBTTtnQkFDbkQsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssY0FBYyxDQUFDO3FCQUNwRSxNQUFNLEVBQ1g7WUFDQSxvRUFBb0U7WUFDcEUsb0VBQW9FO1lBQ3BFLGlDQUFpQztZQUNqQyxPQUFPO1NBQ1I7UUFFRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FDM0MsVUFBVSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FDMUMsQ0FBQztRQUNILE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdkUsbUZBQW1GO1FBQ25GLElBQUksWUFBWSxFQUFFO1lBQ2hCLElBQ0UsTUFBTSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ3ZDLE1BQU0sQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQ3ZDO2dCQUNBLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDhCQUE4QixDQUFDLE1BQU0sQ0FDbEQsV0FBVyxDQUFDLElBQUksRUFDaEIsTUFBTSxDQUFDLElBQUksQ0FDWixDQUNGLENBQUM7YUFDSDtZQUVELE1BQU0sRUFBRSxHQUFHLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxJQUFJLENBQzdELElBQUksRUFDSixNQUFNLENBQ1AsQ0FBQztZQUNGLE1BQU0sT0FBTyxHQUFHLE1BQU0seUJBQXlCLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3JFLE1BQU0sTUFBTSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTlELElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRTtnQkFDM0IsR0FBRztnQkFDSCxtQkFBbUI7Z0JBQ25CLE9BQU87Z0JBQ1AsTUFBTTtnQkFDTixRQUFRLEVBQUUsNEJBQWdCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUM7Z0JBQ3JELGdCQUFnQixFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUM7YUFDeEQsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsV0FBVyxDQUFDLENBQUM7U0FDL0Q7UUFFRCxLQUFLLFVBQVUsZUFBZSxDQUU1QixHQUFjLEVBQ2QsZUFBZSxHQUFHLEtBQUs7O1lBRXZCLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQy9CLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBRSxDQUFFLENBQUM7Z0JBQ25FLE1BQU0sR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3hDLE9BQU87b0JBQ0wsR0FBRztvQkFDSCxtQkFBbUIsRUFBRSxlQUFlO3dCQUNsQyxDQUFDLENBQUMsTUFBTSxDQUFDLG1CQUFtQjt3QkFDNUIsQ0FBQyxDQUFDLEdBQUc7aUJBQ1IsQ0FBQzthQUNIO1lBQ0QsTUFBTSxjQUFjLHFCQUFHLEdBQUc7aUJBQ3ZCLGVBQWUsRUFBRSwwQ0FBRyxDQUFDLDJDQUNwQixhQUFhLDRDQUFJLFFBQVEsQ0FBQztZQUM5QixNQUFNLE9BQU8sR0FBRyxjQUFjO2dCQUM1QixDQUFDLENBQUMsTUFBTSxlQUFlLENBQUMsY0FBYyxDQUFDO2dCQUN2QyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQ2QsTUFBTSxZQUFZLFNBQVcsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLElBQUksbUNBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7WUFDcEUsTUFBTSxHQUFHLEdBQUcsR0FBRyxZQUFZLElBQUksR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzFDLE9BQU87Z0JBQ0wsR0FBRztnQkFDSCxtQkFBbUIsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHO2FBQ25FLENBQUM7UUFDSixDQUFDO1FBRUQsS0FBSyxVQUFVLHlCQUF5QixDQUN0QyxhQUFxQjtZQUVyQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsY0FBYyxDQUFDLENBQUM7WUFDakUsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7Z0JBQ2xDLE9BQU8sU0FBUyxDQUFDO2FBQ2xCO1lBQ0QsTUFBTSxJQUFJLEdBQUcsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN0QixDQUFDO1FBRUQ7Ozs7Ozs7O1dBUUc7UUFDSCxLQUFLLFVBQVUsbUJBQW1CLENBQ2hDLGFBQXFCO1lBRXJCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN6RSxNQUFNLFVBQVUsR0FDZCxRQUFRLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxZQUFZLENBQUM7WUFDL0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBRXBFLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFO2dCQUNwQyxPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE9BQU87Z0JBQ0wsUUFBUSxFQUFFLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUM7YUFDN0QsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSyxLQUFLLENBQUMsZUFBZSxDQUMzQixFQUFhLEVBQ2IsVUFBcUIsRUFDckIsV0FBbUI7O1FBRW5CLDBFQUEwRTtRQUMxRSxLQUFLLE1BQU0sTUFBTSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDckUsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDbEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFFLENBQUM7Z0JBQy9DLHFFQUFxRTtnQkFDckUsdUVBQXVFO2dCQUN2RSx1RUFBdUU7Z0JBQ3ZFLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFO29CQUMzQixNQUFNLFVBQVUsU0FBRyxNQUFNLENBQUMsZ0JBQWdCLG1DQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3JFLE1BQU0sTUFBTSxTQUFHLEVBQUUsQ0FBQyxnQkFBZ0IsbUNBQUksRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFFekQsb0VBQW9FO29CQUNwRSxNQUFNLElBQUksR0FBRzt3QkFDWCxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQVc7d0JBQ2hELEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBVztxQkFDekMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUV6RCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQyxrQ0FBa0MsQ0FBQyxNQUFNLENBQ3RELHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxFQUM5QixJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUNaLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ2I7eUJBQ0UscUJBQXFCLENBQ3BCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQ1osaUNBQWlDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FDM0Q7eUJBQ0EscUJBQXFCLENBQ3BCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQ1osaUNBQWlDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FDM0QsQ0FDSixDQUFDO2lCQUNIO2dCQUNELHVFQUF1RTtnQkFDdkUsb0VBQW9FO2dCQUNwRSx1Q0FBdUM7Z0JBQ3ZDLFNBQVM7YUFDVjtZQUNELElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUVuQyx5RUFBeUU7WUFDekUsa0VBQWtFO1lBQ2xFLHlFQUF5RTtZQUN6RSxzRUFBc0U7WUFDdEUsTUFBTSxJQUFJLFNBQUcsTUFBTSxDQUFDLFlBQVksMENBQUcsQ0FBQyxDQUFDLENBQUM7WUFDdEMsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO2dCQUNoQixJQUNFLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUM7b0JBQzNCLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUM7b0JBQy9CLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFDMUI7b0JBQ0EsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDdkQsSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFO3dCQUMvQyxpRUFBaUU7d0JBQ2pFLGtFQUFrRTt3QkFDbEUsMkJBQTJCO3dCQUMzQixJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO3FCQUN6QztvQkFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFO3dCQUN2Qiw0Q0FBNEM7d0JBQzVDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO3FCQUNyRDtpQkFDRjtxQkFBTSxJQUFJLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDdkMsNENBQTRDO29CQUM1QyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7aUJBQ3JEO3FCQUFNLElBQUksRUFBRSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFO29CQUNyQyw0Q0FBNEM7b0JBQzVDLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztpQkFDckQ7YUFDRjtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsc0NBQXNDO0lBQzlCLEtBQUssQ0FBQyxVQUFVLENBQ3RCLElBQW9CLEVBQ3BCLE9BQW9COztRQUVwQixJQUFJLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM5QixnQ0FBZ0M7WUFDaEMsd0VBQXdFO1lBQ3hFLHlFQUF5RTtZQUN6RSx5REFBeUQ7WUFDekQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsQ0FDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFnQixDQUM1QixDQUFDO1lBRUgsSUFBSSxHQUFHLENBQUMsY0FBYyxFQUFFLEVBQUU7Z0JBQ3hCLEdBQUcsQ0FBQyxLQUFLLENBQ1AsdUJBQXVCLE1BQU0sQ0FBQyxJQUFJLENBQ2hDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQzlDLEVBQUUsQ0FDSixDQUFDO2FBQ0g7WUFFRCxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDMUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLEVBQXdCLENBQUM7WUFDbkQsS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNoRSxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO2FBQ2xFO1lBQ0QsTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTNDLElBQUksR0FBRyxDQUFDLGNBQWMsRUFBRSxFQUFFO2dCQUN4QixHQUFHLENBQUMsS0FBSyxDQUNQLHNCQUFzQixNQUFNLENBQUMsSUFBSSxDQUMvQixDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUM5QyxFQUFFLENBQ0osQ0FBQzthQUNIO1lBRUQsT0FBTyxRQUFRLENBQUM7U0FDakI7UUFFRCxJQUFJLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM5Qiw0RUFBNEU7WUFDNUUsc0RBQXNEO1lBRXRELE1BQU0sY0FBYyxHQUNsQixJQUFJLENBQUMsWUFBWSxDQUFDLG1DQUFtQyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzlELElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ25CLHdEQUF3RDtnQkFDeEQsT0FBTyxFQUFFLENBQUM7YUFDWDtZQUNELE9BQU8sSUFBSSxDQUFDLFVBQVUsT0FDcEIsY0FBYyxDQUFDLGdCQUFnQixtQ0FBSSxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUNqRSxPQUFPLENBQ1IsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN2RSxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQsSUFBSSxRQUErQixDQUFDO1FBRXBDLElBQUksRUFBRSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNwRCw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUVwRCxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUN6QyxPQUFPLENBQ1IsQ0FBQztZQUNGLElBQUksUUFBUSxFQUFFO2dCQUNaLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ25EO1NBQ0Y7YUFBTSxJQUFJLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDL0QsZ0NBQWdDO1lBQ2hDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDcEQsUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FDbkMsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFDekMsT0FBTyxDQUNSLENBQUM7U0FDSDthQUFNLElBQUksRUFBRSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMxRCwyQkFBMkI7WUFDM0IsUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FDOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFDekMsT0FBTyxDQUNSLENBQUM7U0FDSDthQUFNLElBQUksRUFBRSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3ZDLGdDQUFnQztZQUNoQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2pDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBRSxDQUFDO1lBRWpFLElBQUksR0FBRyxDQUFDLGNBQWMsRUFBRSxFQUFFO2dCQUN4QixHQUFHLENBQUMsS0FBSyxDQUNQLHVCQUF1QixNQUFNLENBQUMsSUFBSSxDQUNoQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQ3ZDLEVBQUUsQ0FDSixDQUFDO2FBQ0g7WUFFRCxNQUFNLGdCQUFnQixHQUFHLElBQUksS0FBSyxFQUF3QixDQUFDO1lBQzNELEtBQUssTUFBTSxJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDL0QsZ0JBQWdCLENBQUMsSUFBSSxDQUNuQixJQUFJLENBQUMsVUFBVSxDQUNiLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQ3BCLE9BQU8sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUM3QyxDQUNGLENBQUM7YUFDSDtZQUNELE1BQU0sUUFBUSxHQUFHLE1BQU0sZUFBZSxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFFekQsSUFBSSxHQUFHLENBQUMsY0FBYyxFQUFFLEVBQUU7Z0JBQ3hCLEdBQUcsQ0FBQyxLQUFLLENBQ1AsdUJBQXVCLE1BQU0sQ0FBQyxJQUFJLENBQ2hDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FDdkMsRUFBRSxDQUNKLENBQUM7YUFDSDtZQUNELE9BQU8sUUFBUSxDQUFDO1NBQ2pCO2FBQU07WUFDTCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLE9BQzlDLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsbUNBQUksSUFBSSxFQUNyQyxJQUFJLENBQUMsSUFBSSxDQUNWLENBQ0YsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUU7WUFDdEIsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzVDO1FBRUQsZ0hBQWdIO1FBQ2hILDRFQUE0RTtRQUM1RSxLQUFLLE1BQU0sU0FBUyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDL0MsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FDM0IsSUFBSSxHQUFHLENBQUM7Z0JBQ04sU0FBUyxDQUFDLElBQUk7Z0JBQ2QsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO2dCQUMxQixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7Z0JBQzNCLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQzthQUMzQixDQUFDLENBQ0gsQ0FBQztZQUNGLE1BQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQy9CLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRSxLQUFLLFFBQVMsQ0FBQyxHQUFHLENBQy9ELENBQUM7WUFDRixJQUFJLFNBQVMsSUFBSSxJQUFJLEVBQUU7Z0JBQ3JCLE1BQU0saUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQzVELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLGlDQUFpQyxDQUFDLE1BQU0sT0FDckQsRUFBRSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxtQ0FBSSxJQUFJLEVBQ3JDLFNBQVMsQ0FBQyxJQUFJLEVBQ2QsUUFBUSxDQUFDLElBQUksRUFDYixVQUFVLENBQ1gsQ0FBQyxxQkFBcUIsQ0FDckIsaUJBQWlCLEVBQ2pCLCtDQUErQyxDQUNoRCxDQUNGLENBQUM7YUFDSDtTQUNGO1FBRUQsSUFBSSxHQUFHLENBQUMsYUFBYSxFQUFFLEVBQUU7WUFDdkIsR0FBRyxDQUFDLElBQUksQ0FDTixvQkFBb0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssTUFBTSxDQUFDLEtBQUssQ0FDaEUsUUFBUSxDQUFDLEdBQUcsQ0FDYixFQUFFLENBQ0osQ0FBQztTQUNIO1FBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDO1FBQ3JDLFFBQVEsQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFM0QsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2RCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ3ZCLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoRSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWTtpQkFDbkMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztpQkFDL0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO2lCQUM3QixHQUFHLENBQUMsQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQzdELENBQUM7WUFDSixLQUFLLE1BQU0sV0FBVyxJQUFJLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDekQsS0FBSyxNQUFNLFVBQVUsSUFBSSxXQUFXLEVBQUU7b0JBQ3BDLElBQUksVUFBVSxDQUFDLFNBQVMsS0FBSyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTt3QkFDOUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsMkJBQTJCLENBQUMsTUFBTSxPQUMvQyxFQUFFLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLG1DQUFJLElBQUksRUFDckMsUUFBUSxDQUFDLEdBQUcsRUFDWixVQUFVLENBQUMsU0FBVSxDQUN0QixDQUNGLENBQUM7cUJBQ0g7aUJBQ0Y7YUFDRjtTQUNGO1FBRUQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3BCLENBQUM7SUFFTyxXQUFXLENBQUMsSUFBYTtRQUMvQixPQUFPLDRCQUFnQixDQUNyQixJQUFJLENBQUMsWUFBWSxFQUNqQixJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FDakQsQ0FBQztJQUNKLENBQUM7SUFFTyx3QkFBd0IsQ0FBQyxPQUF5QztRQUN4RSxJQUFJLE9BQU8sSUFBSSxJQUFJLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDM0MsaUJBQWlCO1lBQ2pCLE9BQU87U0FDUjtRQUNELEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxFQUFFO1lBQzVCLEtBQUssTUFBTSxJQUFJLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtnQkFDL0IsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDN0QsSUFBSSxVQUFVLENBQUMsTUFBTSxJQUFJLElBQUksRUFBRTtvQkFDN0IsNkdBQTZHO29CQUM3Ryw2R0FBNkc7b0JBQzdHLDBGQUEwRjtvQkFDMUYsU0FBUztpQkFDVjtnQkFDRCxtRUFBbUU7Z0JBQ25FLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDakQsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUNQLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLG9CQUFvQjtvQkFDcEQsQ0FBQyxFQUFFLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksdUJBQXVCO29CQUMzRCxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FDaEMsQ0FBQztnQkFDRixJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUU7b0JBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDJCQUEyQixDQUFDLE1BQU0sQ0FDL0MsSUFBSSxFQUNKLE1BQU0sRUFDTixPQUFPLENBQ1IsQ0FBQyxxQkFBcUIsQ0FDckIsT0FBTyxFQUNQLDBDQUEwQyxDQUMzQyxDQUNGLENBQUM7aUJBQ0g7YUFDRjtTQUNGO0lBQ0gsQ0FBQztJQUVPLG1CQUFtQixDQUFDLElBQW9CO1FBQzlDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNsQyxNQUFNLElBQUksR0FBRyxFQUFFLENBQUMsNkJBQTZCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUMxRSxNQUFNLFFBQVEsR0FBRyxJQUFJO2FBQ2xCLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNyRSxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZCLE9BQU87WUFDTCxRQUFRO1lBQ1IsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDO1NBQ2YsQ0FBQztJQUNKLENBQUM7SUFFTyxLQUFLLENBQUMsc0JBQXNCLENBQUMsR0FBVyxFQUFFLFNBQXFCO1FBQ3JFLE1BQU0sV0FBVyxHQUFHLElBQUksS0FBSyxFQUFXLENBQUM7UUFDekMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNkLE9BQU8sRUFBRSxXQUFXLEVBQUUsQ0FBQztTQUN4QjtRQUVELE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUEyQixDQUFDO1FBQ3BELE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxFQUFXLENBQUM7UUFFMUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLEtBQWdCLEVBQUUsRUFBRTtZQUM1QyxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssRUFBRTtnQkFDekIsMkVBQTJFO2dCQUMzRSxJQUFJLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQzNDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3hCLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztvQkFDbkMsSUFBSSxLQUFLLEVBQUU7d0JBQ1QsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7cUJBQ3pCO29CQUNELFNBQVM7aUJBQ1Y7Z0JBRUQsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUMzQjtRQUNILENBQUMsQ0FBQztRQUVGLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTVCLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUM5RCxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDO1lBQzNDLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUM7WUFDekUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FBQztRQUNILEtBQUssTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDdkMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsZ0NBQWdDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FDdEUsQ0FBQztnQkFDRixTQUFTO2FBQ1Y7WUFFRCxJQUFJLENBQUMseUJBQXlCLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQzdELElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUNoQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQyxnQ0FBZ0MsQ0FBQyxNQUFNLENBQ3BELElBQUksRUFDSixPQUFPLENBQ1IsQ0FDRixDQUFDO2lCQUNIO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3RCO1FBRUQsT0FBTztZQUNMLFVBQVUsRUFBRSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNO1lBQ3BELFdBQVc7U0FDWixDQUFDO0lBQ0osQ0FBQztJQUVELHNDQUFzQztJQUM5QixLQUFLLENBQUMsV0FBVyxDQUN2QixJQUFhLEVBQ2IsR0FBZ0I7O1FBRWhCLElBQUksR0FBRyxDQUFDLGNBQWMsRUFBRSxFQUFFO1lBQ3hCLEdBQUcsQ0FBQyxLQUFLLENBQ1AscUJBQXFCLE1BQU0sQ0FBQyxJQUFJLENBQzlCLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUN4QixJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNyQyxDQUFDO1NBQ0g7UUFFRCxJQUFJLG9CQUFvQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNyQyxPQUFPLFNBQVMsQ0FBQztTQUNsQjtRQUVELElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUMsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFDaEUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUNkLEVBQUUsQ0FBQztRQUVILE1BQU0sUUFBUSxHQUFtQixRQUFRLENBQUMsbUJBQW1CLENBQzNEO1lBQ0UsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSTtZQUMvQixHQUFHO1lBQ0gsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSztZQUN6QixJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJO1lBQ3RCLFNBQVMsRUFDUCxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQ2hFLElBQUksRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJO1NBQ3RELEVBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBdUMsQ0FDcEQsQ0FBQztRQUVGLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEVBQUU7WUFDdEMsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7U0FDMUI7UUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssRUFBZSxDQUFDO1FBQzdDLEtBQUssSUFBSSxJQUFJLFVBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxtQ0FBSSxFQUFFLEVBQUU7WUFDMUMsSUFBSSxRQUFRLENBQUMsSUFBSSxFQUFFO2dCQUNqQixvRkFBb0Y7Z0JBQ3BGLFNBQVM7YUFDVjtZQUVELEVBQUU7WUFDRiwrQkFBK0I7WUFFL0IsMkdBQTJHO1lBQzNHLDZFQUE2RTtZQUM3RSxPQUFPLElBQUksSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNyRCxHQUFHLENBQUMsS0FBSyxDQUNQLGlCQUFpQixNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxNQUFNLENBQUMsS0FBSyxDQUMvRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDakIsaUNBQWlDLENBQ25DLENBQUM7Z0JBQ0YsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDdkIsSUFBSSxHQUFHLE9BQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxtQ0FBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN2QztZQUNELElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1QscUZBQXFGO2dCQUNyRixTQUFTO2FBQ1Y7WUFFRCw0Q0FBNEM7WUFDNUMsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUNuQyxJQUFJLEVBQ0osSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFDNUIsWUFBWSxDQUNiLENBQUM7WUFFRixJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNuQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQyw0QkFBNEIsQ0FBQyxNQUFNLE9BQ2hELElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLG1DQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUMzRCxHQUFHLENBQ0osQ0FDRixDQUFDO2dCQUNGLFNBQVM7YUFDVjtZQUNELElBQUksQ0FBQyx5QkFBeUIsQ0FDNUIsR0FBRyxFQUNILENBQUMsR0FBRyxDQUFDLEVBQ0wsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFDNUIsQ0FBQyxLQUFLLEVBQUUsRUFBRTs7Z0JBQ1IsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQzVCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDRCQUE0QixDQUFDLE1BQU0sT0FDaEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsbUNBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQzNELEdBQUcsQ0FDSixDQUNGLENBQUM7aUJBQ0g7WUFDSCxDQUFDLENBQ0YsQ0FBQztZQUNGLFFBQVEsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQztTQUN6QjtRQUVELEVBQUU7UUFDRixxQ0FBcUM7UUFFckMsc0VBQXNFO1FBQ3RFLG1FQUFtRTtRQUNuRSxNQUFNLGlCQUFpQixHQUFHLElBQUksS0FBSyxFQUFxQixDQUFDO1FBQ3pELEtBQUssTUFBTSxRQUFRLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQy9DLENBQUMsQ0FBQyxFQUFFLEVBQUUsd0JBQ0gsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxnQkFBd0MsQ0FBQyxlQUFlLG1DQUNsRSxFQUFFLEdBQUEsQ0FDTCxFQUFFO1lBQ0QsS0FBSyxNQUFNLE1BQU0sSUFBSSxRQUFRLEVBQUU7Z0JBQzdCLElBQUksTUFBTSxDQUFDLEtBQUssS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsRUFBRTtvQkFDakQsNEJBQTRCO29CQUM1QixTQUFTO2lCQUNWO3FCQUFNLElBQUksTUFBTSxDQUFDLEtBQUssS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQixFQUFFO29CQUMzRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQzlDLE1BQU0sRUFDTixZQUFZLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FDMUQsQ0FDRixDQUFDO29CQUNGLFNBQVM7aUJBQ1Y7Z0JBRUQsaUJBQWlCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ2hDO1NBQ0Y7UUFFRCxtQ0FBbUM7UUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUN4QyxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUN0RCxJQUFJLENBQUMsc0JBQXNCLENBQ3pCLEdBQUcsRUFDSCxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3RELENBQ0YsQ0FBQztRQUNGLEtBQUssTUFBTSxFQUFFLFVBQVUsRUFBRSxJQUFJLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUM5RCxLQUFLLE1BQU0sR0FBRyxJQUFJLFVBQVUsYUFBVixVQUFVLGNBQVYsVUFBVSxHQUFJLEVBQUUsRUFBRTtnQkFDbEMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDNUI7WUFDRCxJQUFJLFVBQVUsRUFBRTtnQkFDZCxJQUFJLENBQUMseUJBQXlCLENBQzVCLFFBQVEsQ0FBQyxHQUFHLEVBQ1osVUFBVSxFQUNWLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEVBQzVCLENBQUMsR0FBRyxNQUFNLEVBQUUsRUFBRTs7b0JBQ1osS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7d0JBQzFCLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFOzRCQUNqRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQyxrQ0FBa0MsQ0FBQyxNQUFNLE9BQ3RELElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLG1DQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUMzRCxRQUFRLEVBQ1IsS0FBSyxDQUNOLENBQ0YsQ0FBQzt5QkFDSDtxQkFDRjtnQkFDSCxDQUFDLENBQ0YsQ0FBQzthQUNIO1NBQ0Y7UUFFRCxJQUFJLGFBQWEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFO1lBQzFCLFFBQVEsQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNqRDtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMxQjtRQUVELE1BQU0sZUFBZSxHQUdoQixJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRTlELHdFQUF3RTtRQUN4RSxLQUFLLE1BQU0sSUFBSSxJQUFJLFdBQVcsRUFBRTtZQUM5QixlQUFlLENBQUMsSUFBSSxDQUNsQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUNsRSxDQUFDO1NBQ0g7UUFFRCxLQUFLLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxJQUFJLGVBQWUsRUFBRTtZQUMzRCxNQUFNLFNBQVMsR0FBRyxJQUFxRCxDQUFDO1lBQ3hFLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFO2dCQUN0QixTQUFTO2FBQ1Y7WUFFRCxLQUFLLE1BQU0sVUFBVSxJQUFJLFNBQVMsQ0FBQyxPQUFPLEVBQUU7Z0JBQzFDLElBQUksRUFBRSxDQUFDLHVCQUF1QixDQUFDLFVBQVUsQ0FBQyxFQUFFO29CQUMxQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQywyQkFBMkIsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQzlELENBQUM7b0JBQ0YsU0FBUztpQkFDVjtnQkFFRCxNQUFNLE1BQU0sR0FBYyxFQUFFLENBQUMsd0JBQXdCLENBQUMsVUFBVSxDQUFDO29CQUMvRCxDQUFDLENBQUUsVUFBa0IsQ0FBQyxNQUFNO29CQUM1QixDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsQ0FDbkMsRUFBRSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBRSxDQUNwQyxDQUFDO2dCQUVQLElBQ0UsQ0FBQyxPQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLG1DQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDbEQsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxVQUFVLENBQUMsTUFBTSxDQUMvQixFQUNEO29CQUNBLFNBQVM7aUJBQ1Y7Z0JBRUQsSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxFQUFFLFVBQTZCLENBQUMsRUFBRTtvQkFDcEUsU0FBUztpQkFDVjtnQkFFRCxpQ0FBaUM7Z0JBQ2pDLElBQUksRUFBRSxDQUFDLHdCQUF3QixDQUFDLFVBQVUsQ0FBQyxFQUFFO29CQUMzQyxTQUFTO2lCQUNWO2dCQUVELDRDQUE0QztnQkFDNUMsSUFDRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDO29CQUNsQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLEVBQ2hDO29CQUNBLDRDQUE0QztvQkFDNUMsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUNyQixNQUFNLEVBQ04sUUFBUSxFQUNSLEdBQUcsQ0FBQyxnQkFBZ0IsT0FBQyxRQUFRLENBQUMsSUFBSSwwQ0FBRSxTQUFTLENBQUMsRUFDOUMsU0FBUyxDQUNWLENBQUM7aUJBQ0g7cUJBQU0sSUFDTCxFQUFFLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDO29CQUNwQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDO29CQUNsQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUN6QjtvQkFDQSw0Q0FBNEM7b0JBQzVDLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FDdkIsTUFBTSxFQUNOLFFBQVEsRUFDUixHQUFHLENBQUMsZ0JBQWdCLE9BQUMsUUFBUSxDQUFDLElBQUksMENBQUUsU0FBUyxDQUFDLEVBQzlDLFNBQVMsQ0FDVixDQUFDO2lCQUNIO3FCQUFNO29CQUNMLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDBCQUEwQixDQUFDLE1BQU0sT0FDOUMsRUFBRSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxtQ0FBSSxVQUFVLEVBQ2pELFVBQVUsQ0FBQyxJQUFJLENBQ2hCLENBQ0YsQ0FBQztpQkFDSDtnQkFDRCxvQ0FBb0M7YUFDckM7U0FDRjtRQUVELE1BQU0saUJBQWlCLEdBQUcsR0FBRyxDQUFDLGdCQUFnQixDQUM1QyxRQUFRLENBQUMsSUFBSSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUN6QyxDQUFDO1FBRUYseUVBQXlFO1FBQ3pFLE1BQU0sV0FBVyxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsV0FBVyxDQUFDO2FBQ3ZDLEdBQUcsQ0FBQyxjQUFjLENBQUM7YUFDbkIsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUM7UUFDaEMsTUFBTSxlQUFlLEdBQ25CLFdBQVcsSUFBSyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBK0IsQ0FBQztRQUM1RSxJQUFJLFdBQVcsSUFBSSxlQUFlLEVBQUU7WUFDbEMsTUFBTSxTQUFTLEdBQ2IsSUFBSSxDQUFDLFlBQVksQ0FBQywyQkFBMkIsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUVqRSxJQUNFLENBQUMsRUFBRSxDQUFDLHdCQUF3QixDQUFDLGVBQWUsQ0FBQztnQkFDM0MsRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUM7Z0JBQzNCLENBQUMsRUFDRDtnQkFDQSxRQUFRLENBQUMsV0FBVyxHQUFHO29CQUNyQixnQkFBZ0IsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsZUFBZSxDQUFDO2lCQUM1RCxDQUFDO2dCQUNGLElBQUksU0FBUyxFQUFFO29CQUNiLEtBQUssTUFBTSxLQUFLLElBQUksU0FBUyxDQUFDLGFBQWEsRUFBRSxFQUFFO3dCQUM3QyxRQUFRLENBQUMsV0FBVyxDQUFDLFVBQVUsU0FDN0IsUUFBUSxDQUFDLFdBQVcsQ0FBQyxVQUFVLG1DQUFJLEVBQUUsQ0FBQzt3QkFDeEMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSTt3QkFDbEMsNENBQTRDO3dCQUM1QyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQ3JCLEtBQUssRUFDTCxHQUFHLENBQUMsZ0JBQWdCLE9BQUMsUUFBUSxDQUFDLElBQUksMENBQUUsU0FBUyxDQUFDLENBQy9DLENBQ0YsQ0FBQzt3QkFDRixRQUFRLENBQUMsV0FBVyxDQUFDLFFBQVE7NEJBQzNCLGFBQUEsUUFBUSxDQUFDLFdBQVcsMENBQUUsVUFBVSwwQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUTtnQ0FDMUQsU0FBUyxDQUFDO3dCQUNaLFFBQVEsQ0FBQyxXQUFXLENBQUMsU0FBUzs0QkFDNUIsQ0FBQyxFQUFFLENBQUMsd0JBQXdCLENBQUMsZUFBZSxDQUFDO2dDQUMzQyxFQUFFLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQztnQ0FDM0IsQ0FBQyxJQUFJLFNBQVMsQ0FBQztxQkFDcEI7aUJBQ0Y7Z0JBQ0QsSUFBSSxDQUFDLDJCQUEyQixDQUM5QixlQUFlLEVBQ2YsUUFBUSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQ2hDLENBQUM7Z0JBQ0YsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUNsRCxXQUFXLEVBQ1gsaUJBQWlCLENBQ2xCLENBQUMsSUFBSSxDQUFDO2dCQUNQLElBQUksQ0FBQyxrQkFBa0IsQ0FDckIsV0FBVyxFQUNYLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUN6QixTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FDM0MsQ0FBQzthQUNIO1lBRUQsaUZBQWlGO1lBQ2pGLElBQUksU0FBUyxFQUFFO2dCQUNiLEtBQUssTUFBTSxLQUFLLElBQUksU0FBUyxDQUFDLGFBQWEsRUFBRSxFQUFFO29CQUM3QyxJQUNFLEVBQUUsQ0FBQyw4QkFBOEIsQ0FDL0IsS0FBSyxDQUFDLGdCQUFnQixFQUN0QixLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUM5Qjt3QkFDRCxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsRUFDakM7d0JBQ0EsNENBQTRDO3dCQUM1QyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQ3ZCLEtBQUssRUFDTCxRQUFRLEVBQ1IsaUJBQWlCLEVBQ2pCLGVBQWUsQ0FBQyxNQUFNLENBQ3ZCLENBQUM7cUJBQ0g7aUJBQ0Y7YUFDRjtTQUNGO2FBQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxFQUFFO1lBQ3hCLElBQUksQ0FBQyx5QkFBeUIsQ0FDNUIsR0FBRyxFQUNILENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEVBQzVCLENBQUMsUUFBUSxFQUFFLEVBQUU7O2dCQUNYLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDOUIsUUFBUSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO2lCQUM3QztxQkFBTTtvQkFDTCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQywrQkFBK0IsQ0FBQyxNQUFNLE9BQ25ELElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLG1DQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUMzRCxnQkFBZ0IsUUFBUSxDQUFDLEdBQUcsS0FBSyxRQUFRLENBQUMsSUFBSSxrQkFBa0IsQ0FDakUsQ0FDRixDQUFDO2lCQUNIO1lBQ0gsQ0FBQyxDQUNGLENBQUM7U0FDSDthQUFNO1lBQ0wsUUFBUSxDQUFDLFdBQVcsR0FBRztnQkFDckIsSUFBSSxFQUFFLEdBQUcsQ0FBQyxTQUFTLElBQUksRUFBRSxTQUFTLEVBQUUsR0FBRyxDQUFDLFNBQVMsRUFBRTthQUNwRCxDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMscUJBQXFCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUVuRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLFFBQVEsYUFBUixRQUFRLHVCQUFSLFFBQVEsQ0FBRSxJQUFJLENBQUMsQ0FBQztRQUUxRCxPQUFPLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxvQkFBb0IsQ0FBQyxDQUFjO1FBQ3pDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEQsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FDYiwyQkFBMkIsQ0FBQyxDQUFDLFdBQVcsRUFBRSw4RUFBOEUsQ0FDekgsQ0FBQztTQUNIO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxxQkFBcUIsQ0FBQyxLQUFxQixFQUFFLElBQW9COztRQUN2RSx5RkFBeUY7UUFDekYsTUFBTSxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQ3JCLE9BQUMsS0FBSyxDQUFDLE9BQU8sbUNBQUksRUFBRSxDQUFDO2FBQ2xCLE1BQU0sT0FBQyxLQUFLLENBQUMsVUFBVSxtQ0FBSSxFQUFFLENBQUM7YUFDOUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO2FBQ3ZCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUN0QixDQUFDO1FBQ0YsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLENBQ3hCLE9BQUMsS0FBSyxDQUFDLE9BQU8sbUNBQUksRUFBRSxDQUFDO2FBQ2xCLE1BQU0sT0FBQyxLQUFLLENBQUMsVUFBVSxtQ0FBSSxFQUFFLENBQUM7YUFDOUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7YUFDeEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQ3RCLENBQUM7UUFDRixZQUFZO1FBQ1osS0FBSyxNQUFNLE1BQU0sSUFBSSxTQUFTLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxFQUFFO1lBQ25ELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLGtDQUFrQyxDQUFDLE1BQU0sQ0FDdEQsSUFBSSxFQUNKLE1BQU0sRUFDTixLQUFLLENBQ04sQ0FDRixDQUFDO1NBQ0g7UUFFRCwwRkFBMEY7UUFDMUYsMEJBQTBCO1FBQzFCLE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLEVBQUU7WUFDakQsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUU7Z0JBQ2xFLE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbEMsSUFBSSxDQUFDLE1BQU0sRUFBRTtvQkFDWCxTQUFTO2lCQUNWO2dCQUVELElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7b0JBQzNDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLG1DQUFtQyxDQUFDLE1BQU0sQ0FDdkQsSUFBSSxFQUNKLE1BQU0sRUFDTixLQUFLLEVBQ0wsVUFBVSxFQUNWLElBQUksQ0FDTCxDQUNGLENBQUM7aUJBQ0g7YUFDRjtZQUVELE9BQU8sRUFBRSxDQUFDO1FBQ1osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNLLGNBQWMsQ0FDcEIsS0FBcUIsRUFDckIsSUFBb0IsRUFDcEIsRUFBdUQ7UUFFdkQsSUFBSSxLQUFLLENBQUMsSUFBSSxFQUFFO1lBQ2QsSUFBSSxDQUFDLHlCQUF5QixDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7Z0JBQ3JFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUMxQjtnQkFDRCxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3RELENBQUMsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxvQkFBb0IsQ0FDMUIsTUFBaUIsRUFDakIsbUJBQW9DOztRQUVwQyxNQUFNLG1CQUFtQixHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pELE1BQU0sbUJBQW1CLEdBQ3ZCLE1BQU0sQ0FBQyxJQUFJLEtBQUssZUFBZSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWpFLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3RCLEdBQUcsQ0FBQyxLQUFLLENBQ1AsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUNaLE1BQU0sQ0FBQyxJQUFJLENBQ1osNERBQTRELENBQzlELENBQUM7WUFDRixPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsSUFBSSxDQUFDLG1CQUFtQixJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDaEQsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELDRDQUE0QztRQUM1QyxJQUFJLG1CQUFtQixFQUFFO1lBQ3ZCLElBQUksQ0FBQyxtQkFBbUIsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsNkJBQTZCLENBQUMsTUFBTSxPQUNqRCxFQUFFLENBQUMsb0JBQW9CLENBQUMsbUJBQW1CLENBQUMsbUNBQUksbUJBQW1CLEVBQ25FLE1BQU0sQ0FBQyxJQUFJLENBQ1osQ0FDRixDQUFDO2FBQ0g7WUFFRCxJQUFJLENBQUMsbUJBQW1CLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDZCQUE2QixDQUFDLE1BQU0sT0FDakQsRUFBRSxDQUFDLG9CQUFvQixDQUFDLG1CQUFtQixDQUFDLG1DQUFJLG1CQUFtQixFQUNuRSxNQUFNLENBQUMsSUFBSSxDQUNaLENBQ0YsQ0FBQzthQUNIO1NBQ0Y7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTyxLQUFLLENBQUMsVUFBVSxDQUN0QixJQUFhLEVBQ2IsR0FBZ0I7O1FBRWhCLElBQUksR0FBRyxDQUFDLGNBQWMsRUFBRSxFQUFFO1lBQ3hCLEdBQUcsQ0FBQyxLQUFLLENBQ1Asb0JBQW9CLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUNyRSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDakIsRUFBRSxDQUNKLENBQUM7U0FDSDtRQUVELDZFQUE2RTtRQUM3RSxJQUFJLElBQUksR0FBd0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUQsSUFBSSxNQUE2QixDQUFDO1FBQ2xDLElBQUksRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN6QixJQUFJLEdBQUcsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE1BQU0sQ0FBQztTQUNyQjtRQUNELElBQUksRUFBRSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzlCLE1BQU0sR0FBRyx3QkFBd0IsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzVEO1FBQ0QsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNuRCxNQUFNLElBQUksS0FBSyxDQUNiLDBDQUEwQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUM5RCxDQUFDO1NBQ0g7UUFFRCxJQUFJLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2hDLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNuQztRQUVELElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVyQyxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEQsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUU7WUFDbEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsdUJBQXVCLENBQUMsTUFBTSxhQUMzQyxJQUFJLENBQUMsU0FBUywwQ0FBRSxJQUFJLENBQ2xCLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsWUFBWSxvQ0FDN0MsSUFBSSxDQUNWLENBQ0YsQ0FBQztTQUNIO1FBRUQsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFdkQsTUFBTSxXQUFXLEdBQUcsR0FBRyxDQUFDLGdCQUFnQixDQUFDLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxTQUFTLENBQUMsQ0FBQztRQUMxRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFckQsTUFBTSxRQUFRLEdBQWtCLFFBQVEsQ0FBQyxrQkFBa0IsQ0FDekQ7WUFDRSxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJO1lBQy9CLEdBQUcsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUN6RCxNQUFNLENBQUMsSUFDVCxFQUFFO1lBQ0YsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSTtZQUN4QixPQUFPLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUN6QixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7Z0JBQ2pFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUN4QyxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO1lBQ3ZDLENBQUMsQ0FBQztZQUNGLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtZQUNqQixTQUFTLEVBQ1AsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztZQUNoRSxJQUFJO1lBRUoscUZBQXFGO1lBQ3JGLG9DQUFvQztZQUNwQyxRQUFRLEVBQUUsNEJBQWdCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUM7U0FDdEQsRUFDRCxJQUFJLENBQ0wsQ0FBQztRQUVGLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLElBQUksQ0FBQyxDQUFDO1FBRTFELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxtQkFBbUIsQ0FDekIsR0FBYyxFQUNkLE9BQW9COztRQUVwQixNQUFNLE1BQU0sR0FBRywrQkFBd0IsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRWhFLEtBQUssTUFBTSxJQUFJLFVBQUksTUFBTSxDQUFDLFdBQVcsbUNBQUksRUFBRSxFQUFFO1lBQzNDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDZCQUE2QixDQUFDLE1BQU0sT0FDakQsR0FBRyxDQUFDLGdCQUFnQixtQ0FBSSxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUMzQyxJQUFJLENBQ0wsQ0FDRixDQUFDO1NBQ0g7UUFFRCxNQUFNLElBQUksU0FBRyxHQUFHLENBQUMsZ0JBQWdCLG1DQUFJLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekQsNERBQTREO1FBQzVELElBQUksQ0FBQyxFQUFFLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7WUFDM0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUMxQyxTQUFTLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBRSxFQUMxQixRQUFRLEVBQ1IsMENBQTBDLENBQzNDO2lCQUNFLHFCQUFxQixPQUNwQixFQUFFLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLG1DQUFJLElBQUksRUFDckMsbUNBQW1DLENBQ3BDO2lCQUNBLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUMzQyxDQUFDO1lBQ0YsMkJBQTJCO1lBQzNCLE9BQVEsTUFBTSxDQUFDLEtBQWEsQ0FBQyxNQUFNLENBQUM7U0FDckM7UUFFRCx1RUFBdUU7UUFDdkUsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLEVBQUU7WUFDakMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztTQUMzQztRQUVELE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FDbkQsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQ3ZCLENBQUM7UUFDRixPQUFPO1lBQ0wsSUFBSSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQzdDLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSztTQUNwQixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0ssNEJBQTRCLENBQ2xDLE1BQW1CLEVBQ25CLFNBQW9COztRQUVwQixNQUFNLE1BQU0sR0FBRyw2QkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRCxNQUFNLFdBQVcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxPQUFDLE1BQU0sQ0FBQyxVQUFVLG1DQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUUsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQzNCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLGdDQUFnQyxDQUFDLE1BQU0sT0FDcEQsU0FBUyxDQUFDLGdCQUFnQixtQ0FBSSxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUN2RCxNQUFNLEVBQ04sS0FBSyxDQUNOLENBQ0YsQ0FBQzthQUNIO1NBQ0Y7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLGVBQWUsQ0FDM0IsSUFBYSxFQUNiLEdBQWdCOztRQUVoQixJQUFJLEdBQUcsQ0FBQyxjQUFjLEVBQUUsRUFBRTtZQUN4QixHQUFHLENBQUMsS0FBSyxDQUNQLHlCQUF5QixNQUFNLENBQUMsSUFBSSxDQUNsQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FDeEIsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FDckMsQ0FBQztTQUNIO1FBRUQsSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDckMsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFFRCxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQ2hFLElBQUksQ0FBQyxNQUFNLENBQUMsSUFDZCxFQUFFLENBQUM7UUFFSCxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ25FLE1BQU0sUUFBUSxHQUF1QixRQUFRLENBQUMsdUJBQXVCLENBQ25FO1lBQ0UsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSTtZQUMvQixHQUFHO1lBQ0gsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUztZQUM3QixJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJO1lBQ3RCLFNBQVMsRUFDUCxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQ2hFLElBQUk7U0FDTCxFQUNELElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBNEIsQ0FDdkQsQ0FBQztRQUVGLE1BQU0sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsc0JBQXNCLENBQ25FLEdBQUcsRUFDSCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQ3BCLENBQUM7UUFDRixRQUFRLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXhFLEtBQUssTUFBTSxhQUFhLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUMsRUFBRTtZQUNsRCxLQUFLLE1BQU0sTUFBTSxJQUFJLGFBQWEsQ0FBQyxhQUFhLEVBQUUsRUFBRTtnQkFDbEQsSUFDRSxDQUFDLE9BQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQUUsbUNBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUNsRCxDQUFDLElBQUksRUFBRSxFQUFFLFdBQUMsT0FBQSxJQUFJLFlBQUssTUFBTSxDQUFDLGdCQUFnQiwwQ0FBRSxNQUFNLENBQUEsQ0FBQSxFQUFBLENBQ25ELEVBQ0Q7b0JBQ0EsU0FBUztpQkFDVjtnQkFFRCxJQUNFLElBQUksQ0FBQyxvQkFBb0IsQ0FDdkIsTUFBTSxFQUNOLE1BQU0sQ0FBQyxnQkFBMEMsQ0FDbEQsRUFDRDtvQkFDQSxTQUFTO2lCQUNWO2dCQUVELElBQ0UsRUFBRSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztvQkFDL0MsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUM3QztvQkFDQSw0Q0FBNEM7b0JBQzVDLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FDckIsTUFBTSxFQUNOLFFBQVEsRUFDUixHQUFHLENBQUMsZ0JBQWdCLE9BQUMsUUFBUSxDQUFDLElBQUksMENBQUUsU0FBUyxDQUFDLEVBQzlDLE9BQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsbUNBQzNCLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUE0QixDQUMxRCxDQUFDO2lCQUNIO3FCQUFNLElBQ0wsRUFBRSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztvQkFDakQsRUFBRSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztvQkFDL0MsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFDdEM7b0JBQ0EsNENBQTRDO29CQUM1QyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQ3ZCLE1BQU0sRUFDTixRQUFRLEVBQ1IsR0FBRyxDQUFDLGdCQUFnQixPQUFDLFFBQVEsQ0FBQyxJQUFJLDBDQUFFLFNBQVMsQ0FBQyxFQUM5QyxPQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLG1DQUMzQixJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBNEIsQ0FDMUQsQ0FBQztpQkFDSDtxQkFBTTtvQkFDTCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQzlDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxFQUM5QixPQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsbUNBQUksTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDekQsQ0FDRixDQUFDO2lCQUNIO2FBQ0Y7U0FDRjtRQUVELHdGQUF3RjtRQUN4RixnSEFBZ0g7UUFDaEgsTUFBTSxXQUFXLFNBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsbUNBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFDLHlCQUF5QixDQUM1QixHQUFHLFFBQ0gsUUFBUSxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUN6QixXQUFXLEVBQ1gsQ0FBQyxHQUFHLEtBQWtCLEVBQUUsRUFBRTs7WUFDeEIsSUFBSSxPQUFDLFFBQVEsQ0FBQyxPQUFPLG1DQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ3pDLFFBQVEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2FBQzFCO2lCQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtnQkFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLFFBQVEsQ0FBQyxPQUFRLENBQUMsTUFBTSxDQUN0QixDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRTs7b0JBQ2QsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNsRCxPQUFPLElBQUk7d0JBQ1QsQ0FBQyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsT0FDeEIsRUFBRSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxtQ0FBSSxJQUFJLEVBQ3JDLDJCQUEyQixDQUM1Qjt3QkFDSCxDQUFDLENBQUMsSUFBSSxDQUFDO2dCQUNYLENBQUMsRUFDRCxnQ0FBYyxDQUFDLHNCQUFzQixDQUFDLE1BQU0sQ0FDMUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUUsRUFDakMsUUFBUSxFQUNSLDBDQUEwQyxDQUMzQztxQkFDRSxxQkFBcUIsT0FDcEIsRUFBRSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxtQ0FBSSxXQUFXLEVBQ25ELGtDQUFrQyxDQUNuQztxQkFDQSxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsQ0FDM0MsQ0FDRixDQUFDO2FBQ0g7WUFFRCxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtnQkFDeEIsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDaEQsUUFBUSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7aUJBQy9CO2FBQ0Y7WUFFRCxNQUFNLGFBQWEsR0FBRyxlQUFlLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXJELDBEQUEwRDtZQUMxRCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDeEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsbUNBQW1DLENBQUMsTUFBTSxPQUN2RCxFQUFFLENBQUMsb0JBQW9CLENBQUMsV0FBVyxDQUFDLG1DQUFJLFdBQVcsRUFDbkQsUUFBUSxDQUFDLElBQUksQ0FDZCxDQUNGLENBQUM7YUFDSDtZQUVELHVGQUF1RjtZQUN2RixxRkFBcUY7WUFDckYsSUFBSSxRQUFRLENBQUMsUUFBUSxJQUFJLGFBQWEsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7Z0JBQ3ZELE9BQU8sUUFBUSxDQUFDLFFBQVEsQ0FBQzthQUMxQjtZQUVELG9FQUFvRTtZQUNwRSxJQUFJLFFBQVEsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3JCLEtBQUssTUFBTSxJQUFJLFVBQUksUUFBUSxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUFFO29CQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTt3QkFDbkIsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFFLENBQUM7d0JBQ3ZDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLHVDQUF1QyxDQUFDLE1BQU0sQ0FDM0Qsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLEVBQ3pCLENBQUMsQ0FBQyxJQUFJLEVBQ04sUUFBUSxDQUNULENBQ0YsQ0FBQzt3QkFFRiwrRUFBK0U7d0JBQy9FLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO3FCQUN2QjtpQkFDRjthQUNGO2lCQUFNO2dCQUNMLHlFQUF5RTtnQkFDekUsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7b0JBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFO3dCQUMvQix3RUFBd0U7d0JBQ3hFLFNBQVM7cUJBQ1Y7b0JBQ0QsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO3dCQUNqQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQyxrQ0FBa0MsQ0FBQyxNQUFNLE9BQ3RELElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLG1DQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUMzRCxRQUFRLEVBQ1IsSUFBSSxDQUNMLENBQ0YsQ0FBQztxQkFDSDtpQkFDRjthQUNGO1FBQ0gsQ0FBQyxDQUNGLENBQUM7UUFFRixvRUFBb0U7UUFDcEUsc0NBQXNDO1FBQ3RDLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNwQyxNQUFNLG1CQUFtQixHQUFHLENBQUMsR0FBRyxLQUFrQixFQUFFLEVBQUU7O1lBQ3BELEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO2dCQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDL0IsU0FBUztpQkFDVjtnQkFFRCxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3RDLEtBQUssTUFBTSxVQUFVLElBQUksS0FBSyxFQUFFO29CQUM5QixJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7d0JBQ3BDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLHFDQUFxQyxDQUFDLE1BQU0sT0FDekQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsbUNBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQzNELFVBQVUsRUFDVixRQUFRLENBQ1QsQ0FDRixDQUFDO3FCQUNIO2lCQUNGO2dCQUNELGtCQUFrQjtnQkFDbEIsSUFBSSxDQUFDLHlCQUF5QixDQUM1QixHQUFHLFFBQ0gsSUFBSSxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUNyQixJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUM1QixtQkFBbUIsQ0FDcEIsQ0FBQzthQUNIO1FBQ0gsQ0FBQyxDQUFDO1FBQ0YsSUFBSSxDQUFDLHlCQUF5QixDQUM1QixHQUFHLFFBQ0gsUUFBUSxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUM1QixtQkFBbUIsQ0FDcEIsQ0FBQztRQUVGLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLElBQUksQ0FBQyxDQUFDO1FBRTFELE9BQU8sWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFTyxLQUFLLENBQUMsWUFBWSxDQUN4QixNQUFpQixFQUNqQixJQUF5QyxFQUN6QyxHQUFnQixFQUNoQixpQkFBb0U7O1FBRXBFLElBQUksR0FBRyxDQUFDLGNBQWMsRUFBRSxFQUFFO1lBQ3hCLEdBQUcsQ0FBQyxLQUFLLENBQ1Asc0JBQXNCLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQ3pELE1BQU0sQ0FBQyxJQUFJLENBQ1osRUFBRSxDQUNKLENBQUM7U0FDSDtRQUVELE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxnQkFFTCxDQUFDO1FBQ3ZCLE1BQU0sU0FBUyxHQUNiLElBQUksQ0FBQyxZQUFZLENBQUMsMkJBQTJCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDN0QsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNkLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLHFDQUFxQyxDQUFDLE1BQU0sQ0FDekQsV0FBVyxFQUNYLE1BQU0sQ0FBQyxJQUFJLEVBQ1gsSUFBSSxDQUNMLENBQ0YsQ0FBQztZQUNGLE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdkQsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsbUNBQW1DLENBQUMsTUFBTSxDQUN2RCxXQUFXLENBQUMsSUFBSSxFQUNoQixRQUFRLEVBQ1IsTUFBTSxFQUNOLElBQUksQ0FDTCxDQUFDLHFCQUFxQixPQUNyQixpQkFBaUIsQ0FBQyxJQUFJLG1DQUFJLGlCQUFpQixFQUMzQyxpQkFBaUIsSUFBSSxDQUFDLElBQUkscUJBQXFCLENBQ2hELENBQ0YsQ0FBQztTQUNIO1FBRUQsSUFBSSxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdkMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsZ0NBQWdDLENBQUMsTUFBTSxDQUNwRCxXQUFXLENBQUMsSUFBSSxFQUNoQixNQUFNLENBQUMsSUFBSSxDQUNaLENBQ0YsQ0FBQztZQUNGLE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVyQyxNQUFNLFVBQVUsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2xDLFNBQVMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQ2hFLENBQUM7UUFFRixNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDN0MsTUFBTSxNQUFNLEdBQWdCLFFBQVEsQ0FBQyxvQkFBb0IsQ0FDdkQ7WUFDRSxRQUFRLEVBQUUsV0FBVyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxTQUFTO1lBQ2hELElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtZQUNqQixVQUFVLEVBQUUsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsU0FBUztZQUMxRCxTQUFTLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLFNBQVM7WUFDNUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxVQUFVLENBQUM7Z0JBQzFCLENBQUMsQ0FBQyxTQUFTO2dCQUNYLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQ3ZCLFVBQVUsRUFDVixXQUFXLENBQUMsSUFBSSxFQUNoQixhQUFhLENBQ2Q7WUFDTCxLQUFLLEVBQUUsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLFNBQVM7WUFDMUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxTQUFTO1lBQ3RDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUM7U0FDeEQsRUFDRCxXQUFXLENBQ1osQ0FBQztRQUNGLE1BQU0sQ0FBQyxRQUFRO1lBQ2IsT0FBQSxNQUFNLENBQUMsVUFBVSwwQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxPQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFFM0UsSUFBSSxDQUFDLDJCQUEyQixDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFakUsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUV6RCwwRkFBMEY7UUFDMUYsOEZBQThGO1FBQzlGLHFCQUFxQjtRQUNyQixNQUFNLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoRSxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7UUFDeEQsSUFBSSxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUNuRSxJQUFJLENBQUMseUJBQXlCLENBQzVCLE1BQU0sQ0FBQyxJQUFJLEVBQ1gsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUNsQixlQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFDaEMsQ0FBQyxhQUFhLEVBQUUsRUFBRTtnQkFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFO29CQUNuRSxPQUFPO2lCQUNSO2dCQUVELDhGQUE4RjtnQkFDOUYsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQztnQkFDcEQsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLENBQ3hCLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQzlELENBQUM7Z0JBQ0YsTUFBTSxXQUFXLEdBQUcsWUFBWSxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFFeEQsS0FBSyxNQUFNLE9BQU8sSUFBSSxXQUFXLEVBQUU7b0JBQ2pDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLHFDQUFxQyxDQUFDLE1BQU0sQ0FDekQsV0FBVyxFQUNYLE9BQU8sQ0FDUixDQUNGLENBQUM7aUJBQ0g7WUFDSCxDQUFDLENBQ0YsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLDRCQUE0QixDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUVsRCxJQUFJLENBQUMsT0FBTyxTQUFHLElBQUksQ0FBQyxPQUFPLG1DQUFJLEVBQUUsQ0FBQztRQUNsQyxJQUNFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUNmLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsTUFBTSxDQUM1RCxJQUFJLElBQUksRUFDVDtZQUNBLEdBQUcsQ0FBQyxLQUFLLENBQ1AsOEJBQThCLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQ2pFLE1BQU0sQ0FBQyxJQUFJLENBQ1osRUFBRSxDQUNKLENBQUM7WUFDRixPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFTyx1QkFBdUIsQ0FBQyxNQUFpQjtRQUMvQyxJQUFJLENBQUMsMEJBQWUsQ0FBQyxlQUFlLENBQUMsRUFBRTtZQUNyQyxPQUFPO1NBQ1I7UUFFRCxNQUFNLGtCQUFrQixHQUFHLCtCQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZELElBQUksa0JBQWtCLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUMzQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsRUFDOUIsTUFBTSxDQUFDLElBQUksRUFDWCxrQkFBa0IsQ0FDbkIsQ0FDRixDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLGNBQWMsQ0FDMUIsTUFBaUIsRUFDakIsSUFBeUMsRUFDekMsR0FBZ0IsRUFDaEIsaUJBQW9FOztRQUVwRSxVQUFJLElBQUksQ0FBQyxVQUFVLDBDQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsSUFBSSxHQUFHO1lBQ3hEOzs7O2VBSUc7WUFDSCxPQUFPO1NBQ1I7UUFFRCxJQUFJLEdBQUcsQ0FBQyxjQUFjLEVBQUUsRUFBRTtZQUN4QixHQUFHLENBQUMsS0FBSyxDQUNQLHdCQUF3QixNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUMzRCxNQUFNLENBQUMsSUFBSSxDQUNaLEVBQUUsQ0FDSixDQUFDO1NBQ0g7UUFFRCxNQUFNLFdBQVcsU0FBRyxNQUFNLENBQUMsZ0JBQWdCLG1DQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEUsTUFBTSxTQUFTLEdBQUcsV0FJaUIsQ0FBQztRQUVwQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3ZELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLG1DQUFtQyxDQUFDLE1BQU0sQ0FDdkQsU0FBUyxDQUFDLElBQUksRUFDZCxVQUFVLEVBQ1YsTUFBTSxFQUNOLElBQUksQ0FDTCxDQUFDLHFCQUFxQixPQUNyQixpQkFBaUIsQ0FBQyxJQUFJLG1DQUFJLGlCQUFpQixFQUMzQyxpQkFBaUIsSUFBSSxDQUFDLElBQUkscUJBQXFCLENBQ2hELENBQ0YsQ0FBQztTQUNIO1FBRUQsSUFBSSxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdkMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsZ0NBQWdDLENBQUMsTUFBTSxPQUNwRCxNQUFNLENBQUMsZ0JBQWdCLG1DQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQ2pELE1BQU0sQ0FBQyxJQUFJLENBQ1osQ0FDRixDQUFDO1lBQ0YsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXJDLE1BQU0sUUFBUSxHQUFrQixRQUFRLENBQUMsc0JBQXNCLENBQzdEO1lBQ0UsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FDM0IsSUFBSSxDQUFDLFlBQVksQ0FBQyx5QkFBeUIsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLEVBQzlELFNBQVMsQ0FBQyxJQUFJLEVBQ2QsZUFBZSxDQUNoQixDQUFDO1lBQ0YsUUFBUSxFQUFFLFdBQVcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksU0FBUztZQUNoRCxJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7WUFDakIsU0FBUyxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxTQUFTO1lBQzVDLE1BQU0sRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksU0FBUztZQUN0QyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDO1NBQ3RELEVBQ0QsU0FBUyxDQUNWLENBQUM7UUFFRixJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDL0IsTUFBTSxLQUFLLFNBQUcsTUFBTSxDQUFDLGVBQWUsRUFBRSxtQ0FBSSxFQUFFLENBQUM7WUFDN0MsUUFBUSxDQUFDLFNBQVM7Z0JBQ2hCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQztTQUM5RDthQUFNO1lBQ0wsUUFBUSxDQUFDLFNBQVM7Z0JBQ2hCLENBQUMsRUFBRSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDO29CQUNsRSxDQUFDLElBQUksU0FBUyxDQUFDO1NBQ3BCO1FBRUQsSUFBSSxTQUFTLENBQUMsYUFBYSxFQUFFO1lBQzNCLFFBQVEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1NBQzFCO1FBRUQsSUFDRSxRQUFRLENBQUMsTUFBTTtZQUNmLFFBQVEsQ0FBQyxTQUFTO1lBQ2xCLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUM7WUFDbkMsU0FBUyxDQUFDLFdBQVcsRUFDckI7WUFDQSxRQUFRLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztTQUN2QjtRQUVELFFBQVEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFFM0QsSUFBSSxDQUFDLFVBQVUsU0FBRyxJQUFJLENBQUMsVUFBVSxtQ0FBSSxFQUFFLENBQUM7UUFDeEMsSUFDRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDbEIsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUNQLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxNQUFNLENBQ2pFLElBQUksSUFBSSxFQUNUO1lBQ0EsR0FBRyxDQUFDLEtBQUssQ0FDUCw4QkFBOEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FDakUsUUFBUSxDQUFDLElBQUksQ0FDZCxFQUFFLENBQ0osQ0FBQztZQUNGLE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFTyxLQUFLLENBQUMsWUFBWSxDQUN4QixXQUFzQixFQUN0QixHQUFnQjtRQUVoQixJQUFJLEdBQUcsQ0FBQyxjQUFjLEVBQUUsRUFBRTtZQUN4QixHQUFHLENBQUMsS0FBSyxDQUFDLHlCQUF5QixNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDckU7UUFDRCxNQUFNLGdCQUFnQixHQUNwQixXQUFXLENBQUMsZ0JBQTJDLENBQUM7UUFFMUQsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTFDLE1BQU0sU0FBUyxHQUFtQixRQUFRLENBQUMsdUJBQXVCLENBQ2hFO1lBQ0UsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FDM0IsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUNyRCxnQkFBZ0IsQ0FBQyxJQUFJLEVBQ3JCLGdCQUFnQixDQUNqQixDQUFDO1lBQ0YsSUFBSSxFQUFFLFdBQVcsQ0FBQyxJQUFJO1lBQ3RCLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxjQUFjLElBQUksSUFBSTtTQUNsRCxFQUNELGdCQUFnQixDQUNqQixDQUFDO1FBRUYsSUFBSSxTQUFTLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDeEUseUZBQXlGO1lBQ3pGLFNBQVMsQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDO1NBQ3hEO2FBQU0sSUFBSSxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksZ0JBQWdCLENBQUMsYUFBYSxFQUFFO1lBQ3pFLHlEQUF5RDtZQUN6RCxTQUFTLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztTQUMzQjtRQUVELFNBQVMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUN2QyxXQUFXLEVBQ1gsR0FBRyxDQUFDLGVBQWUsRUFBRSxDQUN0QixDQUFDLElBQUksQ0FBQztRQUVQLGdGQUFnRjtRQUNoRixpQ0FBaUM7UUFFakMsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVPLEtBQUssQ0FBQyxjQUFjLENBQzFCLElBQWEsRUFDYixXQUFvQixFQUNwQixPQUFvQjtRQUVwQixNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM1RSxJQUFJLGFBQWEsQ0FBQyxRQUFRLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsK0JBQStCLENBQUMsTUFBTSxDQUNuRCxXQUFXLEVBQ1gsaUZBQWlGLENBQ2xGLENBQ0YsQ0FBQztTQUNIO1FBQ0QsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDO0lBQzVCLENBQUM7SUFFTyxLQUFLLENBQUMsY0FBYyxDQUMxQixJQUFhLEVBQ2IsV0FBb0IsRUFDcEIsT0FBb0I7UUFFcEIsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFeEQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3pDLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3pEO2FBQU07WUFDTCxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDaEQ7UUFFRCxNQUFNLGFBQWEsR0FBRyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkQsSUFBSSxhQUFhLEVBQUU7WUFDakIsT0FBTyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsQ0FBQztTQUNoQztRQUVELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3hDLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM5QjtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2hCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDRCQUE0QixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FDaEUsQ0FBQztZQUNGLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3JDO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUU7WUFDaEMsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztTQUM5QztRQUVELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ3hELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDNUM7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxLQUFLLFNBQVMsRUFBRTtZQUN6QyxNQUFNLE9BQU8sR0FBRyxJQUF3QixDQUFDO1lBQ3pDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxJQUFJLE9BQU8sQ0FBQyxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDaEUsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsNkJBQTZCLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUNqRSxDQUFDO2dCQUNGLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO2FBQ3JDO1lBQ0QsT0FBTztnQkFDTCxJQUFJLEVBQUUsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUM3QixPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUN4QixXQUFXLEVBQ1gsT0FBTyxDQUNSO2FBQ0YsQ0FBQztTQUNIO1FBRUQsT0FBTztZQUNMLElBQUksRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLEVBQUU7U0FDMUUsQ0FBQztRQUVGLEtBQUssVUFBVSxVQUFVOztZQUd2QixNQUFNLE9BQU8sR0FBRyxJQUF3QixDQUFDO1lBQ3pDLElBQUksV0FBK0IsQ0FBQztZQUVwQyxJQUFJLE9BQUEsT0FBTyxDQUFDLGFBQWEsMENBQUUsTUFBTSxNQUFLLENBQUMsRUFBRTtnQkFDdkMsV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FDckMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFDeEIsV0FBVyxFQUNYLG1CQUFtQixDQUNwQixDQUFDO2FBQ0g7aUJBQU07Z0JBQ0wsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLGFBQWE7b0JBQ2pDLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLE1BQU07b0JBQzlCLENBQUMsQ0FBQyxNQUFNLENBQUM7Z0JBQ1gsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLGdDQUFjLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUM5QyxXQUFXLEVBQ1gsK0RBQStELEtBQUssR0FBRyxDQUN4RSxDQUNGLENBQUM7Z0JBQ0YsV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7YUFDbEM7WUFFRCxPQUFPO2dCQUNMLFVBQVUsRUFBRTtvQkFDVixXQUFXO29CQUNYLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUs7aUJBQ2hDO2FBQ0YsQ0FBQztRQUNKLENBQUM7UUFFRCxLQUFLLFVBQVUsUUFBUTtZQUdyQixJQUFJLFdBQStCLENBQUM7WUFDcEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDN0MsSUFBSSxVQUFVLEVBQUU7Z0JBQ2QsV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FDckMsVUFBVSxFQUNWLFdBQVcsRUFDWCxrQkFBa0IsQ0FDbkIsQ0FBQzthQUNIO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUNwQixnQ0FBYyxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FDOUMsV0FBVyxFQUNYLDZDQUE2QyxDQUM5QyxDQUNGLENBQUM7Z0JBQ0YsV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7YUFDbEM7WUFDRCxPQUFPO2dCQUNMLFVBQVUsRUFBRTtvQkFDVixXQUFXO29CQUNYLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUc7aUJBQzlCO2FBQ0YsQ0FBQztRQUNKLENBQUM7UUFFRCxTQUFTLHFCQUFxQjtZQUc1QixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDaEIsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFO29CQUNwQyxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQy9DO2dCQUNELElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQzFELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztpQkFDM0I7YUFDRjtpQkFBTSxJQUNMLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCO2dCQUM1QixPQUFPLENBQ0wsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxRQUFRLEVBQ3JELElBQUksQ0FBQyxNQUFNLENBQ1osRUFDRDtnQkFDQSxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFO29CQUN4QixLQUFLLFNBQVM7d0JBQ1osT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNuRCxLQUFLLE1BQU07d0JBQ1QsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO29CQUNoRCxLQUFLLFFBQVE7d0JBQ1gsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDO29CQUNsRCxLQUFLLFFBQVE7d0JBQ1gsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDO2lCQUNuRDthQUNGO1lBQ0Qsd0JBQXdCO1lBQ3hCLE9BQU8sU0FBUyxDQUFDO1lBRWpCLFNBQVMsT0FBTyxDQUFDLElBQVksRUFBRSxHQUFXO2dCQUN4QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDMUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0RSxDQUFDO1FBQ0gsQ0FBQztRQUVELEtBQUssVUFBVSxVQUFVO1lBQ3ZCLE1BQU0sS0FBSyxHQUFHLElBQUksS0FBSyxFQUFzQixDQUFDO1lBQzlDLElBQUksUUFBNkIsQ0FBQztZQUVsQyxLQUFLLE1BQU0sT0FBTyxJQUFLLElBQXFCLENBQUMsS0FBSyxFQUFFO2dCQUNsRCxJQUFJLE9BQU8sQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUU7b0JBQzFDLFFBQVEsR0FBRyxJQUFJLENBQUM7b0JBQ2hCLFNBQVM7aUJBQ1Y7Z0JBQ0QsNENBQTRDO2dCQUM1QyxNQUFNLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQzVDLE9BQU8sRUFDUCxXQUFXLEVBQ1gsT0FBTyxDQUNSLENBQUM7Z0JBQ0YsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxDQUFDLElBQUksSUFBSSxFQUFFO29CQUM3RCxTQUFTO2lCQUNWO2dCQUNELEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDMUI7WUFFRCxPQUFPLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQztnQkFDdkIsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQzlCLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDL0MsQ0FBQztJQUNILENBQUM7SUFFTyxvQkFBb0I7UUFDMUIsZ0RBQWdEO1FBQ2hELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2hDLDJEQUEyRDtZQUMzRCxnRUFBZ0U7WUFDaEUsb0JBQW9CO1lBQ3BCLE1BQU0sV0FBVyxHQUFHLElBQUksR0FBRyxDQUFTLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN0RSxLQUFLLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ3JDLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQzthQUMvQztZQUVELGdGQUFnRjtZQUNoRixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7WUFDcEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM5QyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7b0JBQy9DLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDaEQsUUFBUSxDQUFDLEVBQUUsRUFBRSxDQUFDO29CQUNkLE9BQU8sR0FBRyxJQUFJLENBQUM7aUJBQ2hCO2FBQ0Y7WUFFRCxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNaLDJDQUEyQztnQkFDM0MsTUFBTSxJQUFJLEtBQUssQ0FDYixzRUFBc0UsSUFBSSxDQUFDLFNBQVMsQ0FDbEYsSUFBSSxDQUFDLFNBQVMsRUFDZCxTQUFTLEVBQ1QsQ0FBQyxDQUNGLEVBQUUsQ0FDSixDQUFDO2FBQ0g7U0FDRjtRQUVEOztXQUVHO1FBQ0gsU0FBUyxzQkFBc0IsQ0FBQyxHQUFtQixFQUFFLElBQWlCO1lBQ3BFLEdBQUcsQ0FBQyxZQUFZLEdBQUcsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNsRSxDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ssYUFBYSxDQUFDLElBQXdCO1FBQzVDLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFDOUIsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDekIsT0FBTyxHQUFHLENBQUM7UUFFWCxTQUFTLE9BQU8sQ0FBa0IsR0FBdUI7O1lBQ3ZELEtBQUssTUFBTSxRQUFRLFVBQUksR0FBRyxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUFFO2dCQUMzQyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN4QjtZQUVELEtBQUssTUFBTSxPQUFPLFVBQUksR0FBRyxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUFFO2dCQUMxQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDbkQsSUFBSSxDQUFDLElBQUksRUFBRTtvQkFDVCxNQUFNLElBQUksS0FBSyxDQUNiLHlEQUF5RCxDQUMxRCxDQUFDO2lCQUNIO2dCQUNELElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUMvQixNQUFNLElBQUksS0FBSyxDQUNiLDBEQUEwRCxDQUMzRCxDQUFDO2lCQUNIO2dCQUVELE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQzFCO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFTywyQkFBMkIsQ0FDakMsSUFBYSxFQUNiLFVBQTZCO1FBRTdCLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDZixPQUFPO1NBQ1I7UUFFRCxNQUFNLFNBQVMsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDNUMsT0FBTyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMzQixNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFHLENBQUM7WUFDakMsSUFBSSxPQUFPLENBQUMsUUFBUSxFQUFFO2dCQUNwQixNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ25FLElBQUksUUFBUSxJQUFJLElBQUksRUFBRTtvQkFDcEIsU0FBUztpQkFDVjtnQkFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDcEIsZ0NBQWMsQ0FBQyw0Q0FBNEMsQ0FBQyxNQUFNLENBQ2hFLElBQUksRUFDSixPQUFPLEVBQ1AsUUFBUSxDQUNULENBQ0YsQ0FBQztnQkFDRixPQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUM7YUFDekI7U0FDRjtJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSyx3QkFBd0IsQ0FBQyxLQUEwQixFQUFFLEdBQVc7UUFDdEUsSUFBSSxDQUFDLHVCQUF1QixDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNLLGtCQUFrQixDQUN4QixNQUFrQixFQUNsQixJQUFnQixFQUNoQixVQUFzQzs7UUFFdEMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNwQixPQUFPO1NBQ1I7UUFFRCxJQUFJLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVqQyw0RUFBNEU7UUFDNUUsNkRBQTZEO1FBQzdELEVBQUU7UUFDRixnRkFBZ0Y7UUFDaEYscUJBQXFCO1FBQ3JCLEtBQUssTUFBTSxJQUFJLFVBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxtQ0FBSSxFQUFFLEVBQUU7WUFDakQsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN4QixTQUFTO2FBQ1Y7WUFFRCxJQUFJLENBQUMsZUFBZSxDQUFDLHNCQUFzQixDQUN6QyxJQUFJLEVBQ0osZ0NBQXlCLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUM1QyxDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxjQUFjLENBQUMsSUFBeUI7UUFDOUMsaUVBQWlFO1FBQ2pFLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2xFLE9BQU87Z0JBQ0wsR0FBRyxJQUFJO2dCQUNQLE9BQU8sRUFBRSxrQkFBa0IsSUFBSSxDQUFDLE9BQU8sRUFBRTthQUMxQyxDQUFDO1NBQ0g7UUFDRCxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNoRSxPQUFPO2dCQUNMLEdBQUcsSUFBSTtnQkFDUCxPQUFPLEVBQUUsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLEVBQUU7YUFDeEMsQ0FBQztTQUNIO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssWUFBWTtRQUNsQixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQ3hELENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUM5QyxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBN3NGRCw4QkE2c0ZDO0FBNkRELFNBQVMsWUFBWSxDQUFDLFFBQXVCO0lBQzNDLE9BQU8sUUFBUSxDQUFDLFdBQVcsQ0FBQztJQUM1QixRQUFRLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzlCLE1BQU0sV0FBVyxHQUFHLE1BQU07U0FDdkIsVUFBVSxDQUFDLFFBQVEsQ0FBQztTQUNwQixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNoQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEIsT0FBTyxFQUFFLEdBQUcsUUFBUSxFQUFFLFdBQVcsRUFBRSxDQUFDO0FBQ3RDLENBQUM7QUFFRCxTQUFTLFdBQVcsQ0FDbEIsTUFBaUIsRUFDakIsYUFBa0Q7SUFFbEQsdUNBQXVDO0lBQ3ZDLElBQUksYUFBYSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRTtRQUNsRCxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsT0FBTyxDQUNMLENBQUMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCO1FBQ3pCLENBQUMsRUFBRSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztZQUNuRCxFQUFFLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQztZQUMxQixDQUFDLENBQ0osQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLFdBQVcsQ0FBQyxJQUFhO0lBQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3BELENBQUM7QUFFRCxTQUFTLFdBQVcsQ0FBQyxJQUFvQjtJQUN2QyxPQUFPLENBQUMsRUFBRSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzdFLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsU0FBUyxVQUFVLENBQUMsTUFBaUI7SUFDbkMsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLEdBQUcsQ0FBQztRQUNyQyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQjtRQUM5QixFQUFFLENBQUMsVUFBVSxDQUFDLG9CQUFvQjtRQUNsQyxFQUFFLENBQUMsVUFBVSxDQUFDLGVBQWU7S0FDOUIsQ0FBQyxDQUFDO0lBRUgscUdBQXFHO0lBQ3JHLDZDQUE2QztJQUM3QyxJQUNFLENBQUMsTUFBTSxDQUFDLGdCQUFnQjtRQUN4QixzQkFBc0IsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUN4RDtRQUNBLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN0QixLQUFLLE1BQU0sSUFBSSxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUU7WUFDdEMsSUFBSSxFQUFFLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUU7Z0JBQy9ELFNBQVMsR0FBRyxJQUFJLENBQUM7Z0JBQ2pCLE1BQU07YUFDUDtZQUNELGdEQUFnRDtZQUNoRCxJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNqQyxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUM3QyxNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUMsd0JBQXdCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztnQkFDakUsNERBQTREO2dCQUM1RCxJQUNFLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztvQkFDNUMsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQzNDO29CQUNBLFNBQVMsR0FBRyxJQUFJLENBQUM7b0JBQ2pCLE1BQU07aUJBQ1A7YUFDRjtTQUNGO1FBQ0QsT0FBTyxDQUFDLFNBQVMsQ0FBQztLQUNuQjtJQUVELE9BQU8sQ0FDTCxNQUFNLENBQUMsZ0JBQWdCO1FBQ3ZCLENBQUMsRUFBRSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztZQUNuRCxFQUFFLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQztZQUN6QixDQUFDLENBQ0osQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLG9CQUFvQixDQUFDLE1BQWlCO0lBQzdDLE9BQU8sTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsQ0FBQztBQUN2RSxDQUFDO0FBRUQsU0FBUyxZQUFZLENBQUMsTUFBaUI7SUFDckMsT0FBTyxDQUNMLENBQUMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCO1FBQ3pCLENBQUMsRUFBRSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztZQUNuRCxFQUFFLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQztZQUMzQixDQUFDLENBQ0osQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBQyxNQUFpQjtJQUNsQyxPQUFPLENBQ0wsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0I7UUFDekIsQ0FBQyxFQUFFLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDO1lBQ25ELEVBQUUsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO1lBQ3hCLENBQUMsQ0FDSixDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsT0FBTyxDQUFDLElBQWE7SUFDNUIsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDaEQsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFDLElBQWE7O0lBQy9CLE9BQU8sT0FBQSxJQUFJLENBQUMsTUFBTSwwQ0FBRSxXQUFXLE1BQUssU0FBUyxDQUFDO0FBQ2hELENBQUM7QUFJRCxTQUFTLFlBQVksQ0FDbkIsSUFBeUM7SUFFekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbkQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDNUQsT0FBTyxJQUFJLENBQUM7SUFFWjs7Ozs7Ozs7OztPQVVHO0lBQ0gsU0FBUyxLQUFLLENBQXVCLE1BQVc7UUFDOUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE9BQU8sTUFBTSxDQUFDO1NBQ2Y7UUFDRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFaEMsU0FBUyxXQUFXLENBQUMsSUFBTyxFQUFFLElBQU87WUFDbkMsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBRWxELFNBQVMsT0FBTyxDQUFDLEdBQU07Z0JBQ3JCLE9BQU87b0JBQ0wsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHO29CQUN0QixHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUc7b0JBQ3pCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHO29CQUN6QixHQUFHLENBQUMsSUFBSTtpQkFDVCxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNkLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztBQU9ILENBQUM7QUF5QkQ7O0dBRUc7QUFDSCxTQUFTLElBQUksQ0FBSSxFQUFPO0lBQ3RCLE9BQU8sRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDdkQsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxLQUFLLENBQ1osQ0FBZ0IsRUFDaEIsRUFBMkI7SUFFM0IsT0FBTyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUM3QyxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFlBQVksQ0FBSSxFQUFVLEVBQUUsRUFBVTtJQUM3QyxNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsRUFBSyxDQUFDO0lBQ3pCLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ2xCLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNiLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjtLQUNGO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsV0FBVyxDQUFDLFFBQTZDO0lBQ2hFLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsUUFBNkM7O0lBR2hFLE1BQU0sR0FBRyxHQUFtRCxFQUFFLENBQUM7SUFFL0QsS0FBSyxNQUFNLElBQUksVUFBSSxRQUFRLENBQUMsVUFBVSxtQ0FBSSxFQUFFLEVBQUU7UUFDNUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDdkI7SUFFRCxLQUFLLE1BQU0sTUFBTSxVQUFJLFFBQVEsQ0FBQyxPQUFPLG1DQUFJLEVBQUUsRUFBRTtRQUMzQyxHQUFHLE9BQUMsTUFBTSxDQUFDLElBQUksbUNBQUksRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDO0tBQ2pDO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLGVBQWUsQ0FBQyxJQUFZO0lBQ25DLE9BQU8sQ0FDTCxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUM7UUFDaEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUNoRCxDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsY0FBYyxDQUFDLElBQWE7O0lBQ25DLGFBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLDBDQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFO0FBQ3JFLENBQUM7QUFFRCxRQUFRLENBQUMsQ0FBQyxTQUFTLENBQUksRUFBVSxFQUFFLEVBQVU7SUFDM0MsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDbEIsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2IsTUFBTSxDQUFDLENBQUM7U0FDVDtLQUNGO0FBQ0gsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUNsQixFQUFpQztJQUVqQyxJQUFJLEVBQUUsSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQzlDLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxVQUFvQztJQUcvRCxNQUFNLE1BQU0sR0FBcUQsRUFBRSxDQUFDO0lBQ3BFLEtBQUssTUFBTSxRQUFRLElBQUksVUFBVSxFQUFFO1FBQ2pDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFO1lBQ3JCLFNBQVM7U0FDVjtRQUNELE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUc7WUFDdEIsVUFBVSxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDO1lBQ3hDLE9BQU8sRUFBRSxRQUFRLENBQUMsT0FBTztTQUMxQixDQUFDO0tBQ0g7SUFDRCxPQUFPLE1BQU0sQ0FBQztJQUVkOzs7Ozs7Ozs7OztPQVdHO0lBQ0gsU0FBUyxPQUFPLENBQ2QsVUFBdUM7UUFFdkMsSUFBSSxVQUFVLElBQUksSUFBSSxFQUFFO1lBQ3RCLE9BQU8sVUFBVSxDQUFDO1NBQ25CO1FBQ0QsTUFBTSxNQUFNLEdBQStDLEVBQUUsQ0FBQztRQUM5RCxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDM0QsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUM7U0FDM0I7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsdUJBQXVCLENBQzlCLFVBQW1DO0lBRW5DLE1BQU0sTUFBTSxHQUFnQyxFQUFFLENBQUM7SUFFL0MsS0FBSyxNQUFNLFNBQVMsSUFBSSxVQUFVLEVBQUU7UUFDbEMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRztZQUN0QixnQkFBZ0IsRUFBRSxTQUFTLENBQUMsZ0JBQWdCO1lBQzVDLE9BQU8sRUFBRSxTQUFTLENBQUMsT0FBTztZQUMxQixNQUFNLEVBQUUsU0FBUyxDQUFDLE1BQU07WUFDeEIsUUFBUSxFQUFFLFNBQVMsQ0FBQyxRQUFRO1NBQzdCLENBQUM7S0FDSDtJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQVMsV0FBVyxDQUFDLENBQVU7SUFDN0IsT0FBUSxDQUFTLENBQUMsYUFBYSxLQUFLLE9BQU8sQ0FBQztBQUM5QyxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBRWhFOztHQUVHO0FBQ0gsU0FBUyxzQkFBc0IsQ0FBQyxJQUFZO0lBQzFDLE9BQU8sdUJBQXVCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0FBQzlELENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sV0FBVztJQUNmLFlBQ2tCLFNBQTRCLEVBQzVCLFNBQTBCO1FBRDFCLGNBQVMsR0FBVCxTQUFTLENBQW1CO1FBQzVCLGNBQVMsR0FBVCxTQUFTLENBQWlCO0lBQ3pDLENBQUM7SUFFSjs7O09BR0c7SUFDSSxlQUFlLENBQUMsT0FBZTtRQUNwQyxPQUFPLElBQUksV0FBVyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksZ0JBQWdCLENBQUMsU0FBMEI7UUFDaEQsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNkLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxPQUFPLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZUFBZTtRQUNwQixPQUFPLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDcEQsQ0FBQztDQUNGO0FBRUQsS0FBSyxVQUFVLGVBQWUsQ0FBSSxRQUE2QjtJQUM3RCxNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBSyxDQUFDO0lBQzlCLEtBQUssTUFBTSxNQUFNLElBQUksTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQ2hELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztLQUN4QjtJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxPQUFtQjtJQUN2QyxNQUFNLFdBQVcsR0FBRyxPQUFPO1NBQ3hCLGdCQUFnQixFQUFFO1NBQ2xCLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO1FBQ25CLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbkQsT0FBTyxDQUNMLFVBQVUsSUFBSSxJQUFJO1lBQ2xCLENBQUMsT0FBTyxDQUFDLCtCQUErQixDQUFDLFVBQVUsQ0FBQztZQUNwRCxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxVQUFVLENBQUMsQ0FDaEQsQ0FBQztJQUNKLENBQUMsQ0FBQztTQUNELEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQ2hCLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLG1CQUFtQixFQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUNyRTtTQUNBLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUVwQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUN4QixHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQ3RELENBQUM7SUFDRixJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNyQixPQUNFLFdBQVcsR0FBRyxTQUFTO1FBQ3ZCLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQzVFO1FBQ0EsV0FBVyxFQUFFLENBQUM7S0FDZjtJQUVELElBQUksV0FBVyxHQUFHLENBQUMsRUFBRTtRQUNuQixPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUVELE9BQU8sV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRW5DLFNBQVMsV0FBVyxDQUFDLFFBQWdCO1FBQ25DLE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7UUFDbkMsS0FDRSxJQUFJLE1BQU0sR0FBRyxRQUFRLEVBQ3JCLE1BQU0sS0FBSyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUMvQixNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFDN0I7WUFDQSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3hCO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBUyxrQkFBa0IsQ0FDekIsSUFBYSxFQUNiLFdBQTJCO0lBRTNCLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN6QyxpRUFBaUU7UUFDakUsT0FBTyxJQUFJLEtBQUssV0FBVyxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzVEO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQsS0FBSyxVQUFVLGVBQWUsQ0FDNUIsT0FBZTtJQUVmLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQ3BELElBQUksTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQ2pDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM5QjtJQUNELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDckMsSUFBSSxNQUFNLEtBQUssT0FBTyxFQUFFO1FBQ3RCLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsT0FBTyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDakMsQ0FBQztBQUVELFNBQVMsU0FBUyxDQUNoQixNQUFrQztJQUVsQyxNQUFNLEdBQUcsR0FBOEIsRUFBRSxDQUFDO0lBQzFDLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksRUFBRSxFQUFFO1FBQ2hDLElBQUksS0FBSyxDQUFDLElBQUksRUFBRTtZQUNkLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztTQUM5QjtLQUNGO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQVMsV0FBVyxDQUFDLElBQWEsRUFBRSxXQUEyQjs7SUFDN0QsT0FBTyxPQUFBLFdBQVcsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLDBDQUFFLElBQUksTUFBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQztBQUM5RSxDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQVMsc0JBQXNCLENBQUMsTUFBaUI7O0lBQy9DLE1BQU0sV0FBVyxTQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsbUNBQUksTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RSxhQUFPLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxXQUFXLENBQUMsbUNBQUksV0FBVyxDQUFDO0FBQzdELENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FDaEIsSUFBb0IsRUFDcEIsSUFBWTtJQUVaLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUMvQixJQUFJLEVBQ0osQ0FBQyxHQUFHLEVBQXNCLEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxJQUFJLENBQ3ZELENBQUM7SUFDRixPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFjRDs7OztHQUlHO0FBQ0gsU0FBUyxjQUFjLENBQUMsSUFBYSxFQUFFLFdBQTJCOztJQUNoRSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNqRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7S0FDcEI7SUFFRCxNQUFNLElBQUksU0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksMENBQUcsQ0FBQyxDQUFDLENBQUM7SUFDM0MsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQjtJQUVELElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzFCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQjtJQUVELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDL0IsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUNwRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7S0FDcEI7SUFFRCxNQUFNLElBQUksR0FBRyxFQUFFLENBQUMsb0JBQW9CLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDakQsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQjtJQUNELGFBQU8sV0FBVyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxtQ0FBSSxJQUFJLENBQUMsTUFBTSxDQUFDO0FBQzlELENBQUM7QUFFRCxNQUFNLGNBQWMsR0FBRyxJQUFJLE9BQU8sRUFBeUMsQ0FBQztBQUU1RTs7OztHQUlHO0FBQ0gsU0FBUyxhQUFhLENBQUMsR0FBa0I7SUFDdkMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QyxJQUFJLFFBQVEsRUFBRTtRQUNaLE9BQU8sUUFBUSxDQUFDO0tBQ2pCO0lBRUQsTUFBTSxHQUFHLEdBQUcsVUFBVSxFQUFFLENBQUM7SUFDekIsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDN0IsT0FBTyxHQUFHLENBQUM7SUFFWCxTQUFTLFVBQVU7O1FBQ2pCLE1BQU0sR0FBRyxHQUEyQixFQUFFLENBQUM7UUFDdkMsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLE9BQUMsR0FBRyxDQUFDLEtBQUssbUNBQUksRUFBRSxDQUFDLEVBQUU7WUFDekQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNqQixHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsQ0FBQzthQUMxQjtTQUNGO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsd0JBQXdCLENBQy9CLElBQW9CLEVBQ3BCLFdBQTJCO0lBRTNCLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDbEUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHNwZWMgZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgeyBQYWNrYWdlSnNvbiB9IGZyb20gJ0Bqc2lpL3NwZWMnO1xuaW1wb3J0ICogYXMgQ2FzZSBmcm9tICdjYXNlJztcbmltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcnMvc2FmZSc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG5pbXBvcnQgZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgbG9nNGpzIGZyb20gJ2xvZzRqcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7XG4gIGdldFJlZmVyZW5jZWREb2NQYXJhbXMsXG4gIHBhcnNlU3ltYm9sRG9jdW1lbnRhdGlvbixcbiAgcmVuZGVyU3ltYm9sRG9jdW1lbnRhdGlvbixcbiAgVHlwZVN5c3RlbUhpbnRzLFxufSBmcm9tICcuL2RvY3MnO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4vZW1pdHRlcic7XG5pbXBvcnQgeyBKc2lpRGlhZ25vc3RpYyB9IGZyb20gJy4vanNpaS1kaWFnbm9zdGljJztcbmltcG9ydCAqIGFzIGxpdGVyYXRlIGZyb20gJy4vbGl0ZXJhdGUnO1xuaW1wb3J0ICogYXMgYmluZGluZ3MgZnJvbSAnLi9ub2RlLWJpbmRpbmdzJztcbmltcG9ydCB7IFByb2plY3RJbmZvIH0gZnJvbSAnLi9wcm9qZWN0LWluZm8nO1xuaW1wb3J0IHsgaXNSZXNlcnZlZE5hbWUgfSBmcm9tICcuL3Jlc2VydmVkLXdvcmRzJztcbmltcG9ydCB7IHN5bWJvbElkZW50aWZpZXIgfSBmcm9tICcuL3N5bWJvbC1pZCc7XG5pbXBvcnQgeyBEZXByZWNhdGVkUmVtb3ZlciB9IGZyb20gJy4vdHJhbnNmb3Jtcy9kZXByZWNhdGVkLXJlbW92ZXInO1xuaW1wb3J0IHsgRGVwcmVjYXRpb25XYXJuaW5nc0luamVjdG9yIH0gZnJvbSAnLi90cmFuc2Zvcm1zL2RlcHJlY2F0aW9uLXdhcm5pbmdzJztcbmltcG9ydCB7IFJ1bnRpbWVUeXBlSW5mb0luamVjdG9yIH0gZnJvbSAnLi90cmFuc2Zvcm1zL3J1bnRpbWUtaW5mbyc7XG5pbXBvcnQgeyBUc0NvbW1lbnRSZXBsYWNlciB9IGZyb20gJy4vdHJhbnNmb3Jtcy90cy1jb21tZW50LXJlcGxhY2VyJztcbmltcG9ydCB7IGNvbWJpbmVkVHJhbnNmb3JtZXJzIH0gZnJvbSAnLi90cmFuc2Zvcm1zL3V0aWxzJztcbmltcG9ydCB7IFZhbGlkYXRvciB9IGZyb20gJy4vdmFsaWRhdG9yJztcbmltcG9ydCB7IFNIT1JUX1ZFUlNJT04sIFZFUlNJT04gfSBmcm9tICcuL3ZlcnNpb24nO1xuaW1wb3J0IHsgZW5hYmxlZFdhcm5pbmdzIH0gZnJvbSAnLi93YXJuaW5ncyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG5jb25zdCBzb3J0SnNvbiA9IHJlcXVpcmUoJ3NvcnQtanNvbicpO1xuXG5jb25zdCBMT0cgPSBsb2c0anMuZ2V0TG9nZ2VyKCdqc2lpL2Fzc2VtYmxlcicpO1xuXG4vKipcbiAqIFRoZSBKU0lJIEFzc2VtYmxlciBjb25zdW1lcyBhIGBgdHMuUHJvZ3JhbWBgIGluc3RhbmNlIGFuZCBlbWl0cyBhIEpTSUkgYXNzZW1ibHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3NlbWJsZXIgaW1wbGVtZW50cyBFbWl0dGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb21tZW50UmVwbGFjZXIgPSBuZXcgVHNDb21tZW50UmVwbGFjZXIoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBydW50aW1lVHlwZUluZm9JbmplY3RvcjogUnVudGltZVR5cGVJbmZvSW5qZWN0b3I7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVwcmVjYXRlZFJlbW92ZXI/OiBEZXByZWNhdGVkUmVtb3ZlcjtcbiAgcHJpdmF0ZSByZWFkb25seSB3YXJuaW5nc0luamVjdG9yPzogRGVwcmVjYXRpb25XYXJuaW5nc0luamVjdG9yO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbWFpbkZpbGU6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSB0c2NSb290RGlyPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgX2RpYWdub3N0aWNzID0gbmV3IEFycmF5PEpzaWlEaWFnbm9zdGljPigpO1xuICBwcml2YXRlIF9kZWZlcnJlZCA9IG5ldyBBcnJheTxEZWZlcnJlZFJlY29yZD4oKTtcbiAgcHJpdmF0ZSBfdHlwZXM6IHsgW2Zxbjogc3RyaW5nXTogc3BlYy5UeXBlIH0gPSB7fTtcblxuICAvKiogTWFwIG9mIFN5bWJvbCB0byBuYW1lc3BhY2UgZXhwb3J0IFN5bWJvbCAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9zdWJtb2R1bGVNYXAgPSBuZXcgTWFwPHRzLlN5bWJvbCwgdHMuU3ltYm9sPigpO1xuXG4gIC8qKlxuICAgKiBTdWJtb2R1bGUgaW5mb3JtYXRpb25cbiAgICpcbiAgICogQ29udGFpbnMgc3VibW9kdWxlIGluZm9ybWF0aW9uIGZvciBhbGwgbmFtZXNwYWNlcyB0aGF0IGhhdmUgYmVlbiBzZWVuXG4gICAqIGFjcm9zcyBhbGwgYXNzZW1ibGllcyAodGhpcyBhbmQgZGVwZW5kZW5jaWVzKS5cbiAgICpcbiAgICogRmlsdGVyZWQgdG8gbG9jYWwgc3VibW9kdWxlcyBvbmx5IGF0IHRpbWUgb2Ygd3JpdGluZyB0aGUgYXNzZW1ibHkgb3V0IHRvIGRpc2suXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9zdWJtb2R1bGVzID0gbmV3IE1hcDx0cy5TeW1ib2wsIFN1Ym1vZHVsZVNwZWM+KCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBwcm9qZWN0SW5mbyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFja2FnZSBiZWluZyBhc3NlbWJsZWRcbiAgICogQHBhcmFtIHByb2dyYW0gICAgIHRoZSBUeXBlU2NyaXB0IHByb2dyYW0gdG8gYmUgYXNzZW1ibGVkIGZyb21cbiAgICogQHBhcmFtIHN0ZGxpYiAgICAgIHRoZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIFR5cGVTY3JpcHQgc3RkbGliIGlzIHJvb3RlZFxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBwcm9qZWN0SW5mbzogUHJvamVjdEluZm8sXG4gICAgcHVibGljIHJlYWRvbmx5IHByb2dyYW06IHRzLlByb2dyYW0sXG4gICAgcHVibGljIHJlYWRvbmx5IHN0ZGxpYjogc3RyaW5nLFxuICAgIG9wdGlvbnM6IEFzc2VtYmxlck9wdGlvbnMgPSB7fSxcbiAgKSB7XG4gICAgaWYgKG9wdGlvbnMuc3RyaXBEZXByZWNhdGVkKSB7XG4gICAgICBsZXQgYWxsb3dsaXN0ZWREZXByZWNhdGlvbnM6IFNldDxzdHJpbmc+IHwgdW5kZWZpbmVkO1xuICAgICAgaWYgKG9wdGlvbnMuc3RyaXBEZXByZWNhdGVkQWxsb3dMaXN0RmlsZSkge1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMob3B0aW9ucy5zdHJpcERlcHJlY2F0ZWRBbGxvd0xpc3RGaWxlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAtLXN0cmlwLWRlcHJlY2F0ZWQgZmlsZSBub3QgZm91bmQ6ICR7b3B0aW9ucy5zdHJpcERlcHJlY2F0ZWRBbGxvd0xpc3RGaWxlfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhbGxvd2xpc3RlZERlcHJlY2F0aW9ucyA9IG5ldyBTZXQ8c3RyaW5nPihcbiAgICAgICAgICBmc1xuICAgICAgICAgICAgLnJlYWRGaWxlU3luYyhvcHRpb25zLnN0cmlwRGVwcmVjYXRlZEFsbG93TGlzdEZpbGUsICd1dGY4JylcbiAgICAgICAgICAgIC5zcGxpdCgnXFxuJyksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVwcmVjYXRlZFJlbW92ZXIgPSBuZXcgRGVwcmVjYXRlZFJlbW92ZXIoXG4gICAgICAgIHRoaXMuX3R5cGVDaGVja2VyLFxuICAgICAgICBhbGxvd2xpc3RlZERlcHJlY2F0aW9ucyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWRkRGVwcmVjYXRpb25XYXJuaW5ncykge1xuICAgICAgdGhpcy53YXJuaW5nc0luamVjdG9yID0gbmV3IERlcHJlY2F0aW9uV2FybmluZ3NJbmplY3RvcihcbiAgICAgICAgdGhpcy5fdHlwZUNoZWNrZXIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGR0cyA9IHByb2plY3RJbmZvLnR5cGVzO1xuICAgIGxldCBtYWluRmlsZSA9IGR0cy5yZXBsYWNlKC9cXC5kXFwudHMoeD8pJC8sICcudHMkMScpO1xuXG4gICAgLy8gSWYgb3V0LW9mLXNvdXJjZSBidWlsZCB3YXMgY29uZmlndXJlZCAodHNjJ3Mgb3V0RGlyIGFuZCByb290RGlyKSwgdGhlXG4gICAgLy8gbWFpbiBmaWxlJ3MgcGF0aCBuZWVkcyB0byBiZSByZS1yb290ZWQgZnJvbSB0aGUgb3V0RGlyIGludG8gdGhlIHJvb3REaXIuXG4gICAgY29uc3QgdHNjT3V0RGlyID0gcHJvZ3JhbS5nZXRDb21waWxlck9wdGlvbnMoKS5vdXREaXI7XG4gICAgaWYgKHRzY091dERpciAhPSBudWxsKSB7XG4gICAgICBtYWluRmlsZSA9IHBhdGgucmVsYXRpdmUodHNjT3V0RGlyLCBtYWluRmlsZSk7XG5cbiAgICAgIC8vIHJvb3REaXIgbWF5IGJlIHNldCBleHBsaWNpdGx5IG9yIG5vdC4gSWYgbm90LCBpbmZlclJvb3REaXIgcmVwbGljYXRlc1xuICAgICAgLy8gdHNjJ3MgYmVoYXZpb3Igb2YgdXNpbmcgdGhlIGxvbmdlc3QgcHJlZml4IG9mIGFsbCBidWlsdCBzb3VyY2UgZmlsZXMuXG4gICAgICB0aGlzLnRzY1Jvb3REaXIgPVxuICAgICAgICBwcm9ncmFtLmdldENvbXBpbGVyT3B0aW9ucygpLnJvb3REaXIgPz8gaW5mZXJSb290RGlyKHByb2dyYW0pO1xuICAgICAgaWYgKHRoaXMudHNjUm9vdERpciAhPSBudWxsKSB7XG4gICAgICAgIG1haW5GaWxlID0gcGF0aC5qb2luKHRoaXMudHNjUm9vdERpciwgbWFpbkZpbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWFpbkZpbGUgPSBwYXRoLnJlc29sdmUocHJvamVjdEluZm8ucHJvamVjdFJvb3QsIG1haW5GaWxlKTtcbiAgICB0aGlzLnJ1bnRpbWVUeXBlSW5mb0luamVjdG9yID0gbmV3IFJ1bnRpbWVUeXBlSW5mb0luamVjdG9yKFxuICAgICAgcHJvamVjdEluZm8udmVyc2lvbixcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCBjdXN0b21UcmFuc2Zvcm1lcnMoKTogdHMuQ3VzdG9tVHJhbnNmb3JtZXJzIHtcbiAgICByZXR1cm4gY29tYmluZWRUcmFuc2Zvcm1lcnMoXG4gICAgICB0aGlzLmRlcHJlY2F0ZWRSZW1vdmVyPy5jdXN0b21UcmFuc2Zvcm1lcnMgPz8ge30sXG4gICAgICB0aGlzLnJ1bnRpbWVUeXBlSW5mb0luamVjdG9yLm1ha2VUcmFuc2Zvcm1lcnMoKSxcbiAgICAgIHRoaXMuY29tbWVudFJlcGxhY2VyLm1ha2VUcmFuc2Zvcm1lcnMoKSxcbiAgICAgIHRoaXMud2FybmluZ3NJbmplY3Rvcj8uY3VzdG9tVHJhbnNmb3JtZXJzID8/IHt9LFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldCBfdHlwZUNoZWNrZXIoKTogdHMuVHlwZUNoZWNrZXIge1xuICAgIHJldHVybiB0aGlzLnByb2dyYW0uZ2V0VHlwZUNoZWNrZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IGVtaXR0aW5nIHRoZSBKU0lJIGFzc2VtYmx5IGZvciB0aGUgcHJvZ3JhbS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBhc3NlbWJseSBlbWlzc2lvbi5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBlbWl0KCk6IFByb21pc2U8dHMuRW1pdFJlc3VsdD4ge1xuICAgIHRoaXMuX2RpYWdub3N0aWNzID0gW107XG4gICAgaWYgKCF0aGlzLnByb2plY3RJbmZvLmRlc2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzAwMDFfUEtHX01JU1NJTkdfREVTQ1JJUFRJT04uY3JlYXRlRGV0YWNoZWQoKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcm9qZWN0SW5mby5ob21lcGFnZSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8wMDAyX1BLR19NSVNTSU5HX0hPTUVQQUdFLmNyZWF0ZURldGFjaGVkKCksXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZWFkbWUgPSBhd2FpdCBfbG9hZFJlYWRtZS5jYWxsKHRoaXMpO1xuICAgIGlmIChyZWFkbWUgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8wMDAzX01JU1NJTkdfUkVBRE1FLmNyZWF0ZURldGFjaGVkKCksXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkb2NzID0gX2xvYWREb2NzLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl90eXBlcyA9IHt9O1xuICAgIHRoaXMuX2RlZmVycmVkID0gW107XG4gICAgY29uc3QgdmlzaXRQcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XG5cbiAgICBjb25zdCBzb3VyY2VGaWxlID0gdGhpcy5wcm9ncmFtLmdldFNvdXJjZUZpbGUodGhpcy5tYWluRmlsZSk7XG5cbiAgICBpZiAoc291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzAwMDRfQ09VTERfTk9UX0ZJTkRfRU5UUllQT0lOVC5jcmVhdGVEZXRhY2hlZChcbiAgICAgICAgICB0aGlzLm1haW5GaWxlLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy5fcmVnaXN0ZXJEZXBlbmRlbmNpZXNOYW1lc3BhY2VzKHNvdXJjZUZpbGUpO1xuXG4gICAgICBpZiAoTE9HLmlzVHJhY2VFbmFibGVkKCkpIHtcbiAgICAgICAgTE9HLnRyYWNlKFxuICAgICAgICAgIGBQcm9jZXNzaW5nIHNvdXJjZSBmaWxlOiAke2NvbG9ycy5ibHVlKFxuICAgICAgICAgICAgcGF0aC5yZWxhdGl2ZSh0aGlzLnByb2plY3RJbmZvLnByb2plY3RSb290LCBzb3VyY2VGaWxlLmZpbGVOYW1lKSxcbiAgICAgICAgICApfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBzeW1ib2wgPSB0aGlzLl90eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICBjb25zdCBtb2R1bGVFeHBvcnRzID0gdGhpcy5fdHlwZUNoZWNrZXIuZ2V0RXhwb3J0c09mTW9kdWxlKHN5bWJvbCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIG1vZHVsZUV4cG9ydHMubWFwKChpdGVtKSA9PlxuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJOYW1lc3BhY2VzKGl0ZW0sIHRoaXMucHJvamVjdEluZm8ucHJvamVjdFJvb3QpLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgICAgdmlzaXRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5fdmlzaXROb2RlKFxuICAgICAgICAgICAgICBub2RlLmRlY2xhcmF0aW9uc1swXSxcbiAgICAgICAgICAgICAgbmV3IEVtaXRDb250ZXh0KFtdLCB0aGlzLnByb2plY3RJbmZvLnN0YWJpbGl0eSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbCh2aXNpdFByb21pc2VzKTtcblxuICAgIHRoaXMuY2FsbERlZmVycmVkc0luT3JkZXIoKTtcblxuICAgIC8vIFNraXAgZW1pdHRpbmcgaWYgYW55IGRpYWdub3N0aWMgbWVzc2FnZSBpcyBhbiBlcnJvclxuICAgIGlmIChcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLmZpbmQoXG4gICAgICAgIChkaWFnKSA9PiBkaWFnLmNhdGVnb3J5ID09PSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IsXG4gICAgICApICE9IG51bGxcbiAgICApIHtcbiAgICAgIExPRy5kZWJ1ZygnU2tpcHBpbmcgZW1pdCBkdWUgdG8gZXJyb3JzLicpO1xuICAgICAgLy8gQ2xlYXJpbmcgYGB0aGlzLl90eXBlc2BgIHRvIGFsbG93IGNvbnRlbnRzIHRvIGJlIGdhcmJhZ2UtY29sbGVjdGVkLlxuICAgICAgZGVsZXRlIHRoaXMuX3R5cGVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgZGlhZ25vc3RpY3M6IHRoaXMuX2RpYWdub3N0aWNzLCBlbWl0U2tpcHBlZDogdHJ1ZSB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gQ2xlYXJpbmcgYGB0aGlzLl9kaWFnbm9zdGljc2BgIHRvIGFsbG93IGNvbnRlbnRzIHRvIGJlIGdhcmJhZ2UtY29sbGVjdGVkLlxuICAgICAgICBkZWxldGUgdGhpcy5fZGlhZ25vc3RpY3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QganNpaVZlcnNpb24gPVxuICAgICAgdGhpcy5wcm9qZWN0SW5mby5qc2lpVmVyc2lvbkZvcm1hdCA9PT0gJ3Nob3J0JyA/IFNIT1JUX1ZFUlNJT04gOiBWRVJTSU9OO1xuXG4gICAgY29uc3QgYXNzZW1ibHk6IHNwZWMuQXNzZW1ibHkgPSB7XG4gICAgICBzY2hlbWE6IHNwZWMuU2NoZW1hVmVyc2lvbi5MQVRFU1QsXG4gICAgICBuYW1lOiB0aGlzLnByb2plY3RJbmZvLm5hbWUsXG4gICAgICB2ZXJzaW9uOiB0aGlzLnByb2plY3RJbmZvLnZlcnNpb24sXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5wcm9qZWN0SW5mby5kZXNjcmlwdGlvbiA/PyB0aGlzLnByb2plY3RJbmZvLm5hbWUsXG4gICAgICBsaWNlbnNlOiB0aGlzLnByb2plY3RJbmZvLmxpY2Vuc2UsXG4gICAgICBrZXl3b3JkczogdGhpcy5wcm9qZWN0SW5mby5rZXl3b3JkcyxcbiAgICAgIGhvbWVwYWdlOiB0aGlzLnByb2plY3RJbmZvLmhvbWVwYWdlID8/IHRoaXMucHJvamVjdEluZm8ucmVwb3NpdG9yeS51cmwsXG4gICAgICBhdXRob3I6IHRoaXMucHJvamVjdEluZm8uYXV0aG9yLFxuICAgICAgY29udHJpYnV0b3JzOiB0aGlzLnByb2plY3RJbmZvLmNvbnRyaWJ1dG9ycyAmJiBbXG4gICAgICAgIC4uLnRoaXMucHJvamVjdEluZm8uY29udHJpYnV0b3JzLFxuICAgICAgXSxcbiAgICAgIHJlcG9zaXRvcnk6IHRoaXMucHJvamVjdEluZm8ucmVwb3NpdG9yeSxcbiAgICAgIGRlcGVuZGVuY2llczogbm9FbXB0eURpY3Qoe1xuICAgICAgICAuLi50aGlzLnByb2plY3RJbmZvLmRlcGVuZGVuY2llcyxcbiAgICAgICAgLi4udGhpcy5wcm9qZWN0SW5mby5wZWVyRGVwZW5kZW5jaWVzLFxuICAgICAgfSksXG4gICAgICBkZXBlbmRlbmN5Q2xvc3VyZTogbm9FbXB0eURpY3QoXG4gICAgICAgIHRvRGVwZW5kZW5jeUNsb3N1cmUodGhpcy5wcm9qZWN0SW5mby5kZXBlbmRlbmN5Q2xvc3VyZSksXG4gICAgICApLFxuICAgICAgYnVuZGxlZDogdGhpcy5wcm9qZWN0SW5mby5idW5kbGVEZXBlbmRlbmNpZXMsXG4gICAgICB0eXBlczogdGhpcy5fdHlwZXMsXG4gICAgICBzdWJtb2R1bGVzOiBub0VtcHR5RGljdCh0b1N1Ym1vZHVsZURlY2xhcmF0aW9ucyh0aGlzLm15U3VibW9kdWxlcygpKSksXG4gICAgICB0YXJnZXRzOiB0aGlzLnByb2plY3RJbmZvLnRhcmdldHMsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICAuLi50aGlzLnByb2plY3RJbmZvLm1ldGFkYXRhLFxuXG4gICAgICAgIC8vIERvd25zdHJlYW0gY29uc3VtZXJzIG5lZWQgdGhpcyB0byBtYXAgYSBzeW1ib2xJZCBpbiB0aGUgb3V0RGlyIHRvIGFcbiAgICAgICAgLy8gc3ltYm9sSWQgaW4gdGhlIHJvb3REaXIuXG4gICAgICAgIHRzY1Jvb3REaXI6IHRoaXMudHNjUm9vdERpcixcbiAgICAgIH0sXG4gICAgICBkb2NzLFxuICAgICAgcmVhZG1lLFxuICAgICAganNpaVZlcnNpb24sXG4gICAgICBiaW46IHRoaXMucHJvamVjdEluZm8uYmluLFxuICAgICAgZmluZ2VycHJpbnQ6ICc8VEJEPicsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmRlcHJlY2F0ZWRSZW1vdmVyKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKC4uLnRoaXMuZGVwcmVjYXRlZFJlbW92ZXIucmVtb3ZlRnJvbShhc3NlbWJseSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndhcm5pbmdzSW5qZWN0b3IpIHtcbiAgICAgIGNvbnN0IGpzaWlNZXRhZGF0YSA9IHtcbiAgICAgICAgLi4uKGFzc2VtYmx5Lm1ldGFkYXRhPy5qc2lpID8/IHt9KSxcbiAgICAgICAgLi4ueyBjb21waWxlZFdpdGhEZXByZWNhdGlvbldhcm5pbmdzOiB0cnVlIH0sXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXNzZW1ibHkubWV0YWRhdGEpIHtcbiAgICAgICAgYXNzZW1ibHkubWV0YWRhdGEuanNpaSA9IGpzaWlNZXRhZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VtYmx5Lm1ldGFkYXRhID0geyBqc2lpOiBqc2lpTWV0YWRhdGEgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybmluZ3NJbmplY3Rvci5wcm9jZXNzKGFzc2VtYmx5LCB0aGlzLnByb2plY3RJbmZvKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHRoaXMucHJvamVjdEluZm8sIGFzc2VtYmx5KTtcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgdmFsaWRhdG9yLmVtaXQoKTtcbiAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuZW1pdFNraXBwZWQpIHtcbiAgICAgIGNvbnN0IGFzc2VtYmx5UGF0aCA9IHBhdGguam9pbih0aGlzLnByb2plY3RJbmZvLnByb2plY3RSb290LCAnLmpzaWknKTtcbiAgICAgIExPRy50cmFjZShgRW1pdHRpbmcgYXNzZW1ibHk6ICR7Y29sb3JzLmJsdWUoYXNzZW1ibHlQYXRoKX1gKTtcbiAgICAgIGF3YWl0IGZzLndyaXRlSnNvbihhc3NlbWJseVBhdGgsIF9maW5nZXJwcmludChhc3NlbWJseSksIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgc3BhY2VzOiAyLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpYWdub3N0aWNzOiBbLi4udGhpcy5fZGlhZ25vc3RpY3MsIC4uLnZhbGlkYXRpb25SZXN1bHQuZGlhZ25vc3RpY3NdLFxuICAgICAgICBlbWl0U2tpcHBlZDogdmFsaWRhdGlvblJlc3VsdC5lbWl0U2tpcHBlZCxcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyaW5nIGBgdGhpcy5fdHlwZXNgYCB0byBhbGxvdyBjb250ZW50cyB0byBiZSBnYXJiYWdlLWNvbGxlY3RlZC5cbiAgICAgIGRlbGV0ZSB0aGlzLl90eXBlcztcblxuICAgICAgLy8gQ2xlYXJpbmcgYGB0aGlzLl9kaWFnbm9zdGljc2BgIHRvIGFsbG93IGNvbnRlbnRzIHRvIGJlIGdhcmJhZ2UtY29sbGVjdGVkLlxuICAgICAgZGVsZXRlIHRoaXMuX2RpYWdub3N0aWNzO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9sb2FkUmVhZG1lKHRoaXM6IEFzc2VtYmxlcikge1xuICAgICAgLy8gU2VhcmNoIGZvciBgUkVBRE1FLm1kYCBpbiBhIGNhc2UtaW5zZW5zaXRpdmUgd2F5XG4gICAgICBjb25zdCBmaWxlTmFtZSA9IChhd2FpdCBmcy5yZWFkZGlyKHRoaXMucHJvamVjdEluZm8ucHJvamVjdFJvb3QpKS5maW5kKFxuICAgICAgICAoZmlsZSkgPT4gZmlsZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSAncmVhZG1lLm1kJyxcbiAgICAgICk7XG4gICAgICBpZiAoZmlsZU5hbWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhZG1lUGF0aCA9IHBhdGguam9pbih0aGlzLnByb2plY3RJbmZvLnByb2plY3RSb290LCBmaWxlTmFtZSk7XG4gICAgICBjb25zdCByZW5kZXJlZExpbmVzID0gYXdhaXQgbGl0ZXJhdGUuaW5jbHVkZUFuZFJlbmRlckV4YW1wbGVzKFxuICAgICAgICBhd2FpdCBsaXRlcmF0ZS5sb2FkRnJvbUZpbGUocmVhZG1lUGF0aCksXG4gICAgICAgIGxpdGVyYXRlLmZpbGVTeXN0ZW1Mb2FkZXIodGhpcy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdCksXG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgbWFya2Rvd246IHJlbmRlcmVkTGluZXMuam9pbignXFxuJykgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbG9hZERvY3ModGhpczogQXNzZW1ibGVyKTogc3BlYy5Eb2NzIHwgdW5kZWZpbmVkIHtcbiAgICAgIGlmICghdGhpcy5wcm9qZWN0SW5mby5zdGFiaWxpdHkgJiYgIXRoaXMucHJvamVjdEluZm8uZGVwcmVjYXRlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVwcmVjYXRlZCA9IHRoaXMucHJvamVjdEluZm8uZGVwcmVjYXRlZDtcbiAgICAgIGNvbnN0IHN0YWJpbGl0eSA9IHRoaXMucHJvamVjdEluZm8uc3RhYmlsaXR5O1xuICAgICAgcmV0dXJuIHsgZGVwcmVjYXRlZCwgc3RhYmlsaXR5IH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmVyIGEgY2FsbGJhY2sgdW50aWwgYSAoc2V0IG9mKSB0eXBlcyBhcmUgYXZhaWxhYmxlXG4gICAqXG4gICAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gYXJvdW5kIF9kZWZlcigpIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgX2RlcmVmZXJlbmNlXG4gICAqIGFjdGlvbiAod2hpY2ggaXMgYmFzaWNhbGx5IHRoZSBtYWpvcml0eSB1c2UgY2FzZSBmb3IgX2RlZmVyIGFueXdheSkuXG4gICAqXG4gICAqIFdpbGwgbm90IGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCBhbnkgJ3VuZGVmaW5lZCdzOyBhbiBlcnJvciB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGVtaXR0ZWQgaW5cbiAgICogdGhhdCBjYXNlIGFueXdheS5cbiAgICpcbiAgICogQHBhcmFtIGZxbiBGUU4gb2YgdGhlIGN1cnJlbnQgdHlwZSAodGhlIHR5cGUgdGhhdCBoYXMgYSBkZXBlbmRlbmN5IG9uIGJhc2VUeXBlcylcbiAgICogQHBhcmFtIGJhc2VUeXBlcyBBcnJheSBvZiB0eXBlIHJlZmVyZW5jZXMgdG8gYmUgbG9va2VkIHVwXG4gICAqIEBwYXJhbSByZWZlcmVuY2luZ05vZGUgTm9kZSB0byByZXBvcnQgYSBkaWFnbm9zdGljIG9uIGlmIHdlIGZhaWwgdG8gbG9vayB1cCBhIHQgeXBlXG4gICAqIEBwYXJhbSBjYiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdpdGggdGhlIFR5cGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIFR5cGVSZWZlcmVuY2VzIGluIGJhc2VUeXBlc1xuICAgKi9cbiAgcHJpdmF0ZSBfZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKFxuICAgIGZxbjogc3RyaW5nLFxuICAgIGJhc2VUeXBlczogQXJyYXk8c3RyaW5nIHwgc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2U+LFxuICAgIHJlZmVyZW5jaW5nTm9kZTogdHMuTm9kZSxcbiAgICBjYjogKC4uLnhzOiBzcGVjLlR5cGVbXSkgPT4gdm9pZCxcbiAgKSB7XG4gICAgLy8gV2UgY2FuIGRvIHRoaXMgb25lIGVhZ2VybHlcbiAgICBpZiAoYmFzZVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmFzZUZxbnMgPSBiYXNlVHlwZXMubWFwKChidCkgPT5cbiAgICAgIHR5cGVvZiBidCA9PT0gJ3N0cmluZycgPyBidCA6IGJ0LmZxbixcbiAgICApO1xuXG4gICAgdGhpcy5fZGVmZXIoZnFuLCBiYXNlRnFucywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSBiYXNlRnFuc1xuICAgICAgICAubWFwKCh4KSA9PiB0aGlzLl9kZXJlZmVyZW5jZSh4LCByZWZlcmVuY2luZ05vZGUpKVxuICAgICAgICAuZmlsdGVyKCh4KSA9PiB4ICE9PSB1bmRlZmluZWQpO1xuICAgICAgaWYgKHJlc29sdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2IoLi4uKHJlc29sdmVkIGFzIHNwZWMuVHlwZVtdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmZXIgY2hlY2tzIGZvciBhZnRlciB0aGUgcHJvZ3JhbSBoYXMgYmVlbiBlbnRpcmVseSBwcm9jZXNzZWQ7IHVzZWZ1bCBmb3IgdmVyaWZ5aW5nIHR5cGUgcmVmZXJlbmNlcyB0aGF0IG1heSBub3RcbiAgICogaGF2ZSBiZWVuIGRpc2NvdmVyZWQgeWV0LCBhbmQgdmVyaWZ5aW5nIHByb3BlcnRpZXMgYWJvdXQgdGhlbS5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGd1YXJhbnRlZWQgdG8gYmUgZXhlY3V0ZWQgb25seSBhZnRlciBhbGwgZGVmZXJyZWRzIGZvciBhbGwgdHlwZXMgaW4gJ2RlcGVuZGVkRnFucycgaGF2ZVxuICAgKiBiZWVuIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZnFuIEZRTiBvZiB0aGUgY3VycmVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGVwZW5kZWRGcW5zIExpc3Qgb2YgRlFOcyBvZiB0eXBlcyB0aGlzIGNhbGxiYWNrIGRlcGVuZHMgb24uIEFsbCBkZWZlcnJlZHMgZm9yIGFsbFxuICAgKiBAcGFyYW0gY2IgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBhIGRlZmVycmVkIHdheS4gSXQgd2lsbCBiZSBib3VuZCB3aXRoIGBgdGhpc2BgLCBzbyBpdCBjYW4gZGVwZW5kIG9uIHVzaW5nXG4gICAqICAgICAgICAgICBgYHRoaXNgYC5cbiAgICovXG4gIHByaXZhdGUgX2RlZmVyKGZxbjogc3RyaW5nLCBkZXBlbmRlZEZxbnM6IHN0cmluZ1tdLCBjYjogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMuX2RlZmVycmVkLnB1c2goeyBmcW4sIGRlcGVuZGVkRnFucywgY2I6IGNiLmJpbmQodGhpcykgfSk7XG4gIH1cblxuICAvKipcbiAgICogT2J0YWlucyB0aGUgYGBzcGVjLlR5cGVgYCBmb3IgYSBnaXZlbiBgYHNwZWMuTmFtZWRUeXBlUmVmZXJlbmNlYGAuXG4gICAqXG4gICAqIEBwYXJhbSByZWYgdGhlIHR5cGUgcmVmZXJlbmNlIHRvIGJlIGRlLXJlZmVyZW5jZWRcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGRlLXJlZmVyZW5jZWQgdHlwZSwgaWYgaXQgd2FzIGZvdW5kLCBvdGhlcndpc2UgYGB1bmRlZmluZWRgYC5cbiAgICovXG4gIHByaXZhdGUgX2RlcmVmZXJlbmNlKFxuICAgIHJlZjogc3RyaW5nIHwgc3BlYy5OYW1lZFR5cGVSZWZlcmVuY2UsXG4gICAgcmVmZXJlbmNpbmdOb2RlOiB0cy5Ob2RlIHwgdW5kZWZpbmVkLFxuICApOiBzcGVjLlR5cGUgfCB1bmRlZmluZWQge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSAnc3RyaW5nJykge1xuICAgICAgcmVmID0gcmVmLmZxbjtcbiAgICB9XG5cbiAgICBjb25zdCBbYXNzbV0gPSByZWYuc3BsaXQoJy4nKTtcbiAgICBsZXQgdHlwZTtcbiAgICBpZiAoYXNzbSA9PT0gdGhpcy5wcm9qZWN0SW5mby5uYW1lKSB7XG4gICAgICB0eXBlID0gdGhpcy5fdHlwZXNbcmVmXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXNzZW1ibHkgPSB0aGlzLnByb2plY3RJbmZvLmRlcGVuZGVuY3lDbG9zdXJlLmZpbmQoXG4gICAgICAgIChkZXApID0+IGRlcC5uYW1lID09PSBhc3NtLFxuICAgICAgKTtcbiAgICAgIHR5cGUgPSBhc3NlbWJseT8udHlwZXM/LltyZWZdO1xuXG4gICAgICAvLyBzaW5jZSB3ZSBhcmUgZXhwb3NpbmcgYSB0eXBlIG9mIHRoaXMgYXNzZW1ibHkgaW4gdGhpcyBtb2R1bGUncyBwdWJsaWMgQVBJLFxuICAgICAgLy8gd2UgZXhwZWN0IGl0IHRvIGFwcGVhciBhcyBhIHBlZXIgZGVwZW5kZW5jeSBpbnN0ZWFkIG9mIGEgbm9ybWFsIGRlcGVuZGVuY3kuXG4gICAgICBpZiAoYXNzZW1ibHkpIHtcbiAgICAgICAgaWYgKCEoYXNzZW1ibHkubmFtZSBpbiB0aGlzLnByb2plY3RJbmZvLnBlZXJEZXBlbmRlbmNpZXMpKSB7XG4gICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMDAwNV9NSVNTSU5HX1BFRVJfREVQRU5ERU5DWS5jcmVhdGUoXG4gICAgICAgICAgICAgIHJlZmVyZW5jaW5nTm9kZSEsIC8vIENoZWF0aW5nIGhlcmUgZm9yIG5vdywgdW50aWwgdGhlIHJlZmVyZW5jaW5nTm9kZSBjYW4gYmUgbWFkZSByZXF1aXJlZFxuICAgICAgICAgICAgICBhc3NlbWJseS5uYW1lLFxuICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfOTAwMl9VTlJFU09MVkVBQkxFX1RZUEUuY3JlYXRlKFxuICAgICAgICAgIHJlZmVyZW5jaW5nTm9kZSEsIC8vIENoZWF0aW5nIGhlcmUgZm9yIG5vdywgdW50aWwgdGhlIHJlZmVyZW5jaW5nTm9kZSBjYW4gYmUgbWFkZSByZXF1aXJlZFxuICAgICAgICAgIHJlZixcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgSlNJSSBmdWxseSBxdWFsaWZpZWQgbmFtZSBjb3JyZXNwb25kaW5nIHRvIGEgYGB0cy5UeXBlYGAgaW5zdGFuY2UuIElmIGZvciBhbnkgcmVhc29uIGEgbmFtZSBjYW5ub3QgYmVcbiAgICogY29tcHV0ZWQgZm9yIHRoZSB0eXBlLCBhIG1hcmtlciBpcyByZXR1cm5lZCBpbnN0ZWFkLCBhbmQgYW4gYGB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3JgYCBkaWFnbm9zdGljIGlzXG4gICAqIGluc2VydGVkIGluIHRoZSBhc3NlbWJsZXIgY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgZm9yIHdoaWNoIGEgSlNJSSBmdWxseSBxdWFsaWZpZWQgbmFtZSBpcyBuZWVkZWQuXG4gICAqIEBwYXJhbSB0eXBlQW5ub3RhdGlvbk5vZGUgdGhlIHR5cGUgYW5ub3RhdGlvbiBmb3Igd2hpY2ggdGhpcyBGUU4gaXMgZ2VuZXJhdGVkLiBUaGlzIGlzIHVzZWQgZm9yIGF0dGFjaGluZyB0aGUgZXJyb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIuIFdoZW4gdGhlcmUgaXMgbm8gZXhwbGljaXQgdHlwZSBhbm5vdGF0aW9uIChlLmc6IGluZmVycmVkIG1ldGhvZCByZXR1cm4gdHlwZSksIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZCBzdWJzdGl0dXRlIGlzIHRoZSBcInR5cGUtaW5mZXJyZWRcIiBlbGVtZW50J3MgbmFtZS5cbiAgICogQHBhcmFtIHR5cGVVc2UgdGhlIHJlYXNvbiB3aHkgdGhpcyB0eXBlIHdhcyByZXNvbHZlZCAoZS5nOiBcInJldHVybiB0eXBlXCIpXG4gICAqIEBwYXJhbSBpc1RoaXNUeXBlIHdoZXRoZXIgdGhpcyB0eXBlIHdhcyBzcGVjaWZpZWQgb3IgaW5mZXJyZWQgYXMgXCJ0aGlzXCIgb3Igbm90XG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBGUU4gb2YgdGhlIHR5cGUsIG9yIHNvbWUgXCJ1bmtub3duXCIgbWFya2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0RlFOKFxuICAgIHR5cGU6IHRzLlR5cGUsXG4gICAgdHlwZUFubm90YXRpb25Ob2RlOiB0cy5Ob2RlLFxuICAgIHR5cGVVc2U6IFR5cGVVc2VLaW5kLFxuICAgIGlzVGhpc1R5cGU6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgc3ltID0gc3ltYm9sRnJvbVR5cGUodHlwZSwgdGhpcy5fdHlwZUNoZWNrZXIpO1xuXG4gICAgY29uc3QgdHlwZURlY2xhcmF0aW9uID0gc3ltLnZhbHVlRGVjbGFyYXRpb24gPz8gc3ltLmRlY2xhcmF0aW9ucz8uWzBdO1xuXG4gICAgLy8gU2V0IHRvIHRydWUgdG8gcHJldmVudCBmdXJ0aGVyIGFkZGluZyBvZiBFcnJvciBkaWFnbm9zdGljcyBmb3Iga25vd24tYmFkIHJlZmVyZW5jZVxuICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuX2lzUHJpdmF0ZU9ySW50ZXJuYWwoc3ltKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyB0eXBlIGlzIFwidGhpc1wiIChleHBsaWNpdCBvciBpbmZlcnJlZCBtZXRob2QgcmV0dXJuIHR5cGUpLlxuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDAxX0VYUE9TRURfSU5URVJOQUxfVFlQRS5jcmVhdGUoXG4gICAgICAgICAgdHlwZUFubm90YXRpb25Ob2RlLFxuICAgICAgICAgIHN5bSxcbiAgICAgICAgICBpc1RoaXNUeXBlLFxuICAgICAgICAgIHR5cGVVc2UsXG4gICAgICAgICkuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgIHR5cGVEZWNsYXJhdGlvbixcbiAgICAgICAgICBgVGhlIHJlZmVyZW5jZWQgdHlwZSBpcyBkZWNsYXJlZCBoZXJlYCxcbiAgICAgICAgKSxcbiAgICAgICk7XG5cbiAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0c05hbWUgPSB0aGlzLl90eXBlQ2hlY2tlci5nZXRGdWxseVF1YWxpZmllZE5hbWUoc3ltKTtcbiAgICBjb25zdCBncm91cHMgPSAvXlwiKFteXCJdKylcIlxcLiguKikkLy5leGVjKHRzTmFtZSk7XG4gICAgaWYgKCFncm91cHMpIHtcbiAgICAgIGlmICghaGFzRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzMwMDFfRVhQT1NFRF9JTlRFUk5BTF9UWVBFLmNyZWF0ZShcbiAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uTm9kZSxcbiAgICAgICAgICAgIHN5bSxcbiAgICAgICAgICAgIGlzVGhpc1R5cGUsXG4gICAgICAgICAgICB0eXBlVXNlLFxuICAgICAgICAgICkuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgICAgdHlwZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgYFRoZSByZWZlcmVuY2VkIHR5cGUgaXMgZGVjbGFyZWQgaGVyZWAsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRzTmFtZTtcbiAgICB9XG4gICAgY29uc3QgWywgbW9kdWxlUGF0aCwgdHlwZU5hbWVdID0gZ3JvdXBzO1xuICAgIGNvbnN0IHBrZyA9IGF3YWl0IGZpbmRQYWNrYWdlSW5mbyhtb2R1bGVQYXRoKTtcbiAgICBpZiAoIXBrZykge1xuICAgICAgaWYgKCFoYXNFcnJvcikge1xuICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfOTAwM19VTlJFU09MVkVBQkxFX01PRFVMRS5jcmVhdGUoXG4gICAgICAgICAgICB0eXBlQW5ub3RhdGlvbk5vZGUsXG4gICAgICAgICAgICBtb2R1bGVQYXRoLFxuICAgICAgICAgICkuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgICAgdHlwZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgYFRoZSByZWZlcmVuY2VkIHR5cGUgaXMgZGVjbGFyZWQgaGVyZWAsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGB1bmtub3duLiR7dHlwZU5hbWV9YDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc3ltYm9sIGNvbWVzIGZyb20gdGhlIGN1cnJlbnQgYXNzZW1ibHkgb3IgYW4gYXNzZW1ibHkgd2hvc2VcbiAgICAvLyBzdWJtb2R1bGVzIHdlJ3ZlIGFscmVhZHkgc3BpZGVyZWQsIGxvb2sgdXAgaW4gdGhlIHRhYmxlcyB3ZSBhcmUgY3VycmVudGx5IGJ1aWxkaW5nXG4gICAgaWYgKHBrZy5uYW1lID09PSB0aGlzLnByb2plY3RJbmZvLm5hbWUpIHtcbiAgICAgIGNvbnN0IHN1Ym1vZHVsZSA9IHRoaXMuX3N1Ym1vZHVsZU1hcC5nZXQoc3ltKTtcbiAgICAgIGlmIChzdWJtb2R1bGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdWJtb2R1bGVOcyA9XG4gICAgICAgICAgdGhpcy5fc3VibW9kdWxlcy5nZXQoc3VibW9kdWxlKSEuZnFuUmVzb2x1dGlvblByZWZpeDtcbiAgICAgICAgcmV0dXJuIGAke3N1Ym1vZHVsZU5zfS4ke3R5cGVOYW1lfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLnByb2plY3RJbmZvLm5hbWV9LiR7dHlwZU5hbWV9YDtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBmYWxsYmFjazogaW4gY2FzZSB3ZSBjYW4ndCBmaW5kIGEgc3ltYm9sSWQgZm9yIHRoZSBnaXZlblxuICAgIC8vIHR5cGUsIHdlJ3JlIHJldHVybiB0aGlzIHZhbHVlLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoXG4gICAgLy8gbW9kdWxlcyB0aGF0IGhhdmVuJ3QgYmVlbiBjb21waWxlZCB0byBoYXZlIHN5bWJvbElkIHN1cHBvcnQuIFRob3NlIGFsc29cbiAgICAvLyBtb3N0IGxpa2VseSB3b24ndCBiZSB1c2luZyBzdWJtb2R1bGVzIHNvIHRoaXMgbGVnYWN5IGd1ZXNzIHdpbGwgYmUgY29ycmVjdC5cbiAgICBjb25zdCBmYWxsYmFja0ZxbiA9IGAke3BrZy5uYW1lfS4ke3R5cGVOYW1lfWA7XG5cbiAgICAvLyBPdGhlcndpc2UgbG9vayB1cCB0aGUgc3ltYm9sIGlkZW50aWZpZXIgaW4gdGhlIGRlcGVuZGVuY3kgYXNzZW1ibGllc1xuICAgIGNvbnN0IGRlcCA9IHRoaXMucHJvamVjdEluZm8uZGVwZW5kZW5jeUNsb3N1cmUuZmluZChcbiAgICAgIChkKSA9PiBkLm5hbWUgPT09IHBrZy5uYW1lLFxuICAgICk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfOTAwMF9VTktOT1dOX01PRFVMRS5jcmVhdGVEZXRhY2hlZChwa2cubmFtZSksXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrRnFuO1xuICAgIH1cbiAgICBjb25zdCBzeW1ib2xJZCA9IHN5bWJvbElkZW50aWZpZXIodGhpcy5fdHlwZUNoZWNrZXIsIHN5bSwge1xuICAgICAgYXNzZW1ibHk6IGRlcCxcbiAgICB9KTtcbiAgICBjb25zdCBmcW4gPVxuICAgICAgKGRlcCAmJiBzeW1ib2xJZCA/IHN5bWJvbElkSW5kZXgoZGVwKVtzeW1ib2xJZF0gOiB1bmRlZmluZWQpID8/XG4gICAgICBmYWxsYmFja0ZxbjtcblxuICAgIGlmICghZnFuIHx8ICF0aGlzLl9kZXJlZmVyZW5jZSh7IGZxbiB9LCBzeW0udmFsdWVEZWNsYXJhdGlvbikpIHtcbiAgICAgIGlmICghaGFzRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzMwMDJfVVNFX09GX1VORVhQT1JURURfRk9SRUlHTl9UWVBFLmNyZWF0ZShcbiAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uTm9kZSxcbiAgICAgICAgICAgIGZxbiA/PyB0c05hbWUsXG4gICAgICAgICAgICB0eXBlVXNlLFxuICAgICAgICAgICAgcGtnLFxuICAgICAgICAgICkuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgICAgdHlwZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgYFRoZSByZWZlcmVuY2VkIHR5cGUgaXMgZGVjbGFyZWQgaGVyZWAsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcW47XG4gIH1cblxuICAvKipcbiAgICogRm9yIGFsbCBtb2R1bGVzIGluIHRoZSBkZXBlbmRlbmN5IGNsb3N1cmUsIGNyYXdsIHRoZWlyIGV4cG9ydHMgdG8gcmVnaXN0ZXJcbiAgICogdGhlIHN1Ym1vZHVsZXMgdGhleSBjb250YWluLlxuICAgKlxuICAgKiBAcGFyYW0gZW50cnlQb2ludCB0aGUgbWFpbiBzb3VyY2UgZmlsZSBmb3IgdGhlIGN1cnJlbnRseSBjb21waWxlZCBtb2R1bGUuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9yZWdpc3RlckRlcGVuZGVuY2llc05hbWVzcGFjZXMoZW50cnlQb2ludDogdHMuU291cmNlRmlsZSkge1xuICAgIGZvciAoY29uc3QgYXNzbSBvZiB0aGlzLnByb2plY3RJbmZvLmRlcGVuZGVuY3lDbG9zdXJlKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHRzLnJlc29sdmVNb2R1bGVOYW1lKFxuICAgICAgICBhc3NtLm5hbWUsXG4gICAgICAgIGVudHJ5UG9pbnQuZmlsZU5hbWUsXG4gICAgICAgIHRoaXMucHJvZ3JhbS5nZXRDb21waWxlck9wdGlvbnMoKSxcbiAgICAgICAgdHMuc3lzLFxuICAgICAgKTtcbiAgICAgIC8vIElmIHdlIGNhbid0IHJlc29sdmUgdGhlIG1vZHVsZSBuYW1lLCBzaW1wbHkgaWdub3JlIGl0IChUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGxpa2VseSBmYWlsZWQpXG4gICAgICBpZiAocmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucHJvZ3JhbS5nZXRTb3VyY2VGaWxlKFxuICAgICAgICByZXNvbHZlZC5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlcE1vZCA9IHNvdXJjZSAmJiB0aGlzLl90eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHNvdXJjZSk7XG4gICAgICAvLyBJdCdzIHVubGlrZWx5LCBidXQgaWYgd2UgY2FuJ3QgZ2V0IHRoZSBTb3VyY2VGaWxlIGhlcmUsIGlnbm9yZSBpdCAoVHlwZVNjcmlwdCBjb21waWxhdGlvbiBwcm9iYWJseSBmYWlsZWQpXG4gICAgICBpZiAoZGVwTW9kID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlcFJvb3QgPSBwYWNrYWdlUm9vdChyZXNvbHZlZC5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lKTtcblxuICAgICAgZm9yIChjb25zdCBzeW1ib2wgb2YgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0RXhwb3J0c09mTW9kdWxlKGRlcE1vZCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVnaXN0ZXJOYW1lc3BhY2VzKHN5bWJvbCwgZGVwUm9vdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFja2FnZVJvb3QoZmlsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZGlybmFtZShmaWxlKTtcbiAgICAgIGlmIChwYXRoLmJhc2VuYW1lKHBhcmVudCkgPT09ICdub2RlX21vZHVsZXMnIHx8IHBhcmVudCA9PT0gZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWNrYWdlUm9vdChwYXJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3JlZ2lzdGVyTmFtZXNwYWNlcyhcbiAgICBzeW1ib2w6IHRzLlN5bWJvbCxcbiAgICBwYWNrYWdlUm9vdDogc3RyaW5nLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHN5bWJvbC52YWx1ZURlY2xhcmF0aW9uID8/IHN5bWJvbC5kZWNsYXJhdGlvbnNbMF07XG4gICAgaWYgKGRlY2xhcmF0aW9uID09IG51bGwpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4uLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHMuaXNNb2R1bGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpIHtcbiAgICAgIC8vIExvb2tzIGxpa2U6XG4gICAgICAvL1xuICAgICAgLy8gICAgZXhwb3J0IHNvbWVfbmFtZXNwYWNlIHtcbiAgICAgIC8vICAgICAgIC4uLlxuICAgICAgLy8gICAgfVxuICAgICAgLy9cbiAgICAgIC8vIE5vIHdheSB0byBjb25maWd1cmUgdGFyZ2V0c1xuXG4gICAgICBjb25zdCB7IGZxbiwgZnFuUmVzb2x1dGlvblByZWZpeCB9ID0gYXdhaXQgcXVhbGlmaWVkTmFtZU9mLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHN5bWJvbCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX3N1Ym1vZHVsZXMuc2V0KHN5bWJvbCwge1xuICAgICAgICBmcW4sXG4gICAgICAgIGZxblJlc29sdXRpb25QcmVmaXgsXG4gICAgICAgIHN5bWJvbElkOiBzeW1ib2xJZGVudGlmaWVyKHRoaXMuX3R5cGVDaGVja2VyLCBzeW1ib2wpLFxuICAgICAgICBsb2NhdGlvbkluTW9kdWxlOiB0aGlzLmRlY2xhcmF0aW9uTG9jYXRpb24oZGVjbGFyYXRpb24pLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLl9hZGRUb1N1Ym1vZHVsZShzeW1ib2wsIHN5bWJvbCwgcGFja2FnZVJvb3QpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRzLmlzTmFtZXNwYWNlRXhwb3J0KGRlY2xhcmF0aW9uKSkge1xuICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlLi4uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbW9kdWxlU3BlY2lmaWVyID0gZGVjbGFyYXRpb24ucGFyZW50Lm1vZHVsZVNwZWNpZmllcjtcbiAgICBpZiAobW9kdWxlU3BlY2lmaWVyID09IG51bGwgfHwgIXRzLmlzU3RyaW5nTGl0ZXJhbChtb2R1bGVTcGVjaWZpZXIpKSB7XG4gICAgICAvLyBUaGVyZSBpcyBhIGdyYW1tYXIgZXJyb3IgaGVyZSwgc28gd2UnbGwgbGV0IHRzYyByZXBvcnQgdGhpcyBmb3IgdXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0cy5yZXNvbHZlTW9kdWxlTmFtZShcbiAgICAgIG1vZHVsZVNwZWNpZmllci50ZXh0LFxuICAgICAgZGVjbGFyYXRpb24uZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lLFxuICAgICAgdGhpcy5wcm9ncmFtLmdldENvbXBpbGVyT3B0aW9ucygpLFxuICAgICAgdHMuc3lzLFxuICAgICk7XG4gICAgaWYgKHJlc29sdXRpb24ucmVzb2x2ZWRNb2R1bGUgPT0gbnVsbCkge1xuICAgICAgLy8gVW5yZXNvbHZhYmxlIG1vZHVsZS4uLiBXZSdsbCBsZXQgdHNjIHJlcG9ydCB0aGlzIGZvciB1cy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGggc28gdGhlIGNvcnJlY3Qgc2VwYXJhdG9yIGlzIGluIHVzZSAoTG9va2luZyBhdCB5b3UsIFdpbmRvd3MpXG4gICAgcmVzb2x1dGlvbi5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lID0gcGF0aC5ub3JtYWxpemUoXG4gICAgICByZXNvbHV0aW9uLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWUsXG4gICAgKTtcbiAgICBpZiAoXG4gICAgICAvLyBXZSdyZSBub3QgbG9va2luZyBpbnRvIGEgZGVwZW5kZW5jeSdzIG5hbWVzcGFjZSBleHBvcnRzLCBhbmQgdGhlIHJlc29sdXRpb24gc2F5cyBpdCdzIGV4dGVybmFsXG4gICAgICAocGFja2FnZVJvb3QgPT09IHRoaXMucHJvamVjdEluZm8ucHJvamVjdFJvb3QgJiZcbiAgICAgICAgcmVzb2x1dGlvbi5yZXNvbHZlZE1vZHVsZS5pc0V4dGVybmFsTGlicmFyeUltcG9ydCkgfHxcbiAgICAgIC8vIE9yIHRoZSBtb2R1bGUgcmVzb2x2ZXMgb3V0c2lkZSBvZiB0aGUgY3VycmVudCBkZXBlbmRlbmN5J3MgdHJlZSBlbnRpcmVseVxuICAgICAgIXJlc29sdXRpb24ucmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRGaWxlTmFtZS5zdGFydHNXaXRoKHBhY2thZ2VSb290KSB8fFxuICAgICAgLy8gT3IgdGhlIG1vZHVsZSBpcyB1bmRlciBvbmUgdGhlIGN1cnJlbnQgZGVwZW5kZW5jeSdzIG5vZGVfbW9kdWxlcyBzdWJ0cmVlXG4gICAgICByZXNvbHV0aW9uLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWVcbiAgICAgICAgLnNwbGl0KHBhdGguc2VwKVxuICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkgPT09ICdub2RlX21vZHVsZXMnKS5sZW5ndGggIT09XG4gICAgICAgIHBhY2thZ2VSb290LnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeSA9PT0gJ25vZGVfbW9kdWxlcycpXG4gICAgICAgICAgLmxlbmd0aFxuICAgICkge1xuICAgICAgLy8gRXh0ZXJuYWwgcmUtZXhwb3J0cyBhcmUgXCJwdXJlLWphdmFzY3JpcHRcIiBzdWdhcjsgdGhleSBuZWVkIG5vdCBiZVxuICAgICAgLy8gcmVwcmVzZW50ZWQgaW4gdGhlIGpzaWkgQXNzZW1ibHkgc2luY2UgdGhlIHR5cGVzIGluIHRoZXJlIHdpbGwgYmVcbiAgICAgIC8vIHJlc29sdmVkIHRocm91Z2ggZGVwZW5kZW5jaWVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZUZpbGUgPSB0aGlzLnByb2dyYW0uZ2V0U291cmNlRmlsZShcbiAgICAgIHJlc29sdXRpb24ucmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRGaWxlTmFtZSxcbiAgICApITtcbiAgICBjb25zdCBzb3VyY2VNb2R1bGUgPSB0aGlzLl90eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHNvdXJjZUZpbGUpO1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9kdWxlLCBpdCdzIGEgc3ludGF4IGVycm9yLCBhbmQgdHNjIHdpbGwgaGF2ZSByZXBvcnRlZCBpdCBmb3IgdXMuXG4gICAgaWYgKHNvdXJjZU1vZHVsZSkge1xuICAgICAgaWYgKFxuICAgICAgICBzeW1ib2wubmFtZSAhPT0gQ2FzZS5jYW1lbChzeW1ib2wubmFtZSkgJiZcbiAgICAgICAgc3ltYm9sLm5hbWUgIT09IENhc2Uuc25ha2Uoc3ltYm9sLm5hbWUpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzgwMDRfU1VCTU9VTEVfTkFNRV9DQVNJTkcuY3JlYXRlKFxuICAgICAgICAgICAgZGVjbGFyYXRpb24ubmFtZSxcbiAgICAgICAgICAgIHN5bWJvbC5uYW1lLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZnFuLCBmcW5SZXNvbHV0aW9uUHJlZml4IH0gPSBhd2FpdCBxdWFsaWZpZWROYW1lT2YuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgc3ltYm9sLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSBhd2FpdCBsb2FkU3VibW9kdWxlVGFyZ2V0Q29uZmlnKHNvdXJjZUZpbGUuZmlsZU5hbWUpO1xuICAgICAgY29uc3QgcmVhZG1lID0gYXdhaXQgbG9hZFN1Ym1vZHVsZVJlYWRNZShzb3VyY2VGaWxlLmZpbGVOYW1lKTtcblxuICAgICAgdGhpcy5fc3VibW9kdWxlcy5zZXQoc3ltYm9sLCB7XG4gICAgICAgIGZxbixcbiAgICAgICAgZnFuUmVzb2x1dGlvblByZWZpeCxcbiAgICAgICAgdGFyZ2V0cyxcbiAgICAgICAgcmVhZG1lLFxuICAgICAgICBzeW1ib2xJZDogc3ltYm9sSWRlbnRpZmllcih0aGlzLl90eXBlQ2hlY2tlciwgc3ltYm9sKSxcbiAgICAgICAgbG9jYXRpb25Jbk1vZHVsZTogdGhpcy5kZWNsYXJhdGlvbkxvY2F0aW9uKGRlY2xhcmF0aW9uKSxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5fYWRkVG9TdWJtb2R1bGUoc3ltYm9sLCBzb3VyY2VNb2R1bGUsIHBhY2thZ2VSb290KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBxdWFsaWZpZWROYW1lT2YoXG4gICAgICB0aGlzOiBBc3NlbWJsZXIsXG4gICAgICBzeW06IHRzLlN5bWJvbCxcbiAgICAgIGlubGluZU5hbWVzcGFjZSA9IGZhbHNlLFxuICAgICk6IFByb21pc2U8eyBmcW46IHN0cmluZzsgZnFuUmVzb2x1dGlvblByZWZpeDogc3RyaW5nIH0+IHtcbiAgICAgIGlmICh0aGlzLl9zdWJtb2R1bGVNYXAuaGFzKHN5bSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3VibW9kdWxlcy5nZXQodGhpcy5fc3VibW9kdWxlTWFwLmdldChzeW0pISkhO1xuICAgICAgICBjb25zdCBmcW4gPSBgJHtwYXJlbnQuZnFufS4ke3N5bS5uYW1lfWA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnFuLFxuICAgICAgICAgIGZxblJlc29sdXRpb25QcmVmaXg6IGlubGluZU5hbWVzcGFjZVxuICAgICAgICAgICAgPyBwYXJlbnQuZnFuUmVzb2x1dGlvblByZWZpeFxuICAgICAgICAgICAgOiBmcW4sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBzeW1ib2xMb2NhdGlvbiA9IHN5bVxuICAgICAgICAuZ2V0RGVjbGFyYXRpb25zKCk/LlswXVxuICAgICAgICA/LmdldFNvdXJjZUZpbGUoKT8uZmlsZU5hbWU7XG4gICAgICBjb25zdCBwa2dJbmZvID0gc3ltYm9sTG9jYXRpb25cbiAgICAgICAgPyBhd2FpdCBmaW5kUGFja2FnZUluZm8oc3ltYm9sTG9jYXRpb24pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgYXNzZW1ibHlOYW1lOiBzdHJpbmcgPSBwa2dJbmZvPy5uYW1lID8/IHRoaXMucHJvamVjdEluZm8ubmFtZTtcbiAgICAgIGNvbnN0IGZxbiA9IGAke2Fzc2VtYmx5TmFtZX0uJHtzeW0ubmFtZX1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnFuLFxuICAgICAgICBmcW5SZXNvbHV0aW9uUHJlZml4OiBpbmxpbmVOYW1lc3BhY2UgPyB0aGlzLnByb2plY3RJbmZvLm5hbWUgOiBmcW4sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRTdWJtb2R1bGVUYXJnZXRDb25maWcoXG4gICAgICBzdWJtb2R1bGVNYWluOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxTdWJtb2R1bGVTcGVjWyd0YXJnZXRzJ10+IHtcbiAgICAgIGNvbnN0IGpzaWlyYyA9IHBhdGgucmVzb2x2ZShzdWJtb2R1bGVNYWluLCAnLi4nLCAnLmpzaWlyYy5qc29uJyk7XG4gICAgICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKGpzaWlyYykpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucmVhZEpzb24oanNpaXJjKTtcbiAgICAgIHJldHVybiBkYXRhLnRhcmdldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgUkVBRE1FIGZvciB0aGUgZ2l2ZW4gc3VibW9kdWxlXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3VibW9kdWxlIGlzIGxvYWRlZCBmcm9tIGEgY29tcGxldGUgZGlyZWN0b3J5IChkZXRlcm1pbmVkIGJ5IHRoZSAnbWFpbidcbiAgICAgKiBmaWxlIGVuZGluZyBpbiBgaW5kZXguW2QuXXRzYCwgdGhlbiB3ZSBsb2FkIGBSRUFETUUubWRgIGluIHRoYXQgc2FtZSBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3VibW9kdWxlIGlzIGxvYWRlZCBmcm9tIGEgZmlsZSwgbGlrZSBgbXltb2R1bGUuW2QuXXRzYCwgd2Ugd2lsbCBsb2FkXG4gICAgICogYG15bW9kdWxlLlJFQURNRS5tZGAuXG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZFN1Ym1vZHVsZVJlYWRNZShcbiAgICAgIHN1Ym1vZHVsZU1haW46IHN0cmluZyxcbiAgICApOiBQcm9taXNlPFN1Ym1vZHVsZVNwZWNbJ3JlYWRtZSddPiB7XG4gICAgICBjb25zdCBmaWxlQmFzZSA9IHBhdGguYmFzZW5hbWUoc3VibW9kdWxlTWFpbikucmVwbGFjZSgvKFxcLmQpP1xcLnRzJC8sICcnKTtcbiAgICAgIGNvbnN0IHJlYWRNZU5hbWUgPVxuICAgICAgICBmaWxlQmFzZSA9PT0gJ2luZGV4JyA/IGBSRUFETUUubWRgIDogYCR7ZmlsZUJhc2V9LlJFQURNRS5tZGA7XG4gICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUoc3VibW9kdWxlTWFpbiksIHJlYWRNZU5hbWUpO1xuXG4gICAgICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKGZ1bGxQYXRoKSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcmtkb3duOiBhd2FpdCBmcy5yZWFkRmlsZShmdWxsUGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBTeW1ib2xzIHRvIGEgcGFydGljdWxhciBzdWJtb2R1bGUuIFRoaXMgaXMgdXNlZCB0byBhc3NvY2lhdGVcbiAgICogZGVjbGFyYXRpb25zIGV4cG9ydGVkIGJ5IGFuIGBleHBvcnQgKiBhcyBucyBmcm9tICdtb2R1bGVMaWtlJztgIHN0YXRlbWVudFxuICAgKiBzbyB0aGF0IHRoZXkgY2FuIHN1YnNlcXVlbnRseSBiZSBjb3JyZWN0bHkgbmFtZXNwYWNlZC5cbiAgICpcbiAgICogQHBhcmFtIG5zICAgICAgICAgIHRoZSBzeW1ib2wgdGhhdCBpZGVudGlmaWVzIHRoZSBzdWJtb2R1bGUuXG4gICAqIEBwYXJhbSBtb2R1bGVMaWtlICB0aGUgbW9kdWxlLWxpa2Ugc3ltYm9sIGJvdW5kIHRvIHRoZSBzdWJtb2R1bGUuXG4gICAqIEBwYXJhbSBwYWNrYWdlUm9vdCB0aGUgcm9vdCBvZiB0aGUgcGFja2FnZSBiZWluZyB0cmF2ZXJzZWQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9hZGRUb1N1Ym1vZHVsZShcbiAgICBuczogdHMuU3ltYm9sLFxuICAgIG1vZHVsZUxpa2U6IHRzLlN5bWJvbCxcbiAgICBwYWNrYWdlUm9vdDogc3RyaW5nLFxuICApIHtcbiAgICAvLyBGb3IgZWFjaCBzeW1ib2wgZXhwb3J0ZWQgYnkgdGhlIG1vZHVsZUxpa2UsIG1hcCBpdCB0byB0aGUgbnMgc3VibW9kdWxlLlxuICAgIGZvciAoY29uc3Qgc3ltYm9sIG9mIHRoaXMuX3R5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShtb2R1bGVMaWtlKSkge1xuICAgICAgaWYgKHRoaXMuX3N1Ym1vZHVsZU1hcC5oYXMoc3ltYm9sKSkge1xuICAgICAgICBjb25zdCBjdXJyTnMgPSB0aGlzLl9zdWJtb2R1bGVNYXAuZ2V0KHN5bWJvbCkhO1xuICAgICAgICAvLyBDaGVja2luZyBpZiB0aGVyZSdzIGJlZW4gdHdvIHN1Ym1vZHVsZXMgZXhwb3J0aW5nIHRoZSBzYW1lIHN5bWJvbCxcbiAgICAgICAgLy8gd2hpY2ggaXMgaWxsZWdhbC4gV2UgY2FuIHRlbGwgaWYgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIHN5bWJvbCBoYXNcbiAgICAgICAgLy8gYSBkaWZmZXJlbnQgbmFtZSB0aGFuIHRoZSBvbmUgd2UncmUgY3VycmVudGx5IHRyeWluZyB0byByZWdpc3RlciBpbi5cbiAgICAgICAgaWYgKGN1cnJOcy5uYW1lICE9PSBucy5uYW1lKSB7XG4gICAgICAgICAgY29uc3QgY3Vyck5zRGVjbCA9IGN1cnJOcy52YWx1ZURlY2xhcmF0aW9uID8/IGN1cnJOcy5kZWNsYXJhdGlvbnNbMF07XG4gICAgICAgICAgY29uc3QgbnNEZWNsID0gbnMudmFsdWVEZWNsYXJhdGlvbiA/PyBucy5kZWNsYXJhdGlvbnNbMF07XG5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVycm9yIG1lc3NhZ2UgYWx3YXlzIGxpc3RzIGNhdXNlcyBpbiB0aGUgc2FtZSBvcmRlclxuICAgICAgICAgIGNvbnN0IHJlZnMgPSBbXG4gICAgICAgICAgICB7IGRlY2w6IGN1cnJOc0RlY2wsIG5hbWU6IGN1cnJOcy5uYW1lIH0gYXMgY29uc3QsXG4gICAgICAgICAgICB7IGRlY2w6IG5zRGVjbCwgbmFtZTogbnMubmFtZSB9IGFzIGNvbnN0LFxuICAgICAgICAgIF0uc29ydCgoeyBuYW1lOiBsIH0sIHsgbmFtZTogciB9KSA9PiBsLmxvY2FsZUNvbXBhcmUocikpO1xuXG4gICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMzAwM19TWU1CT0xfSVNfRVhQT1JURURfVFdJQ0UuY3JlYXRlKFxuICAgICAgICAgICAgICBfbmFtZU9yRGVjbGFyYXRpb25Ob2RlKHN5bWJvbCksXG4gICAgICAgICAgICAgIHJlZnNbMF0ubmFtZSxcbiAgICAgICAgICAgICAgcmVmc1sxXS5uYW1lLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgICAgICAgIHJlZnNbMF0uZGVjbCxcbiAgICAgICAgICAgICAgICBgU3ltYm9sIGlzIGV4cG9ydGVkIHVuZGVyIHRoZSBcIiR7cmVmc1swXS5uYW1lfVwiIHN1Ym1vZHVsZWAsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmFkZFJlbGF0ZWRJbmZvcm1hdGlvbihcbiAgICAgICAgICAgICAgICByZWZzWzFdLmRlY2wsXG4gICAgICAgICAgICAgICAgYFN5bWJvbCBpcyBleHBvcnRlZCB1bmRlciB0aGUgXCIke3JlZnNbMV0ubmFtZX1cIiBzdWJtb2R1bGVgLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm91bmQgdHdvIHJlLWV4cG9ydHMsIHdoaWNoIGlzIG9kZCwgYnV0IHRoZXkgdXNlIHRoZSBzYW1lIHN1Ym1vZHVsZSxcbiAgICAgICAgLy8gc28gaXQncyBwcm9iYWJseSBva2F5PyBUaGF0J3MgbGlrZWx5IGEgdHNjIGVycm9yLCB3aGljaCB3aWxsIGhhdmVcbiAgICAgICAgLy8gYmVlbiByZXBvcnRlZCBmb3IgdXMgYWxyZWFkeSBhbnl3YXkuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3VibW9kdWxlTWFwLnNldChzeW1ib2wsIG5zKTtcblxuICAgICAgLy8gSWYgdGhlIGV4cG9ydGVkIHN5bWJvbCBoYXMgYW55IGRlY2xhcmF0aW9uLCBhbmQgdGhhdCBkZWxjYXJhdGlvbiBpcyBvZlxuICAgICAgLy8gYW4gZW50aXR5IHRoYXQgY2FuIGhhdmUgbmVzdGVkIGRlY2xhcmF0aW9ucyBvZiBpbnRlcmVzdCB0byBqc2lpXG4gICAgICAvLyAoY2xhc3NlcywgaW50ZXJmYWNlcywgZW51bXMsIG1vZHVsZXMpLCB3ZSBuZWVkIHRvIGFsc28gYXNzb2NpYXRlIHRob3NlXG4gICAgICAvLyBuZXN0ZWQgc3ltYm9scyB0byB0aGUgc3VibW9kdWxlIChvciB0aGV5IHdvbid0IGJlIG5hbWVkIGNvcnJlY3RseSEpXG4gICAgICBjb25zdCBkZWNsID0gc3ltYm9sLmRlY2xhcmF0aW9ucz8uWzBdO1xuICAgICAgaWYgKGRlY2wgIT0gbnVsbCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHMuaXNDbGFzc0RlY2xhcmF0aW9uKGRlY2wpIHx8XG4gICAgICAgICAgdHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbihkZWNsKSB8fFxuICAgICAgICAgIHRzLmlzRW51bURlY2xhcmF0aW9uKGRlY2wpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl90eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihkZWNsKTtcbiAgICAgICAgICBpZiAoaXNTaW5nbGVWYWx1ZWRFbnVtKHR5cGUsIHRoaXMuX3R5cGVDaGVja2VyKSkge1xuICAgICAgICAgICAgLy8gdHlwZS5zeW1ib2wgIT09IHN5bWJvbCwgYmVjYXVzZSBzeW1ib2wgaXMgdGhlIGVudW0gaXRzZWxmLCBidXRcbiAgICAgICAgICAgIC8vIHNpbmNlIGl0J3Mgc2luZ2xlLXZhbHVlZCwgdGhlIFR5cGVDaGVja2VyIHdpbGwgb25seSBzaG93IHVzIHRoZVxuICAgICAgICAgICAgLy8gdmFsdWUncyBzeW1ib2wgbGF0ZXIgb24uXG4gICAgICAgICAgICB0aGlzLl9zdWJtb2R1bGVNYXAuc2V0KHR5cGUuc3ltYm9sLCBucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlLnN5bWJvbC5leHBvcnRzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWRkVG9TdWJtb2R1bGUobnMsIHN5bWJvbCwgcGFja2FnZVJvb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0cy5pc01vZHVsZURlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZWdpc3Rlck5hbWVzcGFjZXMoc3ltYm9sLCBwYWNrYWdlUm9vdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHMuaXNOYW1lc3BhY2VFeHBvcnQoZGVjbCkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlZ2lzdGVyTmFtZXNwYWNlcyhzeW1ib2wsIHBhY2thZ2VSb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBleHBvcnRlZCB0eXBlcyBpbiBgYHRoaXMudHlwZXNgYC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgICAgICAgYSBub2RlIGZvdW5kIGluIGEgbW9kdWxlXG4gICAqIEBwYXJhbSBuYW1lUHJlZml4IHRoZSBwcmVmaXggZm9yIHRoZSB0eXBlcycgbmFtZXNwYWNlc1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgcHJpdmF0ZSBhc3luYyBfdmlzaXROb2RlKFxuICAgIG5vZGU6IHRzLkRlY2xhcmF0aW9uLFxuICAgIGNvbnRleHQ6IEVtaXRDb250ZXh0LFxuICApOiBQcm9taXNlPHNwZWMuVHlwZVtdPiB7XG4gICAgaWYgKHRzLmlzTmFtZXNwYWNlRXhwb3J0KG5vZGUpKSB7XG4gICAgICAvLyBleHBvcnQgKiBhcyBucyBmcm9tICdtb2R1bGUnO1xuICAgICAgLy8gTm90ZTogdGhlIFwidHMuTmFtZXNwYWNlRXhwb3J0XCIgcmVmZXJzIHRvIHRoZSBcImV4cG9ydCAqIGFzIG5zXCIgcGFydCBvZlxuICAgICAgLy8gdGhlIHN0YXRlbWVudCBvbmx5LiBXZSBtdXN0IHJlZmVyIHRvIGBub2RlLnBhcmVudGAgaW4gb3JkZXIgdG8gYmUgYWJsZVxuICAgICAgLy8gdG8gYWNjZXNzIHRoZSBtb2R1bGUgc3BlY2lmaWVyIChcImZyb20gJ21vZHVsZSdcIikgcGFydC5cbiAgICAgIGNvbnN0IHN5bWJvbCA9IHRoaXMuX3R5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oXG4gICAgICAgIG5vZGUucGFyZW50Lm1vZHVsZVNwZWNpZmllciEsXG4gICAgICApITtcblxuICAgICAgaWYgKExPRy5pc1RyYWNlRW5hYmxlZCgpKSB7XG4gICAgICAgIExPRy50cmFjZShcbiAgICAgICAgICBgRW50ZXJpbmcgc3VibW9kdWxlOiAke2NvbG9ycy5jeWFuKFxuICAgICAgICAgICAgWy4uLmNvbnRleHQubmFtZXNwYWNlLCBzeW1ib2wubmFtZV0uam9pbignLicpLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbnNDb250ZXh0ID0gY29udGV4dC5hcHBlbmROYW1lc3BhY2Uobm9kZS5uYW1lLnRleHQpO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTxzcGVjLlR5cGVbXT4+KCk7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3R5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShzeW1ib2wpKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fdmlzaXROb2RlKGNoaWxkLmRlY2xhcmF0aW9uc1swXSwgbnNDb250ZXh0KSk7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxUeXBlcyA9IGZsYXR0ZW5Qcm9taXNlcyhwcm9taXNlcyk7XG5cbiAgICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgICBMT0cudHJhY2UoXG4gICAgICAgICAgYExlYXZpbmcgc3VibW9kdWxlOiAke2NvbG9ycy5jeWFuKFxuICAgICAgICAgICAgWy4uLmNvbnRleHQubmFtZXNwYWNlLCBzeW1ib2wubmFtZV0uam9pbignLicpLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbFR5cGVzO1xuICAgIH1cblxuICAgIGlmICh0cy5pc0V4cG9ydFNwZWNpZmllcihub2RlKSkge1xuICAgICAgLy8gVGhpcyBpcyB3aGF0IGhhcHBlbnMgd2hlbiBvbmUgZG9lcyBgZXhwb3J0IHsgU3ltYm9sIH0gZnJvbSBcIi4vbG9jYXRpb25cIjtgXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICBFeHBvcnRTcGVjaWZpZXI6ICAgICAgICAgICB+fn5+fn5cblxuICAgICAgY29uc3QgcmVzb2x2ZWRTeW1ib2wgPVxuICAgICAgICB0aGlzLl90eXBlQ2hlY2tlci5nZXRFeHBvcnRTcGVjaWZpZXJMb2NhbFRhcmdldFN5bWJvbChub2RlKTtcbiAgICAgIGlmICghcmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgLy8gQSBncmFtbWFyIGVycm9yLCBjb21waWxhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBmYWlsZWRcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Tm9kZShcbiAgICAgICAgcmVzb2x2ZWRTeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyByZXNvbHZlZFN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICgodHMuZ2V0Q29tYmluZWRNb2RpZmllckZsYWdzKG5vZGUpICYgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IGpzaWlUeXBlOiBzcGVjLlR5cGUgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHMuaXNDbGFzc0RlY2xhcmF0aW9uKG5vZGUpICYmIF9pc0V4cG9ydGVkKG5vZGUpKSB7XG4gICAgICAvLyBleHBvcnQgY2xhc3MgTmFtZSB7IC4uLiB9XG4gICAgICB0aGlzLl92YWxpZGF0ZUhlcml0YWdlQ2xhdXNlcyhub2RlLmhlcml0YWdlQ2xhdXNlcyk7XG5cbiAgICAgIGpzaWlUeXBlID0gYXdhaXQgdGhpcy5fdmlzaXRDbGFzcyhcbiAgICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9kZSksXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApO1xuICAgICAgaWYgKGpzaWlUeXBlKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFeHBvcnRlZENsYXNzRnFuKG5vZGUsIGpzaWlUeXBlLmZxbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUpICYmIF9pc0V4cG9ydGVkKG5vZGUpKSB7XG4gICAgICAvLyBleHBvcnQgaW50ZXJmYWNlIE5hbWUgeyAuLi4gfVxuICAgICAgdGhpcy5fdmFsaWRhdGVIZXJpdGFnZUNsYXVzZXMobm9kZS5oZXJpdGFnZUNsYXVzZXMpO1xuICAgICAganNpaVR5cGUgPSBhd2FpdCB0aGlzLl92aXNpdEludGVyZmFjZShcbiAgICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9kZSksXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHMuaXNFbnVtRGVjbGFyYXRpb24obm9kZSkgJiYgX2lzRXhwb3J0ZWQobm9kZSkpIHtcbiAgICAgIC8vIGV4cG9ydCBlbnVtIE5hbWUgeyAuLi4gfVxuICAgICAganNpaVR5cGUgPSBhd2FpdCB0aGlzLl92aXNpdEVudW0oXG4gICAgICAgIHRoaXMuX3R5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKG5vZGUpLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzTW9kdWxlRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgIC8vIGV4cG9ydCBuYW1lc3BhY2UgbmFtZSB7IC4uLiB9XG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lLmdldFRleHQoKTtcbiAgICAgIGNvbnN0IHN5bWJvbCA9IHRoaXMuX3R5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZS5uYW1lKSE7XG5cbiAgICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgICBMT0cudHJhY2UoXG4gICAgICAgICAgYEVudGVyaW5nIG5hbWVzcGFjZTogJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICAgIFsuLi5jb250ZXh0Lm5hbWVzcGFjZSwgbmFtZV0uam9pbignLicpLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxsVHlwZXNQcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHNwZWMuVHlwZVtdPj4oKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiB0aGlzLl90eXBlQ2hlY2tlci5nZXRFeHBvcnRzT2ZNb2R1bGUoc3ltYm9sKSkge1xuICAgICAgICBhbGxUeXBlc1Byb21pc2VzLnB1c2goXG4gICAgICAgICAgdGhpcy5fdmlzaXROb2RlKFxuICAgICAgICAgICAgcHJvcC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICBjb250ZXh0LmFwcGVuZE5hbWVzcGFjZShub2RlLm5hbWUuZ2V0VGV4dCgpKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxsVHlwZXMgPSBhd2FpdCBmbGF0dGVuUHJvbWlzZXMoYWxsVHlwZXNQcm9taXNlcyk7XG5cbiAgICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgICBMT0cudHJhY2UoXG4gICAgICAgICAgYExlYXZpbmcgbmFtZXNwYWNlOiAgJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICAgIFsuLi5jb250ZXh0Lm5hbWVzcGFjZSwgbmFtZV0uam9pbignLicpLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV85OTk4X1VOU1VQUE9SVEVEX05PREUuY3JlYXRlKFxuICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG5vZGUpID8/IG5vZGUsXG4gICAgICAgICAgbm9kZS5raW5kLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWpzaWlUeXBlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gSWYgc3ltYm9sSWQgaGFzbid0IGJlZW4gc2V0IHlldCwgc2V0IGl0IGhlcmVcbiAgICBpZiAoIWpzaWlUeXBlLnN5bWJvbElkKSB7XG4gICAgICBqc2lpVHlwZS5zeW1ib2xJZCA9IHRoaXMuZ2V0U3ltYm9sSWQobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gTGV0J3MgcXVpY2tseSB2ZXJpZnkgdGhlIGRlY2xhcmF0aW9uIGRvZXMgbm90IGNvbGxpZGUgd2l0aCBhIHN1Ym1vZHVsZS4gU3VibW9kdWxlcyBnZXQgY2FzZS1hZGp1c3RlZCBmb3IgZWFjaFxuICAgIC8vIHRhcmdldCBsYW5ndWFnZSBzZXBhcmF0ZWx5LCBzbyBuYW1lcyBjYW5ub3QgY29sbGlkZSB3aXRoIGNhc2UtdmFyaWF0aW9ucy5cbiAgICBmb3IgKGNvbnN0IHN1Ym1vZHVsZSBvZiB0aGlzLl9zdWJtb2R1bGVzLmtleXMoKSkge1xuICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBTZXQoW1xuICAgICAgICAgIHN1Ym1vZHVsZS5uYW1lLFxuICAgICAgICAgIENhc2UuY2FtZWwoc3VibW9kdWxlLm5hbWUpLFxuICAgICAgICAgIENhc2UucGFzY2FsKHN1Ym1vZHVsZS5uYW1lKSxcbiAgICAgICAgICBDYXNlLnNuYWtlKHN1Ym1vZHVsZS5uYW1lKSxcbiAgICAgICAgXSksXG4gICAgICApO1xuICAgICAgY29uc3QgY29sbGlkaW5nID0gY2FuZGlkYXRlcy5maW5kKFxuICAgICAgICAobmFtZSkgPT4gYCR7dGhpcy5wcm9qZWN0SW5mby5uYW1lfS4ke25hbWV9YCA9PT0ganNpaVR5cGUhLmZxbixcbiAgICAgICk7XG4gICAgICBpZiAoY29sbGlkaW5nICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3VibW9kdWxlRGVjbE5hbWUgPSBfbmFtZU9yRGVjbGFyYXRpb25Ob2RlKHN1Ym1vZHVsZSk7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDExX1NVQk1PRFVMRV9OQU1FX0NPTkZMSUNULmNyZWF0ZShcbiAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG5vZGUpID8/IG5vZGUsXG4gICAgICAgICAgICBzdWJtb2R1bGUubmFtZSxcbiAgICAgICAgICAgIGpzaWlUeXBlLm5hbWUsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICkuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgICAgc3VibW9kdWxlRGVjbE5hbWUsXG4gICAgICAgICAgICBgVGhpcyBpcyB0aGUgY29uZmxpY3Rpbmcgc3VibW9kdWxlIGRlY2xhcmF0aW9uYCxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChMT0cuaXNJbmZvRW5hYmxlZCgpKSB7XG4gICAgICBMT0cuaW5mbyhcbiAgICAgICAgYFJlZ2lzdGVyaW5nIEpTSUkgJHtjb2xvcnMubWFnZW50YShqc2lpVHlwZS5raW5kKX06ICR7Y29sb3JzLmdyZWVuKFxuICAgICAgICAgIGpzaWlUeXBlLmZxbixcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fdHlwZXNbanNpaVR5cGUuZnFuXSA9IGpzaWlUeXBlO1xuICAgIGpzaWlUeXBlLmxvY2F0aW9uSW5Nb2R1bGUgPSB0aGlzLmRlY2xhcmF0aW9uTG9jYXRpb24obm9kZSk7XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9kZSk7XG4gICAgaWYgKHR5cGUuc3ltYm9sLmV4cG9ydHMpIHtcbiAgICAgIGNvbnN0IG5lc3RlZENvbnRleHQgPSBjb250ZXh0LmFwcGVuZE5hbWVzcGFjZSh0eXBlLnN5bWJvbC5uYW1lKTtcbiAgICAgIGNvbnN0IHZpc2l0ZWROb2RlcyA9IHRoaXMuX3R5cGVDaGVja2VyXG4gICAgICAgIC5nZXRFeHBvcnRzT2ZNb2R1bGUodHlwZS5zeW1ib2wpXG4gICAgICAgIC5maWx0ZXIoKHMpID0+IHMuZGVjbGFyYXRpb25zKVxuICAgICAgICAubWFwKChleHBvcnRlZE5vZGUpID0+XG4gICAgICAgICAgdGhpcy5fdmlzaXROb2RlKGV4cG9ydGVkTm9kZS5kZWNsYXJhdGlvbnNbMF0sIG5lc3RlZENvbnRleHQpLFxuICAgICAgICApO1xuICAgICAgZm9yIChjb25zdCBuZXN0ZWRUeXBlcyBvZiBhd2FpdCBQcm9taXNlLmFsbCh2aXNpdGVkTm9kZXMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmVzdGVkVHlwZSBvZiBuZXN0ZWRUeXBlcykge1xuICAgICAgICAgIGlmIChuZXN0ZWRUeXBlLm5hbWVzcGFjZSAhPT0gbmVzdGVkQ29udGV4dC5uYW1lc3BhY2Uuam9pbignLicpKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTJfTkFNRVNQQUNFX0lOX1RZUEUuY3JlYXRlKFxuICAgICAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG5vZGUpID8/IG5vZGUsXG4gICAgICAgICAgICAgICAganNpaVR5cGUuZnFuLFxuICAgICAgICAgICAgICAgIG5lc3RlZFR5cGUubmFtZXNwYWNlISxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtqc2lpVHlwZV07XG4gIH1cblxuICBwcml2YXRlIGdldFN5bWJvbElkKG5vZGU6IHRzLk5vZGUpIHtcbiAgICByZXR1cm4gc3ltYm9sSWRlbnRpZmllcihcbiAgICAgIHRoaXMuX3R5cGVDaGVja2VyLFxuICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9kZSkuc3ltYm9sLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIF92YWxpZGF0ZUhlcml0YWdlQ2xhdXNlcyhjbGF1c2VzPzogdHMuTm9kZUFycmF5PHRzLkhlcml0YWdlQ2xhdXNlPikge1xuICAgIGlmIChjbGF1c2VzID09IG51bGwgfHwgY2xhdXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2xhdXNlIG9mIGNsYXVzZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjbGF1c2UudHlwZXMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IHRoaXMuX3R5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKG5vZGUpO1xuICAgICAgICBpZiAocGFyZW50VHlwZS5zeW1ib2wgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoZSBwYXJlbnQgdHlwZSB3b24ndCBoYXZlIGEgc3ltYm9sIGlmIGl0J3MgYW4gXCJlcnJvciB0eXBlXCIgaW5zZXJ0ZWQgYnkgdGhlIHR5cGUgY2hlY2tlciB3aGVuIHRoZSBvcmlnaW5hbFxuICAgICAgICAgIC8vIGNvZGUgY29udGFpbnMgYSBjb21waWxhdGlvbiBlcnJvci4gSW4gc3VjaCBjYXNlcywgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXIgd2lsbCBhbHJlYWR5IGhhdmUgcmVwb3J0ZWQgYWJvdXRcbiAgICAgICAgICAvLyB0aGUgaW5jb2hlcmVudCBkZWNsYXJhdGlvbnMsIHNvIHdlJ2xsIGp1c3Qgbm90IHJlLXZhbGlkYXRlIGl0IHRoZXJlICh3ZSdkIGZhaWwgYW55d2F5KS5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIHdlIGNhbm5vdCB0cnVzdCBwYXJlbnRUeXBlLmlzQ2xhc3NPckludGVyZmFjZSgpXG4gICAgICAgIGNvbnN0IGJhZERlY2wgPSBwYXJlbnRUeXBlLnN5bWJvbC5kZWNsYXJhdGlvbnMuZmluZChcbiAgICAgICAgICAoZGVjbCkgPT5cbiAgICAgICAgICAgICF0cy5pc0NsYXNzRGVjbGFyYXRpb24oZGVjbCkgJiYgLy8gPC0tIGxvY2FsIGNsYXNzZXNcbiAgICAgICAgICAgICF0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uKGRlY2wpICYmIC8vIDwtLSBsb2NhbCBpbnRlcmZhY2VzXG4gICAgICAgICAgICAhdHMuaXNNb2R1bGVEZWNsYXJhdGlvbihkZWNsKSwgLy8gPC0tIGltcG9ydGVkIHR5cGVzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChiYWREZWNsICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA0X0lOVkFMSURfU1VQRVJUWVBFLmNyZWF0ZShcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgY2xhdXNlLFxuICAgICAgICAgICAgICBiYWREZWNsLFxuICAgICAgICAgICAgKS5hZGRSZWxhdGVkSW5mb3JtYXRpb24oXG4gICAgICAgICAgICAgIGJhZERlY2wsXG4gICAgICAgICAgICAgIGBUaGUgaW52YWxpZCBzdXBlciB0eXBlIGlzIGRlY2xhcmVkIGhlcmUuYCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGVjbGFyYXRpb25Mb2NhdGlvbihub2RlOiB0cy5EZWNsYXJhdGlvbik6IHNwZWMuU291cmNlTG9jYXRpb24ge1xuICAgIGNvbnN0IGZpbGUgPSBub2RlLmdldFNvdXJjZUZpbGUoKTtcbiAgICBjb25zdCBsaW5lID0gdHMuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24oZmlsZSwgbm9kZS5nZXRTdGFydCgpKS5saW5lO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFxuICAgICAgLm5vcm1hbGl6ZShwYXRoLnJlbGF0aXZlKHRoaXMucHJvamVjdEluZm8ucHJvamVjdFJvb3QsIGZpbGUuZmlsZU5hbWUpKVxuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsZW5hbWUsXG4gICAgICBsaW5lOiBsaW5lICsgMSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcHJvY2Vzc0Jhc2VJbnRlcmZhY2VzKGZxbjogc3RyaW5nLCBiYXNlVHlwZXM/OiB0cy5UeXBlW10pIHtcbiAgICBjb25zdCBlcmFzZWRCYXNlcyA9IG5ldyBBcnJheTx0cy5UeXBlPigpO1xuICAgIGlmICghYmFzZVR5cGVzKSB7XG4gICAgICByZXR1cm4geyBlcmFzZWRCYXNlcyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxzcGVjLk5hbWVkVHlwZVJlZmVyZW5jZT4oKTtcbiAgICBjb25zdCBiYXNlSW50ZXJmYWNlcyA9IG5ldyBTZXQ8dHMuVHlwZT4oKTtcblxuICAgIGNvbnN0IHByb2Nlc3NCYXNlVHlwZXMgPSAodHlwZXM6IHRzLlR5cGVbXSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBpZmFjZSBvZiB0eXBlcykge1xuICAgICAgICAvLyBiYXNlIGlzIHByaXZhdGUvaW50ZXJuYWwsIHNvIHdlIGNvbnRpbnVlIHJlY3Vyc2l2ZWx5IHdpdGggaXQncyBvd24gYmFzZXNcbiAgICAgICAgaWYgKHRoaXMuX2lzUHJpdmF0ZU9ySW50ZXJuYWwoaWZhY2Uuc3ltYm9sKSkge1xuICAgICAgICAgIGVyYXNlZEJhc2VzLnB1c2goaWZhY2UpO1xuICAgICAgICAgIGNvbnN0IGJhc2VzID0gaWZhY2UuZ2V0QmFzZVR5cGVzKCk7XG4gICAgICAgICAgaWYgKGJhc2VzKSB7XG4gICAgICAgICAgICBwcm9jZXNzQmFzZVR5cGVzKGJhc2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlSW50ZXJmYWNlcy5hZGQoaWZhY2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwcm9jZXNzQmFzZVR5cGVzKGJhc2VUeXBlcyk7XG5cbiAgICBjb25zdCB0eXBlUmVmcyA9IEFycmF5LmZyb20oYmFzZUludGVyZmFjZXMpLm1hcChhc3luYyAoaWZhY2UpID0+IHtcbiAgICAgIGNvbnN0IGRlY2wgPSBpZmFjZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbjtcbiAgICAgIGNvbnN0IHR5cGVSZWYgPSBhd2FpdCB0aGlzLl90eXBlUmVmZXJlbmNlKGlmYWNlLCBkZWNsLCAnYmFzZSBpbnRlcmZhY2UnKTtcbiAgICAgIHJldHVybiB7IGRlY2wsIHR5cGVSZWYgfTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHsgZGVjbCwgdHlwZVJlZiB9IG9mIGF3YWl0IFByb21pc2UuYWxsKHR5cGVSZWZzKSkge1xuICAgICAgaWYgKCFzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHR5cGVSZWYpKSB7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA1X1RZUEVfVVNFRF9BU19JTlRFUkZBQ0UuY3JlYXRlKGRlY2wsIHR5cGVSZWYpLFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKGZxbiwgW3R5cGVSZWZdLCBkZWNsLCAoZGVyZWYpID0+IHtcbiAgICAgICAgaWYgKCFzcGVjLmlzSW50ZXJmYWNlVHlwZShkZXJlZikpIHtcbiAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA1X1RZUEVfVVNFRF9BU19JTlRFUkZBQ0UuY3JlYXRlKFxuICAgICAgICAgICAgICBkZWNsLFxuICAgICAgICAgICAgICB0eXBlUmVmLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0LnB1c2godHlwZVJlZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVyZmFjZXM6IHJlc3VsdC5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiByZXN1bHQsXG4gICAgICBlcmFzZWRCYXNlcyxcbiAgICB9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgcHJpdmF0ZSBhc3luYyBfdmlzaXRDbGFzcyhcbiAgICB0eXBlOiB0cy5UeXBlLFxuICAgIGN0eDogRW1pdENvbnRleHQsXG4gICk6IFByb21pc2U8c3BlYy5DbGFzc1R5cGUgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoTE9HLmlzVHJhY2VFbmFibGVkKCkpIHtcbiAgICAgIExPRy50cmFjZShcbiAgICAgICAgYFByb2Nlc3NpbmcgY2xhc3M6ICR7Y29sb3JzLmdyYXkoXG4gICAgICAgICAgY3R4Lm5hbWVzcGFjZS5qb2luKCcuJyksXG4gICAgICAgICl9LiR7Y29sb3JzLmN5YW4odHlwZS5zeW1ib2wubmFtZSl9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNJbnRlcm5hbEpzRG9jVGFnKHR5cGUuc3ltYm9sKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl93YXJuQWJvdXRSZXNlcnZlZFdvcmRzKHR5cGUuc3ltYm9sKTtcblxuICAgIGNvbnN0IGZxbiA9IGAke1t0aGlzLnByb2plY3RJbmZvLm5hbWUsIC4uLmN0eC5uYW1lc3BhY2VdLmpvaW4oJy4nKX0uJHtcbiAgICAgIHR5cGUuc3ltYm9sLm5hbWVcbiAgICB9YDtcblxuICAgIGNvbnN0IGpzaWlUeXBlOiBzcGVjLkNsYXNzVHlwZSA9IGJpbmRpbmdzLnNldENsYXNzUmVsYXRlZE5vZGUoXG4gICAgICB7XG4gICAgICAgIGFzc2VtYmx5OiB0aGlzLnByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIGZxbixcbiAgICAgICAga2luZDogc3BlYy5UeXBlS2luZC5DbGFzcyxcbiAgICAgICAgbmFtZTogdHlwZS5zeW1ib2wubmFtZSxcbiAgICAgICAgbmFtZXNwYWNlOlxuICAgICAgICAgIGN0eC5uYW1lc3BhY2UubGVuZ3RoID4gMCA/IGN0eC5uYW1lc3BhY2Uuam9pbignLicpIDogdW5kZWZpbmVkLFxuICAgICAgICBkb2NzOiB0aGlzLl92aXNpdERvY3VtZW50YXRpb24odHlwZS5zeW1ib2wsIGN0eCkuZG9jcyxcbiAgICAgIH0sXG4gICAgICB0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uIGFzIHRzLkNsYXNzRGVjbGFyYXRpb24sXG4gICAgKTtcblxuICAgIGlmIChfaXNBYnN0cmFjdCh0eXBlLnN5bWJvbCwganNpaVR5cGUpKSB7XG4gICAgICBqc2lpVHlwZS5hYnN0cmFjdCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgZXJhc2VkQmFzZXMgPSBuZXcgQXJyYXk8dHMuQmFzZVR5cGU+KCk7XG4gICAgZm9yIChsZXQgYmFzZSBvZiB0eXBlLmdldEJhc2VUeXBlcygpID8/IFtdKSB7XG4gICAgICBpZiAoanNpaVR5cGUuYmFzZSkge1xuICAgICAgICAvLyBJZ25vcmluZyB0aGlzIC0gdGhlcmUgaGFzIGFscmVhZHkgYmVlbiBhIGNvbXBpbGF0aW9uIGVycm9yIGdlbmVyYXRlZCBieSB0c2MgaGVyZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBiYXNlIGNsYXNzZXMgKFwiZXh0ZW5kcyBmb29cIilcblxuICAgICAgLy8gQ3Jhd2wgdXAgdGhlIGluaGVyaXRhbmNlIHRyZWUgaWYgdGhlIGN1cnJlbnQgYmFzZSB0eXBlIGlzIG5vdCBleHBvcnRlZCwgc28gd2UgaWRlbnRpZnkgdGhlIHR5cGUocykgdG8gYmVcbiAgICAgIC8vIGVyYXNlZCwgYW5kIGlkZW50aWZ5IHRoZSBjbG9zZXN0IGV4cG9ydGVkIGJhc2UgY2xhc3MsIHNob3VsZCB0aGVyZSBiZSBvbmUuXG4gICAgICB3aGlsZSAoYmFzZSAmJiB0aGlzLl9pc1ByaXZhdGVPckludGVybmFsKGJhc2Uuc3ltYm9sKSkge1xuICAgICAgICBMT0cuZGVidWcoXG4gICAgICAgICAgYEJhc2UgY2xhc3Mgb2YgJHtjb2xvcnMuZ3JlZW4oanNpaVR5cGUuZnFuKX0gbmFtZWQgJHtjb2xvcnMuZ3JlZW4oXG4gICAgICAgICAgICBiYXNlLnN5bWJvbC5uYW1lLFxuICAgICAgICAgICl9IGlzIG5vdCBleHBvcnRlZCwgZXJhc2luZyBpdC4uLmAsXG4gICAgICAgICk7XG4gICAgICAgIGVyYXNlZEJhc2VzLnB1c2goYmFzZSk7XG4gICAgICAgIGJhc2UgPSAoYmFzZS5nZXRCYXNlVHlwZXMoKSA/PyBbXSlbMF07XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gZXhwb3J0ZWQgYmFzZSBjbGFzcyB0byBiZSBmb3VuZCwgcHJldGVuZCB0aGlzIGNsYXNzIGhhcyBubyBiYXNlIGNsYXNzLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgIGNvbnN0IHJlZiA9IGF3YWl0IHRoaXMuX3R5cGVSZWZlcmVuY2UoXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24sXG4gICAgICAgICdiYXNlIGNsYXNzJyxcbiAgICAgICk7XG5cbiAgICAgIGlmICghc3BlYy5pc05hbWVkVHlwZVJlZmVyZW5jZShyZWYpKSB7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA2X1RZUEVfVVNFRF9BU19DTEFTUy5jcmVhdGUoXG4gICAgICAgICAgICBiYXNlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uID8/IGJhc2Uuc3ltYm9sLmRlY2xhcmF0aW9uc1swXSxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RlZmVyVW50aWxUeXBlc0F2YWlsYWJsZShcbiAgICAgICAgZnFuLFxuICAgICAgICBbcmVmXSxcbiAgICAgICAgYmFzZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbixcbiAgICAgICAgKGRlcmVmKSA9PiB7XG4gICAgICAgICAgaWYgKCFzcGVjLmlzQ2xhc3NUeXBlKGRlcmVmKSkge1xuICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA2X1RZUEVfVVNFRF9BU19DTEFTUy5jcmVhdGUoXG4gICAgICAgICAgICAgICAgYmFzZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyBiYXNlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAganNpaVR5cGUuYmFzZSA9IHJlZi5mcW47XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBiYXNlIGludGVyZmFjZXMgKFwiaW1wbGVtZW50cyBmb29cIilcblxuICAgIC8vIGNvbGxlY3QgYWxsIFwiaW1wbGVtZW50c1wiIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBjdXJyZW50IHR5cGUgYW5kIGFsbFxuICAgIC8vIGVyYXNlZCBiYXNlIHR5cGVzIChiZWNhdXNlIG90aGVyd2lzZSB3ZSBsb3NlIHRoZW0sIHNlZSBqc2lpIzQ4NylcbiAgICBjb25zdCBpbXBsZW1lbnRzQ2xhdXNlcyA9IG5ldyBBcnJheTx0cy5IZXJpdGFnZUNsYXVzZT4oKTtcbiAgICBmb3IgKGNvbnN0IGhlcml0YWdlIG9mIFt0eXBlLCAuLi5lcmFzZWRCYXNlc10ubWFwKFxuICAgICAgKHQpID0+XG4gICAgICAgICh0LnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uIGFzIHRzLkNsYXNzRGVjbGFyYXRpb24pLmhlcml0YWdlQ2xhdXNlcyA/P1xuICAgICAgICBbXSxcbiAgICApKSB7XG4gICAgICBmb3IgKGNvbnN0IGNsYXVzZSBvZiBoZXJpdGFnZSkge1xuICAgICAgICBpZiAoY2xhdXNlLnRva2VuID09PSB0cy5TeW50YXhLaW5kLkV4dGVuZHNLZXl3b3JkKSB7XG4gICAgICAgICAgLy8gSGFuZGxlZCBieSBgZ2V0QmFzZVR5cGVzYFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNsYXVzZS50b2tlbiAhPT0gdHMuU3ludGF4S2luZC5JbXBsZW1lbnRzS2V5d29yZCkge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzk5OThfVU5TVVBQT1JURURfTk9ERS5jcmVhdGUoXG4gICAgICAgICAgICAgIGNsYXVzZSxcbiAgICAgICAgICAgICAgYElnbm9yaW5nICR7dHMuU3ludGF4S2luZFtjbGF1c2UudG9rZW5dfSBoZXJpdGFnZSBjbGF1c2VgLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1wbGVtZW50c0NsYXVzZXMucHVzaChjbGF1c2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgYWxsIFwiaW1wbGVtZW50c1wiIGNsYXVzZXNcbiAgICBjb25zdCBhbGxJbnRlcmZhY2VzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgYmFzZUludGVyZmFjZXMgPSBpbXBsZW1lbnRzQ2xhdXNlcy5tYXAoKGNsYXVzZSkgPT5cbiAgICAgIHRoaXMuX3Byb2Nlc3NCYXNlSW50ZXJmYWNlcyhcbiAgICAgICAgZnFuLFxuICAgICAgICBjbGF1c2UudHlwZXMubWFwKCh0KSA9PiB0aGlzLl9nZXRUeXBlRnJvbVR5cGVOb2RlKHQpKSxcbiAgICAgICksXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IHsgaW50ZXJmYWNlcyB9IG9mIGF3YWl0IFByb21pc2UuYWxsKGJhc2VJbnRlcmZhY2VzKSkge1xuICAgICAgZm9yIChjb25zdCBpZmMgb2YgaW50ZXJmYWNlcyA/PyBbXSkge1xuICAgICAgICBhbGxJbnRlcmZhY2VzLmFkZChpZmMuZnFuKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcmZhY2VzKSB7XG4gICAgICAgIHRoaXMuX2RlZmVyVW50aWxUeXBlc0F2YWlsYWJsZShcbiAgICAgICAgICBqc2lpVHlwZS5mcW4sXG4gICAgICAgICAgaW50ZXJmYWNlcyxcbiAgICAgICAgICB0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uLFxuICAgICAgICAgICguLi5pZmFjZXMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWZhY2Ugb2YgaWZhY2VzKSB7XG4gICAgICAgICAgICAgIGlmIChzcGVjLmlzSW50ZXJmYWNlVHlwZShpZmFjZSkgJiYgaWZhY2UuZGF0YXR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA3X0lMTEVHQUxfU1RSVUNUX0VYVEVOU0lPTi5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zWzBdLFxuICAgICAgICAgICAgICAgICAgICBqc2lpVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbGxJbnRlcmZhY2VzLnNpemUgPiAwKSB7XG4gICAgICBqc2lpVHlwZS5pbnRlcmZhY2VzID0gQXJyYXkuZnJvbShhbGxJbnRlcmZhY2VzKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUuaXNDbGFzcygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09oIG5vJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYWxsRGVjbGFyYXRpb25zOiBBcnJheTx7XG4gICAgICBkZWNsOiB0cy5EZWNsYXJhdGlvbjtcbiAgICAgIHR5cGU6IHRzLkludGVyZmFjZVR5cGUgfCB0cy5CYXNlVHlwZTtcbiAgICB9PiA9IHR5cGUuc3ltYm9sLmRlY2xhcmF0aW9ucy5tYXAoKGRlY2wpID0+ICh7IGRlY2wsIHR5cGUgfSkpO1xuXG4gICAgLy8gQ29uc2lkZXJpbmcgZXJhc2VkIGJhc2VzJyBkZWNsYXJhdGlvbnMsIHRvbywgc28gdGhleSBhcmUgXCJibGVuZGVkIGluXCJcbiAgICBmb3IgKGNvbnN0IGJhc2Ugb2YgZXJhc2VkQmFzZXMpIHtcbiAgICAgIGFsbERlY2xhcmF0aW9ucy5wdXNoKFxuICAgICAgICAuLi5iYXNlLnN5bWJvbC5kZWNsYXJhdGlvbnMubWFwKChkZWNsKSA9PiAoeyBkZWNsLCB0eXBlOiBiYXNlIH0pKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7IGRlY2wsIHR5cGU6IGRlY2xhcmluZ1R5cGUgfSBvZiBhbGxEZWNsYXJhdGlvbnMpIHtcbiAgICAgIGNvbnN0IGNsYXNzRGVjbCA9IGRlY2wgYXMgdHMuQ2xhc3NEZWNsYXJhdGlvbiB8IHRzLkludGVyZmFjZURlY2xhcmF0aW9uO1xuICAgICAgaWYgKCFjbGFzc0RlY2wubWVtYmVycykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBtZW1iZXJEZWNsIG9mIGNsYXNzRGVjbC5tZW1iZXJzKSB7XG4gICAgICAgIGlmICh0cy5pc1NlbWljb2xvbkNsYXNzRWxlbWVudChtZW1iZXJEZWNsKSkge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzk5OTZfVU5ORUNFU1NBUllfVE9LRU4uY3JlYXRlKG1lbWJlckRlY2wpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZW1iZXI6IHRzLlN5bWJvbCA9IHRzLmlzQ29uc3RydWN0b3JEZWNsYXJhdGlvbihtZW1iZXJEZWNsKVxuICAgICAgICAgID8gKG1lbWJlckRlY2wgYXMgYW55KS5zeW1ib2xcbiAgICAgICAgICA6IHRoaXMuX3R5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oXG4gICAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG1lbWJlckRlY2wpISxcbiAgICAgICAgICAgICkhO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKGRlY2xhcmluZ1R5cGUuc3ltYm9sLmdldERlY2xhcmF0aW9ucygpID8/IFtdKS5maW5kKFxuICAgICAgICAgICAgKGQpID0+IGQgPT09IG1lbWJlckRlY2wucGFyZW50LFxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNQcml2YXRlT3JJbnRlcm5hbChtZW1iZXIsIG1lbWJlckRlY2wgYXMgdHMuQ2xhc3NFbGVtZW50KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3RydWN0b3JzIGFyZSBoYW5kbGVkIGxhdGVyXG4gICAgICAgIGlmICh0cy5pc0NvbnN0cnVjdG9yRGVjbGFyYXRpb24obWVtYmVyRGVjbCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0cy5pc01ldGhvZERlY2xhcmF0aW9uKG1lbWJlckRlY2wpIHx8XG4gICAgICAgICAgdHMuaXNNZXRob2RTaWduYXR1cmUobWVtYmVyRGVjbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICBhd2FpdCB0aGlzLl92aXNpdE1ldGhvZChcbiAgICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICAgIGpzaWlUeXBlLFxuICAgICAgICAgICAgY3R4LnJlcGxhY2VTdGFiaWxpdHkoanNpaVR5cGUuZG9jcz8uc3RhYmlsaXR5KSxcbiAgICAgICAgICAgIGNsYXNzRGVjbCxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHRzLmlzUHJvcGVydHlEZWNsYXJhdGlvbihtZW1iZXJEZWNsKSB8fFxuICAgICAgICAgIHRzLmlzUHJvcGVydHlTaWduYXR1cmUobWVtYmVyRGVjbCkgfHxcbiAgICAgICAgICB0cy5pc0FjY2Vzc29yKG1lbWJlckRlY2wpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgYXdhaXQgdGhpcy5fdmlzaXRQcm9wZXJ0eShcbiAgICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICAgIGpzaWlUeXBlLFxuICAgICAgICAgICAgY3R4LnJlcGxhY2VTdGFiaWxpdHkoanNpaVR5cGUuZG9jcz8uc3RhYmlsaXR5KSxcbiAgICAgICAgICAgIGNsYXNzRGVjbCxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzk5OThfVU5TVVBQT1JURURfTk9ERS5jcmVhdGUoXG4gICAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKG1lbWJlckRlY2wpID8/IG1lbWJlckRlY2wsXG4gICAgICAgICAgICAgIG1lbWJlckRlY2wua2luZCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWF3YWl0LWluLWxvb3AgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZW1iZXJFbWl0Q29udGV4dCA9IGN0eC5yZXBsYWNlU3RhYmlsaXR5KFxuICAgICAganNpaVR5cGUuZG9jcyAmJiBqc2lpVHlwZS5kb2NzLnN0YWJpbGl0eSxcbiAgICApO1xuXG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZGVmaW5lZCBjb25zdHJ1Y3RvciBpbiB0aGlzIGNsYXNzLCBvciBpdCdzIGVyYXNlZCBiYXNlc1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gW3R5cGUsIC4uLmVyYXNlZEJhc2VzXVxuICAgICAgLm1hcChnZXRDb25zdHJ1Y3RvcilcbiAgICAgIC5maW5kKChjdG9yKSA9PiBjdG9yICE9IG51bGwpO1xuICAgIGNvbnN0IGN0b3JEZWNsYXJhdGlvbiA9XG4gICAgICBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGVjbGFyYXRpb25zWzBdIGFzIHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24pO1xuICAgIGlmIChjb25zdHJ1Y3RvciAmJiBjdG9yRGVjbGFyYXRpb24pIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9XG4gICAgICAgIHRoaXMuX3R5cGVDaGVja2VyLmdldFNpZ25hdHVyZUZyb21EZWNsYXJhdGlvbihjdG9yRGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAoXG4gICAgICAgICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoY3RvckRlY2xhcmF0aW9uKSAmXG4gICAgICAgICAgdHMuTW9kaWZpZXJGbGFncy5Qcml2YXRlKSA9PT1cbiAgICAgICAgMFxuICAgICAgKSB7XG4gICAgICAgIGpzaWlUeXBlLmluaXRpYWxpemVyID0ge1xuICAgICAgICAgIGxvY2F0aW9uSW5Nb2R1bGU6IHRoaXMuZGVjbGFyYXRpb25Mb2NhdGlvbihjdG9yRGVjbGFyYXRpb24pLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBzaWduYXR1cmUuZ2V0UGFyYW1ldGVycygpKSB7XG4gICAgICAgICAgICBqc2lpVHlwZS5pbml0aWFsaXplci5wYXJhbWV0ZXJzID1cbiAgICAgICAgICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIucGFyYW1ldGVycyA/PyBbXTtcbiAgICAgICAgICAgIGpzaWlUeXBlLmluaXRpYWxpemVyLnBhcmFtZXRlcnMucHVzaChcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdG9QYXJhbWV0ZXIoXG4gICAgICAgICAgICAgICAgcGFyYW0sXG4gICAgICAgICAgICAgICAgY3R4LnJlcGxhY2VTdGFiaWxpdHkoanNpaVR5cGUuZG9jcz8uc3RhYmlsaXR5KSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBqc2lpVHlwZS5pbml0aWFsaXplci52YXJpYWRpYyA9XG4gICAgICAgICAgICAgIGpzaWlUeXBlLmluaXRpYWxpemVyPy5wYXJhbWV0ZXJzPy5zb21lKChwKSA9PiAhIXAudmFyaWFkaWMpIHx8XG4gICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGpzaWlUeXBlLmluaXRpYWxpemVyLnByb3RlY3RlZCA9XG4gICAgICAgICAgICAgICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoY3RvckRlY2xhcmF0aW9uKSAmXG4gICAgICAgICAgICAgICAgdHMuTW9kaWZpZXJGbGFncy5Qcm90ZWN0ZWQpICE9PVxuICAgICAgICAgICAgICAgIDAgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92ZXJpZnlDb25zZWN1dGl2ZU9wdGlvbmFscyhcbiAgICAgICAgICBjdG9yRGVjbGFyYXRpb24sXG4gICAgICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIucGFyYW1ldGVycyxcbiAgICAgICAgKTtcbiAgICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIuZG9jcyA9IHRoaXMuX3Zpc2l0RG9jdW1lbnRhdGlvbihcbiAgICAgICAgICBjb25zdHJ1Y3RvcixcbiAgICAgICAgICBtZW1iZXJFbWl0Q29udGV4dCxcbiAgICAgICAgKS5kb2NzO1xuICAgICAgICB0aGlzLm92ZXJyaWRlRG9jQ29tbWVudChcbiAgICAgICAgICBjb25zdHJ1Y3RvcixcbiAgICAgICAgICBqc2lpVHlwZS5pbml0aWFsaXplci5kb2NzLFxuICAgICAgICAgIHBhcmFtRG9jcyhqc2lpVHlwZS5pbml0aWFsaXplci5wYXJhbWV0ZXJzKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJvY2VzcyBjb25zdHJ1Y3Rvci1iYXNlZCBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgZXZlbiBpZiBjb25zdHJ1Y3RvciBpcyBwcml2YXRlXG4gICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2Ygc2lnbmF0dXJlLmdldFBhcmFtZXRlcnMoKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRzLmlzUGFyYW1ldGVyUHJvcGVydHlEZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgcGFyYW0udmFsdWVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgcGFyYW0udmFsdWVEZWNsYXJhdGlvbi5wYXJlbnQsXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICAhdGhpcy5faXNQcml2YXRlT3JJbnRlcm5hbChwYXJhbSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl92aXNpdFByb3BlcnR5KFxuICAgICAgICAgICAgICBwYXJhbSxcbiAgICAgICAgICAgICAganNpaVR5cGUsXG4gICAgICAgICAgICAgIG1lbWJlckVtaXRDb250ZXh0LFxuICAgICAgICAgICAgICBjdG9yRGVjbGFyYXRpb24ucGFyZW50LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGpzaWlUeXBlLmJhc2UpIHtcbiAgICAgIHRoaXMuX2RlZmVyVW50aWxUeXBlc0F2YWlsYWJsZShcbiAgICAgICAgZnFuLFxuICAgICAgICBbanNpaVR5cGUuYmFzZV0sXG4gICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24sXG4gICAgICAgIChiYXNlVHlwZSkgPT4ge1xuICAgICAgICAgIGlmIChzcGVjLmlzQ2xhc3NUeXBlKGJhc2VUeXBlKSkge1xuICAgICAgICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIgPSBiYXNlVHlwZS5pbml0aWFsaXplcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zOTk5X0lOQ09IRVJFTlRfVFlQRV9NT0RFTC5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgYEJhc2UgdHlwZSBvZiAke2pzaWlUeXBlLmZxbn0gKCR7anNpaVR5cGUuYmFzZX0pIGlzIG5vdCBhIGNsYXNzYCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAganNpaVR5cGUuaW5pdGlhbGl6ZXIgPSB7XG4gICAgICAgIGRvY3M6IGN0eC5zdGFiaWxpdHkgJiYgeyBzdGFiaWxpdHk6IGN0eC5zdGFiaWxpdHkgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5fdmVyaWZ5Tm9TdGF0aWNNaXhpbmcoanNpaVR5cGUsIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24pO1xuXG4gICAgdGhpcy5vdmVycmlkZURvY0NvbW1lbnQodHlwZS5nZXRTeW1ib2woKSwganNpaVR5cGU/LmRvY3MpO1xuXG4gICAgcmV0dXJuIF9zb3J0TWVtYmVycyhqc2lpVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBUeXBlQ2hlY2tlcidzIGdldFR5cGVGcm9tVHlwZU5vZGUsIGJ1dCB0aHJvdyBhIGRlc2NyaXB0aXZlIGVycm9yIGlmIGl0IGZhaWxzXG4gICAqL1xuICBwcml2YXRlIF9nZXRUeXBlRnJvbVR5cGVOb2RlKHQ6IHRzLlR5cGVOb2RlKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuX3R5cGVDaGVja2VyLmdldFR5cGVGcm9tVHlwZU5vZGUodCk7XG4gICAgaWYgKGlzRXJyb3JUeXBlKHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbmFibGUgdG8gcmVzb2x2ZSB0eXBlOiAke3QuZ2V0RnVsbFRleHQoKX0uIFRoaXMgdHlwaWNhbGx5IGhhcHBlbnMgaWYgc29tZXRoaW5nIGlzIHdyb25nIHdpdGggeW91ciBkZXBlbmRlbmN5IGNsb3N1cmUuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoYXQgdGhpcyBjbGFzcyBkb2Vzbid0IGRlY2xhcmUgYW55IG1lbWJlcnMgdGhhdCBhcmUgb2YgZGlmZmVyZW50IHN0YXRpY25lc3MgaW4gaXRzZWxmIG9yIGFueSBvZiBpdHMgYmFzZXNcbiAgICovXG4gIHByaXZhdGUgX3ZlcmlmeU5vU3RhdGljTWl4aW5nKGtsYXNzOiBzcGVjLkNsYXNzVHlwZSwgZGVjbDogdHMuRGVjbGFyYXRpb24pIHtcbiAgICAvLyBDaGVjayBjbGFzcyBpdHNlbGYtLW1heSBoYXZlIHR3byBtZXRob2RzL3Byb3BzIHdpdGggdGhlIHNhbWUgbmFtZSwgc28gY2hlY2sgdGhlIGFycmF5c1xuICAgIGNvbnN0IHN0YXRpY3MgPSBuZXcgU2V0KFxuICAgICAgKGtsYXNzLm1ldGhvZHMgPz8gW10pXG4gICAgICAgIC5jb25jYXQoa2xhc3MucHJvcGVydGllcyA/PyBbXSlcbiAgICAgICAgLmZpbHRlcigoeCkgPT4geC5zdGF0aWMpXG4gICAgICAgIC5tYXAoKHgpID0+IHgubmFtZSksXG4gICAgKTtcbiAgICBjb25zdCBub25TdGF0aWNzID0gbmV3IFNldChcbiAgICAgIChrbGFzcy5tZXRob2RzID8/IFtdKVxuICAgICAgICAuY29uY2F0KGtsYXNzLnByb3BlcnRpZXMgPz8gW10pXG4gICAgICAgIC5maWx0ZXIoKHgpID0+ICF4LnN0YXRpYylcbiAgICAgICAgLm1hcCgoeCkgPT4geC5uYW1lKSxcbiAgICApO1xuICAgIC8vIEludGVyc2VjdFxuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGludGVyc2VjdChzdGF0aWNzLCBub25TdGF0aWNzKSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDEzX1NUQVRJQ19JTlNUQU5DRV9DT05GTElDVC5jcmVhdGUoXG4gICAgICAgICAgZGVjbCxcbiAgICAgICAgICBtZW1iZXIsXG4gICAgICAgICAga2xhc3MsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFnYWluc3QgYmFzZSBjbGFzc2VzLiBUaGV5IHdpbGwgbm90IGNvbnRhaW4gZHVwbGljYXRlIG1lbWJlciBuYW1lcyBzbyB3ZSBjYW4gbG9hZFxuICAgIC8vIHRoZSBtZW1iZXJzIGludG8gYSBtYXAuXG4gICAgY29uc3QgY2xhc3NNZW1iZXJzID0gdHlwZU1lbWJlcnMoa2xhc3MpO1xuICAgIHRoaXMuX3dpdGhCYXNlQ2xhc3Moa2xhc3MsIGRlY2wsIChiYXNlLCByZWN1cnNlKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCBiYXNlTWVtYmVyXSBvZiBPYmplY3QuZW50cmllcyh0eXBlTWVtYmVycyhiYXNlKSkpIHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gY2xhc3NNZW1iZXJzW25hbWVdO1xuICAgICAgICBpZiAoIW1lbWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhYmFzZU1lbWJlci5zdGF0aWMgIT09ICEhbWVtYmVyLnN0YXRpYykge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzUwMTRfSU5IRVJJVEVEX1NUQVRJQ19DT05GTElDVC5jcmVhdGUoXG4gICAgICAgICAgICAgIGRlY2wsXG4gICAgICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICAgICAga2xhc3MsXG4gICAgICAgICAgICAgIGJhc2VNZW1iZXIsXG4gICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVjdXJzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIF9kZWZlclVudGlsVHlwZXNBdmFpbGFibGUsIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgZ2l2ZW4gY2xhc3NlcycgYmFzZSB0eXBlXG4gICAqXG4gICAqIERvZXMgbm90aGluZyBpZiB0aGUgZ2l2ZW4gY2xhc3MgZG9lc24ndCBoYXZlIGEgYmFzZSBjbGFzcy5cbiAgICpcbiAgICogVGhlIHNlY29uZCBhcmd1bWVudCB3aWxsIGJlIGEgYHJlY3Vyc2VgIGZ1bmN0aW9uIGZvciBlYXN5IHJlY3Vyc2lvbiB1cCB0aGUgaW5oZXJpdGFuY2UgdHJlZVxuICAgKiAobm8gbWVzc2luZyBhcm91bmQgd2l0aCBiaW5kaW5nICdzZWxmJyBhbmQgJ3RoaXMnIGFuZCBkb2luZyBtdWx0aXBsZSBjYWxscyB0byBfd2l0aEJhc2VDbGFzcy4pXG4gICAqL1xuICBwcml2YXRlIF93aXRoQmFzZUNsYXNzKFxuICAgIGtsYXNzOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBkZWNsOiB0cy5EZWNsYXJhdGlvbixcbiAgICBjYjogKGJhc2U6IHNwZWMuQ2xhc3NUeXBlLCByZWN1cnNlOiAoKSA9PiB2b2lkKSA9PiB2b2lkLFxuICApIHtcbiAgICBpZiAoa2xhc3MuYmFzZSkge1xuICAgICAgdGhpcy5fZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKGtsYXNzLmZxbiwgW2tsYXNzLmJhc2VdLCBkZWNsLCAoYmFzZSkgPT4ge1xuICAgICAgICBpZiAoIXNwZWMuaXNDbGFzc1R5cGUoYmFzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09oIG5vJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2IoYmFzZSwgKCkgPT4gdGhpcy5fd2l0aEJhc2VDbGFzcyhiYXNlLCBkZWNsLCBjYikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBtZW1iZXIgaXMgaW50ZXJuYWwgYW5kIHNob3VsZCBiZSBvbWl0dGVkIGZyb20gdGhlIHR5cGUgbWFuaWZlc3RcbiAgICovXG4gIHByaXZhdGUgX2lzUHJpdmF0ZU9ySW50ZXJuYWwoXG4gICAgc3ltYm9sOiB0cy5TeW1ib2wsXG4gICAgdmFsaWRhdGVEZWNsYXJhdGlvbj86IHRzLkRlY2xhcmF0aW9uLFxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBoYXNJbnRlcm5hbEpzRG9jVGFnID0gX2hhc0ludGVybmFsSnNEb2NUYWcoc3ltYm9sKTtcbiAgICBjb25zdCBoYXNVbmRlcnNjb3JlUHJlZml4ID1cbiAgICAgIHN5bWJvbC5uYW1lICE9PSAnX19jb25zdHJ1Y3RvcicgJiYgc3ltYm9sLm5hbWUuc3RhcnRzV2l0aCgnXycpO1xuXG4gICAgaWYgKF9pc1ByaXZhdGUoc3ltYm9sKSkge1xuICAgICAgTE9HLnRyYWNlKFxuICAgICAgICBgJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgKX0gaXMgbWFya2VkIFwicHJpdmF0ZVwiLCBvciBpcyBhbiB1bmV4cG9ydGVkIHR5cGUgZGVjbGFyYXRpb25gLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaGFzSW50ZXJuYWxKc0RvY1RhZyAmJiAhaGFzVW5kZXJzY29yZVByZWZpeCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdlIG9ubHkgdmFsaWRhdGUgaWYgd2UgaGF2ZSBhIGRlY2xhcmF0aW9uXG4gICAgaWYgKHZhbGlkYXRlRGVjbGFyYXRpb24pIHtcbiAgICAgIGlmICghaGFzVW5kZXJzY29yZVByZWZpeCkge1xuICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfODAwNV9JTlRFUk5BTF9VTkRFUlNDT1JFLmNyZWF0ZShcbiAgICAgICAgICAgIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKHZhbGlkYXRlRGVjbGFyYXRpb24pID8/IHZhbGlkYXRlRGVjbGFyYXRpb24sXG4gICAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc0ludGVybmFsSnNEb2NUYWcpIHtcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzgwMDZfVU5ERVJTQ09SRV9JTlRFUk5BTC5jcmVhdGUoXG4gICAgICAgICAgICB0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbih2YWxpZGF0ZURlY2xhcmF0aW9uKSA/PyB2YWxpZGF0ZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgc3ltYm9sLm5hbWUsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3Zpc2l0RW51bShcbiAgICB0eXBlOiB0cy5UeXBlLFxuICAgIGN0eDogRW1pdENvbnRleHQsXG4gICk6IFByb21pc2U8c3BlYy5FbnVtVHlwZSB8IHVuZGVmaW5lZD4ge1xuICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgTE9HLnRyYWNlKFxuICAgICAgICBgUHJvY2Vzc2luZyBlbnVtOiAke2NvbG9ycy5ncmF5KGN0eC5uYW1lc3BhY2Uuam9pbignLicpKX0uJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICB0eXBlLnN5bWJvbC5uYW1lLFxuICAgICAgICApfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZvcmNlZnVsbHkgcmVzb2x2aW5nIHRvIHRoZSBFbnVtRGVjbGFyYXRpb24gc3ltYm9sIGZvciBzaW5nbGUtdmFsdWVkIGVudW1zXG4gICAgbGV0IGRlY2w6IHRzLk5vZGUgfCB1bmRlZmluZWQgPSB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF07XG4gICAgbGV0IHN5bWJvbDogdHMuU3ltYm9sIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0cy5pc0VudW1NZW1iZXIoZGVjbCkpIHtcbiAgICAgIGRlY2wgPSBkZWNsPy5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICh0cy5pc0VudW1EZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgc3ltYm9sID0gZ2V0U3ltYm9sRnJvbURlY2xhcmF0aW9uKGRlY2wsIHRoaXMuX3R5cGVDaGVja2VyKTtcbiAgICB9XG4gICAgaWYgKCFkZWNsIHx8ICFzeW1ib2wgfHwgIXRzLmlzRW51bURlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbmFibGUgdG8gcmVzb2x2ZSBlbnVtIGRlY2xhcmF0aW9uIGZvciAke3R5cGUuc3ltYm9sLm5hbWV9IWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChfaGFzSW50ZXJuYWxKc0RvY1RhZyhzeW1ib2wpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2FybkFib3V0UmVzZXJ2ZWRXb3JkcyhzeW1ib2wpO1xuXG4gICAgY29uc3QgZmxhZ3MgPSB0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoZGVjbCk7XG4gICAgaWYgKGZsYWdzICYgdHMuTW9kaWZpZXJGbGFncy5Db25zdCkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8xMDAwX05PX0NPTlNUX0VOVU0uY3JlYXRlKFxuICAgICAgICAgIGRlY2wubW9kaWZpZXJzPy5maW5kKFxuICAgICAgICAgICAgKG1vZCkgPT4gbW9kLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29uc3RLZXl3b3JkLFxuICAgICAgICAgICkgPz8gZGVjbCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBkb2NzIH0gPSB0aGlzLl92aXNpdERvY3VtZW50YXRpb24oc3ltYm9sLCBjdHgpO1xuXG4gICAgY29uc3QgdHlwZUNvbnRleHQgPSBjdHgucmVwbGFjZVN0YWJpbGl0eShkb2NzPy5zdGFiaWxpdHkpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0eXBlLmlzVW5pb24oKSA/IHR5cGUudHlwZXMgOiBbdHlwZV07XG5cbiAgICBjb25zdCBqc2lpVHlwZTogc3BlYy5FbnVtVHlwZSA9IGJpbmRpbmdzLnNldEVudW1SZWxhdGVkTm9kZShcbiAgICAgIHtcbiAgICAgICAgYXNzZW1ibHk6IHRoaXMucHJvamVjdEluZm8ubmFtZSxcbiAgICAgICAgZnFuOiBgJHtbdGhpcy5wcm9qZWN0SW5mby5uYW1lLCAuLi5jdHgubmFtZXNwYWNlXS5qb2luKCcuJyl9LiR7XG4gICAgICAgICAgc3ltYm9sLm5hbWVcbiAgICAgICAgfWAsXG4gICAgICAgIGtpbmQ6IHNwZWMuVHlwZUtpbmQuRW51bSxcbiAgICAgICAgbWVtYmVyczogbWVtYmVycy5tYXAoKG0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRvY3MgfSA9IHRoaXMuX3Zpc2l0RG9jdW1lbnRhdGlvbihtLnN5bWJvbCwgdHlwZUNvbnRleHQpO1xuICAgICAgICAgIHRoaXMub3ZlcnJpZGVEb2NDb21tZW50KG0uc3ltYm9sLCBkb2NzKTtcbiAgICAgICAgICByZXR1cm4geyBuYW1lOiBtLnN5bWJvbC5uYW1lLCBkb2NzIH07XG4gICAgICAgIH0pLFxuICAgICAgICBuYW1lOiBzeW1ib2wubmFtZSxcbiAgICAgICAgbmFtZXNwYWNlOlxuICAgICAgICAgIGN0eC5uYW1lc3BhY2UubGVuZ3RoID4gMCA/IGN0eC5uYW1lc3BhY2Uuam9pbignLicpIDogdW5kZWZpbmVkLFxuICAgICAgICBkb2NzLFxuXG4gICAgICAgIC8vIFNldCBTeW1ib2xJZCBoZXJlIGluc3RlYWQgb2YgbGF0ZXIsIGFzIGJ5IGRlZmF1bHQgVFMgd2lsbCBwaWNrIHNpbmdsZS1lbnVtIG1lbWJlcnNcbiAgICAgICAgLy8gYXMgdGhlIHRhcmdldCBzeW1ib2wgaWYgcG9zc2libGUuXG4gICAgICAgIHN5bWJvbElkOiBzeW1ib2xJZGVudGlmaWVyKHRoaXMuX3R5cGVDaGVja2VyLCBzeW1ib2wpLFxuICAgICAgfSxcbiAgICAgIGRlY2wsXG4gICAgKTtcblxuICAgIHRoaXMub3ZlcnJpZGVEb2NDb21tZW50KHR5cGUuZ2V0U3ltYm9sKCksIGpzaWlUeXBlPy5kb2NzKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoanNpaVR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBkb2NzIGZvciBhIHN5bWJvbFxuICAgKi9cbiAgcHJpdmF0ZSBfdmlzaXREb2N1bWVudGF0aW9uKFxuICAgIHN5bTogdHMuU3ltYm9sLFxuICAgIGNvbnRleHQ6IEVtaXRDb250ZXh0LFxuICApOiB7IHJlYWRvbmx5IGRvY3M/OiBzcGVjLkRvY3M7IHJlYWRvbmx5IGhpbnRzOiBUeXBlU3lzdGVtSGludHMgfSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VTeW1ib2xEb2N1bWVudGF0aW9uKHN5bSwgdGhpcy5fdHlwZUNoZWNrZXIpO1xuXG4gICAgZm9yIChjb25zdCBkaWFnIG9mIHJlc3VsdC5kaWFnbm9zdGljcyA/PyBbXSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV83OTk5X0RPQ1VNRU5UQVRJT05fRVJST1IuY3JlYXRlKFxuICAgICAgICAgIHN5bS52YWx1ZURlY2xhcmF0aW9uID8/IHN5bS5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgZGlhZyxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjbCA9IHN5bS52YWx1ZURlY2xhcmF0aW9uID8/IHN5bS5kZWNsYXJhdGlvbnNbMF07XG4gICAgLy8gVGhlIEBzdHJ1Y3QgaGludCBpcyBvbmx5IHZhbGlkIGZvciBpbnRlcmZhY2UgZGVjbGFyYXRpb25zXG4gICAgaWYgKCF0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uKGRlY2wpICYmIHJlc3VsdC5oaW50cy5zdHJ1Y3QpIHtcbiAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfNzAwMV9JTExFR0FMX0hJTlQuY3JlYXRlKFxuICAgICAgICAgIF9maW5kSGludChkZWNsLCAnc3RydWN0JykhLFxuICAgICAgICAgICdzdHJ1Y3QnLFxuICAgICAgICAgICdpbnRlcmZhY2VzIHdpdGggb25seSByZWFkb25seSBwcm9wZXJ0aWVzJyxcbiAgICAgICAgKVxuICAgICAgICAgIC5hZGRSZWxhdGVkSW5mb3JtYXRpb24oXG4gICAgICAgICAgICB0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbihkZWNsKSA/PyBkZWNsLFxuICAgICAgICAgICAgJ1RoZSBhbm5vdGF0ZWQgZGVjbGFyYXRpb24gaXMgaGVyZScsXG4gICAgICAgICAgKVxuICAgICAgICAgIC5wcmVmb3JtYXQodGhpcy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdCksXG4gICAgICApO1xuICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJhZCBoaW50Li4uXG4gICAgICBkZWxldGUgKHJlc3VsdC5oaW50cyBhcyBhbnkpLnN0cnVjdDtcbiAgICB9XG5cbiAgICAvLyBBcHBseSB0aGUgY3VycmVudCBjb250ZXh0J3Mgc3RhYmlsaXR5IGlmIG5vbmUgd2FzIHNwZWNpZmllZCBsb2NhbGx5LlxuICAgIGlmIChyZXN1bHQuZG9jcy5zdGFiaWxpdHkgPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmRvY3Muc3RhYmlsaXR5ID0gY29udGV4dC5zdGFiaWxpdHk7XG4gICAgfVxuXG4gICAgY29uc3QgYWxsVW5kZWZpbmVkID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQuZG9jcykuZXZlcnkoXG4gICAgICAodikgPT4gdiA9PT0gdW5kZWZpbmVkLFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvY3M6ICFhbGxVbmRlZmluZWQgPyByZXN1bHQuZG9jcyA6IHVuZGVmaW5lZCxcbiAgICAgIGhpbnRzOiByZXN1bHQuaGludHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGF0IGFsbCBwYXJhbWV0ZXJzIHRoZSBkb2MgYmxvY2sgcmVmZXJzIHRvIHdpdGggYSBAcGFyYW0gZGVjbGFyYXRpb24gYWN0dWFsbHkgZXhpc3RcbiAgICovXG4gIHByaXZhdGUgX3ZhbGlkYXRlUmVmZXJlbmNlZERvY1BhcmFtcyhcbiAgICBtZXRob2Q6IHNwZWMuTWV0aG9kLFxuICAgIG1ldGhvZFN5bTogdHMuU3ltYm9sLFxuICApIHtcbiAgICBjb25zdCBwYXJhbXMgPSBnZXRSZWZlcmVuY2VkRG9jUGFyYW1zKG1ldGhvZFN5bSk7XG4gICAgY29uc3QgYWN0dWFsTmFtZXMgPSBuZXcgU2V0KChtZXRob2QucGFyYW1ldGVycyA/PyBbXSkubWFwKChwKSA9PiBwLm5hbWUpKTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgaWYgKCFhY3R1YWxOYW1lcy5oYXMocGFyYW0pKSB7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV83MDAwX05PTl9FWElTVEVOVF9QQVJBTUVURVIuY3JlYXRlKFxuICAgICAgICAgICAgbWV0aG9kU3ltLnZhbHVlRGVjbGFyYXRpb24gPz8gbWV0aG9kU3ltLmRlY2xhcmF0aW9uc1swXSxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfdmlzaXRJbnRlcmZhY2UoXG4gICAgdHlwZTogdHMuVHlwZSxcbiAgICBjdHg6IEVtaXRDb250ZXh0LFxuICApOiBQcm9taXNlPHNwZWMuSW50ZXJmYWNlVHlwZSB8IHVuZGVmaW5lZD4ge1xuICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgTE9HLnRyYWNlKFxuICAgICAgICBgUHJvY2Vzc2luZyBpbnRlcmZhY2U6ICR7Y29sb3JzLmdyYXkoXG4gICAgICAgICAgY3R4Lm5hbWVzcGFjZS5qb2luKCcuJyksXG4gICAgICAgICl9LiR7Y29sb3JzLmN5YW4odHlwZS5zeW1ib2wubmFtZSl9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNJbnRlcm5hbEpzRG9jVGFnKHR5cGUuc3ltYm9sKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl93YXJuQWJvdXRSZXNlcnZlZFdvcmRzKHR5cGUuc3ltYm9sKTtcblxuICAgIGNvbnN0IGZxbiA9IGAke1t0aGlzLnByb2plY3RJbmZvLm5hbWUsIC4uLmN0eC5uYW1lc3BhY2VdLmpvaW4oJy4nKX0uJHtcbiAgICAgIHR5cGUuc3ltYm9sLm5hbWVcbiAgICB9YDtcblxuICAgIGNvbnN0IHsgZG9jcywgaGludHMgfSA9IHRoaXMuX3Zpc2l0RG9jdW1lbnRhdGlvbih0eXBlLnN5bWJvbCwgY3R4KTtcbiAgICBjb25zdCBqc2lpVHlwZTogc3BlYy5JbnRlcmZhY2VUeXBlID0gYmluZGluZ3Muc2V0SW50ZXJmYWNlUmVsYXRlZE5vZGUoXG4gICAgICB7XG4gICAgICAgIGFzc2VtYmx5OiB0aGlzLnByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIGZxbixcbiAgICAgICAga2luZDogc3BlYy5UeXBlS2luZC5JbnRlcmZhY2UsXG4gICAgICAgIG5hbWU6IHR5cGUuc3ltYm9sLm5hbWUsXG4gICAgICAgIG5hbWVzcGFjZTpcbiAgICAgICAgICBjdHgubmFtZXNwYWNlLmxlbmd0aCA+IDAgPyBjdHgubmFtZXNwYWNlLmpvaW4oJy4nKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9jcyxcbiAgICAgIH0sXG4gICAgICB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnNbMF0gYXMgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgKTtcblxuICAgIGNvbnN0IHsgaW50ZXJmYWNlcywgZXJhc2VkQmFzZXMgfSA9IGF3YWl0IHRoaXMuX3Byb2Nlc3NCYXNlSW50ZXJmYWNlcyhcbiAgICAgIGZxbixcbiAgICAgIHR5cGUuZ2V0QmFzZVR5cGVzKCksXG4gICAgKTtcbiAgICBqc2lpVHlwZS5pbnRlcmZhY2VzID0gYXBwbHkoaW50ZXJmYWNlcywgKGFycikgPT4gYXJyLm1hcCgoaSkgPT4gaS5mcW4pKTtcblxuICAgIGZvciAoY29uc3QgZGVjbGFyaW5nVHlwZSBvZiBbdHlwZSwgLi4uZXJhc2VkQmFzZXNdKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBkZWNsYXJpbmdUeXBlLmdldFByb3BlcnRpZXMoKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIShkZWNsYXJpbmdUeXBlLnN5bWJvbC5nZXREZWNsYXJhdGlvbnMoKSA/PyBbXSkuZmluZChcbiAgICAgICAgICAgIChkZWNsKSA9PiBkZWNsID09PSBtZW1iZXIudmFsdWVEZWNsYXJhdGlvbj8ucGFyZW50LFxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5faXNQcml2YXRlT3JJbnRlcm5hbChcbiAgICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICAgIG1lbWJlci52YWx1ZURlY2xhcmF0aW9uIGFzIHRzLlByb3BlcnR5RGVjbGFyYXRpb24sXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0cy5pc01ldGhvZERlY2xhcmF0aW9uKG1lbWJlci52YWx1ZURlY2xhcmF0aW9uKSB8fFxuICAgICAgICAgIHRzLmlzTWV0aG9kU2lnbmF0dXJlKG1lbWJlci52YWx1ZURlY2xhcmF0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgIGF3YWl0IHRoaXMuX3Zpc2l0TWV0aG9kKFxuICAgICAgICAgICAgbWVtYmVyLFxuICAgICAgICAgICAganNpaVR5cGUsXG4gICAgICAgICAgICBjdHgucmVwbGFjZVN0YWJpbGl0eShqc2lpVHlwZS5kb2NzPy5zdGFiaWxpdHkpLFxuICAgICAgICAgICAgKHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz9cbiAgICAgICAgICAgICAgdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zWzBdKSBhcyB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHRzLmlzUHJvcGVydHlEZWNsYXJhdGlvbihtZW1iZXIudmFsdWVEZWNsYXJhdGlvbikgfHxcbiAgICAgICAgICB0cy5pc1Byb3BlcnR5U2lnbmF0dXJlKG1lbWJlci52YWx1ZURlY2xhcmF0aW9uKSB8fFxuICAgICAgICAgIHRzLmlzQWNjZXNzb3IobWVtYmVyLnZhbHVlRGVjbGFyYXRpb24pXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgYXdhaXQgdGhpcy5fdmlzaXRQcm9wZXJ0eShcbiAgICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICAgIGpzaWlUeXBlLFxuICAgICAgICAgICAgY3R4LnJlcGxhY2VTdGFiaWxpdHkoanNpaVR5cGUuZG9jcz8uc3RhYmlsaXR5KSxcbiAgICAgICAgICAgICh0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uID8/XG4gICAgICAgICAgICAgIHR5cGUuc3ltYm9sLmRlY2xhcmF0aW9uc1swXSkgYXMgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV85OTk4X1VOU1VQUE9SVEVEX05PREUuY3JlYXRlKFxuICAgICAgICAgICAgICBfbmFtZU9yRGVjbGFyYXRpb25Ob2RlKG1lbWJlciksXG4gICAgICAgICAgICAgIChtZW1iZXIudmFsdWVEZWNsYXJhdGlvbiA/PyBtZW1iZXIuZGVjbGFyYXRpb25zWzBdKS5raW5kLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGRhdGF0eXBlIGJhc2VkIG9uIHRoZSBkYXRhdHlwZW5lc3Mgb2YgdGhpcyBpbnRlcmZhY2UgYW5kIGFsbCBvZiBpdHMgcGFyZW50c1xuICAgIC8vIFRvIGtlZXAgdGhlIHNwZWMgbWluaW1hbCB0aGUgYWN0dWFsIHZhbHVlcyBvZiB0aGUgYXR0cmlidXRlIGFyZSBcInRydWVcIiBvciBcInVuZGVmaW5lZFwiICh0byByZXByZXNlbnQgXCJmYWxzZVwiKS5cbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9XG4gICAgICB0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uID8/IHR5cGUuc3ltYm9sLmRlY2xhcmF0aW9uc1swXTtcbiAgICB0aGlzLl9kZWZlclVudGlsVHlwZXNBdmFpbGFibGUoXG4gICAgICBmcW4sXG4gICAgICBqc2lpVHlwZS5pbnRlcmZhY2VzID8/IFtdLFxuICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAoLi4uYmFzZXM6IHNwZWMuVHlwZVtdKSA9PiB7XG4gICAgICAgIGlmICgoanNpaVR5cGUubWV0aG9kcyA/PyBbXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAganNpaVR5cGUuZGF0YXR5cGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGhpbnRzLnN0cnVjdCkge1xuICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICBqc2lpVHlwZS5tZXRob2RzIS5yZWR1Y2UoXG4gICAgICAgICAgICAgIChkaWFnLCBtdGhvZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBiaW5kaW5ncy5nZXRNZXRob2RSZWxhdGVkTm9kZShtdGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgICAgICAgICAgID8gZGlhZy5hZGRSZWxhdGVkSW5mb3JtYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgdHMuZ2V0TmFtZU9mRGVjbGFyYXRpb24obm9kZSkgPz8gbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBgQSBtZXRob2QgaXMgZGVjbGFyZWQgaGVyZWAsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogZGlhZztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV83MDAxX0lMTEVHQUxfSElOVC5jcmVhdGUoXG4gICAgICAgICAgICAgICAgX2ZpbmRIaW50KGRlY2xhcmF0aW9uLCAnc3RydWN0JykhLFxuICAgICAgICAgICAgICAgICdzdHJ1Y3QnLFxuICAgICAgICAgICAgICAgICdpbnRlcmZhY2VzIHdpdGggb25seSByZWFkb25seSBwcm9wZXJ0aWVzJyxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5hZGRSZWxhdGVkSW5mb3JtYXRpb24oXG4gICAgICAgICAgICAgICAgICB0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikgPz8gZGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgICAgICAnVGhlIGFubm90YXRlZCBkZWNsYXJ0aW9uIGlzIGhlcmUnLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAucHJlZm9ybWF0KHRoaXMucHJvamVjdEluZm8ucHJvamVjdFJvb3QpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBiYXNlIG9mIGJhc2VzKSB7XG4gICAgICAgICAgaWYgKHNwZWMuaXNJbnRlcmZhY2VUeXBlKGJhc2UpICYmICFiYXNlLmRhdGF0eXBlKSB7XG4gICAgICAgICAgICBqc2lpVHlwZS5kYXRhdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbnRlcmZhY2VOYW1lID0gaXNJbnRlcmZhY2VOYW1lKGpzaWlUeXBlLm5hbWUpO1xuXG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGEgZGF0YXR5cGUgdGhlIG5hbWUgbXVzdCBzdGFydCB3aXRoIGFuIFwiSVwiLlxuICAgICAgICBpZiAoIWpzaWlUeXBlLmRhdGF0eXBlICYmICFpbnRlcmZhY2VOYW1lKSB7XG4gICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfODAwN19CRUhBVklPUkFMX0lOVEVSRkFDRV9OQU1FLmNyZWF0ZShcbiAgICAgICAgICAgICAgdHMuZ2V0TmFtZU9mRGVjbGFyYXRpb24oZGVjbGFyYXRpb24pID8/IGRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICBqc2lpVHlwZS5uYW1lLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIG5hbWUgc3RhcnRzIHdpdGggYW4gXCJJXCIgaXQgaXMgbm90IGludGVuZGVkIGFzIGEgZGF0YXR5cGUsIHNvIHN3aXRjaCB0aGF0IG9mZixcbiAgICAgICAgLy8gdW5sZXNzIGEgVFNEb2MgaGludCB3YXMgc2V0IHRvIGZvcmNlIHRoaXMgdG8gYmUgY29uc2lkZXJlZCBhIGJlaGF2aW9yYWwgaW50ZXJmYWNlLlxuICAgICAgICBpZiAoanNpaVR5cGUuZGF0YXR5cGUgJiYgaW50ZXJmYWNlTmFtZSAmJiAhaGludHMuc3RydWN0KSB7XG4gICAgICAgICAgZGVsZXRlIGpzaWlUeXBlLmRhdGF0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2theSwgdGhpcyBpcyBhIGRhdGEgdHlwZSwgY2hlY2sgdGhhdCBhbGwgcHJvcGVydGllcyBhcmUgcmVhZG9ubHlcbiAgICAgICAgaWYgKGpzaWlUeXBlLmRhdGF0eXBlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGpzaWlUeXBlLnByb3BlcnRpZXMgPz8gW10pIHtcbiAgICAgICAgICAgIGlmICghcHJvcC5pbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IHR5cGUuZ2V0UHJvcGVydHkocHJvcC5uYW1lKSE7XG4gICAgICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA4X1NUUlVDVF9QUk9QU19NVVNUX0JFX1JFQURPTkxZLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIF9uYW1lT3JEZWNsYXJhdGlvbk5vZGUocCksXG4gICAgICAgICAgICAgICAgICBwLm5hbWUsXG4gICAgICAgICAgICAgICAgICBqc2lpVHlwZSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIC8vIGZvcmNlIHByb3BlcnR5IHRvIGJlIFwicmVhZG9ubHlcIiBzaW5jZSBqc2lpIGxhbmd1YWdlcyB3aWxsIHBhc3MgdGhpcyBieS12YWx1ZVxuICAgICAgICAgICAgICBwcm9wLmltbXV0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgaXMgKk5PVCogYSBkYXRhIHR5cGUsIHNvIGl0IG1heSBub3QgZXh0ZW5kIHNvbWV0aGluZyB0aGF0IGlzIG9uZS5cbiAgICAgICAgICBmb3IgKGNvbnN0IGJhc2Ugb2YgYmFzZXMpIHtcbiAgICAgICAgICAgIGlmICghc3BlYy5pc0ludGVyZmFjZVR5cGUoYmFzZSkpIHtcbiAgICAgICAgICAgICAgLy8gSW52YWxpZCB0eXBlIHdlIGFscmVhZHkgd2FybmVkIGFib3V0IGVhcmxpZXIsIGp1c3QgaWdub3JpbmcgaXQgaGVyZS4uXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhc2UuZGF0YXR5cGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzMwMDdfSUxMRUdBTF9TVFJVQ1RfRVhURU5TSU9OLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zWzBdLFxuICAgICAgICAgICAgICAgICAganNpaVR5cGUsXG4gICAgICAgICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICk7XG5cbiAgICAvLyBDaGVjayB0aGF0IG5vIGludGVyZmFjZSBkZWNsYXJlcyBhIG1lbWJlciB0aGF0J3MgYWxyZWFkeSBkZWNsYXJlZFxuICAgIC8vIGluIGEgYmFzZSB0eXBlIChub3QgYWxsb3dlZCBpbiBDIykuXG4gICAgY29uc3QgbmFtZXMgPSBtZW1iZXJOYW1lcyhqc2lpVHlwZSk7XG4gICAgY29uc3QgY2hlY2tOb0ludGVyc2VjdGlvbiA9ICguLi5iYXNlczogc3BlYy5UeXBlW10pID0+IHtcbiAgICAgIGZvciAoY29uc3QgYmFzZSBvZiBiYXNlcykge1xuICAgICAgICBpZiAoIXNwZWMuaXNJbnRlcmZhY2VUeXBlKGJhc2UpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXNlTWVtYmVycyA9IG1lbWJlck5hbWVzKGJhc2UpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlck5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgICBpZiAoYmFzZU1lbWJlcnMuaW5jbHVkZXMobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfNTAxNV9SRURFQ0xBUkVEX0lOVEVSRkFDRV9NRU1CRVIuY3JlYXRlKFxuICAgICAgICAgICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zWzBdLFxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgICAgICAganNpaVR5cGUsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNlIHVwd2FyZHNcbiAgICAgICAgdGhpcy5fZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKFxuICAgICAgICAgIGZxbixcbiAgICAgICAgICBiYXNlLmludGVyZmFjZXMgPz8gW10sXG4gICAgICAgICAgdHlwZS5zeW1ib2wudmFsdWVEZWNsYXJhdGlvbixcbiAgICAgICAgICBjaGVja05vSW50ZXJzZWN0aW9uLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZGVmZXJVbnRpbFR5cGVzQXZhaWxhYmxlKFxuICAgICAgZnFuLFxuICAgICAganNpaVR5cGUuaW50ZXJmYWNlcyA/PyBbXSxcbiAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24sXG4gICAgICBjaGVja05vSW50ZXJzZWN0aW9uLFxuICAgICk7XG5cbiAgICB0aGlzLm92ZXJyaWRlRG9jQ29tbWVudCh0eXBlLmdldFN5bWJvbCgpLCBqc2lpVHlwZT8uZG9jcyk7XG5cbiAgICByZXR1cm4gX3NvcnRNZW1iZXJzKGpzaWlUeXBlKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3Zpc2l0TWV0aG9kKFxuICAgIHN5bWJvbDogdHMuU3ltYm9sLFxuICAgIHR5cGU6IHNwZWMuQ2xhc3NUeXBlIHwgc3BlYy5JbnRlcmZhY2VUeXBlLFxuICAgIGN0eDogRW1pdENvbnRleHQsXG4gICAgZGVjbGFyaW5nVHlwZURlY2w6IHRzLkNsYXNzTGlrZURlY2xhcmF0aW9uIHwgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICkge1xuICAgIGlmIChMT0cuaXNUcmFjZUVuYWJsZWQoKSkge1xuICAgICAgTE9HLnRyYWNlKFxuICAgICAgICBgUHJvY2Vzc2luZyBtZXRob2Q6ICR7Y29sb3JzLmdyZWVuKHR5cGUuZnFuKX0jJHtjb2xvcnMuY3lhbihcbiAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHN5bWJvbC52YWx1ZURlY2xhcmF0aW9uIGFzXG4gICAgICB8IHRzLk1ldGhvZERlY2xhcmF0aW9uXG4gICAgICB8IHRzLk1ldGhvZFNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWduYXR1cmUgPVxuICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0U2lnbmF0dXJlRnJvbURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKTtcbiAgICBpZiAoIXNpZ25hdHVyZSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV85MDA0X1VOQUJMRV9UT19DT01QVVRFX1NJR05BVFVSRS5jcmVhdGUoXG4gICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgc3ltYm9sLm5hbWUsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKENhc2UucGFzY2FsKHR5cGUubmFtZSkgPT09IENhc2UucGFzY2FsKHN5bWJvbC5uYW1lKSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDE5X01FTUJFUl9UWVBFX05BTUVfQ09ORkxJQ1QuY3JlYXRlKFxuICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgICAgJ21ldGhvZCcsXG4gICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICkuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgIGRlY2xhcmluZ1R5cGVEZWNsLm5hbWUgPz8gZGVjbGFyaW5nVHlwZURlY2wsXG4gICAgICAgICAgYFRoZSBkZWNsYXJpbmcgJHt0eXBlLmtpbmR9IGlzIGludHJvZHVjZWQgaGVyZWAsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc1Byb2hpYml0ZWRNZW1iZXJOYW1lKHN5bWJvbC5uYW1lKSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDE2X1BST0hJQklURURfTUVNQkVSX05BTUUuY3JlYXRlKFxuICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgICAgc3ltYm9sLm5hbWUsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl93YXJuQWJvdXRSZXNlcnZlZFdvcmRzKHN5bWJvbCk7XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBzaWduYXR1cmUuZ2V0UGFyYW1ldGVycygpLm1hcCgocCkgPT4gdGhpcy5fdG9QYXJhbWV0ZXIocCwgY3R4KSksXG4gICAgKTtcblxuICAgIGNvbnN0IHJldHVyblR5cGUgPSBzaWduYXR1cmUuZ2V0UmV0dXJuVHlwZSgpO1xuICAgIGNvbnN0IG1ldGhvZDogc3BlYy5NZXRob2QgPSBiaW5kaW5ncy5zZXRNZXRob2RSZWxhdGVkTm9kZShcbiAgICAgIHtcbiAgICAgICAgYWJzdHJhY3Q6IF9pc0Fic3RyYWN0KHN5bWJvbCwgdHlwZSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBuYW1lOiBzeW1ib2wubmFtZSxcbiAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycy5sZW5ndGggPiAwID8gcGFyYW1ldGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJvdGVjdGVkOiBfaXNQcm90ZWN0ZWQoc3ltYm9sKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHJldHVybnM6IF9pc1ZvaWQocmV0dXJuVHlwZSlcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogYXdhaXQgdGhpcy5fb3B0aW9uYWxWYWx1ZShcbiAgICAgICAgICAgICAgcmV0dXJuVHlwZSxcbiAgICAgICAgICAgICAgZGVjbGFyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgJ3JldHVybiB0eXBlJyxcbiAgICAgICAgICAgICksXG4gICAgICAgIGFzeW5jOiBfaXNQcm9taXNlKHJldHVyblR5cGUpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGljOiBfaXNTdGF0aWMoc3ltYm9sKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGxvY2F0aW9uSW5Nb2R1bGU6IHRoaXMuZGVjbGFyYXRpb25Mb2NhdGlvbihkZWNsYXJhdGlvbiksXG4gICAgICB9LFxuICAgICAgZGVjbGFyYXRpb24sXG4gICAgKTtcbiAgICBtZXRob2QudmFyaWFkaWMgPVxuICAgICAgbWV0aG9kLnBhcmFtZXRlcnM/LnNvbWUoKHApID0+ICEhcC52YXJpYWRpYykgPT09IHRydWUgPyB0cnVlIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fdmVyaWZ5Q29uc2VjdXRpdmVPcHRpb25hbHMoZGVjbGFyYXRpb24sIG1ldGhvZC5wYXJhbWV0ZXJzKTtcblxuICAgIG1ldGhvZC5kb2NzID0gdGhpcy5fdmlzaXREb2N1bWVudGF0aW9uKHN5bWJvbCwgY3R4KS5kb2NzO1xuXG4gICAgLy8gSWYgdGhlIGxhc3QgcGFyYW1ldGVyIGlzIGEgZGF0YXR5cGUsIHZlcmlmeSB0aGF0IGl0IGRvZXMgbm90IHNoYXJlIGFueSBmaWVsZCBuYW1lcyB3aXRoXG4gICAgLy8gb3RoZXIgZnVuY3Rpb24gYXJndW1lbnRzLCBzbyB0aGF0IGl0IGNhbiBiZSB0dXJuZWQgaW50byBrZXl3b3JkIGFyZ3VtZW50cyBieSBqc2lpIGZyb250ZW5kc1xuICAgIC8vIHRoYXQgc3VwcG9ydCBzdWNoLlxuICAgIGNvbnN0IGxhc3RQYXJhbVR5cGVSZWYgPSBhcHBseShsYXN0KHBhcmFtZXRlcnMpLCAoeCkgPT4geC50eXBlKTtcbiAgICBjb25zdCBsYXN0UGFyYW1TeW1ib2wgPSBsYXN0KHNpZ25hdHVyZS5nZXRQYXJhbWV0ZXJzKCkpO1xuICAgIGlmIChsYXN0UGFyYW1UeXBlUmVmICYmIHNwZWMuaXNOYW1lZFR5cGVSZWZlcmVuY2UobGFzdFBhcmFtVHlwZVJlZikpIHtcbiAgICAgIHRoaXMuX2RlZmVyVW50aWxUeXBlc0F2YWlsYWJsZShcbiAgICAgICAgc3ltYm9sLm5hbWUsXG4gICAgICAgIFtsYXN0UGFyYW1UeXBlUmVmXSxcbiAgICAgICAgbGFzdFBhcmFtU3ltYm9sIS5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgIChsYXN0UGFyYW1UeXBlKSA9PiB7XG4gICAgICAgICAgaWYgKCFzcGVjLmlzSW50ZXJmYWNlVHlwZShsYXN0UGFyYW1UeXBlKSB8fCAhbGFzdFBhcmFtVHlwZS5kYXRhdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIExpZnRhYmxlIGRhdGF0eXBlLCBtYWtlIHN1cmUgbm8gcGFyYW1ldGVyIG5hbWVzIG1hdGNoIGFueSBvZiB0aGUgcHJvcGVydGllcyBpbiB0aGUgZGF0YXR5cGVcbiAgICAgICAgICBjb25zdCBwcm9wTmFtZXMgPSB0aGlzLmFsbFByb3BlcnRpZXMobGFzdFBhcmFtVHlwZSk7XG4gICAgICAgICAgY29uc3QgcGFyYW1OYW1lcyA9IG5ldyBTZXQoXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnNsaWNlKDAsIHBhcmFtZXRlcnMubGVuZ3RoIC0gMSkubWFwKCh4KSA9PiB4Lm5hbWUpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgc2hhcmVkTmFtZXMgPSBpbnRlcnNlY3Rpb24ocHJvcE5hbWVzLCBwYXJhbU5hbWVzKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgYmFkTmFtZSBvZiBzaGFyZWROYW1lcykge1xuICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDE3X1BPU0lUSU9OQUxfS0VZV09SRF9DT05GTElDVC5jcmVhdGUoXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgICAgYmFkTmFtZSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWxpZGF0ZVJlZmVyZW5jZWREb2NQYXJhbXMobWV0aG9kLCBzeW1ib2wpO1xuXG4gICAgdHlwZS5tZXRob2RzID0gdHlwZS5tZXRob2RzID8/IFtdO1xuICAgIGlmIChcbiAgICAgIHR5cGUubWV0aG9kcy5maW5kKFxuICAgICAgICAobSkgPT4gbS5uYW1lID09PSBtZXRob2QubmFtZSAmJiBtLnN0YXRpYyA9PT0gbWV0aG9kLnN0YXRpYyxcbiAgICAgICkgIT0gbnVsbFxuICAgICkge1xuICAgICAgTE9HLnRyYWNlKFxuICAgICAgICBgRHJvcHBpbmcgcmUtZGVjbGFyYXRpb24gb2YgJHtjb2xvcnMuZ3JlZW4odHlwZS5mcW4pfSMke2NvbG9ycy5jeWFuKFxuICAgICAgICAgIG1ldGhvZC5uYW1lLFxuICAgICAgICApfWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlLm1ldGhvZHMucHVzaChtZXRob2QpO1xuICAgIHRoaXMub3ZlcnJpZGVEb2NDb21tZW50KHN5bWJvbCwgbWV0aG9kLmRvY3MsIHBhcmFtRG9jcyhtZXRob2QucGFyYW1ldGVycykpO1xuICB9XG5cbiAgcHJpdmF0ZSBfd2FybkFib3V0UmVzZXJ2ZWRXb3JkcyhzeW1ib2w6IHRzLlN5bWJvbCkge1xuICAgIGlmICghZW5hYmxlZFdhcm5pbmdzWydyZXNlcnZlZC13b3JkJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXNlcnZpbmdMYW5ndWFnZXMgPSBpc1Jlc2VydmVkTmFtZShzeW1ib2wubmFtZSk7XG4gICAgaWYgKHJlc2VydmluZ0xhbmd1YWdlcykge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDE4X1JFU0VSVkVEX1dPUkQuY3JlYXRlKFxuICAgICAgICAgIF9uYW1lT3JEZWNsYXJhdGlvbk5vZGUoc3ltYm9sKSxcbiAgICAgICAgICBzeW1ib2wubmFtZSxcbiAgICAgICAgICByZXNlcnZpbmdMYW5ndWFnZXMsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3Zpc2l0UHJvcGVydHkoXG4gICAgc3ltYm9sOiB0cy5TeW1ib2wsXG4gICAgdHlwZTogc3BlYy5DbGFzc1R5cGUgfCBzcGVjLkludGVyZmFjZVR5cGUsXG4gICAgY3R4OiBFbWl0Q29udGV4dCxcbiAgICBkZWNsYXJpbmdUeXBlRGVjbDogdHMuQ2xhc3NMaWtlRGVjbGFyYXRpb24gfCB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgKSB7XG4gICAgaWYgKHR5cGUucHJvcGVydGllcz8uZmluZCgocCkgPT4gcC5uYW1lID09PSBzeW1ib2wubmFtZSkpIHtcbiAgICAgIC8qXG4gICAgICAgKiBTZWNvbmQgZGVjbGFyYXRpb24gb2YgdGhlIHNhbWUgcHJvcGVydHkuIEZvciBleGFtcGxlLCBpZiBjb2RlIHNwZWNpZmllcyBhIGdldHRlciAmIHNldHRlciBzaWduYXR1cmUsXG4gICAgICAgKiB0aGVyZSB3aWxsIGJlIG9uZSBwYXNzIGZvciBlYWNoIG9mIHRoZSBzaWduYXR1cmVzLCBidXQgd2UgY2FuIHByb2Nlc3Mgb25seSB0aGUgZmlyc3QgZW5jb3VudGVyZWQuIFRoZVxuICAgICAgICogdHlwZXNjcmlwdCBjb21waWxlciB3aWxsIHRha2UgY2FyZSBvZiBtYWtpbmcgc3VyZSB3ZSBkb24ndCBoYXZlIGNvbmZsaWN0aW5nIGRlY2xhcmF0aW9ucywgYW55d2F5LlxuICAgICAgICovXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKExPRy5pc1RyYWNlRW5hYmxlZCgpKSB7XG4gICAgICBMT0cudHJhY2UoXG4gICAgICAgIGBQcm9jZXNzaW5nIHByb3BlcnR5OiAke2NvbG9ycy5ncmVlbih0eXBlLmZxbil9IyR7Y29sb3JzLmN5YW4oXG4gICAgICAgICAgc3ltYm9sLm5hbWUsXG4gICAgICAgICl9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSBzeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA/PyBzeW1ib2wuZGVjbGFyYXRpb25zWzBdO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGRlY2xhcmF0aW9uIGFzXG4gICAgICB8IHRzLlByb3BlcnR5U2lnbmF0dXJlXG4gICAgICB8IHRzLlByb3BlcnR5RGVjbGFyYXRpb25cbiAgICAgIHwgdHMuQWNjZXNzb3JEZWNsYXJhdGlvblxuICAgICAgfCB0cy5QYXJhbWV0ZXJQcm9wZXJ0eURlY2xhcmF0aW9uO1xuXG4gICAgaWYgKENhc2UucGFzY2FsKHR5cGUubmFtZSkgPT09IENhc2UucGFzY2FsKHN5bWJvbC5uYW1lKSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDE5X01FTUJFUl9UWVBFX05BTUVfQ09ORkxJQ1QuY3JlYXRlKFxuICAgICAgICAgIHNpZ25hdHVyZS5uYW1lLFxuICAgICAgICAgICdwcm9wZXJ0eScsXG4gICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICkuYWRkUmVsYXRlZEluZm9ybWF0aW9uKFxuICAgICAgICAgIGRlY2xhcmluZ1R5cGVEZWNsLm5hbWUgPz8gZGVjbGFyaW5nVHlwZURlY2wsXG4gICAgICAgICAgYFRoZSBkZWNsYXJpbmcgJHt0eXBlLmtpbmR9IGlzIGludHJvZHVjZWQgaGVyZWAsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc1Byb2hpYml0ZWRNZW1iZXJOYW1lKHN5bWJvbC5uYW1lKSkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV81MDE2X1BST0hJQklURURfTUVNQkVSX05BTUUuY3JlYXRlKFxuICAgICAgICAgIHN5bWJvbC52YWx1ZURlY2xhcmF0aW9uID8/IHN5bWJvbC5kZWNsYXJhdGlvbnNbMF0sXG4gICAgICAgICAgc3ltYm9sLm5hbWUsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3dhcm5BYm91dFJlc2VydmVkV29yZHMoc3ltYm9sKTtcblxuICAgIGNvbnN0IHByb3BlcnR5OiBzcGVjLlByb3BlcnR5ID0gYmluZGluZ3Muc2V0UHJvcGVydHlSZWxhdGVkTm9kZShcbiAgICAgIHtcbiAgICAgICAgLi4uKGF3YWl0IHRoaXMuX29wdGlvbmFsVmFsdWUoXG4gICAgICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZU9mU3ltYm9sQXRMb2NhdGlvbihzeW1ib2wsIHNpZ25hdHVyZSksXG4gICAgICAgICAgc2lnbmF0dXJlLm5hbWUsXG4gICAgICAgICAgJ3Byb3BlcnR5IHR5cGUnLFxuICAgICAgICApKSxcbiAgICAgICAgYWJzdHJhY3Q6IF9pc0Fic3RyYWN0KHN5bWJvbCwgdHlwZSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBuYW1lOiBzeW1ib2wubmFtZSxcbiAgICAgICAgcHJvdGVjdGVkOiBfaXNQcm90ZWN0ZWQoc3ltYm9sKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHN0YXRpYzogX2lzU3RhdGljKHN5bWJvbCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBsb2NhdGlvbkluTW9kdWxlOiB0aGlzLmRlY2xhcmF0aW9uTG9jYXRpb24oc2lnbmF0dXJlKSxcbiAgICAgIH0sXG4gICAgICBzaWduYXR1cmUsXG4gICAgKTtcblxuICAgIGlmICh0cy5pc0dldEFjY2Vzc29yKHNpZ25hdHVyZSkpIHtcbiAgICAgIGNvbnN0IGRlY2xzID0gc3ltYm9sLmdldERlY2xhcmF0aW9ucygpID8/IFtdO1xuICAgICAgcHJvcGVydHkuaW1tdXRhYmxlID1cbiAgICAgICAgIWRlY2xzLnNvbWUoKGRlY2wpID0+IHRzLmlzU2V0QWNjZXNzb3IoZGVjbCkpIHx8IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcGVydHkuaW1tdXRhYmxlID1cbiAgICAgICAgKHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhzaWduYXR1cmUpICYgdHMuTW9kaWZpZXJGbGFncy5SZWFkb25seSkgIT09XG4gICAgICAgICAgMCB8fCB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHNpZ25hdHVyZS5xdWVzdGlvblRva2VuKSB7XG4gICAgICBwcm9wZXJ0eS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcHJvcGVydHkuc3RhdGljICYmXG4gICAgICBwcm9wZXJ0eS5pbW11dGFibGUgJiZcbiAgICAgIHRzLmlzUHJvcGVydHlEZWNsYXJhdGlvbihzaWduYXR1cmUpICYmXG4gICAgICBzaWduYXR1cmUuaW5pdGlhbGl6ZXJcbiAgICApIHtcbiAgICAgIHByb3BlcnR5LmNvbnN0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eS5kb2NzID0gdGhpcy5fdmlzaXREb2N1bWVudGF0aW9uKHN5bWJvbCwgY3R4KS5kb2NzO1xuXG4gICAgdHlwZS5wcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzID8/IFtdO1xuICAgIGlmIChcbiAgICAgIHR5cGUucHJvcGVydGllcy5maW5kKFxuICAgICAgICAocHJvcCkgPT5cbiAgICAgICAgICBwcm9wLm5hbWUgPT09IHByb3BlcnR5Lm5hbWUgJiYgcHJvcC5zdGF0aWMgPT09IHByb3BlcnR5LnN0YXRpYyxcbiAgICAgICkgIT0gbnVsbFxuICAgICkge1xuICAgICAgTE9HLnRyYWNlKFxuICAgICAgICBgRHJvcHBpbmcgcmUtZGVjbGFyYXRpb24gb2YgJHtjb2xvcnMuZ3JlZW4odHlwZS5mcW4pfSMke2NvbG9ycy5jeWFuKFxuICAgICAgICAgIHByb3BlcnR5Lm5hbWUsXG4gICAgICAgICl9YCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHR5cGUucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICB0aGlzLm92ZXJyaWRlRG9jQ29tbWVudChzeW1ib2wsIHByb3BlcnR5LmRvY3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfdG9QYXJhbWV0ZXIoXG4gICAgcGFyYW1TeW1ib2w6IHRzLlN5bWJvbCxcbiAgICBjdHg6IEVtaXRDb250ZXh0LFxuICApOiBQcm9taXNlPHNwZWMuUGFyYW1ldGVyPiB7XG4gICAgaWYgKExPRy5pc1RyYWNlRW5hYmxlZCgpKSB7XG4gICAgICBMT0cudHJhY2UoYFByb2Nlc3NpbmcgcGFyYW1ldGVyOiAke2NvbG9ycy5jeWFuKHBhcmFtU3ltYm9sLm5hbWUpfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbURlY2xhcmF0aW9uID1cbiAgICAgIHBhcmFtU3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gYXMgdHMuUGFyYW1ldGVyRGVjbGFyYXRpb247XG5cbiAgICB0aGlzLl93YXJuQWJvdXRSZXNlcnZlZFdvcmRzKHBhcmFtU3ltYm9sKTtcblxuICAgIGNvbnN0IHBhcmFtZXRlcjogc3BlYy5QYXJhbWV0ZXIgPSBiaW5kaW5ncy5zZXRQYXJhbWV0ZXJSZWxhdGVkTm9kZShcbiAgICAgIHtcbiAgICAgICAgLi4uKGF3YWl0IHRoaXMuX29wdGlvbmFsVmFsdWUoXG4gICAgICAgICAgdGhpcy5fdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24ocGFyYW1EZWNsYXJhdGlvbiksXG4gICAgICAgICAgcGFyYW1EZWNsYXJhdGlvbi5uYW1lLFxuICAgICAgICAgICdwYXJhbWV0ZXIgdHlwZScsXG4gICAgICAgICkpLFxuICAgICAgICBuYW1lOiBwYXJhbVN5bWJvbC5uYW1lLFxuICAgICAgICB2YXJpYWRpYzogcGFyYW1EZWNsYXJhdGlvbi5kb3REb3REb3RUb2tlbiAmJiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHBhcmFtRGVjbGFyYXRpb24sXG4gICAgKTtcblxuICAgIGlmIChwYXJhbWV0ZXIudmFyaWFkaWMgJiYgc3BlYy5pc0NvbGxlY3Rpb25UeXBlUmVmZXJlbmNlKHBhcmFtZXRlci50eXBlKSkge1xuICAgICAgLy8gVHlwZVNjcmlwdCB0eXBlcyB2YXJpYWRpYyBwYXJhbWV0ZXJzIGFzIGFuIGFycmF5LCBidXQgSlNJSSB1c2VzIHRoZSBpdGVtLXR5cGUgaW5zdGVhZC5cbiAgICAgIHBhcmFtZXRlci50eXBlID0gcGFyYW1ldGVyLnR5cGUuY29sbGVjdGlvbi5lbGVtZW50dHlwZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtRGVjbGFyYXRpb24uaW5pdGlhbGl6ZXIgfHwgcGFyYW1EZWNsYXJhdGlvbi5xdWVzdGlvblRva2VuKSB7XG4gICAgICAvLyBPcHRpb25hbCBwYXJhbWV0ZXJzIGhhdmUgYW4gaW5oZXJlbnRseSBudWxsLWFibGUgdHlwZS5cbiAgICAgIHBhcmFtZXRlci5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuXG4gICAgcGFyYW1ldGVyLmRvY3MgPSB0aGlzLl92aXNpdERvY3VtZW50YXRpb24oXG4gICAgICBwYXJhbVN5bWJvbCxcbiAgICAgIGN0eC5yZW1vdmVTdGFiaWxpdHkoKSwgLy8gTm8gaW5oZXJpdGFuY2Ugb24gcHVycG9zZVxuICAgICkuZG9jcztcblxuICAgIC8vIERvbid0IHJld3JpdGUgZG9jIGNvbW1lbnQgaGVyZSBvbiBwdXJwb3NlIC0tIGluc3RlYWQsIHdlIGFkZCB0aGVtIGFzICdAcGFyYW0nXG4gICAgLy8gaW50byB0aGUgcGFyZW50J3MgZG9jIGNvbW1lbnQuXG5cbiAgICByZXR1cm4gcGFyYW1ldGVyO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfdHlwZVJlZmVyZW5jZShcbiAgICB0eXBlOiB0cy5UeXBlLFxuICAgIGRlY2xhcmF0aW9uOiB0cy5Ob2RlLFxuICAgIHB1cnBvc2U6IFR5cGVVc2VLaW5kLFxuICApOiBQcm9taXNlPHNwZWMuVHlwZVJlZmVyZW5jZT4ge1xuICAgIGNvbnN0IG9wdGlvbmFsVmFsdWUgPSBhd2FpdCB0aGlzLl9vcHRpb25hbFZhbHVlKHR5cGUsIGRlY2xhcmF0aW9uLCBwdXJwb3NlKTtcbiAgICBpZiAob3B0aW9uYWxWYWx1ZS5vcHRpb25hbCkge1xuICAgICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChcbiAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zOTk5X0lOQ09IRVJFTlRfVFlQRV9NT0RFTC5jcmVhdGUoXG4gICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgJ0VuY291bnRlcmVkIG9wdGlvbmFsIHZhbHVlIGluIGxvY2F0aW9uIHdoZXJlIGEgcGxhaW4gdHlwZSByZWZlcmVuY2UgaXMgZXhwZWN0ZWQnLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbmFsVmFsdWUudHlwZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX29wdGlvbmFsVmFsdWUoXG4gICAgdHlwZTogdHMuVHlwZSxcbiAgICBkZWNsYXJhdGlvbjogdHMuTm9kZSxcbiAgICBwdXJwb3NlOiBUeXBlVXNlS2luZCxcbiAgKTogUHJvbWlzZTxzcGVjLk9wdGlvbmFsVmFsdWU+IHtcbiAgICBjb25zdCBpc1RoaXNUeXBlID0gX2lzVGhpc1R5cGUodHlwZSwgdGhpcy5fdHlwZUNoZWNrZXIpO1xuXG4gICAgaWYgKHR5cGUuaXNMaXRlcmFsKCkgJiYgX2lzRW51bUxpa2UodHlwZSkpIHtcbiAgICAgIHR5cGUgPSB0aGlzLl90eXBlQ2hlY2tlci5nZXRCYXNlVHlwZU9mTGl0ZXJhbFR5cGUodHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSB0aGlzLl90eXBlQ2hlY2tlci5nZXRBcHBhcmVudFR5cGUodHlwZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbWl0aXZlVHlwZSA9IF90cnlNYWtlUHJpbWl0aXZlVHlwZS5jYWxsKHRoaXMpO1xuICAgIGlmIChwcmltaXRpdmVUeXBlKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmltaXRpdmVUeXBlIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuaXNVbmlvbigpICYmICFfaXNFbnVtTGlrZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIF91bmlvblR5cGUuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICBKc2lpRGlhZ25vc3RpYy5KU0lJXzEwMDFfVFlQRV9IQVNfTk9fU1lNQk9MLmNyZWF0ZShkZWNsYXJhdGlvbiksXG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgdHlwZTogc3BlYy5DQU5PTklDQUxfQU5ZIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuc3ltYm9sLm5hbWUgPT09ICdBcnJheScpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IGF3YWl0IF9hcnJheVR5cGUuY2FsbCh0aGlzKSB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlLnN5bWJvbC5uYW1lID09PSAnX190eXBlJyAmJiB0eXBlLnN5bWJvbC5tZW1iZXJzKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBhd2FpdCBfbWFwVHlwZS5jYWxsKHRoaXMpIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuc3ltYm9sLmVzY2FwZWROYW1lID09PSAnUHJvbWlzZScpIHtcbiAgICAgIGNvbnN0IHR5cGVSZWYgPSB0eXBlIGFzIHRzLlR5cGVSZWZlcmVuY2U7XG4gICAgICBpZiAoIXR5cGVSZWYudHlwZUFyZ3VtZW50cyB8fCB0eXBlUmVmLnR5cGVBcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8xMDAyX1VOU1BFQ0lGSUVEX1BST01JU0UuY3JlYXRlKGRlY2xhcmF0aW9uKSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogc3BlYy5DQU5PTklDQUxfQU5ZIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBhd2FpdCB0aGlzLl90eXBlUmVmZXJlbmNlKFxuICAgICAgICAgIHR5cGVSZWYudHlwZUFyZ3VtZW50c1swXSxcbiAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICBwdXJwb3NlLFxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogeyBmcW46IGF3YWl0IHRoaXMuX2dldEZRTih0eXBlLCBkZWNsYXJhdGlvbiwgcHVycG9zZSwgaXNUaGlzVHlwZSkgfSxcbiAgICB9O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2FycmF5VHlwZShcbiAgICAgIHRoaXM6IEFzc2VtYmxlcixcbiAgICApOiBQcm9taXNlPHNwZWMuQ29sbGVjdGlvblR5cGVSZWZlcmVuY2U+IHtcbiAgICAgIGNvbnN0IHR5cGVSZWYgPSB0eXBlIGFzIHRzLlR5cGVSZWZlcmVuY2U7XG4gICAgICBsZXQgZWxlbWVudHR5cGU6IHNwZWMuVHlwZVJlZmVyZW5jZTtcblxuICAgICAgaWYgKHR5cGVSZWYudHlwZUFyZ3VtZW50cz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsZW1lbnR0eXBlID0gYXdhaXQgdGhpcy5fdHlwZVJlZmVyZW5jZShcbiAgICAgICAgICB0eXBlUmVmLnR5cGVBcmd1bWVudHNbMF0sXG4gICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgJ2xpc3QgZWxlbWVudCB0eXBlJyxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdHlwZVJlZi50eXBlQXJndW1lbnRzXG4gICAgICAgICAgPyB0eXBlUmVmLnR5cGVBcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgOiAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8xMDAzX1VOU1VQUE9SVEVEX1RZUEUuY3JlYXRlKFxuICAgICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgICBgQXJyYXkgcmVmZXJlbmNlcyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgdHlwZSBhcmd1bWVudCAoZm91bmQgJHtjb3VudH0pYCxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgICBlbGVtZW50dHlwZSA9IHNwZWMuQ0FOT05JQ0FMX0FOWTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjoge1xuICAgICAgICAgIGVsZW1lbnR0eXBlLFxuICAgICAgICAgIGtpbmQ6IHNwZWMuQ29sbGVjdGlvbktpbmQuQXJyYXksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9tYXBUeXBlKFxuICAgICAgdGhpczogQXNzZW1ibGVyLFxuICAgICk6IFByb21pc2U8c3BlYy5Db2xsZWN0aW9uVHlwZVJlZmVyZW5jZT4ge1xuICAgICAgbGV0IGVsZW1lbnR0eXBlOiBzcGVjLlR5cGVSZWZlcmVuY2U7XG4gICAgICBjb25zdCBvYmplY3RUeXBlID0gdHlwZS5nZXRTdHJpbmdJbmRleFR5cGUoKTtcbiAgICAgIGlmIChvYmplY3RUeXBlKSB7XG4gICAgICAgIGVsZW1lbnR0eXBlID0gYXdhaXQgdGhpcy5fdHlwZVJlZmVyZW5jZShcbiAgICAgICAgICBvYmplY3RUeXBlLFxuICAgICAgICAgIGRlY2xhcmF0aW9uLFxuICAgICAgICAgICdtYXAgZWxlbWVudCB0eXBlJyxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8xMDAzX1VOU1VQUE9SVEVEX1RZUEUuY3JlYXRlKFxuICAgICAgICAgICAgZGVjbGFyYXRpb24sXG4gICAgICAgICAgICAnT25seSBzdHJpbmctaW5kZXhlZCBtYXAgdHlwZXMgYXJlIHN1cHBvcnRlZCcsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgZWxlbWVudHR5cGUgPSBzcGVjLkNBTk9OSUNBTF9BTlk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgICAgZWxlbWVudHR5cGUsXG4gICAgICAgICAga2luZDogc3BlYy5Db2xsZWN0aW9uS2luZC5NYXAsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90cnlNYWtlUHJpbWl0aXZlVHlwZShcbiAgICAgIHRoaXM6IEFzc2VtYmxlcixcbiAgICApOiBzcGVjLlByaW1pdGl2ZVR5cGVSZWZlcmVuY2UgfCB1bmRlZmluZWQge1xuICAgICAgaWYgKCF0eXBlLnN5bWJvbCkge1xuICAgICAgICBpZiAodHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5PYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4geyBwcmltaXRpdmU6IHNwZWMuUHJpbWl0aXZlVHlwZS5Kc29uIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUuZmxhZ3MgJiAodHMuVHlwZUZsYWdzLkFueSB8IHRzLlR5cGVGbGFncy5Vbmtub3duKSkge1xuICAgICAgICAgIHJldHVybiBzcGVjLkNBTk9OSUNBTF9BTlk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGUuc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gJiZcbiAgICAgICAgaXNVbmRlcihcbiAgICAgICAgICB0eXBlLnN5bWJvbC52YWx1ZURlY2xhcmF0aW9uLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZSxcbiAgICAgICAgICB0aGlzLnN0ZGxpYixcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZS5zeW1ib2wubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJpbWl0aXZlOiBzcGVjLlByaW1pdGl2ZVR5cGUuQm9vbGVhbiB9O1xuICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJpbWl0aXZlOiBzcGVjLlByaW1pdGl2ZVR5cGUuRGF0ZSB9O1xuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICByZXR1cm4geyBwcmltaXRpdmU6IHNwZWMuUHJpbWl0aXZlVHlwZS5OdW1iZXIgfTtcbiAgICAgICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHsgcHJpbWl0aXZlOiBzcGVjLlByaW1pdGl2ZVR5cGUuU3RyaW5nIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE5vdCBhIHByaW1pdGl2ZSB0eXBlIVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgZnVuY3Rpb24gaXNVbmRlcihmaWxlOiBzdHJpbmcsIGRpcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlID0gcGF0aC5yZWxhdGl2ZShkaXIsIGZpbGUpO1xuICAgICAgICByZXR1cm4gIXJlbGF0aXZlLnN0YXJ0c1dpdGgocGF0aC5zZXApICYmICFyZWxhdGl2ZS5zdGFydHNXaXRoKCcuLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF91bmlvblR5cGUodGhpczogQXNzZW1ibGVyKTogUHJvbWlzZTxzcGVjLk9wdGlvbmFsVmFsdWU+IHtcbiAgICAgIGNvbnN0IHR5cGVzID0gbmV3IEFycmF5PHNwZWMuVHlwZVJlZmVyZW5jZT4oKTtcbiAgICAgIGxldCBvcHRpb25hbDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuICAgICAgZm9yIChjb25zdCBzdWJUeXBlIG9mICh0eXBlIGFzIHRzLlVuaW9uVHlwZSkudHlwZXMpIHtcbiAgICAgICAgaWYgKHN1YlR5cGUuZmxhZ3MgJiB0cy5UeXBlRmxhZ3MuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgIGNvbnN0IHJlc29sdmVkVHlwZSA9IGF3YWl0IHRoaXMuX3R5cGVSZWZlcmVuY2UoXG4gICAgICAgICAgc3ViVHlwZSxcbiAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICBwdXJwb3NlLFxuICAgICAgICApO1xuICAgICAgICBpZiAodHlwZXMuZmluZCgocmVmKSA9PiBkZWVwRXF1YWwocmVmLCByZXNvbHZlZFR5cGUpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMucHVzaChyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZXMubGVuZ3RoID09PSAxXG4gICAgICAgID8geyBvcHRpb25hbCwgdHlwZTogdHlwZXNbMF0gfVxuICAgICAgICA6IHsgb3B0aW9uYWwsIHR5cGU6IHsgdW5pb246IHsgdHlwZXMgfSB9IH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjYWxsRGVmZXJyZWRzSW5PcmRlcigpIHtcbiAgICAvLyBEbyBhIHRvcG9sb2dpY2FsIGNhbGwgb3JkZXIgb2YgYWxsIGRlZmVycmVkcy5cbiAgICB3aGlsZSAodGhpcy5fZGVmZXJyZWQubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQWxsIGZxbnMgaW4gZGVwZW5kZW5jeSBsaXN0cyB0aGF0IGRvbid0IGhhdmUgYW55IHBlbmRpbmdcbiAgICAgIC8vIGRlZmVycmVkcyB0aGVtc2VsdmVzIGNhbiBiZSBleGVjdXRlZCBub3csIHNvIGFyZSByZW1vdmVkIGZyb21cbiAgICAgIC8vIGRlcGVuZGVuY3kgbGlzdHMuXG4gICAgICBjb25zdCBwZW5kaW5nRnFucyA9IG5ldyBTZXQ8c3RyaW5nPih0aGlzLl9kZWZlcnJlZC5tYXAoKHgpID0+IHguZnFuKSk7XG4gICAgICBmb3IgKGNvbnN0IGRlZmVycmVkIG9mIHRoaXMuX2RlZmVycmVkKSB7XG4gICAgICAgIHJlc3RyaWN0RGVwZW5kZW5jaWVzVG8oZGVmZXJyZWQsIHBlbmRpbmdGcW5zKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW52b2tlIGFsbCBkZWZlcnJlZHMgd2l0aCBubyBtb3JlIGRlcGVuZGVuY2llcyBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbGlzdC5cbiAgICAgIGxldCBpbnZva2VkID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWZlcnJlZFtpXS5kZXBlbmRlZEZxbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl9kZWZlcnJlZC5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgICAgZGVmZXJyZWQuY2IoKTtcbiAgICAgICAgICBpbnZva2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWludm9rZWQpIHtcbiAgICAgICAgLy8gQXBwYXJlbnRseSB3ZSdyZSBzdHVjay4gQ29tcGxhaW4gbG91ZGx5LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENvdWxkIG5vdCBpbnZva2UgYW55IG1vcmUgZGVmZXJyZWRzLCBjeWNsaWMgZGVwZW5kZW5jeT8gUmVtYWluaW5nOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgdGhpcy5fZGVmZXJyZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRhaW4gb25seSBlbGVtZW50cyBpbiB0aGUgZGVwZW5kZW5jeWZxbiB0aGF0IGFyZSBhbHNvIGluIHRoZSBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0cmljdERlcGVuZGVuY2llc1RvKGRlZjogRGVmZXJyZWRSZWNvcmQsIGZxbnM6IFNldDxzdHJpbmc+KSB7XG4gICAgICBkZWYuZGVwZW5kZWRGcW5zID0gZGVmLmRlcGVuZGVkRnFucy5maWx0ZXIoZnFucy5oYXMuYmluZChmcW5zKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGFsbCAoaW5oZXJpdGVkKSBwcm9wZXJ0aWVzIG9mIGFuIGludGVyZmFjZVxuICAgKi9cbiAgcHJpdmF0ZSBhbGxQcm9wZXJ0aWVzKHJvb3Q6IHNwZWMuSW50ZXJmYWNlVHlwZSk6IFNldDxzdHJpbmc+IHtcbiAgICBjb25zdCByZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICByZWN1cnNlLmNhbGwodGhpcywgcm9vdCk7XG4gICAgcmV0dXJuIHJldDtcblxuICAgIGZ1bmN0aW9uIHJlY3Vyc2UodGhpczogQXNzZW1ibGVyLCBpbnQ6IHNwZWMuSW50ZXJmYWNlVHlwZSkge1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBpbnQucHJvcGVydGllcyA/PyBbXSkge1xuICAgICAgICByZXQuYWRkKHByb3BlcnR5Lm5hbWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGJhc2VSZWYgb2YgaW50LmludGVyZmFjZXMgPz8gW10pIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlcmVmZXJlbmNlKGJhc2VSZWYsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICghYmFzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdJbXBvc3NpYmxlIHRvIGhhdmUgdW5yZXNvbHZhYmxlIGJhc2UgaW4gYWxsUHJvcGVydGllcygpJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3BlYy5pc0ludGVyZmFjZVR5cGUoYmFzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnSW1wb3NzaWJsZSB0byBoYXZlIG5vbi1pbnRlcmZhY2UgYmFzZSBpbiBhbGxQcm9wZXJ0aWVzKCknLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNlLmNhbGwodGhpcywgYmFzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdmVyaWZ5Q29uc2VjdXRpdmVPcHRpb25hbHMoXG4gICAgbm9kZTogdHMuTm9kZSxcbiAgICBwYXJhbWV0ZXJzPzogc3BlYy5QYXJhbWV0ZXJbXSxcbiAgKSB7XG4gICAgaWYgKCFwYXJhbWV0ZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVtYWluaW5nID0gWy4uLnBhcmFtZXRlcnNdLnJldmVyc2UoKTtcbiAgICB3aGlsZSAocmVtYWluaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSByZW1haW5pbmcucG9wKCkhO1xuICAgICAgaWYgKGN1cnJlbnQub3B0aW9uYWwpIHtcbiAgICAgICAgY29uc3Qgb2ZmZW5kZXIgPSByZW1haW5pbmcuZmluZCgocCkgPT4gIXAub3B0aW9uYWwgJiYgIXAudmFyaWFkaWMpO1xuICAgICAgICBpZiAob2ZmZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2goXG4gICAgICAgICAgSnNpaURpYWdub3N0aWMuSlNJSV8zMDA5X09QVElPTkFMX1BBUkFNRVRFUl9CRUZPUkVfUkVRVUlSRUQuY3JlYXRlKFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBvZmZlbmRlcixcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgICBkZWxldGUgY3VycmVudC5vcHRpb25hbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcnVudGltZSB0eXBlIGluZm8gd2l0aCB0aGUgZnVsbHktcXVhbGlmaWVkIG5hbWUgZm9yIHRoZSBjdXJyZW50IGNsYXNzIGRlZmluaXRpb24uXG4gICAqIFVzZWQgYnkgdGhlIHJ1bnRpbWUgdHlwZSBpbmZvIGluamVjdG9yIHRvIGFkZCB0aGlzIGluZm9ybWF0aW9uIHRvIHRoZSBjb21waWxlZCBmaWxlLlxuICAgKi9cbiAgcHJpdmF0ZSByZWdpc3RlckV4cG9ydGVkQ2xhc3NGcW4oY2xheno6IHRzLkNsYXNzRGVjbGFyYXRpb24sIGZxbjogc3RyaW5nKSB7XG4gICAgdGhpcy5ydW50aW1lVHlwZUluZm9JbmplY3Rvci5yZWdpc3RlckNsYXNzRnFuKGNsYXp6LCBmcW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gdGhlIGdpdmVuIEpTSUlEb2NzLCByZS1yZW5kZXIgdGhlIFRTRG9jIGNvbW1lbnQgZm9yIHRoZSBOb2RlXG4gICAqXG4gICAqIFdlIG1heSBjaGFuZ2UgdGhlIGRvY3VtZW50YXRpb24gYSBsaXR0bGUsIHNvIHRoYXQgdGhlIGRvYyBjb21tZW50IHRoYXQgZ2V0c1xuICAgKiB3cml0dGVuIGlzIG5vdCBuZWNlc3NhcmlseSBleGFjdGx5IHRoZSBzYW1lIGFzIHRoZSBkb2NzIHRoYXQgZ28gaW50byB0aGVcbiAgICogSlNJSSBtYW5pZmVzdC5cbiAgICpcbiAgICogVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgdGhlIGNvZGUgZG9jIGNvbW1lbnRzIHRvIGhpZ2hsaWdodCB0aGluZ3NcbiAgICogc2xpZ2hseSBkaWZmZXJlbnRseSBmcm9tIHRoZSBBUEkgUmVmZXJlbmNlLCBhbmQgbWFrZXMgc3VyZSB3ZSBkb24ndFxuICAgKiBkdXBsaWNhdGUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIFVubGVzcyB0aGUgZG9jcyBnb3QgY2hhbmdlZCwgdGhpcyB5aWVsZHMgdGhlIHNhbWUgb3V0cHV0IGJhY2sgYXMgdGhlIG9uZSB0aGF0XG4gICAqIHdlIG9yaWdpbmFsbHkgc2F3IChtb2R1bG8gd2hpdGVzcGFjZSBjaGFuZ2VzKS5cbiAgICovXG4gIHByaXZhdGUgb3ZlcnJpZGVEb2NDb21tZW50KFxuICAgIHN5bWJvbD86IHRzLlN5bWJvbCxcbiAgICBkb2NzPzogc3BlYy5Eb2NzLFxuICAgIHBhcmFtZXRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzcGVjLkRvY3M+LFxuICApIHtcbiAgICBpZiAoIWRvY3MgfHwgIXN5bWJvbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvY3MgPSB0aGlzLmRvY0NvbW1lbnREb2NzKGRvY3MpO1xuXG4gICAgLy8gU29tZSBzeW1ib2xzIGhhdmUgbXVsdGlwbGUgZGVjbGFyYXRpb25zIChmb3IgZXhhbXBsZSwgYSBjbGFzcyArIGludGVyZmFjZVxuICAgIC8vIG1peGlucywgb3IgYSBwcm9wZXJ0eSBkZWNsYXJ0YWlvbiArIGNvbnN0cnVjdG9yIGFyZ3VtZW50KS5cbiAgICAvL1xuICAgIC8vIFdlIERPTidUIHd3YW50IHRvIHB1dCB0aGUgZG9jIGNvbW1lbnQgb24gdGhlIGNvbnN0cnVjdG9yIGFyZ3VtZW50LCBiZWNhdXNlIGl0XG4gICAgLy8gbG9va3Mgc2lsbHkgdGhlcmUuXG4gICAgZm9yIChjb25zdCBkZWNsIG9mIHN5bWJvbC5nZXREZWNsYXJhdGlvbnMoKSA/PyBbXSkge1xuICAgICAgaWYgKHRzLmlzUGFyYW1ldGVyKGRlY2wpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbW1lbnRSZXBsYWNlci5vdmVycmlkZU5vZGVEb2NDb21tZW50KFxuICAgICAgICBkZWNsLFxuICAgICAgICByZW5kZXJTeW1ib2xEb2N1bWVudGF0aW9uKGRvY3MsIHBhcmFtZXRlcnMpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgcG90ZW50aWFsbHkgbmV3IHNldCBvZiBEb2NzLCBmb3IgcmVuZGVyaW5nIGJhY2sgdG8gYSBUeXBlU2NyaXB0IGRvYyBjb21tZW50XG4gICAqXG4gICAqIFdlIHB1dCB0aGUgXCIoZXhwZXJpbWVudGFsKVwiL1wiKGRlcHJlY2F0ZWQpXCIgc3RhdHVzIGludG8gdGhlIGRvY1xuICAgKiBjb21tZW50IHN1bW1hcnksIHNvIHRoYXQgaXQncyBwcmVzZW50ZWQgZnJvbnQgYW5kIGNlbnRlci5cbiAgICovXG4gIHByaXZhdGUgZG9jQ29tbWVudERvY3MoZG9jczogUmVhZG9ubHk8c3BlYy5Eb2NzPik6IHNwZWMuRG9jcyB7XG4gICAgLy8gTW9kaWZ5IHRoZSBzdW1tYXJ5IGlmIHRoaXMgQVBJIGVsZW1lbnQgaGFzIGEgc3BlY2lhbCBzdGFiaWxpdHlcbiAgICBpZiAoZG9jcy5zdGFiaWxpdHkgPT09IHNwZWMuU3RhYmlsaXR5LkV4cGVyaW1lbnRhbCAmJiBkb2NzLnN1bW1hcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRvY3MsXG4gICAgICAgIHN1bW1hcnk6IGAoZXhwZXJpbWVudGFsKSAke2RvY3Muc3VtbWFyeX1gLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGRvY3Muc3RhYmlsaXR5ID09PSBzcGVjLlN0YWJpbGl0eS5EZXByZWNhdGVkICYmIGRvY3Muc3VtbWFyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZG9jcyxcbiAgICAgICAgc3VtbWFyeTogYChkZXByZWNhdGVkKSAke2RvY3Muc3VtbWFyeX1gLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGRvY3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIG9ubHkgdGhvc2Ugc3VibW9kdWxlcyBmcm9tIHRoZSBzdWJtb2R1bGVzIGxpc3QgdGhhdCBhcmUgc3VibW9kdWxlcyBpbnNpZGUgdGhpc1xuICAgKiBhc3NlbWJseS5cbiAgICovXG4gIHByaXZhdGUgbXlTdWJtb2R1bGVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3N1Ym1vZHVsZXMudmFsdWVzKCkpLmZpbHRlcigobSkgPT5cbiAgICAgIG0uZnFuLnN0YXJ0c1dpdGgoYCR7dGhpcy5wcm9qZWN0SW5mby5uYW1lfS5gKSxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzZW1ibGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlbW92ZSBgQGRlcHJlY2F0ZWRgIG1lbWJlcnMgZnJvbSB0aGUgZ2VuZXJhdGVkIGFzc2VtYmx5LlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RyaXBEZXByZWNhdGVkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgYHN0cmlwRGVwcmVjYXRlZGAgaXMgdHJ1ZSwgYW5kIGEgZmlsZSBpcyBwcm92aWRlZCBoZXJlLCBvbmx5IHRoZSBGUU5zXG4gICAqIHByZXNlbnQgaW4gdGhlIGZpbGUgd2lsbCBhY3R1YWxseSBiZSByZW1vdmVkLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlblxuICAgKiB5b3Ugd2lzaCB0byBkZXByZWNhdGUgc29tZSBlbGVtZW50cyB3aXRob3V0IGFjdHVhbGx5IHJlbW92aW5nIHRoZW0uXG4gICAqXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgcmVhZG9ubHkgc3RyaXBEZXByZWNhdGVkQWxsb3dMaXN0RmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0byBpbmplY3QgY29kZSB0aGF0IHdhcm5zIHdoZW4gYSBkZXByZWNhdGVkIGVsZW1lbnQgaXMgdXNlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGFkZERlcHJlY2F0aW9uV2FybmluZ3M/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgU3VibW9kdWxlU3BlYyB7XG4gIC8qKlxuICAgKiBUaGUgc3VibW9kdWxlJ3MgZnVsbHkgcXVhbGlmaWVkIG5hbWUuXG4gICAqL1xuICByZWFkb25seSBmcW46IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHN1Ym1vZHVsZSdzIGZ1bGx5IHF1YWxpZmllZCBuYW1lIHByZWZpeCB0byB1c2Ugd2hlbiByZXNvbHZpbmcgdHlwZSBGUU5zLiBUaGlzIGRvZXMgbm90XG4gICAqIGluY2x1ZGUgXCJpbmxpbmUgbmFtZXNwYWNlXCIgbmFtZXMgYXMgdGhvc2UgYXJlIGFscmVhZHkgcmVwcmVzZW50ZWQgaW4gdGhlIFR5cGVDaGVja2VycycgdmlldyBvZlxuICAgKiB0aGUgdHlwZSBuYW1lcy5cbiAgICovXG4gIHJlYWRvbmx5IGZxblJlc29sdXRpb25QcmVmaXg6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxvY2F0aW9uIG9mIHRoZSBzdWJtb2R1bGUgZGVmaW5pdGlvbiBpbiB0aGUgc291cmNlLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb25Jbk1vZHVsZTogc3BlYy5Tb3VyY2VMb2NhdGlvbjtcblxuICAvKipcbiAgICogU3ltYm9sIGlkZW50aWZpZXIgb2YgdGhlIHJvb3Qgb2YgdGhlIHJvb3QgZmlsZSB0aGF0IHJlcHJlc2VudHMgdGhpcyBzdWJtb2R1bGVcbiAgICovXG4gIHJlYWRvbmx5IHN5bWJvbElkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbnkgY3VzdG9taXplZCBjb25maWd1cmF0aW9uIGZvciB0aGUgY3VycmVudGwgc3VibW9kdWxlLlxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0cz86IHNwZWMuQXNzZW1ibHlUYXJnZXRzO1xuXG4gIC8qKlxuICAgKiBSZWFkbWUgZm9yIHRoaXMgc3VibW9kdWxlIChpZiBmb3VuZClcbiAgICovXG4gIHJlYWRvbmx5IHJlYWRtZT86IHNwZWMuUmVhZE1lO1xufVxuXG5mdW5jdGlvbiBfZmluZ2VycHJpbnQoYXNzZW1ibHk6IHNwZWMuQXNzZW1ibHkpOiBzcGVjLkFzc2VtYmx5IHtcbiAgZGVsZXRlIGFzc2VtYmx5LmZpbmdlcnByaW50O1xuICBhc3NlbWJseSA9IHNvcnRKc29uKGFzc2VtYmx5KTtcbiAgY29uc3QgZmluZ2VycHJpbnQgPSBjcnlwdG9cbiAgICAuY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAudXBkYXRlKEpTT04uc3RyaW5naWZ5KGFzc2VtYmx5KSlcbiAgICAuZGlnZXN0KCdiYXNlNjQnKTtcbiAgcmV0dXJuIHsgLi4uYXNzZW1ibHksIGZpbmdlcnByaW50IH07XG59XG5cbmZ1bmN0aW9uIF9pc0Fic3RyYWN0KFxuICBzeW1ib2w6IHRzLlN5bWJvbCxcbiAgZGVjbGFyaW5nVHlwZTogc3BlYy5DbGFzc1R5cGUgfCBzcGVjLkludGVyZmFjZVR5cGUsXG4pOiBib29sZWFuIHtcbiAgLy8gZXZlcnl0aGluZyBpcyBhYnN0cmFjdCBpbiBpbnRlcmZhY2VzXG4gIGlmIChkZWNsYXJpbmdUeXBlLmtpbmQgPT09IHNwZWMuVHlwZUtpbmQuSW50ZXJmYWNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gKFxuICAgICEhc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gJiZcbiAgICAodHMuZ2V0Q29tYmluZWRNb2RpZmllckZsYWdzKHN5bWJvbC52YWx1ZURlY2xhcmF0aW9uKSAmXG4gICAgICB0cy5Nb2RpZmllckZsYWdzLkFic3RyYWN0KSAhPT1cbiAgICAgIDBcbiAgKTtcbn1cblxuZnVuY3Rpb24gX2lzRW51bUxpa2UodHlwZTogdHMuVHlwZSk6IHR5cGUgaXMgdHMuRW51bVR5cGUge1xuICByZXR1cm4gKHR5cGUuZmxhZ3MgJiB0cy5UeXBlRmxhZ3MuRW51bUxpa2UpICE9PSAwO1xufVxuXG5mdW5jdGlvbiBfaXNFeHBvcnRlZChub2RlOiB0cy5EZWNsYXJhdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gKHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhub2RlKSAmIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSAhPT0gMDtcbn1cblxuLyoqXG4gKiBNZW1iZXJzIHdpdGggbmFtZXMgc3RhcnRpbmcgd2l0aCBgX2AgKGFuZCBtYXJrZWQgYXMgQGludGVybmFsKSBhbmQgbWVtYmVyc1xuICogdGhhdCBhcmUgcHJpdmF0ZSBhcmUgaGlkZGVuLlxuICpcbiAqIEBwYXJhbSBzeW1ib2wgdGhlIHN5bWJvbCB3aGljaCBzaG91bGQgYmUgYXNzZXNzZWRcbiAqXG4gKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgc3ltYm9sIHNob3VsZCBiZSBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gX2lzUHJpdmF0ZShzeW1ib2w6IHRzLlN5bWJvbCk6IGJvb2xlYW4ge1xuICBjb25zdCBUWVBFX0RFQ0xBUkFUSU9OX0tJTkRTID0gbmV3IFNldChbXG4gICAgdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uLFxuICAgIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgdHMuU3ludGF4S2luZC5FbnVtRGVjbGFyYXRpb24sXG4gIF0pO1xuXG4gIC8vIGlmIHRoZSBzeW1ib2wgZG9lc24ndCBoYXZlIGEgdmFsdWUgZGVjbGFyYXRpb24sIHdlIGFyZSBhc3N1bWluZyBpdCdzIGEgdHlwZSAoZW51bS9pbnRlcmZhY2UvY2xhc3MpXG4gIC8vIGFuZCBjaGVjayB0aGF0IGl0IGhhcyBhbiBcImV4cG9ydFwiIG1vZGlmaWVyXG4gIGlmIChcbiAgICAhc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gfHxcbiAgICBUWVBFX0RFQ0xBUkFUSU9OX0tJTkRTLmhhcyhzeW1ib2wudmFsdWVEZWNsYXJhdGlvbi5raW5kKVxuICApIHtcbiAgICBsZXQgaGFzRXhwb3J0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBkZWNsIG9mIHN5bWJvbC5kZWNsYXJhdGlvbnMpIHtcbiAgICAgIGlmICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoZGVjbCkgJiB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkge1xuICAgICAgICBoYXNFeHBvcnQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgY2xhc3NlcyBmcm9tIHByb2plY3QgcmVmZXJlbmNlc1xuICAgICAgaWYgKHRzLmlzTW9kdWxlQmxvY2soZGVjbC5wYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZURlY2xhcmF0aW9uID0gZGVjbC5wYXJlbnQucGFyZW50O1xuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSB0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MobW9kdWxlRGVjbGFyYXRpb24pO1xuICAgICAgICAvLyBUaGUgdHJpY2sgaXMgdGhlIG1vZHVsZSBpcyBkZWNsYXJlZCBhcyBhbWJpZW50ICYgZXhwb3J0ZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChtb2RpZmllcnMgJiB0cy5Nb2RpZmllckZsYWdzLkFtYmllbnQpICE9PSAwICYmXG4gICAgICAgICAgKG1vZGlmaWVycyAmIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSAhPT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNFeHBvcnQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhaGFzRXhwb3J0O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBzeW1ib2wudmFsdWVEZWNsYXJhdGlvbiAmJlxuICAgICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3Moc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24pICZcbiAgICAgIHRzLk1vZGlmaWVyRmxhZ3MuUHJpdmF0ZSkgIT09XG4gICAgICAwXG4gICk7XG59XG5cbmZ1bmN0aW9uIF9oYXNJbnRlcm5hbEpzRG9jVGFnKHN5bWJvbDogdHMuU3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2wuZ2V0SnNEb2NUYWdzKCkuc29tZSgodDogYW55KSA9PiB0Lm5hbWUgPT09ICdpbnRlcm5hbCcpO1xufVxuXG5mdW5jdGlvbiBfaXNQcm90ZWN0ZWQoc3ltYm9sOiB0cy5TeW1ib2wpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAhIXN5bWJvbC52YWx1ZURlY2xhcmF0aW9uICYmXG4gICAgKHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhzeW1ib2wudmFsdWVEZWNsYXJhdGlvbikgJlxuICAgICAgdHMuTW9kaWZpZXJGbGFncy5Qcm90ZWN0ZWQpICE9PVxuICAgICAgMFxuICApO1xufVxuXG5mdW5jdGlvbiBfaXNTdGF0aWMoc3ltYm9sOiB0cy5TeW1ib2wpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAhIXN5bWJvbC52YWx1ZURlY2xhcmF0aW9uICYmXG4gICAgKHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhzeW1ib2wudmFsdWVEZWNsYXJhdGlvbikgJlxuICAgICAgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpICE9PVxuICAgICAgMFxuICApO1xufVxuXG5mdW5jdGlvbiBfaXNWb2lkKHR5cGU6IHRzLlR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLlZvaWQpICE9PSAwO1xufVxuXG5mdW5jdGlvbiBfaXNQcm9taXNlKHR5cGU6IHRzLlR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGUuc3ltYm9sPy5lc2NhcGVkTmFtZSA9PT0gJ1Byb21pc2UnO1xufVxuXG5mdW5jdGlvbiBfc29ydE1lbWJlcnModHlwZTogc3BlYy5DbGFzc1R5cGUpOiBzcGVjLkNsYXNzVHlwZTtcbmZ1bmN0aW9uIF9zb3J0TWVtYmVycyh0eXBlOiBzcGVjLkludGVyZmFjZVR5cGUpOiBzcGVjLkludGVyZmFjZVR5cGU7XG5mdW5jdGlvbiBfc29ydE1lbWJlcnMoXG4gIHR5cGU6IHNwZWMuQ2xhc3NUeXBlIHwgc3BlYy5JbnRlcmZhY2VUeXBlLFxuKTogc3BlYy5DbGFzc1R5cGUgfCBzcGVjLkludGVyZmFjZVR5cGUge1xuICB0eXBlLm1ldGhvZHMgPSB0eXBlLm1ldGhvZHMgJiYgX3NvcnQodHlwZS5tZXRob2RzKTtcbiAgdHlwZS5wcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzICYmIF9zb3J0KHR5cGUucHJvcGVydGllcyk7XG4gIHJldHVybiB0eXBlO1xuXG4gIC8qKlxuICAgKiBTb3J0cyBhIG1lbWJlciBhcnJheSBzdWNoIHRoYXQ6XG4gICAqIDEuIFN0YXRpYyBtZW1iZXJzIGFwcGVhciBmaXJzdFxuICAgKiAyLiBJbW11dGFibGUgbWVtYmVycyBhcHBlYXIgZmlyc3RcbiAgICogMy4gTm9uLW9wdGlvbmFsIG1lbWJlcnMgYXBwZWFyIGZpcnN0XG4gICAqIDQuIE1lbWJlcnMgYXBwZWFyIGluIGxleGljb2dyYXBoaWNhbCBvcmRlclxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIHRoZSBhcnJheSBvZiBtZW1iZXJzIHRvIGJlIHNvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJuIGEgc29ydGVkIGNvcHkgb2YgYGB2YWx1ZXNgYFxuICAgKi9cbiAgZnVuY3Rpb24gX3NvcnQ8VCBleHRlbmRzIFR5cGVNZW1iZXI+KHZhbHVlczogVFtdKTogVFtdIHtcbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcy5zb3J0KF9jb21wYXJhdG9yKTtcblxuICAgIGZ1bmN0aW9uIF9jb21wYXJhdG9yKGx2YWw6IFQsIHJ2YWw6IFQpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIF9mb3JtYXQobHZhbCkubG9jYWxlQ29tcGFyZShfZm9ybWF0KHJ2YWwpKTtcblxuICAgICAgZnVuY3Rpb24gX2Zvcm1hdCh2YWw6IFQpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHZhbC5zdGF0aWMgPyAnMCcgOiAnMScsXG4gICAgICAgICAgdmFsLmltbXV0YWJsZSA/ICcwJyA6ICcxJyxcbiAgICAgICAgICAhdmFsLm9wdGlvbmFsID8gJzAnIDogJzEnLFxuICAgICAgICAgIHZhbC5uYW1lLFxuICAgICAgICBdLmpvaW4oJ3wnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHlwZSBUeXBlTWVtYmVyID0ge1xuICAgIG5hbWU/OiBzdHJpbmc7IC8vIE1ldGhvZHMgJiBQcm9wZXJ0aWVzXG4gICAgc3RhdGljPzogYm9vbGVhbjsgLy8gTWV0aG9kcyAmIFByb3BlcnRpZXNcbiAgICBpbW11dGFibGU/OiBib29sZWFuOyAvLyAgICAgICAgICAgUHJvcGVydGllc1xuICAgIG9wdGlvbmFsPzogYm9vbGVhbjsgLy8gICAgICAgICAgIFByb3BlcnRpZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWZlcnJlZCBwcm9jZXNzaW5nIHRoYXQgbmVlZHMgdG8gaGFwcGVuIGluIGEgc2Vjb25kLCBvcmRlcmVkIHBhc3NcbiAqL1xuaW50ZXJmYWNlIERlZmVycmVkUmVjb3JkIHtcbiAgLyoqXG4gICAqIFRoZSBGUU4gb2YgdGhlIHR5cGUgdGhlIGFjdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIG9uXG4gICAqL1xuICBmcW46IHN0cmluZztcblxuICAvKipcbiAgICogRGVwZW5kZW5jeSBGUU5zIG9mIHRoZSB0eXBlcyB0aGF0IG5lZWQgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSBhbmFseXNpcy5cbiAgICpcbiAgICogQWxsIGRlZmVycmVkIGFuYWx5c2lzIGFjdGlvbnMgZm9yIHRoZSB0eXBlcyBsaXN0ZWQgaGVyZSBtdXN0IGJlIGNvbXBsZXRlXG4gICAqIGJlZm9yZSB0aGlzIGFuYWx5c2lzIGFjdGlvbiBjYW4gcnVuLlxuICAgKi9cbiAgZGVwZW5kZWRGcW5zOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgcmVwcmVzZW50aW5nIHRoZSBhY3Rpb24gdG8gcnVuLlxuICAgKi9cbiAgY2I6ICgpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSBhIGxpc3RcbiAqL1xuZnVuY3Rpb24gbGFzdDxUPih4czogVFtdKTogVCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB4cy5sZW5ndGggPiAwID8geHNbeHMubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiB0byBhIHZhbHVlIGlmIGl0J3Mgbm90IGVxdWFsIHRvIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBhcHBseTxULCBVPihcbiAgeDogVCB8IHVuZGVmaW5lZCxcbiAgZm46ICh4OiBUKSA9PiBVIHwgdW5kZWZpbmVkLFxuKTogVSB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB4ICE9PSB1bmRlZmluZWQgPyBmbih4KSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVyc2VjdGlvbiBvZiB0d28gc2V0c1xuICovXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb248VD4oeHM6IFNldDxUPiwgeXM6IFNldDxUPik6IFNldDxUPiB7XG4gIGNvbnN0IHJldCA9IG5ldyBTZXQ8VD4oKTtcbiAgZm9yIChjb25zdCB4IG9mIHhzKSB7XG4gICAgaWYgKHlzLmhhcyh4KSkge1xuICAgICAgcmV0LmFkZCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIG1lbWJlcnMgbmFtZXMgb2YgYSBKU0lJIGludGVyZmFjZSB0eXBlXG4gKlxuICogUmV0dXJucyBlbXB0eSBzdHJpbmcgZm9yIGEgbm9uLWludGVyZmFjZSB0eXBlLlxuICovXG5mdW5jdGlvbiBtZW1iZXJOYW1lcyhqc2lpVHlwZTogc3BlYy5JbnRlcmZhY2VUeXBlIHwgc3BlYy5DbGFzc1R5cGUpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0eXBlTWVtYmVycyhqc2lpVHlwZSkpLmZpbHRlcigobikgPT4gbiAhPT0gJycpO1xufVxuXG5mdW5jdGlvbiB0eXBlTWVtYmVycyhqc2lpVHlwZTogc3BlYy5JbnRlcmZhY2VUeXBlIHwgc3BlYy5DbGFzc1R5cGUpOiB7XG4gIFtrZXk6IHN0cmluZ106IHNwZWMuUHJvcGVydHkgfCBzcGVjLk1ldGhvZDtcbn0ge1xuICBjb25zdCByZXQ6IHsgW2tleTogc3RyaW5nXTogc3BlYy5Qcm9wZXJ0eSB8IHNwZWMuTWV0aG9kIH0gPSB7fTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2YganNpaVR5cGUucHJvcGVydGllcyA/PyBbXSkge1xuICAgIHJldFtwcm9wLm5hbWVdID0gcHJvcDtcbiAgfVxuXG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIGpzaWlUeXBlLm1ldGhvZHMgPz8gW10pIHtcbiAgICByZXRbbWV0aG9kLm5hbWUgPz8gJyddID0gbWV0aG9kO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gbmFtZSBpcyBjb252ZW50aW9uYWxseSBhbiBpbnRlcmZhY2UgbmFtZVxuICpcbiAqIEl0J3MgYW4gaW50ZXJmYWNlIG5hbWUgaWYgaXQgc3RhcnRzIHdpdGggSSBhbmQgaGFzIGFub3RoZXIgY2FwaXRhbFxuICogKHNvIHdlIGRvbid0IG1hcmsgSW9uaWNDb2x1bW5Qcm9wcyBhcyBhbiBpbnRlcmZhY2UpLlxuICovXG5mdW5jdGlvbiBpc0ludGVyZmFjZU5hbWUobmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiAoXG4gICAgbmFtZS5sZW5ndGggPj0gMiAmJlxuICAgIG5hbWUuc3RhcnRzV2l0aCgnSScpICYmXG4gICAgbmFtZS5jaGFyQXQoMSkudG9VcHBlckNhc2UoKSA9PT0gbmFtZS5jaGFyQXQoMSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IodHlwZTogdHMuVHlwZSk6IHRzLlN5bWJvbCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB0eXBlLnN5bWJvbC5tZW1iZXJzPy5nZXQodHMuSW50ZXJuYWxTeW1ib2xOYW1lLkNvbnN0cnVjdG9yKTtcbn1cblxuZnVuY3Rpb24qIGludGVyc2VjdDxUPih4czogU2V0PFQ+LCB5czogU2V0PFQ+KSB7XG4gIGZvciAoY29uc3QgeCBvZiB4cykge1xuICAgIGlmICh5cy5oYXMoeCkpIHtcbiAgICAgIHlpZWxkIHg7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vRW1wdHlEaWN0PFQ+KFxuICB4czogUmVjb3JkPHN0cmluZywgVD4gfCB1bmRlZmluZWQsXG4pOiBSZWNvcmQ8c3RyaW5nLCBUPiB8IHVuZGVmaW5lZCB7XG4gIGlmICh4cyA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHhzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB4cztcbn1cblxuZnVuY3Rpb24gdG9EZXBlbmRlbmN5Q2xvc3VyZShhc3NlbWJsaWVzOiByZWFkb25seSBzcGVjLkFzc2VtYmx5W10pOiB7XG4gIFtuYW1lOiBzdHJpbmddOiBzcGVjLkRlcGVuZGVuY3lDb25maWd1cmF0aW9uO1xufSB7XG4gIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogc3BlYy5EZXBlbmRlbmN5Q29uZmlndXJhdGlvbiB9ID0ge307XG4gIGZvciAoY29uc3QgYXNzZW1ibHkgb2YgYXNzZW1ibGllcykge1xuICAgIGlmICghYXNzZW1ibHkudGFyZ2V0cykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdFthc3NlbWJseS5uYW1lXSA9IHtcbiAgICAgIHN1Ym1vZHVsZXM6IGNsZWFuVXAoYXNzZW1ibHkuc3VibW9kdWxlcyksXG4gICAgICB0YXJnZXRzOiBhc3NlbWJseS50YXJnZXRzLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB1bm5lZWRlZCBmaWVsZHMgZnJvbSB0aGUgZW50cmllcyBwYXJ0IG9mIHRoZSBgZGVwZW5kZW5jeUNsb3N1cmVgXG4gICAqIHByb3BlcnR5LiBGaWVsZHMgc3VjaCBhcyBgcmVhZG1lYCBhcmUgbm90IG5lY2Vzc2FyeSBhbmQgY2FuIGJsb2F0IHVwIHRoZVxuICAgKiBhc3NlbWJseSBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgcmVtb3ZlcyB0aGUgYHJlYWRtZWAgYW5kIGBsb2NhdGlvbkluTW9kdWxlYCBmaWVsZHMgZnJvbSB0aGUgc3VibW9kdWxlXG4gICAqIGRlc2NyaXB0aW9zIGlmIHByZXNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzdWJtb2R1bGVzIHRoZSBzdWJtb2R1bGVzIGxpc3QgdG8gY2xlYW4gdXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjbGVhbmVkIHVwIHN1Ym1vZHVsZXMgbGlzdC5cbiAgICovXG4gIGZ1bmN0aW9uIGNsZWFuVXAoXG4gICAgc3VibW9kdWxlczogc3BlYy5Bc3NlbWJseVsnc3VibW9kdWxlcyddLFxuICApOiBzcGVjLkRlcGVuZGVuY3lDb25maWd1cmF0aW9uWydzdWJtb2R1bGVzJ10ge1xuICAgIGlmIChzdWJtb2R1bGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdWJtb2R1bGVzO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQ6IHNwZWMuRGVwZW5kZW5jeUNvbmZpZ3VyYXRpb25bJ3N1Ym1vZHVsZXMnXSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2ZxbiwgeyB0YXJnZXRzIH1dIG9mIE9iamVjdC5lbnRyaWVzKHN1Ym1vZHVsZXMpKSB7XG4gICAgICByZXN1bHRbZnFuXSA9IHsgdGFyZ2V0cyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3VibW9kdWxlRGVjbGFyYXRpb25zKFxuICBzdWJtb2R1bGVzOiBJdGVyYWJsZTxTdWJtb2R1bGVTcGVjPixcbik6IHNwZWMuQXNzZW1ibHlbJ3N1Ym1vZHVsZXMnXSB7XG4gIGNvbnN0IHJlc3VsdDogc3BlYy5Bc3NlbWJseVsnc3VibW9kdWxlcyddID0ge307XG5cbiAgZm9yIChjb25zdCBzdWJtb2R1bGUgb2Ygc3VibW9kdWxlcykge1xuICAgIHJlc3VsdFtzdWJtb2R1bGUuZnFuXSA9IHtcbiAgICAgIGxvY2F0aW9uSW5Nb2R1bGU6IHN1Ym1vZHVsZS5sb2NhdGlvbkluTW9kdWxlLFxuICAgICAgdGFyZ2V0czogc3VibW9kdWxlLnRhcmdldHMsXG4gICAgICByZWFkbWU6IHN1Ym1vZHVsZS5yZWFkbWUsXG4gICAgICBzeW1ib2xJZDogc3VibW9kdWxlLnN5bWJvbElkLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyB0eXBlIGlzIHRoZSBpbnRyaW5zaWMgVHlwZVNjcmlwdCBcImVycm9yIHR5cGVcIlxuICpcbiAqIFRoaXMgdHlwZSBpcyByZXR1cm5lZCBpZiB0eXBlIGxvb2t1cCBmYWlscy4gVW5mb3J0dW5hdGVseSBubyBwdWJsaWNcbiAqIGFjY2Vzc29ycyBmb3IgaXQgYXJlIGV4cG9zZWQuXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3JUeXBlKHQ6IHRzLlR5cGUpIHtcbiAgcmV0dXJuICh0IGFzIGFueSkuaW50cmluc2ljTmFtZSA9PT0gJ2Vycm9yJztcbn1cblxuLyoqXG4gKiBUaG9zZSBoYXZlIHNwZWNpZmljIHNlbWFudGljcyBpbiBjZXJ0YWluIGxhbmd1YWdlcyB0aGF0IGRvbid0IGFsd2F5cyB0cmFuc2xhdGUgY2xlYW5seSBpbiBvdGhlcnNcbiAqIChsaWtlIGhvdyBlcXVhbHMvaGFzaENvZGUgYXJlIG5vdCBhIHRoaW5nIGluIEphdmFzY3JpcHQsIGJ1dCBjYXJyeSBtZWFuaW5nIGluIEphdmEgYW5kIEMjKS4gVGhlXG4gKiBgYnVpbGRgIG5hbWUgaXMgcmVzZXJ2ZWQgZm9yIGdlbmVyYXRlZCBjb2RlIChKYXZhIGJ1aWxkZXJzIHVzZSB0aGF0KS5cbiAqL1xuY29uc3QgUFJPSElCSVRFRF9NRU1CRVJfTkFNRVMgPSBbJ2J1aWxkJywgJ2VxdWFscycsICdoYXNoY29kZSddO1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGdpdmVuIG5hbWUgaXMgcHJvaGliaXRlZFxuICovXG5mdW5jdGlvbiBpc1Byb2hpYml0ZWRNZW1iZXJOYW1lKG5hbWU6IHN0cmluZykge1xuICByZXR1cm4gUFJPSElCSVRFRF9NRU1CRVJfTkFNRVMuaW5jbHVkZXMobmFtZS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY29udGV4dCBpbiB3aGljaCBhIGRlY2xhcmF0aW9uIGlzIGVtaXR0ZWQuXG4gKi9cbmNsYXNzIEVtaXRDb250ZXh0IHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lc3BhY2U6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICAgIHB1YmxpYyByZWFkb25seSBzdGFiaWxpdHk/OiBzcGVjLlN0YWJpbGl0eSxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRW1pdENvbnRleHQgYnkgYXBwZW5kaW5nIGEgbmFtZXNwYWNlIGVudHJ5IGF0IHRoZSBlbmQuXG4gICAqIEBwYXJhbSBlbGVtZW50IHRoZSBuZXcgbmFtZXNwYWNlIGVudHJ5LlxuICAgKi9cbiAgcHVibGljIGFwcGVuZE5hbWVzcGFjZShlbGVtZW50OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IEVtaXRDb250ZXh0KFsuLi50aGlzLm5hbWVzcGFjZSwgZWxlbWVudF0sIHRoaXMuc3RhYmlsaXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRW1pdENvbnRleHQgYnkgcmVwbGFjaW5nIHRoZSBzdGFiaWxpdHkuXG4gICAqIEBwYXJhbSBzdGFiaWxpdHkgdGhlIG5ldyBzdGFiaWxpdHksIGlmIGF2YWlsYWJsZS5cbiAgICovXG4gIHB1YmxpYyByZXBsYWNlU3RhYmlsaXR5KHN0YWJpbGl0eT86IHNwZWMuU3RhYmlsaXR5KSB7XG4gICAgaWYgKCFzdGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVtaXRDb250ZXh0KHRoaXMubmFtZXNwYWNlLCBzdGFiaWxpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBFbWl0Q29udGV4dCB3aXRob3V0IHN0YWJpbGl0eS5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVTdGFiaWxpdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBFbWl0Q29udGV4dCh0aGlzLm5hbWVzcGFjZSwgdW5kZWZpbmVkKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmbGF0dGVuUHJvbWlzZXM8VD4ocHJvbWlzZXM6IEFycmF5PFByb21pc2U8VFtdPj4pOiBQcm9taXNlPFRbXT4ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8VD4oKTtcbiAgZm9yIChjb25zdCBzdWJzZXQgb2YgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpKSB7XG4gICAgcmVzdWx0LnB1c2goLi4uc3Vic2V0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpbmZlclJvb3REaXIocHJvZ3JhbTogdHMuUHJvZ3JhbSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGRpcmVjdG9yaWVzID0gcHJvZ3JhbVxuICAgIC5nZXRSb290RmlsZU5hbWVzKClcbiAgICAuZmlsdGVyKChmaWxlTmFtZSkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlRmlsZSA9IHByb2dyYW0uZ2V0U291cmNlRmlsZShmaWxlTmFtZSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzb3VyY2VGaWxlICE9IG51bGwgJiZcbiAgICAgICAgIXByb2dyYW0uaXNTb3VyY2VGaWxlRnJvbUV4dGVybmFsTGlicmFyeShzb3VyY2VGaWxlKSAmJlxuICAgICAgICAhcHJvZ3JhbS5pc1NvdXJjZUZpbGVEZWZhdWx0TGlicmFyeShzb3VyY2VGaWxlKVxuICAgICAgKTtcbiAgICB9KVxuICAgIC5tYXAoKGZpbGVOYW1lKSA9PlxuICAgICAgcGF0aC5yZWxhdGl2ZShwcm9ncmFtLmdldEN1cnJlbnREaXJlY3RvcnkoKSwgcGF0aC5kaXJuYW1lKGZpbGVOYW1lKSksXG4gICAgKVxuICAgIC5tYXAoc2VnbWVudFBhdGgpO1xuXG4gIGNvbnN0IG1heFByZWZpeCA9IE1hdGgubWluKFxuICAgIC4uLmRpcmVjdG9yaWVzLm1hcCgoc2VnbWVudHMpID0+IHNlZ21lbnRzLmxlbmd0aCAtIDEpLFxuICApO1xuICBsZXQgY29tbW9uSW5kZXggPSAtMTtcbiAgd2hpbGUgKFxuICAgIGNvbW1vbkluZGV4IDwgbWF4UHJlZml4ICYmXG4gICAgbmV3IFNldChkaXJlY3Rvcmllcy5tYXAoKHNlZ21lbnRzKSA9PiBzZWdtZW50c1tjb21tb25JbmRleCArIDFdKSkuc2l6ZSA9PT0gMVxuICApIHtcbiAgICBjb21tb25JbmRleCsrO1xuICB9XG5cbiAgaWYgKGNvbW1vbkluZGV4IDwgMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0b3JpZXNbMF1bY29tbW9uSW5kZXhdO1xuXG4gIGZ1bmN0aW9uIHNlZ21lbnRQYXRoKGZpbGVOYW1lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBmb3IgKFxuICAgICAgbGV0IHBhcmVudCA9IGZpbGVOYW1lO1xuICAgICAgcGFyZW50ICE9PSBwYXRoLmRpcm5hbWUocGFyZW50KTtcbiAgICAgIHBhcmVudCA9IHBhdGguZGlybmFtZShwYXJlbnQpXG4gICAgKSB7XG4gICAgICByZXN1bHQudW5zaGlmdChwYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB0eXBlIGlzIGEgc2luZ2xlLXZhbHVlZCBlbnVtLiBJdCBpcyBuZWNlc3NhcnlcbiAqIHRvIGNoZWNrIGFzIGVudW1zIGFyZSB1bmlvbi1saWtlIGluIHRoZSB0eXBlIG1vZGVsLCBhbmQgc2luZ2xlLXZhbHVlZCBlbnVtXG4gKiB0eXBlcyBhcmUgYWN0dWFsbHkgcmVkdWNlZCB0byB0aGUgb25seSBhdmFpbGFibGUgbGl0ZXJhbCwgd2hpY2ggY2FuIHRyaXBcbiAqIHRoZSBhc3NlbWJsZXIuXG4gKlxuICogQHBhcmFtIHR5cGUgICAgICAgIHRoZSB0eXBlIGJlaW5nIGNoZWNrZWQuXG4gKiBAcGFyYW0gdHlwZUNoZWNrZXIgdGhlIHR5cGUgY2hlY2tlciB0byB1c2UgdG8gZ2V0IG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJldHVybiBgdHJ1ZWAgaWYgYHR5cGVgIGlzIGEgc2luZ2xlLXZhbHVlZCBlbnVtIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlVmFsdWVkRW51bShcbiAgdHlwZTogdHMuVHlwZSxcbiAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuKTogdHlwZSBpcyB0cy5FbnVtVHlwZSB7XG4gIGlmICh0eXBlLmlzTGl0ZXJhbCgpICYmIF9pc0VudW1MaWtlKHR5cGUpKSB7XG4gICAgLy8gU2luZ2xlLVZhbHVlZCBlbnVtcyBhcmUgcmVkdWNlZCB0byB0aGUgb25seSBsaXRlcmFsIGF2YWlsYWJsZS5cbiAgICByZXR1cm4gdHlwZSA9PT0gdHlwZUNoZWNrZXIuZ2V0QmFzZVR5cGVPZkxpdGVyYWxUeXBlKHR5cGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZFBhY2thZ2VJbmZvKFxuICBmcm9tRGlyOiBzdHJpbmcsXG4pOiBQcm9taXNlPFBhY2thZ2VKc29uIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGZyb21EaXIsICdwYWNrYWdlLmpzb24nKTtcbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoZmlsZVBhdGgpKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRKc29uKGZpbGVQYXRoKTtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZnJvbURpcik7XG4gIGlmIChwYXJlbnQgPT09IGZyb21EaXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmaW5kUGFja2FnZUluZm8ocGFyZW50KTtcbn1cblxuZnVuY3Rpb24gcGFyYW1Eb2NzKFxuICBwYXJhbXM/OiByZWFkb25seSBzcGVjLlBhcmFtZXRlcltdLFxuKTogUmVjb3JkPHN0cmluZywgc3BlYy5Eb2NzPiB7XG4gIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgc3BlYy5Eb2NzPiA9IHt9O1xuICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcyA/PyBbXSkge1xuICAgIGlmIChwYXJhbS5kb2NzKSB7XG4gICAgICByZXRbcGFyYW0ubmFtZV0gPSBwYXJhbS5kb2NzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpcyB0aGUgcHJvdmlkZWQgdHlwZSBpcyBcInRoaXNcIiAoYXMgYSB0eXBlIGFubm90YXRpb24pLlxuICpcbiAqIEBwYXJhbSB0eXBlICAgICAgICB0aGUgdmFsaWRhdGVkIHR5cGUuXG4gKiBAcGFyYW0gdHlwZUNoZWNrZXIgdGhlIHR5cGUgY2hlY2tlci5cbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWlmIHRoZSB0eXBlIGlzIGB0aGlzYFxuICovXG5mdW5jdGlvbiBfaXNUaGlzVHlwZSh0eXBlOiB0cy5UeXBlLCB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVDaGVja2VyLnR5cGVUb1R5cGVOb2RlKHR5cGUpPy5raW5kID09PSB0cy5TeW50YXhLaW5kLlRoaXNLZXl3b3JkO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgbm9kZSBmb3IgYSBnaXZlbiBzeW1ib2w7IG9yIGl0J3MgZmlyc3QgZGVjbGFyYXRpb24gaWYgbm8gbmFtZSBjYW4gYmUgZm91bmQuIFRoaXMgaXNcbiAqIGludGVuZGVkIGZvciB1c2UgaW4gcGxhY2luZyBwcm9ibGVtIG1hcmtlcnMgb24gdGhlIHJpZ2h0IGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBzeW1ib2wgdGhlIHN5bWJvbCBmb3Igd2hpY2ggdGhlIG5hbWUgbm9kZSBpcyBuZWVkZWQuXG4gKlxuICogQHJldHVybnMgdGhlIG5hbWUgbm9kZSBmb3IgdGhlIHN5bWJvbCwgb3IgdGhlIHN5bWJvbCdzIGZpcnN0IGRlY2xhcmF0aW9uLlxuICovXG5mdW5jdGlvbiBfbmFtZU9yRGVjbGFyYXRpb25Ob2RlKHN5bWJvbDogdHMuU3ltYm9sKTogdHMuTm9kZSB7XG4gIGNvbnN0IGRlY2xhcmF0aW9uID0gc3ltYm9sLnZhbHVlRGVjbGFyYXRpb24gPz8gc3ltYm9sLmRlY2xhcmF0aW9uc1swXTtcbiAgcmV0dXJuIHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSA/PyBkZWNsYXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gX2ZpbmRIaW50KFxuICBkZWNsOiB0cy5EZWNsYXJhdGlvbixcbiAgaGludDogc3RyaW5nLFxuKTogdHMuSlNEb2NUYWcgfCB1bmRlZmluZWQge1xuICBjb25zdCBbbm9kZV0gPSB0cy5nZXRBbGxKU0RvY1RhZ3MoXG4gICAgZGVjbCxcbiAgICAodGFnKTogdGFnIGlzIHRzLkpTRG9jVGFnID0+IHRhZy50YWdOYW1lLnRleHQgPT09IGhpbnQsXG4gICk7XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEEgbG9jYXRpb24gd2hlcmUgYSB0eXBlIGNhbiBiZSB1c2VkLlxuICovXG50eXBlIFR5cGVVc2VLaW5kID1cbiAgfCAnYmFzZSBjbGFzcydcbiAgfCAnYmFzZSBpbnRlcmZhY2UnXG4gIHwgJ2xpc3QgZWxlbWVudCB0eXBlJ1xuICB8ICdtYXAgZWxlbWVudCB0eXBlJ1xuICB8ICdwYXJhbWV0ZXIgdHlwZSdcbiAgfCAncHJvcGVydHkgdHlwZSdcbiAgfCAncmV0dXJuIHR5cGUnO1xuXG4vKipcbiAqIFJlc29sdmUgYSBUeXBlIHRvIFN5bWJvbCwgdGFraW5nIGludG8gYWNjb3VudCBzaW5nbGUtdmFsdWVkIGVudW1zIHdoaWNoIGhhdmUgYSBidWdcbiAqXG4gKiBCdWcgcmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ2NzU1XG4gKi9cbmZ1bmN0aW9uIHN5bWJvbEZyb21UeXBlKHR5cGU6IHRzLlR5cGUsIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcik6IHRzLlN5bWJvbCB7XG4gIGlmICgodHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5FbnVtTGl0ZXJhbCkgPT09IDApIHtcbiAgICByZXR1cm4gdHlwZS5zeW1ib2w7XG4gIH1cblxuICBjb25zdCBkZWNsID0gdHlwZS5zeW1ib2wuZGVjbGFyYXRpb25zPy5bMF07XG4gIGlmICghZGVjbCkge1xuICAgIHJldHVybiB0eXBlLnN5bWJvbDtcbiAgfVxuXG4gIGlmICghdHMuaXNFbnVtTWVtYmVyKGRlY2wpKSB7XG4gICAgcmV0dXJuIHR5cGUuc3ltYm9sO1xuICB9XG5cbiAgY29uc3QgcGFyZW50RGVjbCA9IGRlY2wucGFyZW50O1xuICBpZiAoIXBhcmVudERlY2wgfHwgIXRzLmlzRW51bURlY2xhcmF0aW9uKHBhcmVudERlY2wpKSB7XG4gICAgcmV0dXJuIHR5cGUuc3ltYm9sO1xuICB9XG5cbiAgY29uc3QgbmFtZSA9IHRzLmdldE5hbWVPZkRlY2xhcmF0aW9uKHBhcmVudERlY2wpO1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gdHlwZS5zeW1ib2w7XG4gIH1cbiAgcmV0dXJuIHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obmFtZSkgPz8gdHlwZS5zeW1ib2w7XG59XG5cbmNvbnN0IFNZTUJPTElEX0NBQ0hFID0gbmV3IFdlYWtNYXA8c3BlYy5Bc3NlbWJseSwgUmVjb3JkPHN0cmluZywgc3RyaW5nPj4oKTtcblxuLyoqXG4gKiBCdWlsZCBhbmQgcmV0dXJuIGFuIGluZGV4IG9mIHsgc3ltYm9sSWQgLT4gZnFuIH1cbiAqXG4gKiBVc2VzIGEgY2FjaGUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKi9cbmZ1bmN0aW9uIHN5bWJvbElkSW5kZXgoYXNtOiBzcGVjLkFzc2VtYmx5KTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIGNvbnN0IGV4aXN0aW5nID0gU1lNQk9MSURfQ0FDSEUuZ2V0KGFzbSk7XG4gIGlmIChleGlzdGluZykge1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIGNvbnN0IHJldCA9IGJ1aWxkSW5kZXgoKTtcbiAgU1lNQk9MSURfQ0FDSEUuc2V0KGFzbSwgcmV0KTtcbiAgcmV0dXJuIHJldDtcblxuICBmdW5jdGlvbiBidWlsZEluZGV4KCkge1xuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGZvciAoY29uc3QgW2ZxbiwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMoYXNtLnR5cGVzID8/IHt9KSkge1xuICAgICAgaWYgKHR5cGUuc3ltYm9sSWQpIHtcbiAgICAgICAgcmV0W3R5cGUuc3ltYm9sSWRdID0gZnFuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN5bWJvbEZyb21EZWNsYXJhdGlvbihcbiAgZGVjbDogdHMuRGVjbGFyYXRpb24sXG4gIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbik6IHRzLlN5bWJvbCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IG5hbWUgPSB0cy5nZXROYW1lT2ZEZWNsYXJhdGlvbihkZWNsKTtcbiAgcmV0dXJuIG5hbWUgPyB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5hbWUpIDogdW5kZWZpbmVkO1xufVxuIl19