"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compiler = exports.JSII_DIAGNOSTICS_CODE = exports.DIAGNOSTICS = void 0;
const Case = require("case");
const colors = require("colors/safe");
const fs = require("fs-extra");
const log4js = require("log4js");
const path = require("path");
const ts = require("typescript");
const assembler_1 = require("./assembler");
const jsii_diagnostic_1 = require("./jsii-diagnostic");
const deprecation_warnings_1 = require("./transforms/deprecation-warnings");
const utils = require("./utils");
const BASE_COMPILER_OPTIONS = {
    alwaysStrict: true,
    charset: 'utf8',
    declaration: true,
    experimentalDecorators: true,
    incremental: true,
    inlineSourceMap: true,
    inlineSources: true,
    lib: ['lib.es2019.d.ts'],
    module: ts.ModuleKind.CommonJS,
    newLine: ts.NewLineKind.LineFeed,
    noEmitOnError: true,
    noFallthroughCasesInSwitch: true,
    noImplicitAny: true,
    noImplicitReturns: true,
    noImplicitThis: true,
    noUnusedLocals: true,
    noUnusedParameters: true,
    resolveJsonModule: true,
    strict: true,
    strictNullChecks: true,
    strictPropertyInitialization: true,
    stripInternal: false,
    target: ts.ScriptTarget.ES2019,
};
const LOG = log4js.getLogger('jsii/compiler');
exports.DIAGNOSTICS = 'diagnostics';
exports.JSII_DIAGNOSTICS_CODE = 9999;
class Compiler {
    constructor(options) {
        var _a;
        this.options = options;
        this.rootFiles = [];
        this.compilerHost = ts.createIncrementalCompilerHost(BASE_COMPILER_OPTIONS, {
            ...ts.sys,
            getCurrentDirectory: () => this.options.projectInfo.projectRoot,
        });
        const configFileName = (_a = options.generateTypeScriptConfig) !== null && _a !== void 0 ? _a : 'tsconfig.json';
        this.configPath = path.join(this.options.projectInfo.projectRoot, configFileName);
        this.projectReferences =
            options.projectReferences !== undefined
                ? options.projectReferences
                : options.projectInfo.projectReferences !== undefined
                    ? options.projectInfo.projectReferences
                    : false;
    }
    /**
     * Compiles the configured program.
     *
     * @param files can be specified to override the standard source code location logic. Useful for example when testing "negatives".
     */
    async emit(...files) {
        await this._prepareForBuild(...files);
        return this._buildOnce();
    }
    async watch(opts) {
        await this._prepareForBuild();
        const pi = this.options.projectInfo;
        const projectRoot = pi.projectRoot;
        const host = ts.createWatchCompilerHost(this.configPath, {
            ...pi.tsc,
            ...BASE_COMPILER_OPTIONS,
            noEmitOnError: false,
        }, {
            ...ts.sys,
            getCurrentDirectory() {
                return projectRoot;
            },
        }, ts.createEmitAndSemanticDiagnosticsBuilderProgram, opts === null || opts === void 0 ? void 0 : opts.reportDiagnostics, opts === null || opts === void 0 ? void 0 : opts.reportWatchStatus);
        if (!host.getDefaultLibLocation) {
            throw new Error('No default library location was found on the TypeScript compiler host!');
        }
        const orig = host.afterProgramCreate;
        host.afterProgramCreate = async (builderProgram) => {
            const emitResult = await this._consumeProgram(builderProgram.getProgram(), host.getDefaultLibLocation());
            for (const diag of emitResult.diagnostics.filter((d) => d.code === exports.JSII_DIAGNOSTICS_CODE)) {
                utils.logDiagnostic(diag, projectRoot);
            }
            if (orig) {
                orig.call(host, builderProgram);
            }
            if (opts === null || opts === void 0 ? void 0 : opts.compilationComplete) {
                await opts.compilationComplete(emitResult);
            }
        };
        const watch = ts.createWatchProgram(host);
        if (opts === null || opts === void 0 ? void 0 : opts.nonBlocking) {
            // In non-blocking mode, returns the handle to the TypeScript watch interface.
            return watch;
        }
        // In blocking mode, returns a never-resolving promise.
        return new Promise(() => null);
    }
    /**
     * Prepares the project for build, by creating the necessary configuration
     * file(s), and assigning the relevant root file(s).
     *
     * @param files the files that were specified as input in the CLI invocation.
     */
    async _prepareForBuild(...files) {
        await this.buildTypeScriptConfig();
        await this.writeTypeScriptConfig();
        this.rootFiles = this.determineSources(files);
    }
    /**
     * Do a single build
     */
    async _buildOnce() {
        var _a, _b;
        if (!this.compilerHost.getDefaultLibLocation) {
            throw new Error('No default library location was found on the TypeScript compiler host!');
        }
        const tsconf = this.typescriptConfig;
        const pi = this.options.projectInfo;
        const prog = ts.createIncrementalProgram({
            rootNames: this.rootFiles.concat(_pathOfLibraries(this.compilerHost)),
            options: {
                ...pi.tsc,
                ...((_a = tsconf === null || tsconf === void 0 ? void 0 : tsconf.compilerOptions) !== null && _a !== void 0 ? _a : BASE_COMPILER_OPTIONS),
            },
            // Make the references absolute for the compiler
            projectReferences: (_b = tsconf.references) === null || _b === void 0 ? void 0 : _b.map((ref) => ({
                path: path.resolve(path.dirname(this.configPath), ref.path),
            })),
            host: this.compilerHost,
        });
        return this._consumeProgram(prog.getProgram(), this.compilerHost.getDefaultLibLocation());
    }
    async _consumeProgram(program, stdlib) {
        const diagnostics = [...ts.getPreEmitDiagnostics(program)];
        let hasErrors = false;
        if (!hasErrors && this.diagsHaveAbortableErrors(diagnostics)) {
            hasErrors = true;
            LOG.error('Compilation errors prevented the JSII assembly from being created');
        }
        // Do the "Assembler" part first because we need some of the analysis done in there
        // to post-process the AST
        const assembler = new assembler_1.Assembler(this.options.projectInfo, program, stdlib, {
            stripDeprecated: this.options.stripDeprecated,
            stripDeprecatedAllowListFile: this.options.stripDeprecatedAllowListFile,
            addDeprecationWarnings: this.options.addDeprecationWarnings,
        });
        try {
            const assmEmit = await assembler.emit();
            if (!hasErrors &&
                (assmEmit.emitSkipped ||
                    this.diagsHaveAbortableErrors(assmEmit.diagnostics))) {
                hasErrors = true;
                LOG.error('Type model errors prevented the JSII assembly from being created');
            }
            diagnostics.push(...assmEmit.diagnostics);
        }
        catch (e) {
            diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_9997_UNKNOWN_ERROR.createDetached(e));
            hasErrors = true;
        }
        // Do the emit, but add in transformers which are going to replace real
        // comments with synthetic ones.
        const emit = program.emit(undefined, // targetSourceFile
        undefined, // writeFile
        undefined, // cancellationToken
        undefined, // emitOnlyDtsFiles
        assembler.customTransformers);
        diagnostics.push(...emit.diagnostics);
        if (!hasErrors &&
            (emit.emitSkipped || this.diagsHaveAbortableErrors(emit.diagnostics))) {
            hasErrors = true;
            LOG.error('Compilation errors prevented the JSII assembly from being created');
        }
        // Some extra validation on the config.
        // Make sure that { "./.warnings.jsii.js": "./.warnings.jsii.js" } is in the set of
        // exports, if they are specified.
        if (this.options.addDeprecationWarnings &&
            this.options.projectInfo.exports !== undefined) {
            const expected = `./${deprecation_warnings_1.WARNINGSCODE_FILE_NAME}`;
            const warningsExport = Object.entries(this.options.projectInfo.exports).filter(([k, v]) => k === expected && v === expected);
            if (warningsExport.length === 0) {
                hasErrors = true;
                diagnostics.push(jsii_diagnostic_1.JsiiDiagnostic.JSII_0007_MISSING_WARNINGS_EXPORT.createDetached());
            }
        }
        return {
            emitSkipped: hasErrors,
            diagnostics: ts.sortAndDeduplicateDiagnostics(diagnostics),
            emittedFiles: emit.emittedFiles,
        };
    }
    /**
     * Build the TypeScript config object
     *
     * This is the object that will be written to disk.
     */
    async buildTypeScriptConfig() {
        var _a, _b, _c, _d, _e, _f;
        let references;
        if (this.projectReferences) {
            references = await this.findProjectReferences();
        }
        const pi = this.options.projectInfo;
        this.typescriptConfig = {
            compilerOptions: {
                ...pi.tsc,
                ...BASE_COMPILER_OPTIONS,
                // Enable composite mode if project references are enabled
                composite: this.projectReferences,
                // When incremental, configure a tsbuildinfo file
                tsBuildInfoFile: path.join((_b = (_a = pi.tsc) === null || _a === void 0 ? void 0 : _a.outDir) !== null && _b !== void 0 ? _b : '.', 'tsconfig.tsbuildinfo'),
            },
            include: [
                ((_c = pi.tsc) === null || _c === void 0 ? void 0 : _c.rootDir) != null
                    ? path.join(pi.tsc.rootDir, '**', '*.ts')
                    : path.join('**', '*.ts'),
            ],
            exclude: [
                'node_modules',
                ...((_d = pi.excludeTypescript) !== null && _d !== void 0 ? _d : []),
                ...(((_e = pi.tsc) === null || _e === void 0 ? void 0 : _e.outDir) != null &&
                    (((_f = pi.tsc) === null || _f === void 0 ? void 0 : _f.rootDir) == null ||
                        path
                            .resolve(pi.tsc.outDir)
                            .startsWith(path.resolve(pi.tsc.rootDir) + path.sep))
                    ? [path.join(pi.tsc.outDir, '**', '*.ts')]
                    : []),
            ],
            // Change the references a little. We write 'originalpath' to the
            // file under the 'path' key, which is the same as what the
            // TypeScript compiler does. Make it relative so that the files are
            // movable. Not strictly required but looks better.
            references: references === null || references === void 0 ? void 0 : references.map((p) => ({ path: p })),
        };
    }
    /**
     * Creates a `tsconfig.json` file to improve the IDE experience.
     *
     * @return the fully qualified path to the `tsconfig.json` file
     */
    async writeTypeScriptConfig() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const commentKey = '_generated_by_jsii_';
        const commentValue = 'Generated by jsii - safe to delete, and ideally should be in .gitignore';
        this.typescriptConfig[commentKey] = commentValue;
        if (await fs.pathExists(this.configPath)) {
            const currentConfig = await fs.readJson(this.configPath);
            if (!(commentKey in currentConfig)) {
                throw new Error(`A '${this.configPath}' file that was not generated by jsii is in ${this.options.projectInfo.projectRoot}. Aborting instead of overwriting.`);
            }
        }
        const outputConfig = {
            ...this.typescriptConfig,
            compilerOptions: {
                ...(_a = this.typescriptConfig) === null || _a === void 0 ? void 0 : _a.compilerOptions,
                lib: (_d = (_c = (_b = this.typescriptConfig) === null || _b === void 0 ? void 0 : _b.compilerOptions) === null || _c === void 0 ? void 0 : _c.lib) === null || _d === void 0 ? void 0 : _d.map((lib) => 
                // Drop the "lib." prefix and ".d.ts" suffix before writing up the tsconfig.json file
                lib.slice(4, lib.length - 5)),
                // Re-write the module, targets & jsx to be the JSON format instead of Programmatic API
                module: (((_f = (_e = this.typescriptConfig) === null || _e === void 0 ? void 0 : _e.compilerOptions) === null || _f === void 0 ? void 0 : _f.module) &&
                    ts.ModuleKind[this.typescriptConfig.compilerOptions.module]),
                newLine: newLineForTsconfigJson((_g = this.typescriptConfig) === null || _g === void 0 ? void 0 : _g.compilerOptions.newLine),
                target: (((_j = (_h = this.typescriptConfig) === null || _h === void 0 ? void 0 : _h.compilerOptions) === null || _j === void 0 ? void 0 : _j.target) &&
                    ts.ScriptTarget[this.typescriptConfig.compilerOptions.target]),
                jsx: (((_l = (_k = this.typescriptConfig) === null || _k === void 0 ? void 0 : _k.compilerOptions) === null || _l === void 0 ? void 0 : _l.jsx) &&
                    Case.snake(ts.JsxEmit[this.typescriptConfig.compilerOptions.jsx])),
            },
        };
        LOG.debug(`Creating or updating ${colors.blue(this.configPath)}`);
        await fs.writeJson(this.configPath, outputConfig, {
            encoding: 'utf8',
            spaces: 2,
        });
        /**
         * This is annoying - the values expected in the tsconfig.json file are not
         * the same as the enum constant names, or their values. So we need this
         * function to map the "compiler API version" to the "tsconfig.json version"
         *
         * @param newLine the compiler form of the new line configuration
         *
         * @return the requivalent value to put in tsconfig.json
         */
        function newLineForTsconfigJson(newLine) {
            switch (newLine) {
                case ts.NewLineKind.CarriageReturnLineFeed:
                    return 'crlf';
                case ts.NewLineKind.LineFeed:
                    return 'lf';
                default:
                    return undefined;
            }
        }
    }
    /**
     * Find all dependencies that look like TypeScript projects.
     *
     * Enumerate all dependencies, if they have a tsconfig.json file with
     * "composite: true" we consider them project references.
     *
     * (Note: TypeScript seems to only correctly find transitive project references
     * if there's an "index" tsconfig.json of all projects somewhere up the directory
     * tree)
     */
    async findProjectReferences() {
        var _a;
        const pkg = this.options.projectInfo.packageJson;
        const ret = new Array();
        const dependencyNames = new Set();
        for (const dependencyMap of [
            pkg.dependencies,
            pkg.devDependencies,
            pkg.peerDependencies,
        ]) {
            if (dependencyMap === undefined) {
                continue;
            }
            Object.keys(dependencyMap).forEach(dependencyNames.add.bind(dependencyNames));
        }
        for (const tsconfigFile of await Promise.all(Array.from(dependencyNames).map((depName) => this.findMonorepoPeerTsconfig(depName)))) {
            if (!tsconfigFile) {
                continue;
            }
            const { config: tsconfig } = ts.readConfigFile(tsconfigFile, ts.sys.readFile);
            // Add references to any TypeScript package we find that is 'composite' enabled.
            // Make it relative.
            if ((_a = tsconfig.compilerOptions) === null || _a === void 0 ? void 0 : _a.composite) {
                ret.push(path.relative(this.options.projectInfo.projectRoot, path.dirname(tsconfigFile)));
            }
            else {
                // Not a composite package--if this package is in a node_modules directory, that is most
                // likely correct, otherwise it is most likely an error (heuristic here, I don't know how to
                // properly check this).
                if (tsconfigFile.includes('node_modules')) {
                    LOG.warn('%s: not a composite TypeScript package, but it probably should be', path.dirname(tsconfigFile));
                }
            }
        }
        return ret;
    }
    /**
     * Find source files using the same mechanism that the TypeScript compiler itself uses.
     *
     * Respects includes/excludes/etc.
     *
     * This makes it so that running 'tsc' and running 'jsii' has the same behavior.
     */
    determineSources(files) {
        const ret = new Array();
        if (files.length > 0) {
            ret.push(...files);
        }
        else {
            const parseConfigHost = parseConfigHostFromCompilerHost(this.compilerHost);
            const parsed = ts.parseJsonConfigFileContent(this.typescriptConfig, parseConfigHost, this.options.projectInfo.projectRoot);
            ret.push(...parsed.fileNames);
        }
        return ret;
    }
    /**
     * Resolve the given dependency name from the current package, and find the associated tsconfig.json location
     *
     * Because we have the following potential directory layout:
     *
     *   package/node_modules/some_dependency
     *   package/tsconfig.json
     *
     * We resolve symlinks and only find a "TypeScript" dependency if doesn't have 'node_modules' in
     * the path after resolving symlinks (i.e., if it's a peer package in the same monorepo).
     *
     * Returns undefined if no such tsconfig could be found.
     */
    async findMonorepoPeerTsconfig(depName) {
        // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires
        const { builtinModules } = require('module');
        if ((builtinModules !== null && builtinModules !== void 0 ? builtinModules : []).includes(depName)) {
            // Can happen for modules like 'punycode' which are declared as dependency for polyfill purposes
            return undefined;
        }
        try {
            const depDir = await utils.findDependencyDirectory(depName, this.options.projectInfo.projectRoot);
            const dep = path.join(depDir, 'tsconfig.json');
            if (!(await fs.pathExists(dep))) {
                return undefined;
            }
            // Resolve symlinks, to check if this is a monorepo peer
            const dependencyRealPath = await fs.realpath(dep);
            if (dependencyRealPath.split(path.sep).includes('node_modules')) {
                return undefined;
            }
            return dependencyRealPath;
        }
        catch (e) {
            // @types modules cannot be required, for example
            if (['MODULE_NOT_FOUND', 'ERR_PACKAGE_PATH_NOT_EXPORTED'].includes(e.code)) {
                return undefined;
            }
            throw e;
        }
    }
    diagsHaveAbortableErrors(diags) {
        return diags.some((d) => d.category === ts.DiagnosticCategory.Error ||
            (this.options.failOnWarnings &&
                d.category === ts.DiagnosticCategory.Warning));
    }
}
exports.Compiler = Compiler;
function _pathOfLibraries(host) {
    var _a;
    if (!BASE_COMPILER_OPTIONS.lib || BASE_COMPILER_OPTIONS.lib.length === 0) {
        return [];
    }
    const lib = (_a = host.getDefaultLibLocation) === null || _a === void 0 ? void 0 : _a.call(host);
    if (!lib) {
        throw new Error(`Compiler host doesn't have a default library directory available for ${BASE_COMPILER_OPTIONS.lib.join(', ')}`);
    }
    return BASE_COMPILER_OPTIONS.lib.map((name) => path.join(lib, name));
}
function parseConfigHostFromCompilerHost(host) {
    // Copied from upstream
    // https://github.com/Microsoft/TypeScript/blob/9e05abcfd3f8bb3d6775144ede807daceab2e321/src/compiler/program.ts#L3105
    return {
        fileExists: (f) => host.fileExists(f),
        readDirectory(root, extensions, excludes, includes, depth) {
            if (host.readDirectory === undefined) {
                throw new Error("'CompilerHost.readDirectory' must be implemented to correctly process 'projectReferences'");
            }
            return host.readDirectory(root, extensions, excludes, includes, depth);
        },
        readFile: (f) => host.readFile(f),
        useCaseSensitiveFileNames: host.useCaseSensitiveFileNames(),
        trace: host.trace ? (s) => host.trace(s) : undefined,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2QkFBNkI7QUFDN0Isc0NBQXNDO0FBQ3RDLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUVqQywyQ0FBd0M7QUFFeEMsdURBQW1EO0FBRW5ELDRFQUEyRTtBQUMzRSxpQ0FBaUM7QUFFakMsTUFBTSxxQkFBcUIsR0FBdUI7SUFDaEQsWUFBWSxFQUFFLElBQUk7SUFDbEIsT0FBTyxFQUFFLE1BQU07SUFDZixXQUFXLEVBQUUsSUFBSTtJQUNqQixzQkFBc0IsRUFBRSxJQUFJO0lBQzVCLFdBQVcsRUFBRSxJQUFJO0lBQ2pCLGVBQWUsRUFBRSxJQUFJO0lBQ3JCLGFBQWEsRUFBRSxJQUFJO0lBQ25CLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDO0lBQ3hCLE1BQU0sRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVE7SUFDOUIsT0FBTyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsUUFBUTtJQUNoQyxhQUFhLEVBQUUsSUFBSTtJQUNuQiwwQkFBMEIsRUFBRSxJQUFJO0lBQ2hDLGFBQWEsRUFBRSxJQUFJO0lBQ25CLGlCQUFpQixFQUFFLElBQUk7SUFDdkIsY0FBYyxFQUFFLElBQUk7SUFDcEIsY0FBYyxFQUFFLElBQUk7SUFDcEIsa0JBQWtCLEVBQUUsSUFBSTtJQUN4QixpQkFBaUIsRUFBRSxJQUFJO0lBQ3ZCLE1BQU0sRUFBRSxJQUFJO0lBQ1osZ0JBQWdCLEVBQUUsSUFBSTtJQUN0Qiw0QkFBNEIsRUFBRSxJQUFJO0lBQ2xDLGFBQWEsRUFBRSxLQUFLO0lBQ3BCLE1BQU0sRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLE1BQU07Q0FDL0IsQ0FBQztBQUVGLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDakMsUUFBQSxX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SSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDckMsYUFBYSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxLQUFLO1lBQ3ZELElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxTQUFTLEVBQUU7Z0JBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQ2IsMkZBQTJGLENBQzVGLENBQUM7YUFDSDtZQUNELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDekUsQ0FBQztRQUNELFFBQVEsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakMseUJBQXlCLEVBQUUsSUFBSSxDQUFDLHlCQUF5QixFQUFFO1FBQzNELEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztLQUN0RCxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIENhc2UgZnJvbSAnY2FzZSc7XG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JzL3NhZmUnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgbG9nNGpzIGZyb20gJ2xvZzRqcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IEFzc2VtYmxlciB9IGZyb20gJy4vYXNzZW1ibGVyJztcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuL2VtaXR0ZXInO1xuaW1wb3J0IHsgSnNpaURpYWdub3N0aWMgfSBmcm9tICcuL2pzaWktZGlhZ25vc3RpYyc7XG5pbXBvcnQgeyBQcm9qZWN0SW5mbyB9IGZyb20gJy4vcHJvamVjdC1pbmZvJztcbmltcG9ydCB7IFdBUk5JTkdTQ09ERV9GSUxFX05BTUUgfSBmcm9tICcuL3RyYW5zZm9ybXMvZGVwcmVjYXRpb24td2FybmluZ3MnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IEJBU0VfQ09NUElMRVJfT1BUSU9OUzogdHMuQ29tcGlsZXJPcHRpb25zID0ge1xuICBhbHdheXNTdHJpY3Q6IHRydWUsXG4gIGNoYXJzZXQ6ICd1dGY4JyxcbiAgZGVjbGFyYXRpb246IHRydWUsXG4gIGV4cGVyaW1lbnRhbERlY29yYXRvcnM6IHRydWUsXG4gIGluY3JlbWVudGFsOiB0cnVlLFxuICBpbmxpbmVTb3VyY2VNYXA6IHRydWUsXG4gIGlubGluZVNvdXJjZXM6IHRydWUsXG4gIGxpYjogWydsaWIuZXMyMDE5LmQudHMnXSxcbiAgbW9kdWxlOiB0cy5Nb2R1bGVLaW5kLkNvbW1vbkpTLFxuICBuZXdMaW5lOiB0cy5OZXdMaW5lS2luZC5MaW5lRmVlZCxcbiAgbm9FbWl0T25FcnJvcjogdHJ1ZSxcbiAgbm9GYWxsdGhyb3VnaENhc2VzSW5Td2l0Y2g6IHRydWUsXG4gIG5vSW1wbGljaXRBbnk6IHRydWUsXG4gIG5vSW1wbGljaXRSZXR1cm5zOiB0cnVlLFxuICBub0ltcGxpY2l0VGhpczogdHJ1ZSxcbiAgbm9VbnVzZWRMb2NhbHM6IHRydWUsXG4gIG5vVW51c2VkUGFyYW1ldGVyczogdHJ1ZSxcbiAgcmVzb2x2ZUpzb25Nb2R1bGU6IHRydWUsXG4gIHN0cmljdDogdHJ1ZSxcbiAgc3RyaWN0TnVsbENoZWNrczogdHJ1ZSxcbiAgc3RyaWN0UHJvcGVydHlJbml0aWFsaXphdGlvbjogdHJ1ZSxcbiAgc3RyaXBJbnRlcm5hbDogZmFsc2UsXG4gIHRhcmdldDogdHMuU2NyaXB0VGFyZ2V0LkVTMjAxOSxcbn07XG5cbmNvbnN0IExPRyA9IGxvZzRqcy5nZXRMb2dnZXIoJ2pzaWkvY29tcGlsZXInKTtcbmV4cG9ydCBjb25zdCBESUFHTk9TVElDUyA9ICdkaWFnbm9zdGljcyc7XG5leHBvcnQgY29uc3QgSlNJSV9ESUFHTk9TVElDU19DT0RFID0gOTk5OTtcblxuZXhwb3J0IGludGVyZmFjZSBDb21waWxlck9wdGlvbnMge1xuICAvKiogVGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwcm9qZWN0IHRvIGJlIGJ1aWx0ICovXG4gIHByb2plY3RJbmZvOiBQcm9qZWN0SW5mbztcbiAgLyoqIFdoZXRoZXIgdGhlIGNvbXBpbGVyIHNob3VsZCB3YXRjaCBmb3IgY2hhbmdlcyBvciBqdXN0IGNvbXBpbGUgb25jZSAqL1xuICB3YXRjaD86IGJvb2xlYW47XG4gIC8qKiBXaGV0aGVyIHRvIGRldGVjdCBhbmQgZ2VuZXJhdGUgVHlwZVNjcmlwdCBwcm9qZWN0IHJlZmVyZW5jZXMgKi9cbiAgcHJvamVjdFJlZmVyZW5jZXM/OiBib29sZWFuO1xuICAvKiogV2hldGhlciB0byBmYWlsIHdoZW4gYSB3YXJuaW5nIGlzIGVtaXR0ZWQgKi9cbiAgZmFpbE9uV2FybmluZ3M/OiBib29sZWFuO1xuICAvKiogV2hldGhlciB0byBzdHJpcCBkZXByZWNhdGVkIG1lbWJlcnMgZnJvbSBlbWl0dGVkIGFydGlmYWN0cyAqL1xuICBzdHJpcERlcHJlY2F0ZWQ/OiBib29sZWFuO1xuICAvKiogVGhlIHBhdGggdG8gYW4gYWxsb3dsaXN0IG9mIEZRTnMgdG8gc3RyaXAgaWYgc3RyaXBEZXByZWNhdGVkIGlzIHNldCAqL1xuICBzdHJpcERlcHJlY2F0ZWRBbGxvd0xpc3RGaWxlPzogc3RyaW5nO1xuICAvKiogV2hldGhlciB0byBhZGQgd2FybmluZ3MgZm9yIGRlcHJlY2F0ZWQgZWxlbWVudHMgKi9cbiAgYWRkRGVwcmVjYXRpb25XYXJuaW5ncz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgdHNjb25maWcgZmlsZSB0byBnZW5lcmF0ZVxuICAgKiBAZGVmYXVsdCBcInRzY29uZmlnLmpzb25cIlxuICAgKi9cbiAgZ2VuZXJhdGVUeXBlU2NyaXB0Q29uZmlnPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVzY3JpcHRDb25maWcge1xuICBjb21waWxlck9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucztcbiAgaW5jbHVkZT86IHN0cmluZ1tdO1xuICBleGNsdWRlPzogc3RyaW5nW107XG4gIHJlZmVyZW5jZXM/OiB0cy5Qcm9qZWN0UmVmZXJlbmNlW107XG59XG5cbmV4cG9ydCBjbGFzcyBDb21waWxlciBpbXBsZW1lbnRzIEVtaXR0ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbXBpbGVySG9zdDogdHMuQ29tcGlsZXJIb3N0O1xuICBwcml2YXRlIHR5cGVzY3JpcHRDb25maWc/OiBUeXBlc2NyaXB0Q29uZmlnO1xuICBwcml2YXRlIHJvb3RGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWdQYXRoOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvamVjdFJlZmVyZW5jZXM6IGJvb2xlYW47XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogQ29tcGlsZXJPcHRpb25zKSB7XG4gICAgdGhpcy5jb21waWxlckhvc3QgPSB0cy5jcmVhdGVJbmNyZW1lbnRhbENvbXBpbGVySG9zdChcbiAgICAgIEJBU0VfQ09NUElMRVJfT1BUSU9OUyxcbiAgICAgIHtcbiAgICAgICAgLi4udHMuc3lzLFxuICAgICAgICBnZXRDdXJyZW50RGlyZWN0b3J5OiAoKSA9PiB0aGlzLm9wdGlvbnMucHJvamVjdEluZm8ucHJvamVjdFJvb3QsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb25zdCBjb25maWdGaWxlTmFtZSA9IG9wdGlvbnMuZ2VuZXJhdGVUeXBlU2NyaXB0Q29uZmlnID8/ICd0c2NvbmZpZy5qc29uJztcblxuICAgIHRoaXMuY29uZmlnUGF0aCA9IHBhdGguam9pbihcbiAgICAgIHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdCxcbiAgICAgIGNvbmZpZ0ZpbGVOYW1lLFxuICAgICk7XG5cbiAgICB0aGlzLnByb2plY3RSZWZlcmVuY2VzID1cbiAgICAgIG9wdGlvbnMucHJvamVjdFJlZmVyZW5jZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMucHJvamVjdFJlZmVyZW5jZXNcbiAgICAgICAgOiBvcHRpb25zLnByb2plY3RJbmZvLnByb2plY3RSZWZlcmVuY2VzICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnByb2plY3RJbmZvLnByb2plY3RSZWZlcmVuY2VzXG4gICAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGlsZXMgdGhlIGNvbmZpZ3VyZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIGZpbGVzIGNhbiBiZSBzcGVjaWZpZWQgdG8gb3ZlcnJpZGUgdGhlIHN0YW5kYXJkIHNvdXJjZSBjb2RlIGxvY2F0aW9uIGxvZ2ljLiBVc2VmdWwgZm9yIGV4YW1wbGUgd2hlbiB0ZXN0aW5nIFwibmVnYXRpdmVzXCIuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZW1pdCguLi5maWxlczogc3RyaW5nW10pOiBQcm9taXNlPHRzLkVtaXRSZXN1bHQ+IHtcbiAgICBhd2FpdCB0aGlzLl9wcmVwYXJlRm9yQnVpbGQoLi4uZmlsZXMpO1xuICAgIHJldHVybiB0aGlzLl9idWlsZE9uY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXRjaGVzIGZvciBmaWxlLXN5c3RlbSBjaGFuZ2VzIGFuZCBkeW5hbWljYWxseSByZWNvbXBpbGVzIHRoZSBwcm9qZWN0IGFzIG5lZWRlZC4gSW4gbm9uLWJsb2NraW5nIG1vZGUsIHRoaXNcbiAgICogcmV0dXJucyB0aGUgVHlwZVNjcmlwdCB3YXRjaCBoYW5kbGUgZm9yIHRoZSBhcHBsaWNhdGlvbiB0byB1c2UuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHdhdGNoKFxuICAgIG9wdHM6IE5vbkJsb2NraW5nV2F0Y2hPcHRpb25zLFxuICApOiBQcm9taXNlPHRzLldhdGNoPHRzLkJ1aWxkZXJQcm9ncmFtPj47XG4gIC8qKlxuICAgKiBXYXRjaGVzIGZvciBmaWxlLXN5c3RlbSBjaGFuZ2VzIGFuZCBkeW5hbWljYWxseSByZWNvbXBpbGVzIHRoZSBwcm9qZWN0IGFzIG5lZWRlZC4gSW4gYmxvY2tpbmcgbW9kZSwgdGhpcyByZXN1bHRzXG4gICAqIGluIGEgbmV2ZXItcmVzb2x2aW5nIHByb21pc2UuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgd2F0Y2goKTogUHJvbWlzZTxuZXZlcj47XG4gIHB1YmxpYyBhc3luYyB3YXRjaChcbiAgICBvcHRzPzogTm9uQmxvY2tpbmdXYXRjaE9wdGlvbnMsXG4gICk6IFByb21pc2U8dHMuV2F0Y2g8dHMuQnVpbGRlclByb2dyYW0+IHwgbmV2ZXI+IHtcbiAgICBhd2FpdCB0aGlzLl9wcmVwYXJlRm9yQnVpbGQoKTtcblxuICAgIGNvbnN0IHBpID0gdGhpcy5vcHRpb25zLnByb2plY3RJbmZvO1xuICAgIGNvbnN0IHByb2plY3RSb290ID0gcGkucHJvamVjdFJvb3Q7XG4gICAgY29uc3QgaG9zdCA9IHRzLmNyZWF0ZVdhdGNoQ29tcGlsZXJIb3N0KFxuICAgICAgdGhpcy5jb25maWdQYXRoLFxuICAgICAge1xuICAgICAgICAuLi5waS50c2MsXG4gICAgICAgIC4uLkJBU0VfQ09NUElMRVJfT1BUSU9OUyxcbiAgICAgICAgbm9FbWl0T25FcnJvcjogZmFsc2UsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAuLi50cy5zeXMsXG4gICAgICAgIGdldEN1cnJlbnREaXJlY3RvcnkoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2plY3RSb290O1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRzLmNyZWF0ZUVtaXRBbmRTZW1hbnRpY0RpYWdub3N0aWNzQnVpbGRlclByb2dyYW0sXG4gICAgICBvcHRzPy5yZXBvcnREaWFnbm9zdGljcyxcbiAgICAgIG9wdHM/LnJlcG9ydFdhdGNoU3RhdHVzLFxuICAgICk7XG4gICAgaWYgKCFob3N0LmdldERlZmF1bHRMaWJMb2NhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnTm8gZGVmYXVsdCBsaWJyYXJ5IGxvY2F0aW9uIHdhcyBmb3VuZCBvbiB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBob3N0IScsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvcmlnID0gaG9zdC5hZnRlclByb2dyYW1DcmVhdGU7XG4gICAgaG9zdC5hZnRlclByb2dyYW1DcmVhdGUgPSBhc3luYyAoYnVpbGRlclByb2dyYW0pID0+IHtcbiAgICAgIGNvbnN0IGVtaXRSZXN1bHQgPSBhd2FpdCB0aGlzLl9jb25zdW1lUHJvZ3JhbShcbiAgICAgICAgYnVpbGRlclByb2dyYW0uZ2V0UHJvZ3JhbSgpLFxuICAgICAgICBob3N0LmdldERlZmF1bHRMaWJMb2NhdGlvbiEoKSxcbiAgICAgICk7XG5cbiAgICAgIGZvciAoY29uc3QgZGlhZyBvZiBlbWl0UmVzdWx0LmRpYWdub3N0aWNzLmZpbHRlcihcbiAgICAgICAgKGQpID0+IGQuY29kZSA9PT0gSlNJSV9ESUFHTk9TVElDU19DT0RFLFxuICAgICAgKSkge1xuICAgICAgICB1dGlscy5sb2dEaWFnbm9zdGljKGRpYWcsIHByb2plY3RSb290KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWcpIHtcbiAgICAgICAgb3JpZy5jYWxsKGhvc3QsIGJ1aWxkZXJQcm9ncmFtKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzPy5jb21waWxhdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgIGF3YWl0IG9wdHMuY29tcGlsYXRpb25Db21wbGV0ZShlbWl0UmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdhdGNoID0gdHMuY3JlYXRlV2F0Y2hQcm9ncmFtKGhvc3QpO1xuXG4gICAgaWYgKG9wdHM/Lm5vbkJsb2NraW5nKSB7XG4gICAgICAvLyBJbiBub24tYmxvY2tpbmcgbW9kZSwgcmV0dXJucyB0aGUgaGFuZGxlIHRvIHRoZSBUeXBlU2NyaXB0IHdhdGNoIGludGVyZmFjZS5cbiAgICAgIHJldHVybiB3YXRjaDtcbiAgICB9XG4gICAgLy8gSW4gYmxvY2tpbmcgbW9kZSwgcmV0dXJucyBhIG5ldmVyLXJlc29sdmluZyBwcm9taXNlLlxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxuZXZlcj4oKCkgPT4gbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgdGhlIHByb2plY3QgZm9yIGJ1aWxkLCBieSBjcmVhdGluZyB0aGUgbmVjZXNzYXJ5IGNvbmZpZ3VyYXRpb25cbiAgICogZmlsZShzKSwgYW5kIGFzc2lnbmluZyB0aGUgcmVsZXZhbnQgcm9vdCBmaWxlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsZXMgdGhlIGZpbGVzIHRoYXQgd2VyZSBzcGVjaWZpZWQgYXMgaW5wdXQgaW4gdGhlIENMSSBpbnZvY2F0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfcHJlcGFyZUZvckJ1aWxkKC4uLmZpbGVzOiBzdHJpbmdbXSkge1xuICAgIGF3YWl0IHRoaXMuYnVpbGRUeXBlU2NyaXB0Q29uZmlnKCk7XG4gICAgYXdhaXQgdGhpcy53cml0ZVR5cGVTY3JpcHRDb25maWcoKTtcbiAgICB0aGlzLnJvb3RGaWxlcyA9IHRoaXMuZGV0ZXJtaW5lU291cmNlcyhmaWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogRG8gYSBzaW5nbGUgYnVpbGRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2J1aWxkT25jZSgpOiBQcm9taXNlPHRzLkVtaXRSZXN1bHQ+IHtcbiAgICBpZiAoIXRoaXMuY29tcGlsZXJIb3N0LmdldERlZmF1bHRMaWJMb2NhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnTm8gZGVmYXVsdCBsaWJyYXJ5IGxvY2F0aW9uIHdhcyBmb3VuZCBvbiB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBob3N0IScsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHRzY29uZiA9IHRoaXMudHlwZXNjcmlwdENvbmZpZyE7XG4gICAgY29uc3QgcGkgPSB0aGlzLm9wdGlvbnMucHJvamVjdEluZm87XG5cbiAgICBjb25zdCBwcm9nID0gdHMuY3JlYXRlSW5jcmVtZW50YWxQcm9ncmFtKHtcbiAgICAgIHJvb3ROYW1lczogdGhpcy5yb290RmlsZXMuY29uY2F0KF9wYXRoT2ZMaWJyYXJpZXModGhpcy5jb21waWxlckhvc3QpKSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLi4ucGkudHNjLFxuICAgICAgICAuLi4odHNjb25mPy5jb21waWxlck9wdGlvbnMgPz8gQkFTRV9DT01QSUxFUl9PUFRJT05TKSxcbiAgICAgIH0sXG4gICAgICAvLyBNYWtlIHRoZSByZWZlcmVuY2VzIGFic29sdXRlIGZvciB0aGUgY29tcGlsZXJcbiAgICAgIHByb2plY3RSZWZlcmVuY2VzOiB0c2NvbmYucmVmZXJlbmNlcz8ubWFwKChyZWYpID0+ICh7XG4gICAgICAgIHBhdGg6IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUodGhpcy5jb25maWdQYXRoKSwgcmVmLnBhdGgpLFxuICAgICAgfSkpLFxuICAgICAgaG9zdDogdGhpcy5jb21waWxlckhvc3QsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fY29uc3VtZVByb2dyYW0oXG4gICAgICBwcm9nLmdldFByb2dyYW0oKSxcbiAgICAgIHRoaXMuY29tcGlsZXJIb3N0LmdldERlZmF1bHRMaWJMb2NhdGlvbigpLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9jb25zdW1lUHJvZ3JhbShcbiAgICBwcm9ncmFtOiB0cy5Qcm9ncmFtLFxuICAgIHN0ZGxpYjogc3RyaW5nLFxuICApOiBQcm9taXNlPHRzLkVtaXRSZXN1bHQ+IHtcbiAgICBjb25zdCBkaWFnbm9zdGljcyA9IFsuLi50cy5nZXRQcmVFbWl0RGlhZ25vc3RpY3MocHJvZ3JhbSldO1xuICAgIGxldCBoYXNFcnJvcnMgPSBmYWxzZTtcblxuICAgIGlmICghaGFzRXJyb3JzICYmIHRoaXMuZGlhZ3NIYXZlQWJvcnRhYmxlRXJyb3JzKGRpYWdub3N0aWNzKSkge1xuICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgIExPRy5lcnJvcihcbiAgICAgICAgJ0NvbXBpbGF0aW9uIGVycm9ycyBwcmV2ZW50ZWQgdGhlIEpTSUkgYXNzZW1ibHkgZnJvbSBiZWluZyBjcmVhdGVkJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRG8gdGhlIFwiQXNzZW1ibGVyXCIgcGFydCBmaXJzdCBiZWNhdXNlIHdlIG5lZWQgc29tZSBvZiB0aGUgYW5hbHlzaXMgZG9uZSBpbiB0aGVyZVxuICAgIC8vIHRvIHBvc3QtcHJvY2VzcyB0aGUgQVNUXG4gICAgY29uc3QgYXNzZW1ibGVyID0gbmV3IEFzc2VtYmxlcih0aGlzLm9wdGlvbnMucHJvamVjdEluZm8sIHByb2dyYW0sIHN0ZGxpYiwge1xuICAgICAgc3RyaXBEZXByZWNhdGVkOiB0aGlzLm9wdGlvbnMuc3RyaXBEZXByZWNhdGVkLFxuICAgICAgc3RyaXBEZXByZWNhdGVkQWxsb3dMaXN0RmlsZTogdGhpcy5vcHRpb25zLnN0cmlwRGVwcmVjYXRlZEFsbG93TGlzdEZpbGUsXG4gICAgICBhZGREZXByZWNhdGlvbldhcm5pbmdzOiB0aGlzLm9wdGlvbnMuYWRkRGVwcmVjYXRpb25XYXJuaW5ncyxcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhc3NtRW1pdCA9IGF3YWl0IGFzc2VtYmxlci5lbWl0KCk7XG4gICAgICBpZiAoXG4gICAgICAgICFoYXNFcnJvcnMgJiZcbiAgICAgICAgKGFzc21FbWl0LmVtaXRTa2lwcGVkIHx8XG4gICAgICAgICAgdGhpcy5kaWFnc0hhdmVBYm9ydGFibGVFcnJvcnMoYXNzbUVtaXQuZGlhZ25vc3RpY3MpKVxuICAgICAgKSB7XG4gICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgIExPRy5lcnJvcihcbiAgICAgICAgICAnVHlwZSBtb2RlbCBlcnJvcnMgcHJldmVudGVkIHRoZSBKU0lJIGFzc2VtYmx5IGZyb20gYmVpbmcgY3JlYXRlZCcsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGRpYWdub3N0aWNzLnB1c2goLi4uYXNzbUVtaXQuZGlhZ25vc3RpY3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRpYWdub3N0aWNzLnB1c2goXG4gICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfOTk5N19VTktOT1dOX0VSUk9SLmNyZWF0ZURldGFjaGVkKGUpLFxuICAgICAgKTtcbiAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gRG8gdGhlIGVtaXQsIGJ1dCBhZGQgaW4gdHJhbnNmb3JtZXJzIHdoaWNoIGFyZSBnb2luZyB0byByZXBsYWNlIHJlYWxcbiAgICAvLyBjb21tZW50cyB3aXRoIHN5bnRoZXRpYyBvbmVzLlxuICAgIGNvbnN0IGVtaXQgPSBwcm9ncmFtLmVtaXQoXG4gICAgICB1bmRlZmluZWQsIC8vIHRhcmdldFNvdXJjZUZpbGVcbiAgICAgIHVuZGVmaW5lZCwgLy8gd3JpdGVGaWxlXG4gICAgICB1bmRlZmluZWQsIC8vIGNhbmNlbGxhdGlvblRva2VuXG4gICAgICB1bmRlZmluZWQsIC8vIGVtaXRPbmx5RHRzRmlsZXNcbiAgICAgIGFzc2VtYmxlci5jdXN0b21UcmFuc2Zvcm1lcnMsXG4gICAgKTtcbiAgICBkaWFnbm9zdGljcy5wdXNoKC4uLmVtaXQuZGlhZ25vc3RpY3MpO1xuXG4gICAgaWYgKFxuICAgICAgIWhhc0Vycm9ycyAmJlxuICAgICAgKGVtaXQuZW1pdFNraXBwZWQgfHwgdGhpcy5kaWFnc0hhdmVBYm9ydGFibGVFcnJvcnMoZW1pdC5kaWFnbm9zdGljcykpXG4gICAgKSB7XG4gICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgTE9HLmVycm9yKFxuICAgICAgICAnQ29tcGlsYXRpb24gZXJyb3JzIHByZXZlbnRlZCB0aGUgSlNJSSBhc3NlbWJseSBmcm9tIGJlaW5nIGNyZWF0ZWQnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBTb21lIGV4dHJhIHZhbGlkYXRpb24gb24gdGhlIGNvbmZpZy5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB7IFwiLi8ud2FybmluZ3MuanNpaS5qc1wiOiBcIi4vLndhcm5pbmdzLmpzaWkuanNcIiB9IGlzIGluIHRoZSBzZXQgb2ZcbiAgICAvLyBleHBvcnRzLCBpZiB0aGV5IGFyZSBzcGVjaWZpZWQuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLmFkZERlcHJlY2F0aW9uV2FybmluZ3MgJiZcbiAgICAgIHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mby5leHBvcnRzICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkID0gYC4vJHtXQVJOSU5HU0NPREVfRklMRV9OQU1FfWA7XG4gICAgICBjb25zdCB3YXJuaW5nc0V4cG9ydCA9IE9iamVjdC5lbnRyaWVzKFxuICAgICAgICB0aGlzLm9wdGlvbnMucHJvamVjdEluZm8uZXhwb3J0cyxcbiAgICAgICkuZmlsdGVyKChbaywgdl0pID0+IGsgPT09IGV4cGVjdGVkICYmIHYgPT09IGV4cGVjdGVkKTtcblxuICAgICAgaWYgKHdhcm5pbmdzRXhwb3J0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICBkaWFnbm9zdGljcy5wdXNoKFxuICAgICAgICAgIEpzaWlEaWFnbm9zdGljLkpTSUlfMDAwN19NSVNTSU5HX1dBUk5JTkdTX0VYUE9SVC5jcmVhdGVEZXRhY2hlZCgpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbWl0U2tpcHBlZDogaGFzRXJyb3JzLFxuICAgICAgZGlhZ25vc3RpY3M6IHRzLnNvcnRBbmREZWR1cGxpY2F0ZURpYWdub3N0aWNzKGRpYWdub3N0aWNzKSxcbiAgICAgIGVtaXR0ZWRGaWxlczogZW1pdC5lbWl0dGVkRmlsZXMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCB0aGUgVHlwZVNjcmlwdCBjb25maWcgb2JqZWN0XG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgd3JpdHRlbiB0byBkaXNrLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBidWlsZFR5cGVTY3JpcHRDb25maWcoKSB7XG4gICAgbGV0IHJlZmVyZW5jZXM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLnByb2plY3RSZWZlcmVuY2VzKSB7XG4gICAgICByZWZlcmVuY2VzID0gYXdhaXQgdGhpcy5maW5kUHJvamVjdFJlZmVyZW5jZXMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBwaSA9IHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mbztcblxuICAgIHRoaXMudHlwZXNjcmlwdENvbmZpZyA9IHtcbiAgICAgIGNvbXBpbGVyT3B0aW9uczoge1xuICAgICAgICAuLi5waS50c2MsXG4gICAgICAgIC4uLkJBU0VfQ09NUElMRVJfT1BUSU9OUyxcbiAgICAgICAgLy8gRW5hYmxlIGNvbXBvc2l0ZSBtb2RlIGlmIHByb2plY3QgcmVmZXJlbmNlcyBhcmUgZW5hYmxlZFxuICAgICAgICBjb21wb3NpdGU6IHRoaXMucHJvamVjdFJlZmVyZW5jZXMsXG4gICAgICAgIC8vIFdoZW4gaW5jcmVtZW50YWwsIGNvbmZpZ3VyZSBhIHRzYnVpbGRpbmZvIGZpbGVcbiAgICAgICAgdHNCdWlsZEluZm9GaWxlOiBwYXRoLmpvaW4oXG4gICAgICAgICAgcGkudHNjPy5vdXREaXIgPz8gJy4nLFxuICAgICAgICAgICd0c2NvbmZpZy50c2J1aWxkaW5mbycsXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAgaW5jbHVkZTogW1xuICAgICAgICBwaS50c2M/LnJvb3REaXIgIT0gbnVsbFxuICAgICAgICAgID8gcGF0aC5qb2luKHBpLnRzYy5yb290RGlyLCAnKionLCAnKi50cycpXG4gICAgICAgICAgOiBwYXRoLmpvaW4oJyoqJywgJyoudHMnKSxcbiAgICAgIF0sXG4gICAgICBleGNsdWRlOiBbXG4gICAgICAgICdub2RlX21vZHVsZXMnLFxuICAgICAgICAuLi4ocGkuZXhjbHVkZVR5cGVzY3JpcHQgPz8gW10pLFxuICAgICAgICAuLi4ocGkudHNjPy5vdXREaXIgIT0gbnVsbCAmJlxuICAgICAgICAocGkudHNjPy5yb290RGlyID09IG51bGwgfHxcbiAgICAgICAgICBwYXRoXG4gICAgICAgICAgICAucmVzb2x2ZShwaS50c2Mub3V0RGlyKVxuICAgICAgICAgICAgLnN0YXJ0c1dpdGgocGF0aC5yZXNvbHZlKHBpLnRzYy5yb290RGlyKSArIHBhdGguc2VwKSlcbiAgICAgICAgICA/IFtwYXRoLmpvaW4ocGkudHNjLm91dERpciwgJyoqJywgJyoudHMnKV1cbiAgICAgICAgICA6IFtdKSxcbiAgICAgIF0sXG4gICAgICAvLyBDaGFuZ2UgdGhlIHJlZmVyZW5jZXMgYSBsaXR0bGUuIFdlIHdyaXRlICdvcmlnaW5hbHBhdGgnIHRvIHRoZVxuICAgICAgLy8gZmlsZSB1bmRlciB0aGUgJ3BhdGgnIGtleSwgd2hpY2ggaXMgdGhlIHNhbWUgYXMgd2hhdCB0aGVcbiAgICAgIC8vIFR5cGVTY3JpcHQgY29tcGlsZXIgZG9lcy4gTWFrZSBpdCByZWxhdGl2ZSBzbyB0aGF0IHRoZSBmaWxlcyBhcmVcbiAgICAgIC8vIG1vdmFibGUuIE5vdCBzdHJpY3RseSByZXF1aXJlZCBidXQgbG9va3MgYmV0dGVyLlxuICAgICAgcmVmZXJlbmNlczogcmVmZXJlbmNlcz8ubWFwKChwKSA9PiAoeyBwYXRoOiBwIH0pKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBgdHNjb25maWcuanNvbmAgZmlsZSB0byBpbXByb3ZlIHRoZSBJREUgZXhwZXJpZW5jZS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIGB0c2NvbmZpZy5qc29uYCBmaWxlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHdyaXRlVHlwZVNjcmlwdENvbmZpZygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb21tZW50S2V5ID0gJ19nZW5lcmF0ZWRfYnlfanNpaV8nO1xuICAgIGNvbnN0IGNvbW1lbnRWYWx1ZSA9XG4gICAgICAnR2VuZXJhdGVkIGJ5IGpzaWkgLSBzYWZlIHRvIGRlbGV0ZSwgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIGluIC5naXRpZ25vcmUnO1xuXG4gICAgKHRoaXMudHlwZXNjcmlwdENvbmZpZyBhcyBhbnkpW2NvbW1lbnRLZXldID0gY29tbWVudFZhbHVlO1xuXG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHModGhpcy5jb25maWdQYXRoKSkge1xuICAgICAgY29uc3QgY3VycmVudENvbmZpZyA9IGF3YWl0IGZzLnJlYWRKc29uKHRoaXMuY29uZmlnUGF0aCk7XG4gICAgICBpZiAoIShjb21tZW50S2V5IGluIGN1cnJlbnRDb25maWcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQSAnJHt0aGlzLmNvbmZpZ1BhdGh9JyBmaWxlIHRoYXQgd2FzIG5vdCBnZW5lcmF0ZWQgYnkganNpaSBpcyBpbiAke3RoaXMub3B0aW9ucy5wcm9qZWN0SW5mby5wcm9qZWN0Um9vdH0uIEFib3J0aW5nIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRDb25maWcgPSB7XG4gICAgICAuLi50aGlzLnR5cGVzY3JpcHRDb25maWcsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHtcbiAgICAgICAgLi4udGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnMsXG4gICAgICAgIGxpYjogdGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnM/LmxpYj8ubWFwKChsaWIpID0+XG4gICAgICAgICAgLy8gRHJvcCB0aGUgXCJsaWIuXCIgcHJlZml4IGFuZCBcIi5kLnRzXCIgc3VmZml4IGJlZm9yZSB3cml0aW5nIHVwIHRoZSB0c2NvbmZpZy5qc29uIGZpbGVcbiAgICAgICAgICBsaWIuc2xpY2UoNCwgbGliLmxlbmd0aCAtIDUpLFxuICAgICAgICApLFxuICAgICAgICAvLyBSZS13cml0ZSB0aGUgbW9kdWxlLCB0YXJnZXRzICYganN4IHRvIGJlIHRoZSBKU09OIGZvcm1hdCBpbnN0ZWFkIG9mIFByb2dyYW1tYXRpYyBBUElcbiAgICAgICAgbW9kdWxlOiAodGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnM/Lm1vZHVsZSAmJlxuICAgICAgICAgIHRzLk1vZHVsZUtpbmRbdGhpcy50eXBlc2NyaXB0Q29uZmlnLmNvbXBpbGVyT3B0aW9ucy5tb2R1bGVdKSBhcyBhbnksXG4gICAgICAgIG5ld0xpbmU6IG5ld0xpbmVGb3JUc2NvbmZpZ0pzb24oXG4gICAgICAgICAgdGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnMubmV3TGluZSxcbiAgICAgICAgKSxcbiAgICAgICAgdGFyZ2V0OiAodGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnM/LnRhcmdldCAmJlxuICAgICAgICAgIHRzLlNjcmlwdFRhcmdldFt0aGlzLnR5cGVzY3JpcHRDb25maWcuY29tcGlsZXJPcHRpb25zLnRhcmdldF0pIGFzIGFueSxcbiAgICAgICAganN4OiAodGhpcy50eXBlc2NyaXB0Q29uZmlnPy5jb21waWxlck9wdGlvbnM/LmpzeCAmJlxuICAgICAgICAgIENhc2Uuc25ha2UoXG4gICAgICAgICAgICB0cy5Kc3hFbWl0W3RoaXMudHlwZXNjcmlwdENvbmZpZy5jb21waWxlck9wdGlvbnMuanN4XSxcbiAgICAgICAgICApKSBhcyBhbnksXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBMT0cuZGVidWcoYENyZWF0aW5nIG9yIHVwZGF0aW5nICR7Y29sb3JzLmJsdWUodGhpcy5jb25maWdQYXRoKX1gKTtcbiAgICBhd2FpdCBmcy53cml0ZUpzb24odGhpcy5jb25maWdQYXRoLCBvdXRwdXRDb25maWcsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICBzcGFjZXM6IDIsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFubm95aW5nIC0gdGhlIHZhbHVlcyBleHBlY3RlZCBpbiB0aGUgdHNjb25maWcuanNvbiBmaWxlIGFyZSBub3RcbiAgICAgKiB0aGUgc2FtZSBhcyB0aGUgZW51bSBjb25zdGFudCBuYW1lcywgb3IgdGhlaXIgdmFsdWVzLiBTbyB3ZSBuZWVkIHRoaXNcbiAgICAgKiBmdW5jdGlvbiB0byBtYXAgdGhlIFwiY29tcGlsZXIgQVBJIHZlcnNpb25cIiB0byB0aGUgXCJ0c2NvbmZpZy5qc29uIHZlcnNpb25cIlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0xpbmUgdGhlIGNvbXBpbGVyIGZvcm0gb2YgdGhlIG5ldyBsaW5lIGNvbmZpZ3VyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIHJlcXVpdmFsZW50IHZhbHVlIHRvIHB1dCBpbiB0c2NvbmZpZy5qc29uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV3TGluZUZvclRzY29uZmlnSnNvbihuZXdMaW5lOiB0cy5OZXdMaW5lS2luZCB8IHVuZGVmaW5lZCkge1xuICAgICAgc3dpdGNoIChuZXdMaW5lKSB7XG4gICAgICAgIGNhc2UgdHMuTmV3TGluZUtpbmQuQ2FycmlhZ2VSZXR1cm5MaW5lRmVlZDpcbiAgICAgICAgICByZXR1cm4gJ2NybGYnO1xuICAgICAgICBjYXNlIHRzLk5ld0xpbmVLaW5kLkxpbmVGZWVkOlxuICAgICAgICAgIHJldHVybiAnbGYnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIGRlcGVuZGVuY2llcyB0aGF0IGxvb2sgbGlrZSBUeXBlU2NyaXB0IHByb2plY3RzLlxuICAgKlxuICAgKiBFbnVtZXJhdGUgYWxsIGRlcGVuZGVuY2llcywgaWYgdGhleSBoYXZlIGEgdHNjb25maWcuanNvbiBmaWxlIHdpdGhcbiAgICogXCJjb21wb3NpdGU6IHRydWVcIiB3ZSBjb25zaWRlciB0aGVtIHByb2plY3QgcmVmZXJlbmNlcy5cbiAgICpcbiAgICogKE5vdGU6IFR5cGVTY3JpcHQgc2VlbXMgdG8gb25seSBjb3JyZWN0bHkgZmluZCB0cmFuc2l0aXZlIHByb2plY3QgcmVmZXJlbmNlc1xuICAgKiBpZiB0aGVyZSdzIGFuIFwiaW5kZXhcIiB0c2NvbmZpZy5qc29uIG9mIGFsbCBwcm9qZWN0cyBzb21ld2hlcmUgdXAgdGhlIGRpcmVjdG9yeVxuICAgKiB0cmVlKVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBmaW5kUHJvamVjdFJlZmVyZW5jZXMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHBrZyA9IHRoaXMub3B0aW9ucy5wcm9qZWN0SW5mby5wYWNrYWdlSnNvbjtcblxuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICBjb25zdCBkZXBlbmRlbmN5TmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lNYXAgb2YgW1xuICAgICAgcGtnLmRlcGVuZGVuY2llcyxcbiAgICAgIHBrZy5kZXZEZXBlbmRlbmNpZXMsXG4gICAgICBwa2cucGVlckRlcGVuZGVuY2llcyxcbiAgICBdKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoZGVwZW5kZW5jeU1hcCkuZm9yRWFjaChcbiAgICAgICAgZGVwZW5kZW5jeU5hbWVzLmFkZC5iaW5kKGRlcGVuZGVuY3lOYW1lcyksXG4gICAgICApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdHNjb25maWdGaWxlIG9mIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgQXJyYXkuZnJvbShkZXBlbmRlbmN5TmFtZXMpLm1hcCgoZGVwTmFtZSkgPT5cbiAgICAgICAgdGhpcy5maW5kTW9ub3JlcG9QZWVyVHNjb25maWcoZGVwTmFtZSksXG4gICAgICApLFxuICAgICkpIHtcbiAgICAgIGlmICghdHNjb25maWdGaWxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGNvbmZpZzogdHNjb25maWcgfSA9IHRzLnJlYWRDb25maWdGaWxlKFxuICAgICAgICB0c2NvbmZpZ0ZpbGUsXG4gICAgICAgIHRzLnN5cy5yZWFkRmlsZSxcbiAgICAgICk7XG5cbiAgICAgIC8vIEFkZCByZWZlcmVuY2VzIHRvIGFueSBUeXBlU2NyaXB0IHBhY2thZ2Ugd2UgZmluZCB0aGF0IGlzICdjb21wb3NpdGUnIGVuYWJsZWQuXG4gICAgICAvLyBNYWtlIGl0IHJlbGF0aXZlLlxuICAgICAgaWYgKHRzY29uZmlnLmNvbXBpbGVyT3B0aW9ucz8uY29tcG9zaXRlKSB7XG4gICAgICAgIHJldC5wdXNoKFxuICAgICAgICAgIHBhdGgucmVsYXRpdmUoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJvamVjdEluZm8ucHJvamVjdFJvb3QsXG4gICAgICAgICAgICBwYXRoLmRpcm5hbWUodHNjb25maWdGaWxlKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgY29tcG9zaXRlIHBhY2thZ2UtLWlmIHRoaXMgcGFja2FnZSBpcyBpbiBhIG5vZGVfbW9kdWxlcyBkaXJlY3RvcnksIHRoYXQgaXMgbW9zdFxuICAgICAgICAvLyBsaWtlbHkgY29ycmVjdCwgb3RoZXJ3aXNlIGl0IGlzIG1vc3QgbGlrZWx5IGFuIGVycm9yIChoZXVyaXN0aWMgaGVyZSwgSSBkb24ndCBrbm93IGhvdyB0b1xuICAgICAgICAvLyBwcm9wZXJseSBjaGVjayB0aGlzKS5cbiAgICAgICAgaWYgKHRzY29uZmlnRmlsZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJykpIHtcbiAgICAgICAgICBMT0cud2FybihcbiAgICAgICAgICAgICclczogbm90IGEgY29tcG9zaXRlIFR5cGVTY3JpcHQgcGFja2FnZSwgYnV0IGl0IHByb2JhYmx5IHNob3VsZCBiZScsXG4gICAgICAgICAgICBwYXRoLmRpcm5hbWUodHNjb25maWdGaWxlKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHNvdXJjZSBmaWxlcyB1c2luZyB0aGUgc2FtZSBtZWNoYW5pc20gdGhhdCB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBpdHNlbGYgdXNlcy5cbiAgICpcbiAgICogUmVzcGVjdHMgaW5jbHVkZXMvZXhjbHVkZXMvZXRjLlxuICAgKlxuICAgKiBUaGlzIG1ha2VzIGl0IHNvIHRoYXQgcnVubmluZyAndHNjJyBhbmQgcnVubmluZyAnanNpaScgaGFzIHRoZSBzYW1lIGJlaGF2aW9yLlxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlcm1pbmVTb3VyY2VzKGZpbGVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldC5wdXNoKC4uLmZpbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyc2VDb25maWdIb3N0ID0gcGFyc2VDb25maWdIb3N0RnJvbUNvbXBpbGVySG9zdChcbiAgICAgICAgdGhpcy5jb21waWxlckhvc3QsXG4gICAgICApO1xuICAgICAgY29uc3QgcGFyc2VkID0gdHMucGFyc2VKc29uQ29uZmlnRmlsZUNvbnRlbnQoXG4gICAgICAgIHRoaXMudHlwZXNjcmlwdENvbmZpZyxcbiAgICAgICAgcGFyc2VDb25maWdIb3N0LFxuICAgICAgICB0aGlzLm9wdGlvbnMucHJvamVjdEluZm8ucHJvamVjdFJvb3QsXG4gICAgICApO1xuICAgICAgcmV0LnB1c2goLi4ucGFyc2VkLmZpbGVOYW1lcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBnaXZlbiBkZXBlbmRlbmN5IG5hbWUgZnJvbSB0aGUgY3VycmVudCBwYWNrYWdlLCBhbmQgZmluZCB0aGUgYXNzb2NpYXRlZCB0c2NvbmZpZy5qc29uIGxvY2F0aW9uXG4gICAqXG4gICAqIEJlY2F1c2Ugd2UgaGF2ZSB0aGUgZm9sbG93aW5nIHBvdGVudGlhbCBkaXJlY3RvcnkgbGF5b3V0OlxuICAgKlxuICAgKiAgIHBhY2thZ2Uvbm9kZV9tb2R1bGVzL3NvbWVfZGVwZW5kZW5jeVxuICAgKiAgIHBhY2thZ2UvdHNjb25maWcuanNvblxuICAgKlxuICAgKiBXZSByZXNvbHZlIHN5bWxpbmtzIGFuZCBvbmx5IGZpbmQgYSBcIlR5cGVTY3JpcHRcIiBkZXBlbmRlbmN5IGlmIGRvZXNuJ3QgaGF2ZSAnbm9kZV9tb2R1bGVzJyBpblxuICAgKiB0aGUgcGF0aCBhZnRlciByZXNvbHZpbmcgc3ltbGlua3MgKGkuZS4sIGlmIGl0J3MgYSBwZWVyIHBhY2thZ2UgaW4gdGhlIHNhbWUgbW9ub3JlcG8pLlxuICAgKlxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBzdWNoIHRzY29uZmlnIGNvdWxkIGJlIGZvdW5kLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBmaW5kTW9ub3JlcG9QZWVyVHNjb25maWcoXG4gICAgZGVwTmFtZTogc3RyaW5nLFxuICApOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICBjb25zdCB7IGJ1aWx0aW5Nb2R1bGVzIH0gPSByZXF1aXJlKCdtb2R1bGUnKTtcbiAgICBpZiAoKGJ1aWx0aW5Nb2R1bGVzID8/IFtdKS5pbmNsdWRlcyhkZXBOYW1lKSkge1xuICAgICAgLy8gQ2FuIGhhcHBlbiBmb3IgbW9kdWxlcyBsaWtlICdwdW55Y29kZScgd2hpY2ggYXJlIGRlY2xhcmVkIGFzIGRlcGVuZGVuY3kgZm9yIHBvbHlmaWxsIHB1cnBvc2VzXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZXBEaXIgPSBhd2FpdCB1dGlscy5maW5kRGVwZW5kZW5jeURpcmVjdG9yeShcbiAgICAgICAgZGVwTmFtZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLnByb2plY3RJbmZvLnByb2plY3RSb290LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgZGVwID0gcGF0aC5qb2luKGRlcERpciwgJ3RzY29uZmlnLmpzb24nKTtcbiAgICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMoZGVwKSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzb2x2ZSBzeW1saW5rcywgdG8gY2hlY2sgaWYgdGhpcyBpcyBhIG1vbm9yZXBvIHBlZXJcbiAgICAgIGNvbnN0IGRlcGVuZGVuY3lSZWFsUGF0aCA9IGF3YWl0IGZzLnJlYWxwYXRoKGRlcCk7XG4gICAgICBpZiAoZGVwZW5kZW5jeVJlYWxQYXRoLnNwbGl0KHBhdGguc2VwKS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlcGVuZGVuY3lSZWFsUGF0aDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBAdHlwZXMgbW9kdWxlcyBjYW5ub3QgYmUgcmVxdWlyZWQsIGZvciBleGFtcGxlXG4gICAgICBpZiAoXG4gICAgICAgIFsnTU9EVUxFX05PVF9GT1VORCcsICdFUlJfUEFDS0FHRV9QQVRIX05PVF9FWFBPUlRFRCddLmluY2x1ZGVzKGUuY29kZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRpYWdzSGF2ZUFib3J0YWJsZUVycm9ycyhkaWFnczogcmVhZG9ubHkgdHMuRGlhZ25vc3RpY1tdKSB7XG4gICAgcmV0dXJuIGRpYWdzLnNvbWUoXG4gICAgICAoZCkgPT5cbiAgICAgICAgZC5jYXRlZ29yeSA9PT0gdHMuRGlhZ25vc3RpY0NhdGVnb3J5LkVycm9yIHx8XG4gICAgICAgICh0aGlzLm9wdGlvbnMuZmFpbE9uV2FybmluZ3MgJiZcbiAgICAgICAgICBkLmNhdGVnb3J5ID09PSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuV2FybmluZyksXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIFdhdGNoIGluIG5vbi1ibG9ja2luZyBtb2RlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vbkJsb2NraW5nV2F0Y2hPcHRpb25zIHtcbiAgLyoqXG4gICAqIFNpZ25hbHMgbm9uLWJsb2NraW5nIGV4ZWN1dGlvblxuICAgKi9cbiAgcmVhZG9ubHkgbm9uQmxvY2tpbmc6IHRydWU7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhlIGRpYWdub3N0aWNzIHJlcG9ydGVyXG4gICAqL1xuICByZWFkb25seSByZXBvcnREaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1JlcG9ydGVyO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHRoZSB3YXRjaCBzdGF0dXMgcmVwb3J0ZXJcbiAgICovXG4gIHJlYWRvbmx5IHJlcG9ydFdhdGNoU3RhdHVzOiB0cy5XYXRjaFN0YXR1c1JlcG9ydGVyO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvb2sgZ2V0cyBpbnZva2VkIHdoZW4gYSBjb21waWxhdGlvbiBjeWNsZSAoY29tcGxldGUgd2l0aCBBc3NlbWJsZXIgZXhlY3V0aW9uKSBjb21wbGV0ZXMuXG4gICAqL1xuICByZWFkb25seSBjb21waWxhdGlvbkNvbXBsZXRlOiAoXG4gICAgZW1pdFJlc3VsdDogdHMuRW1pdFJlc3VsdCxcbiAgKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbn1cblxuZnVuY3Rpb24gX3BhdGhPZkxpYnJhcmllcyhcbiAgaG9zdDogdHMuQ29tcGlsZXJIb3N0IHwgdHMuV2F0Y2hDb21waWxlckhvc3Q8YW55Pixcbik6IHN0cmluZ1tdIHtcbiAgaWYgKCFCQVNFX0NPTVBJTEVSX09QVElPTlMubGliIHx8IEJBU0VfQ09NUElMRVJfT1BUSU9OUy5saWIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGxpYiA9IGhvc3QuZ2V0RGVmYXVsdExpYkxvY2F0aW9uPy4oKTtcbiAgaWYgKCFsaWIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ29tcGlsZXIgaG9zdCBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGxpYnJhcnkgZGlyZWN0b3J5IGF2YWlsYWJsZSBmb3IgJHtCQVNFX0NPTVBJTEVSX09QVElPTlMubGliLmpvaW4oXG4gICAgICAgICcsICcsXG4gICAgICApfWAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gQkFTRV9DT01QSUxFUl9PUFRJT05TLmxpYi5tYXAoKG5hbWUpID0+IHBhdGguam9pbihsaWIsIG5hbWUpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDb25maWdIb3N0RnJvbUNvbXBpbGVySG9zdChcbiAgaG9zdDogdHMuQ29tcGlsZXJIb3N0LFxuKTogdHMuUGFyc2VDb25maWdIb3N0IHtcbiAgLy8gQ29waWVkIGZyb20gdXBzdHJlYW1cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2Jsb2IvOWUwNWFiY2ZkM2Y4YmIzZDY3NzUxNDRlZGU4MDdkYWNlYWIyZTMyMS9zcmMvY29tcGlsZXIvcHJvZ3JhbS50cyNMMzEwNVxuICByZXR1cm4ge1xuICAgIGZpbGVFeGlzdHM6IChmKSA9PiBob3N0LmZpbGVFeGlzdHMoZiksXG4gICAgcmVhZERpcmVjdG9yeShyb290LCBleHRlbnNpb25zLCBleGNsdWRlcywgaW5jbHVkZXMsIGRlcHRoKSB7XG4gICAgICBpZiAoaG9zdC5yZWFkRGlyZWN0b3J5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiJ0NvbXBpbGVySG9zdC5yZWFkRGlyZWN0b3J5JyBtdXN0IGJlIGltcGxlbWVudGVkIHRvIGNvcnJlY3RseSBwcm9jZXNzICdwcm9qZWN0UmVmZXJlbmNlcydcIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0LnJlYWREaXJlY3Rvcnkocm9vdCwgZXh0ZW5zaW9ucywgZXhjbHVkZXMsIGluY2x1ZGVzLCBkZXB0aCk7XG4gICAgfSxcbiAgICByZWFkRmlsZTogKGYpID0+IGhvc3QucmVhZEZpbGUoZiksXG4gICAgdXNlQ2FzZVNlbnNpdGl2ZUZpbGVOYW1lczogaG9zdC51c2VDYXNlU2Vuc2l0aXZlRmlsZU5hbWVzKCksXG4gICAgdHJhY2U6IGhvc3QudHJhY2UgPyAocykgPT4gaG9zdC50cmFjZSEocykgOiB1bmRlZmluZWQsXG4gIH07XG59XG4iXX0=