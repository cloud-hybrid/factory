"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeprecationWarningsInjector = exports.WARNINGSCODE_FILE_NAME = void 0;
const spec = require("@jsii/spec");
const fs = require("fs");
const path = require("path");
const ts = require("typescript");
const symbol_id_1 = require("../symbol-id");
exports.WARNINGSCODE_FILE_NAME = '.warnings.jsii.js';
const WARNING_FUNCTION_NAME = 'print';
const PARAMETER_NAME = 'p';
const NAMESPACE = 'jsiiDeprecationWarnings';
const LOCAL_ENUM_NAMESPACE = 'ns';
const VISITED_OBJECTS_SET_NAME = 'visitedObjects';
class DeprecationWarningsInjector {
    constructor(typeChecker) {
        this.typeChecker = typeChecker;
        this.transformers = {
            before: [],
        };
    }
    process(assembly, projectInfo) {
        var _a, _b, _c, _d, _e, _f;
        const projectRoot = projectInfo.projectRoot;
        const functionDeclarations = [];
        const types = (_a = assembly.types) !== null && _a !== void 0 ? _a : {};
        for (const type of Object.values(types)) {
            const statements = [];
            let isEmpty = true;
            // This will add the parameter to the set of visited objects, to prevent infinite recursion
            statements.push(ts.createExpressionStatement(ts.createCall(ts.createIdentifier(`${VISITED_OBJECTS_SET_NAME}.add`), [], [ts.createIdentifier(PARAMETER_NAME)])));
            if (spec.isDeprecated(type) && spec.isEnumType(type)) {
                // The type is deprecated
                statements.push(createWarningFunctionCall(type.fqn, (_b = type.docs) === null || _b === void 0 ? void 0 : _b.deprecated));
                isEmpty = false;
            }
            if (spec.isEnumType(type) && ((_c = type.locationInModule) === null || _c === void 0 ? void 0 : _c.filename)) {
                statements.push(createEnumRequireStatement((_d = type.locationInModule) === null || _d === void 0 ? void 0 : _d.filename));
                statements.push(createDuplicateEnumValuesCheck(type));
                for (const member of Object.values((_e = type.members) !== null && _e !== void 0 ? _e : [])) {
                    if (spec.isDeprecated(member)) {
                        // The enum member is deprecated
                        const condition = ts.createIdentifier(`${PARAMETER_NAME} === ${LOCAL_ENUM_NAMESPACE}.${type.name}.${member.name}`);
                        statements.push(createWarningFunctionCall(`${type.fqn}#${member.name}`, (_f = member.docs) === null || _f === void 0 ? void 0 : _f.deprecated, condition));
                        isEmpty = false;
                    }
                }
            }
            else if (spec.isInterfaceType(type) && type.datatype) {
                const { statementsByProp, excludedProps } = processInterfaceType(type, types, assembly, projectInfo);
                for (const [name, statement] of statementsByProp.entries()) {
                    if (!excludedProps.has(name)) {
                        statements.push(statement);
                        isEmpty = false;
                    }
                }
            }
            statements.push(ts.createExpressionStatement(ts.createCall(ts.createIdentifier(`${VISITED_OBJECTS_SET_NAME}.delete`), [], [ts.createIdentifier(PARAMETER_NAME)])));
            const parameter = ts.createParameter(undefined, undefined, undefined, PARAMETER_NAME);
            const functionName = fnName(type.fqn);
            const functionDeclaration = ts.createFunctionDeclaration(undefined, undefined, undefined, functionName, undefined, [parameter], undefined, createFunctionBlock(isEmpty ? [] : statements));
            functionDeclarations.push(functionDeclaration);
        }
        this.transformers = {
            before: [
                (context) => {
                    const transformer = new Transformer(this.typeChecker, context, projectRoot, this.buildTypeIndex(assembly), assembly);
                    return transformer.transform.bind(transformer);
                },
            ],
        };
        generateWarningsFile(projectRoot, functionDeclarations);
    }
    get customTransformers() {
        return this.transformers;
    }
    buildTypeIndex(assembly) {
        var _a;
        const result = new Map();
        for (const type of Object.values((_a = assembly.types) !== null && _a !== void 0 ? _a : {})) {
            const symbolId = type.symbolId;
            if (symbolId) {
                result.set(symbolId, type);
            }
        }
        return result;
    }
}
exports.DeprecationWarningsInjector = DeprecationWarningsInjector;
function processInterfaceType(type, types, assembly, projectInfo, statementsByProp = new Map(), excludedProps = new Set()) {
    var _a, _b, _c, _d, _e;
    for (const prop of Object.values((_a = type.properties) !== null && _a !== void 0 ? _a : {})) {
        const fqn = `${type.fqn}#${prop.name}`;
        if (spec.isDeprecated(prop) || spec.isDeprecated(type)) {
            // If the property individually is deprecated, or the entire type is deprecated
            const deprecatedDocs = (_c = (_b = prop.docs) === null || _b === void 0 ? void 0 : _b.deprecated) !== null && _c !== void 0 ? _c : (_d = type.docs) === null || _d === void 0 ? void 0 : _d.deprecated;
            const statement = createWarningFunctionCall(fqn, deprecatedDocs, ts.createIdentifier(`"${prop.name}" in ${PARAMETER_NAME}`));
            statementsByProp.set(prop.name, statement);
        }
        else {
            /* If a prop is not deprecated, we don't want to generate a warning for it,
               even if another property with the same name is deprecated in another
               super-interface. */
            excludedProps.add(prop.name);
        }
        if (spec.isNamedTypeReference(prop.type) &&
            Object.keys(types).includes(prop.type.fqn)) {
            const functionName = importedFunctionName(prop.type.fqn, assembly, projectInfo);
            if (functionName) {
                const statement = createTypeHandlerCall(functionName, `${PARAMETER_NAME}.${prop.name}`);
                statementsByProp.set(`${prop.name}_`, statement);
            }
        }
        else if (spec.isCollectionTypeReference(prop.type) &&
            spec.isNamedTypeReference(prop.type.collection.elementtype)) {
            const functionName = importedFunctionName(prop.type.collection.elementtype.fqn, assembly, projectInfo);
            if (functionName) {
                const statement = createTypeHandlerCall(functionName, `${PARAMETER_NAME}.${prop.name}`);
                statementsByProp.set(`${prop.name}_`, statement);
            }
        }
        else if (spec.isUnionTypeReference(prop.type) &&
            spec.isNamedTypeReference(prop.type.union.types[0]) &&
            Object.keys(types).includes(prop.type.union.types[0].fqn)) {
            const functionName = importedFunctionName(prop.type.union.types[0].fqn, assembly, projectInfo);
            if (functionName) {
                const statement = createTypeHandlerCall(functionName, `${PARAMETER_NAME}.${prop.name}`);
                statementsByProp.set(`${prop.name}_`, statement);
            }
        }
    }
    // We also generate calls to all the supertypes
    for (const interfaceName of (_e = type.interfaces) !== null && _e !== void 0 ? _e : []) {
        const assemblies = projectInfo.dependencyClosure.concat(assembly);
        const superType = findType(interfaceName, assemblies);
        if (superType.type) {
            processInterfaceType(superType.type, types, assembly, projectInfo, statementsByProp, excludedProps);
        }
    }
    return { statementsByProp, excludedProps };
}
function fnName(fqn) {
    return fqn.replace(/[^\w\d]/g, '_');
}
function createFunctionBlock(statements) {
    if (statements.length > 0) {
        const validation = ts.createIf(ts.createIdentifier(`${PARAMETER_NAME} == null`), ts.createReturn());
        return ts.createBlock([validation, ...statements], true);
    }
    return ts.createBlock([], true);
}
function createWarningFunctionCall(fqn, message = '', condition, includeNamespace = false) {
    const functionName = includeNamespace
        ? `${NAMESPACE}.${WARNING_FUNCTION_NAME}`
        : WARNING_FUNCTION_NAME;
    const mainStatement = ts.createExpressionStatement(ts.createCall(ts.createIdentifier(functionName), [], [ts.createLiteral(fqn), ts.createLiteral(message)]));
    return condition ? ts.createIf(condition, mainStatement) : mainStatement;
}
function generateWarningsFile(projectRoot, functionDeclarations) {
    const names = [...functionDeclarations]
        .map((d) => { var _a; return (_a = d.name) === null || _a === void 0 ? void 0 : _a.text; })
        .filter(Boolean);
    const exportedSymbols = [WARNING_FUNCTION_NAME, ...names].join(',');
    const functionText = `function ${WARNING_FUNCTION_NAME}(name, deprecationMessage) {
  const deprecated = process.env.JSII_DEPRECATED;
  const deprecationMode = ['warn', 'fail', 'quiet'].includes(deprecated) ? deprecated : 'warn';
  const message = \`\${name} is deprecated.\\n  \${deprecationMessage}\\n  This API will be removed in the next major release.\`;
  switch (deprecationMode) {
    case "fail":
      throw new DeprecationError(message);
    case "warn":
      console.warn("[WARNING]", message);
      break;
  }
}

const ${VISITED_OBJECTS_SET_NAME} = new Set();

class DeprecationError extends Error {}

module.exports = {${exportedSymbols}}
module.exports.DeprecationError = DeprecationError;
`;
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    const resultFile = ts.createSourceFile(path.join(projectRoot, exports.WARNINGSCODE_FILE_NAME), functionText, ts.ScriptTarget.Latest, false, ts.ScriptKind.JS);
    const declarations = functionDeclarations.map((declaration) => printer.printNode(ts.EmitHint.Unspecified, declaration, resultFile));
    const content = declarations.concat(printer.printFile(resultFile)).join('\n');
    fs.writeFileSync(path.join(projectRoot, exports.WARNINGSCODE_FILE_NAME), content);
}
class Transformer {
    constructor(typeChecker, context, projectRoot, typeIndex, assembly) {
        this.typeChecker = typeChecker;
        this.context = context;
        this.projectRoot = projectRoot;
        this.typeIndex = typeIndex;
        this.assembly = assembly;
        this.warningCallsWereInjected = false;
    }
    transform(node) {
        this.warningCallsWereInjected = false;
        const result = this.visitEachChild(node);
        if (ts.isSourceFile(result) && this.warningCallsWereInjected) {
            const importDir = path.relative(path.dirname(result.fileName), this.projectRoot);
            const importPath = importDir.startsWith('..')
                ? unixPath(path.join(importDir, exports.WARNINGSCODE_FILE_NAME))
                : `./${exports.WARNINGSCODE_FILE_NAME}`;
            return ts.updateSourceFileNode(result, [
                createRequireStatement(NAMESPACE, importPath),
                ...result.statements,
            ]);
        }
        return result;
    }
    visitEachChild(node) {
        return ts.visitEachChild(node, this.visitor.bind(this), this.context);
    }
    visitor(node) {
        if (ts.isMethodDeclaration(node) && node.body != null) {
            const statements = this.getStatementsForDeclaration(node);
            this.warningCallsWereInjected =
                this.warningCallsWereInjected || statements.length > 0;
            return ts.updateMethod(node, node.decorators, node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, ts.updateBlock(node.body, ts.createNodeArray([...statements, ...node.body.statements])));
        }
        else if (ts.isGetAccessorDeclaration(node) && node.body != null) {
            const statements = this.getStatementsForDeclaration(node);
            this.warningCallsWereInjected =
                this.warningCallsWereInjected || statements.length > 0;
            return ts.updateGetAccessor(node, node.decorators, node.modifiers, node.name, node.parameters, node.type, ts.updateBlock(node.body, ts.createNodeArray([...statements, ...node.body.statements])));
        }
        else if (ts.isSetAccessorDeclaration(node) && node.body != null) {
            const statements = this.getStatementsForDeclaration(node);
            this.warningCallsWereInjected =
                this.warningCallsWereInjected || statements.length > 0;
            return ts.updateSetAccessor(node, node.decorators, node.modifiers, node.name, node.parameters, ts.updateBlock(node.body, ts.createNodeArray([...statements, ...node.body.statements])));
        }
        else if (ts.isConstructorDeclaration(node) && node.body != null) {
            const statements = this.getStatementsForDeclaration(node);
            this.warningCallsWereInjected =
                this.warningCallsWereInjected || statements.length > 0;
            return ts.updateConstructor(node, node.decorators, node.modifiers, node.parameters, ts.updateBlock(node.body, insertStatements(node.body, statements)));
        }
        return this.visitEachChild(node);
    }
    getStatementsForDeclaration(node) {
        var _a, _b;
        const klass = node.parent;
        const classSymbolId = symbol_id_1.symbolIdentifier(this.typeChecker, this.typeChecker.getTypeAtLocation(klass).symbol);
        if (classSymbolId && this.typeIndex.has(classSymbolId)) {
            const classType = this.typeIndex.get(classSymbolId);
            if (ts.isConstructorDeclaration(node)) {
                const initializer = classType === null || classType === void 0 ? void 0 : classType.initializer;
                if (initializer) {
                    return this.getStatements(classType, initializer);
                }
            }
            const methods = (_a = classType === null || classType === void 0 ? void 0 : classType.methods) !== null && _a !== void 0 ? _a : [];
            const method = methods.find((method) => { var _a; return method.name === ((_a = node.name) === null || _a === void 0 ? void 0 : _a.getText()); });
            if (method) {
                return this.getStatements(classType, method);
            }
            const properties = (_b = classType === null || classType === void 0 ? void 0 : classType.properties) !== null && _b !== void 0 ? _b : [];
            const property = properties.find((property) => { var _a; return property.name === ((_a = node.name) === null || _a === void 0 ? void 0 : _a.getText()); });
            if (property) {
                return createWarningStatementForElement(property, classType);
            }
        }
        return [];
    }
    getStatements(classType, method) {
        var _a;
        const statements = createWarningStatementForElement(method, classType);
        for (const parameter of Object.values((_a = method.parameters) !== null && _a !== void 0 ? _a : {})) {
            const parameterType = this.assembly.types && spec.isNamedTypeReference(parameter.type)
                ? this.assembly.types[parameter.type.fqn]
                : undefined;
            if (parameterType) {
                const functionName = `${NAMESPACE}.${fnName(parameterType.fqn)}`;
                statements.push(ts.createExpressionStatement(ts.createCall(ts.createIdentifier(functionName), [], [ts.createIdentifier(parameter.name)])));
            }
        }
        return statements;
    }
}
function createWarningStatementForElement(element, classType) {
    var _a, _b, _c;
    if (spec.isDeprecated(element)) {
        const elementName = element.name;
        const fqn = elementName ? `${classType.fqn}#${elementName}` : classType.fqn;
        const message = (_b = (_a = element.docs) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : (_c = classType.docs) === null || _c === void 0 ? void 0 : _c.deprecated;
        return [createWarningFunctionCall(fqn, message, undefined, true)];
    }
    return [];
}
/**
 * Inserts a list of statements in the correct position inside a block of statements.
 * If there is a `super` call, It inserts the statements just after it. Otherwise,
 * insert the statements right at the beginning of the block.
 */
function insertStatements(block, newStatements) {
    function splicePoint(statement) {
        if (statement == null) {
            return 0;
        }
        let isSuper = false;
        statement.forEachChild((node) => {
            if (ts.isCallExpression(node) &&
                node.expression.kind === ts.SyntaxKind.SuperKeyword) {
                isSuper = true;
            }
        });
        return isSuper ? 1 : 0;
    }
    const result = [...block.statements];
    result.splice(splicePoint(block.statements[0]), 0, ...newStatements);
    return ts.createNodeArray(result);
}
function createEnumRequireStatement(typeLocation) {
    const { ext } = path.parse(typeLocation);
    const jsFileName = typeLocation.replace(ext, '.js');
    return createRequireStatement(LOCAL_ENUM_NAMESPACE, `./${jsFileName}`);
}
function createRequireStatement(name, importPath) {
    return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
        ts.createVariableDeclaration(name, undefined, ts.createCall(ts.createIdentifier('require'), undefined, [
            ts.createLiteral(importPath),
        ])),
    ], ts.NodeFlags.Const));
}
/**
 * Returns a ready-to-used function name (including a `require`, if necessary)
 */
function importedFunctionName(typeName, assembly, projectInfo) {
    const assemblies = projectInfo.dependencyClosure.concat(assembly);
    const { type, moduleName } = findType(typeName, assemblies);
    if (type) {
        return moduleName !== assembly.name
            ? `require("${moduleName}/${exports.WARNINGSCODE_FILE_NAME}").${fnName(type.fqn)}`
            : fnName(type.fqn);
    }
    return undefined;
}
/**
 * Find the type and module name in an array of assemblies
 * matching a given type name
 */
function findType(typeName, assemblies) {
    var _a, _b, _c;
    for (const asm of assemblies) {
        if ((_b = (_a = asm.metadata) === null || _a === void 0 ? void 0 : _a.jsii) === null || _b === void 0 ? void 0 : _b.compiledWithDeprecationWarnings) {
            const types = (_c = asm.types) !== null && _c !== void 0 ? _c : {};
            for (const name of Object.keys(types)) {
                if (typeName === name) {
                    return { type: types[name], moduleName: asm.name };
                }
            }
        }
    }
    return {};
}
function createTypeHandlerCall(functionName, parameter) {
    return ts.createIf(ts.createIdentifier(`!${VISITED_OBJECTS_SET_NAME}.has(${parameter})`), ts.createExpressionStatement(ts.createCall(ts.createIdentifier(functionName), [], [ts.createIdentifier(parameter)])));
}
/**
 * There is a chance an enum contains duplicates values with distinct keys,
 * with one of those keys being deprecated. This is a potential pattern to "rename" an enum.
 * In this case, we can't concretely determine if the deprecated member was used or not,
 * so in those cases we skip the warnings altogether, rather than erroneously warning for valid usage.
 * This create a statement to check if the enum value is a duplicate:
 *
 * if (Object.values(Foo).filter(x => x === p).length > 1) { return; }
 *
 * Note that we can't just check the assembly for these duplicates, due to:
 * https://github.com/aws/jsii/issues/2782
 */
function createDuplicateEnumValuesCheck(type) {
    return ts.createIf(ts.createBinary(ts.createPropertyAccess(ts.createCall(ts.createPropertyAccess(ts.createCall(ts.createIdentifier('Object.values'), undefined, [
        ts.createIdentifier(`${LOCAL_ENUM_NAMESPACE}.${type.name}`),
    ]), ts.createIdentifier('filter')), undefined, [
        ts.createArrowFunction(undefined, undefined, [ts.createParameter(undefined, undefined, undefined, 'x')], undefined, ts.createToken(ts.SyntaxKind.EqualsGreaterThanToken), ts.createBinary(ts.createIdentifier('x'), ts.createToken(ts.SyntaxKind.EqualsEqualsEqualsToken), ts.createIdentifier(PARAMETER_NAME))),
    ]), ts.createIdentifier('length')), ts.createToken(ts.SyntaxKind.GreaterThanToken), ts.createNumericLiteral('1')), ts.createReturn());
}
/**
 * Force a path to be UNIXy (use `/` as a separator)
 *
 * `path.join()` etc. will use the system-dependent path separator (either `/` or `\`
 * depending on your platform).
 *
 * However, if we actually emit the path-dependent separator to the `.js` files, then
 * files compiled with jsii on Windows cannot be used on any other platform. That seems
 * like an unnecessary restriction, especially since a `/` will work fine on Windows,
 * so make sure to always emit `/`.
 *
 * TSC itself always strictly emits `/` (or at least, emits the same what you put in).
 */
function unixPath(filePath) {
    if (path.sep === '\\') {
        return filePath.replace(/\\/g, '/');
    }
    return filePath;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwcmVjYXRpb24td2FybmluZ3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkZXByZWNhdGlvbi13YXJuaW5ncy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBbUM7QUFFbkMseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFHakMsNENBQWdEO0FBRW5DLFFBQUEsc0JBQXNCLEdBQUcsbUJBQW1CLENBQUM7QUFDMUQsTUFBTSxxQkFBcUIsR0FBRyxPQUFPLENBQUM7QUFDdEMsTUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDO0FBQzNCLE1BQU0sU0FBUyxHQUFHLHlCQUF5QixDQUFDO0FBQzVDLE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDO0FBQ2xDLE1BQU0sd0JBQXdCLEdBQUcsZ0JBQWdCLENBQUM7QUFFbEQsTUFBYSwyQkFBMkI7SUFLdEMsWUFBb0MsV0FBMkI7UUFBM0IsZ0JBQVcsR0FBWCxXQUFXLENBQWdCO1FBSnZELGlCQUFZLEdBQTBCO1lBQzVDLE1BQU0sRUFBRSxFQUFFO1NBQ1gsQ0FBQztJQUVnRSxDQUFDO0lBRTVELE9BQU8sQ0FBQyxRQUFrQixFQUFFLFdBQXdCOztRQUN6RCxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFDO1FBQzVDLE1BQU0sb0JBQW9CLEdBQTZCLEVBQUUsQ0FBQztRQUUxRCxNQUFNLEtBQUssU0FBRyxRQUFRLENBQUMsS0FBSyxtQ0FBSSxFQUFFLENBQUM7UUFDbkMsS0FBSyxNQUFNLElBQUksSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3ZDLE1BQU0sVUFBVSxHQUFtQixFQUFFLENBQUM7WUFDdEMsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDO1lBRW5CLDJGQUEyRjtZQUMzRixVQUFVLENBQUMsSUFBSSxDQUNiLEVBQUUsQ0FBQyx5QkFBeUIsQ0FDMUIsRUFBRSxDQUFDLFVBQVUsQ0FDWCxFQUFFLENBQUMsZ0JBQWdCLENB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RSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUMxRCxTQUFTLEVBQ1QsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHNCQUFzQixDQUFDLEVBQ3BELEVBQUUsQ0FBQyxZQUFZLENBQ2IsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxFQUN4QixFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFDckQsRUFBRSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxDQUNwQyxDQUNGO0tBQ0YsQ0FDRixFQUNELEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FDOUIsRUFDRCxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsRUFDOUMsRUFBRSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUM3QixFQUNELEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FDbEIsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxTQUFTLFFBQVEsQ0FBQyxRQUFnQjtJQUNoQyxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssSUFBSSxFQUFFO1FBQ3JCLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FDckM7SUFDRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3BlYyBmcm9tICdAanNpaS9zcGVjJztcbmltcG9ydCB7IEFzc2VtYmx5IH0gZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IFByb2plY3RJbmZvIH0gZnJvbSAnLi4vcHJvamVjdC1pbmZvJztcbmltcG9ydCB7IHN5bWJvbElkZW50aWZpZXIgfSBmcm9tICcuLi9zeW1ib2wtaWQnO1xuXG5leHBvcnQgY29uc3QgV0FSTklOR1NDT0RFX0ZJTEVfTkFNRSA9ICcud2FybmluZ3MuanNpaS5qcyc7XG5jb25zdCBXQVJOSU5HX0ZVTkNUSU9OX05BTUUgPSAncHJpbnQnO1xuY29uc3QgUEFSQU1FVEVSX05BTUUgPSAncCc7XG5jb25zdCBOQU1FU1BBQ0UgPSAnanNpaURlcHJlY2F0aW9uV2FybmluZ3MnO1xuY29uc3QgTE9DQUxfRU5VTV9OQU1FU1BBQ0UgPSAnbnMnO1xuY29uc3QgVklTSVRFRF9PQkpFQ1RTX1NFVF9OQU1FID0gJ3Zpc2l0ZWRPYmplY3RzJztcblxuZXhwb3J0IGNsYXNzIERlcHJlY2F0aW9uV2FybmluZ3NJbmplY3RvciB7XG4gIHByaXZhdGUgdHJhbnNmb3JtZXJzOiB0cy5DdXN0b21UcmFuc2Zvcm1lcnMgPSB7XG4gICAgYmVmb3JlOiBbXSxcbiAgfTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIpIHt9XG5cbiAgcHVibGljIHByb2Nlc3MoYXNzZW1ibHk6IEFzc2VtYmx5LCBwcm9qZWN0SW5mbzogUHJvamVjdEluZm8pIHtcbiAgICBjb25zdCBwcm9qZWN0Um9vdCA9IHByb2plY3RJbmZvLnByb2plY3RSb290O1xuICAgIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb25zOiB0cy5GdW5jdGlvbkRlY2xhcmF0aW9uW10gPSBbXTtcblxuICAgIGNvbnN0IHR5cGVzID0gYXNzZW1ibHkudHlwZXMgPz8ge307XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIE9iamVjdC52YWx1ZXModHlwZXMpKSB7XG4gICAgICBjb25zdCBzdGF0ZW1lbnRzOiB0cy5TdGF0ZW1lbnRbXSA9IFtdO1xuICAgICAgbGV0IGlzRW1wdHkgPSB0cnVlO1xuXG4gICAgICAvLyBUaGlzIHdpbGwgYWRkIHRoZSBwYXJhbWV0ZXIgdG8gdGhlIHNldCBvZiB2aXNpdGVkIG9iamVjdHMsIHRvIHByZXZlbnQgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICBzdGF0ZW1lbnRzLnB1c2goXG4gICAgICAgIHRzLmNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICAgICAgdHMuY3JlYXRlQ2FsbChcbiAgICAgICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoYCR7VklTSVRFRF9PQkpFQ1RTX1NFVF9OQU1FfS5hZGRgKSxcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgW3RzLmNyZWF0ZUlkZW50aWZpZXIoUEFSQU1FVEVSX05BTUUpXSxcbiAgICAgICAgICApLFxuICAgICAgICApLFxuICAgICAgKTtcblxuICAgICAgaWYgKHNwZWMuaXNEZXByZWNhdGVkKHR5cGUpICYmIHNwZWMuaXNFbnVtVHlwZSh0eXBlKSkge1xuICAgICAgICAvLyBUaGUgdHlwZSBpcyBkZXByZWNhdGVkXG4gICAgICAgIHN0YXRlbWVudHMucHVzaChcbiAgICAgICAgICBjcmVhdGVXYXJuaW5nRnVuY3Rpb25DYWxsKHR5cGUuZnFuLCB0eXBlLmRvY3M/LmRlcHJlY2F0ZWQpLFxuICAgICAgICApO1xuICAgICAgICBpc0VtcHR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVjLmlzRW51bVR5cGUodHlwZSkgJiYgdHlwZS5sb2NhdGlvbkluTW9kdWxlPy5maWxlbmFtZSkge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goXG4gICAgICAgICAgY3JlYXRlRW51bVJlcXVpcmVTdGF0ZW1lbnQodHlwZS5sb2NhdGlvbkluTW9kdWxlPy5maWxlbmFtZSksXG4gICAgICAgICk7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChjcmVhdGVEdXBsaWNhdGVFbnVtVmFsdWVzQ2hlY2sodHlwZSkpO1xuXG4gICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIE9iamVjdC52YWx1ZXModHlwZS5tZW1iZXJzID8/IFtdKSkge1xuICAgICAgICAgIGlmIChzcGVjLmlzRGVwcmVjYXRlZChtZW1iZXIpKSB7XG4gICAgICAgICAgICAvLyBUaGUgZW51bSBtZW1iZXIgaXMgZGVwcmVjYXRlZFxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gdHMuY3JlYXRlSWRlbnRpZmllcihcbiAgICAgICAgICAgICAgYCR7UEFSQU1FVEVSX05BTUV9ID09PSAke0xPQ0FMX0VOVU1fTkFNRVNQQUNFfS4ke3R5cGUubmFtZX0uJHttZW1iZXIubmFtZX1gLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKFxuICAgICAgICAgICAgICBjcmVhdGVXYXJuaW5nRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICAgIGAke3R5cGUuZnFufSMke21lbWJlci5uYW1lfWAsXG4gICAgICAgICAgICAgICAgbWVtYmVyLmRvY3M/LmRlcHJlY2F0ZWQsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3BlYy5pc0ludGVyZmFjZVR5cGUodHlwZSkgJiYgdHlwZS5kYXRhdHlwZSkge1xuICAgICAgICBjb25zdCB7IHN0YXRlbWVudHNCeVByb3AsIGV4Y2x1ZGVkUHJvcHMgfSA9IHByb2Nlc3NJbnRlcmZhY2VUeXBlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdHlwZXMsXG4gICAgICAgICAgYXNzZW1ibHksXG4gICAgICAgICAgcHJvamVjdEluZm8sXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc3RhdGVtZW50XSBvZiBzdGF0ZW1lbnRzQnlQcm9wLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICghZXhjbHVkZWRQcm9wcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICAgICAgaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGVtZW50cy5wdXNoKFxuICAgICAgICB0cy5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgICAgIHRzLmNyZWF0ZUNhbGwoXG4gICAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKGAke1ZJU0lURURfT0JKRUNUU19TRVRfTkFNRX0uZGVsZXRlYCksXG4gICAgICAgICAgICBbXSxcbiAgICAgICAgICAgIFt0cy5jcmVhdGVJZGVudGlmaWVyKFBBUkFNRVRFUl9OQU1FKV0sXG4gICAgICAgICAgKSxcbiAgICAgICAgKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHBhcmFtZXRlciA9IHRzLmNyZWF0ZVBhcmFtZXRlcihcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgUEFSQU1FVEVSX05BTUUsXG4gICAgICApO1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gZm5OYW1lKHR5cGUuZnFuKTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb24gPSB0cy5jcmVhdGVGdW5jdGlvbkRlY2xhcmF0aW9uKFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgW3BhcmFtZXRlcl0sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgY3JlYXRlRnVuY3Rpb25CbG9jayhpc0VtcHR5ID8gW10gOiBzdGF0ZW1lbnRzKSxcbiAgICAgICk7XG4gICAgICBmdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKGZ1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybWVycyA9IHtcbiAgICAgIGJlZm9yZTogW1xuICAgICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybWVyKFxuICAgICAgICAgICAgdGhpcy50eXBlQ2hlY2tlcixcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBwcm9qZWN0Um9vdCxcbiAgICAgICAgICAgIHRoaXMuYnVpbGRUeXBlSW5kZXgoYXNzZW1ibHkpLFxuICAgICAgICAgICAgYXNzZW1ibHksXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtLmJpbmQodHJhbnNmb3JtZXIpO1xuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICAgIGdlbmVyYXRlV2FybmluZ3NGaWxlKHByb2plY3RSb290LCBmdW5jdGlvbkRlY2xhcmF0aW9ucyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGN1c3RvbVRyYW5zZm9ybWVycygpOiB0cy5DdXN0b21UcmFuc2Zvcm1lcnMge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWVycztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRUeXBlSW5kZXgoYXNzZW1ibHk6IEFzc2VtYmx5KTogTWFwPHN0cmluZywgc3BlYy5UeXBlPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcDxzdHJpbmcsIHNwZWMuVHlwZT4oKTtcblxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3QudmFsdWVzKGFzc2VtYmx5LnR5cGVzID8/IHt9KSkge1xuICAgICAgY29uc3Qgc3ltYm9sSWQgPSB0eXBlLnN5bWJvbElkO1xuICAgICAgaWYgKHN5bWJvbElkKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoc3ltYm9sSWQsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ludGVyZmFjZVR5cGUoXG4gIHR5cGU6IHNwZWMuSW50ZXJmYWNlVHlwZSxcbiAgdHlwZXM6IHsgW3A6IHN0cmluZ106IHNwZWMuVHlwZSB9LFxuICBhc3NlbWJseTogQXNzZW1ibHksXG4gIHByb2plY3RJbmZvOiBQcm9qZWN0SW5mbyxcbiAgc3RhdGVtZW50c0J5UHJvcDogTWFwPHN0cmluZywgdHMuU3RhdGVtZW50PiA9IG5ldyBNYXA8c3RyaW5nLCB0cy5TdGF0ZW1lbnQ+KCksXG4gIGV4Y2x1ZGVkUHJvcHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KCksXG4pIHtcbiAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC52YWx1ZXModHlwZS5wcm9wZXJ0aWVzID8/IHt9KSkge1xuICAgIGNvbnN0IGZxbiA9IGAke3R5cGUuZnFufSMke3Byb3AubmFtZX1gO1xuICAgIGlmIChzcGVjLmlzRGVwcmVjYXRlZChwcm9wKSB8fCBzcGVjLmlzRGVwcmVjYXRlZCh0eXBlKSkge1xuICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGluZGl2aWR1YWxseSBpcyBkZXByZWNhdGVkLCBvciB0aGUgZW50aXJlIHR5cGUgaXMgZGVwcmVjYXRlZFxuICAgICAgY29uc3QgZGVwcmVjYXRlZERvY3MgPSBwcm9wLmRvY3M/LmRlcHJlY2F0ZWQgPz8gdHlwZS5kb2NzPy5kZXByZWNhdGVkO1xuICAgICAgY29uc3Qgc3RhdGVtZW50ID0gY3JlYXRlV2FybmluZ0Z1bmN0aW9uQ2FsbChcbiAgICAgICAgZnFuLFxuICAgICAgICBkZXByZWNhdGVkRG9jcyxcbiAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcihgXCIke3Byb3AubmFtZX1cIiBpbiAke1BBUkFNRVRFUl9OQU1FfWApLFxuICAgICAgKTtcbiAgICAgIHN0YXRlbWVudHNCeVByb3Auc2V0KHByb3AubmFtZSwgc3RhdGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSWYgYSBwcm9wIGlzIG5vdCBkZXByZWNhdGVkLCB3ZSBkb24ndCB3YW50IHRvIGdlbmVyYXRlIGEgd2FybmluZyBmb3IgaXQsXG4gICAgICAgICBldmVuIGlmIGFub3RoZXIgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGRlcHJlY2F0ZWQgaW4gYW5vdGhlclxuICAgICAgICAgc3VwZXItaW50ZXJmYWNlLiAqL1xuICAgICAgZXhjbHVkZWRQcm9wcy5hZGQocHJvcC5uYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHByb3AudHlwZSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHR5cGVzKS5pbmNsdWRlcyhwcm9wLnR5cGUuZnFuKVxuICAgICkge1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gaW1wb3J0ZWRGdW5jdGlvbk5hbWUoXG4gICAgICAgIHByb3AudHlwZS5mcW4sXG4gICAgICAgIGFzc2VtYmx5LFxuICAgICAgICBwcm9qZWN0SW5mbyxcbiAgICAgICk7XG4gICAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudCA9IGNyZWF0ZVR5cGVIYW5kbGVyQ2FsbChcbiAgICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgYCR7UEFSQU1FVEVSX05BTUV9LiR7cHJvcC5uYW1lfWAsXG4gICAgICAgICk7XG4gICAgICAgIHN0YXRlbWVudHNCeVByb3Auc2V0KGAke3Byb3AubmFtZX1fYCwgc3RhdGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc3BlYy5pc0NvbGxlY3Rpb25UeXBlUmVmZXJlbmNlKHByb3AudHlwZSkgJiZcbiAgICAgIHNwZWMuaXNOYW1lZFR5cGVSZWZlcmVuY2UocHJvcC50eXBlLmNvbGxlY3Rpb24uZWxlbWVudHR5cGUpXG4gICAgKSB7XG4gICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBpbXBvcnRlZEZ1bmN0aW9uTmFtZShcbiAgICAgICAgcHJvcC50eXBlLmNvbGxlY3Rpb24uZWxlbWVudHR5cGUuZnFuLFxuICAgICAgICBhc3NlbWJseSxcbiAgICAgICAgcHJvamVjdEluZm8sXG4gICAgICApO1xuICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSBjcmVhdGVUeXBlSGFuZGxlckNhbGwoXG4gICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGAke1BBUkFNRVRFUl9OQU1FfS4ke3Byb3AubmFtZX1gLFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZW1lbnRzQnlQcm9wLnNldChgJHtwcm9wLm5hbWV9X2AsIHN0YXRlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNwZWMuaXNVbmlvblR5cGVSZWZlcmVuY2UocHJvcC50eXBlKSAmJlxuICAgICAgc3BlYy5pc05hbWVkVHlwZVJlZmVyZW5jZShwcm9wLnR5cGUudW5pb24udHlwZXNbMF0pICYmXG4gICAgICBPYmplY3Qua2V5cyh0eXBlcykuaW5jbHVkZXMocHJvcC50eXBlLnVuaW9uLnR5cGVzWzBdLmZxbilcbiAgICApIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGltcG9ydGVkRnVuY3Rpb25OYW1lKFxuICAgICAgICBwcm9wLnR5cGUudW5pb24udHlwZXNbMF0uZnFuLFxuICAgICAgICBhc3NlbWJseSxcbiAgICAgICAgcHJvamVjdEluZm8sXG4gICAgICApO1xuICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSBjcmVhdGVUeXBlSGFuZGxlckNhbGwoXG4gICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGAke1BBUkFNRVRFUl9OQU1FfS4ke3Byb3AubmFtZX1gLFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZW1lbnRzQnlQcm9wLnNldChgJHtwcm9wLm5hbWV9X2AsIHN0YXRlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgYWxzbyBnZW5lcmF0ZSBjYWxscyB0byBhbGwgdGhlIHN1cGVydHlwZXNcbiAgZm9yIChjb25zdCBpbnRlcmZhY2VOYW1lIG9mIHR5cGUuaW50ZXJmYWNlcyA/PyBbXSkge1xuICAgIGNvbnN0IGFzc2VtYmxpZXMgPSBwcm9qZWN0SW5mby5kZXBlbmRlbmN5Q2xvc3VyZS5jb25jYXQoYXNzZW1ibHkpO1xuICAgIGNvbnN0IHN1cGVyVHlwZSA9IGZpbmRUeXBlKGludGVyZmFjZU5hbWUsIGFzc2VtYmxpZXMpO1xuICAgIGlmIChzdXBlclR5cGUudHlwZSkge1xuICAgICAgcHJvY2Vzc0ludGVyZmFjZVR5cGUoXG4gICAgICAgIHN1cGVyVHlwZS50eXBlIGFzIHNwZWMuSW50ZXJmYWNlVHlwZSxcbiAgICAgICAgdHlwZXMsXG4gICAgICAgIGFzc2VtYmx5LFxuICAgICAgICBwcm9qZWN0SW5mbyxcbiAgICAgICAgc3RhdGVtZW50c0J5UHJvcCxcbiAgICAgICAgZXhjbHVkZWRQcm9wcyxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHN0YXRlbWVudHNCeVByb3AsIGV4Y2x1ZGVkUHJvcHMgfTtcbn1cblxuZnVuY3Rpb24gZm5OYW1lKGZxbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGZxbi5yZXBsYWNlKC9bXlxcd1xcZF0vZywgJ18nKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25CbG9jayhzdGF0ZW1lbnRzOiB0cy5TdGF0ZW1lbnRbXSk6IHRzLkJsb2NrIHtcbiAgaWYgKHN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0cy5jcmVhdGVJZihcbiAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoYCR7UEFSQU1FVEVSX05BTUV9ID09IG51bGxgKSxcbiAgICAgIHRzLmNyZWF0ZVJldHVybigpLFxuICAgICk7XG4gICAgcmV0dXJuIHRzLmNyZWF0ZUJsb2NrKFt2YWxpZGF0aW9uLCAuLi5zdGF0ZW1lbnRzXSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHRzLmNyZWF0ZUJsb2NrKFtdLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV2FybmluZ0Z1bmN0aW9uQ2FsbChcbiAgZnFuOiBzdHJpbmcsXG4gIG1lc3NhZ2UgPSAnJyxcbiAgY29uZGl0aW9uPzogdHMuSWRlbnRpZmllcixcbiAgaW5jbHVkZU5hbWVzcGFjZSA9IGZhbHNlLFxuKTogdHMuU3RhdGVtZW50IHtcbiAgY29uc3QgZnVuY3Rpb25OYW1lID0gaW5jbHVkZU5hbWVzcGFjZVxuICAgID8gYCR7TkFNRVNQQUNFfS4ke1dBUk5JTkdfRlVOQ1RJT05fTkFNRX1gXG4gICAgOiBXQVJOSU5HX0ZVTkNUSU9OX05BTUU7XG5cbiAgY29uc3QgbWFpblN0YXRlbWVudCA9IHRzLmNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgdHMuY3JlYXRlQ2FsbChcbiAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoZnVuY3Rpb25OYW1lKSxcbiAgICAgIFtdLFxuICAgICAgW3RzLmNyZWF0ZUxpdGVyYWwoZnFuKSwgdHMuY3JlYXRlTGl0ZXJhbChtZXNzYWdlKV0sXG4gICAgKSxcbiAgKTtcblxuICByZXR1cm4gY29uZGl0aW9uID8gdHMuY3JlYXRlSWYoY29uZGl0aW9uLCBtYWluU3RhdGVtZW50KSA6IG1haW5TdGF0ZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlV2FybmluZ3NGaWxlKFxuICBwcm9qZWN0Um9vdDogc3RyaW5nLFxuICBmdW5jdGlvbkRlY2xhcmF0aW9uczogdHMuRnVuY3Rpb25EZWNsYXJhdGlvbltdLFxuKSB7XG4gIGNvbnN0IG5hbWVzID0gWy4uLmZ1bmN0aW9uRGVjbGFyYXRpb25zXVxuICAgIC5tYXAoKGQpID0+IGQubmFtZT8udGV4dClcbiAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBleHBvcnRlZFN5bWJvbHMgPSBbV0FSTklOR19GVU5DVElPTl9OQU1FLCAuLi5uYW1lc10uam9pbignLCcpO1xuXG4gIGNvbnN0IGZ1bmN0aW9uVGV4dCA9IGBmdW5jdGlvbiAke1dBUk5JTkdfRlVOQ1RJT05fTkFNRX0obmFtZSwgZGVwcmVjYXRpb25NZXNzYWdlKSB7XG4gIGNvbnN0IGRlcHJlY2F0ZWQgPSBwcm9jZXNzLmVudi5KU0lJX0RFUFJFQ0FURUQ7XG4gIGNvbnN0IGRlcHJlY2F0aW9uTW9kZSA9IFsnd2FybicsICdmYWlsJywgJ3F1aWV0J10uaW5jbHVkZXMoZGVwcmVjYXRlZCkgPyBkZXByZWNhdGVkIDogJ3dhcm4nO1xuICBjb25zdCBtZXNzYWdlID0gXFxgXFwke25hbWV9IGlzIGRlcHJlY2F0ZWQuXFxcXG4gIFxcJHtkZXByZWNhdGlvbk1lc3NhZ2V9XFxcXG4gIFRoaXMgQVBJIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxcYDtcbiAgc3dpdGNoIChkZXByZWNhdGlvbk1vZGUpIHtcbiAgICBjYXNlIFwiZmFpbFwiOlxuICAgICAgdGhyb3cgbmV3IERlcHJlY2F0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgY2FzZSBcIndhcm5cIjpcbiAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXVwiLCBtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmNvbnN0ICR7VklTSVRFRF9PQkpFQ1RTX1NFVF9OQU1FfSA9IG5ldyBTZXQoKTtcblxuY2xhc3MgRGVwcmVjYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbm1vZHVsZS5leHBvcnRzID0geyR7ZXhwb3J0ZWRTeW1ib2xzfX1cbm1vZHVsZS5leHBvcnRzLkRlcHJlY2F0aW9uRXJyb3IgPSBEZXByZWNhdGlvbkVycm9yO1xuYDtcblxuICBjb25zdCBwcmludGVyID0gdHMuY3JlYXRlUHJpbnRlcih7IG5ld0xpbmU6IHRzLk5ld0xpbmVLaW5kLkxpbmVGZWVkIH0pO1xuICBjb25zdCByZXN1bHRGaWxlID0gdHMuY3JlYXRlU291cmNlRmlsZShcbiAgICBwYXRoLmpvaW4ocHJvamVjdFJvb3QsIFdBUk5JTkdTQ09ERV9GSUxFX05BTUUpLFxuICAgIGZ1bmN0aW9uVGV4dCxcbiAgICB0cy5TY3JpcHRUYXJnZXQuTGF0ZXN0LFxuICAgIGZhbHNlLFxuICAgIHRzLlNjcmlwdEtpbmQuSlMsXG4gICk7XG5cbiAgY29uc3QgZGVjbGFyYXRpb25zID0gZnVuY3Rpb25EZWNsYXJhdGlvbnMubWFwKChkZWNsYXJhdGlvbikgPT5cbiAgICBwcmludGVyLnByaW50Tm9kZSh0cy5FbWl0SGludC5VbnNwZWNpZmllZCwgZGVjbGFyYXRpb24sIHJlc3VsdEZpbGUpLFxuICApO1xuXG4gIGNvbnN0IGNvbnRlbnQgPSBkZWNsYXJhdGlvbnMuY29uY2F0KHByaW50ZXIucHJpbnRGaWxlKHJlc3VsdEZpbGUpKS5qb2luKCdcXG4nKTtcblxuICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9qZWN0Um9vdCwgV0FSTklOR1NDT0RFX0ZJTEVfTkFNRSksIGNvbnRlbnQpO1xufVxuXG5jbGFzcyBUcmFuc2Zvcm1lciB7XG4gIHByaXZhdGUgd2FybmluZ0NhbGxzV2VyZUluamVjdGVkID0gZmFsc2U7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29udGV4dDogdHMuVHJhbnNmb3JtYXRpb25Db250ZXh0LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJvamVjdFJvb3Q6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHR5cGVJbmRleDogTWFwPHN0cmluZywgc3BlYy5UeXBlPixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFzc2VtYmx5OiBBc3NlbWJseSxcbiAgKSB7fVxuXG4gIHB1YmxpYyB0cmFuc2Zvcm08VCBleHRlbmRzIHRzLk5vZGU+KG5vZGU6IFQpOiBUIHtcbiAgICB0aGlzLndhcm5pbmdDYWxsc1dlcmVJbmplY3RlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy52aXNpdEVhY2hDaGlsZChub2RlKTtcblxuICAgIGlmICh0cy5pc1NvdXJjZUZpbGUocmVzdWx0KSAmJiB0aGlzLndhcm5pbmdDYWxsc1dlcmVJbmplY3RlZCkge1xuICAgICAgY29uc3QgaW1wb3J0RGlyID0gcGF0aC5yZWxhdGl2ZShcbiAgICAgICAgcGF0aC5kaXJuYW1lKHJlc3VsdC5maWxlTmFtZSksXG4gICAgICAgIHRoaXMucHJvamVjdFJvb3QsXG4gICAgICApO1xuICAgICAgY29uc3QgaW1wb3J0UGF0aCA9IGltcG9ydERpci5zdGFydHNXaXRoKCcuLicpXG4gICAgICAgID8gdW5peFBhdGgocGF0aC5qb2luKGltcG9ydERpciwgV0FSTklOR1NDT0RFX0ZJTEVfTkFNRSkpXG4gICAgICAgIDogYC4vJHtXQVJOSU5HU0NPREVfRklMRV9OQU1FfWA7XG5cbiAgICAgIHJldHVybiB0cy51cGRhdGVTb3VyY2VGaWxlTm9kZShyZXN1bHQsIFtcbiAgICAgICAgY3JlYXRlUmVxdWlyZVN0YXRlbWVudChOQU1FU1BBQ0UsIGltcG9ydFBhdGgpLFxuICAgICAgICAuLi5yZXN1bHQuc3RhdGVtZW50cyxcbiAgICAgIF0pIGFzIGFueTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRFYWNoQ2hpbGQ8VCBleHRlbmRzIHRzLk5vZGU+KG5vZGU6IFQpOiBUIHtcbiAgICByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdGhpcy52aXNpdG9yLmJpbmQodGhpcyksIHRoaXMuY29udGV4dCk7XG4gIH1cblxuICBwcml2YXRlIHZpc2l0b3I8VCBleHRlbmRzIHRzLk5vZGU+KG5vZGU6IFQpOiB0cy5WaXNpdFJlc3VsdDxUPiB7XG4gICAgaWYgKHRzLmlzTWV0aG9kRGVjbGFyYXRpb24obm9kZSkgJiYgbm9kZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSB0aGlzLmdldFN0YXRlbWVudHNGb3JEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHRoaXMud2FybmluZ0NhbGxzV2VyZUluamVjdGVkID1cbiAgICAgICAgdGhpcy53YXJuaW5nQ2FsbHNXZXJlSW5qZWN0ZWQgfHwgc3RhdGVtZW50cy5sZW5ndGggPiAwO1xuICAgICAgcmV0dXJuIHRzLnVwZGF0ZU1ldGhvZChcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZS5kZWNvcmF0b3JzLFxuICAgICAgICBub2RlLm1vZGlmaWVycyxcbiAgICAgICAgbm9kZS5hc3Rlcmlza1Rva2VuLFxuICAgICAgICBub2RlLm5hbWUsXG4gICAgICAgIG5vZGUucXVlc3Rpb25Ub2tlbixcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyxcbiAgICAgICAgbm9kZS5wYXJhbWV0ZXJzLFxuICAgICAgICBub2RlLnR5cGUsXG4gICAgICAgIHRzLnVwZGF0ZUJsb2NrKFxuICAgICAgICAgIG5vZGUuYm9keSxcbiAgICAgICAgICB0cy5jcmVhdGVOb2RlQXJyYXkoWy4uLnN0YXRlbWVudHMsIC4uLm5vZGUuYm9keS5zdGF0ZW1lbnRzXSksXG4gICAgICAgICksXG4gICAgICApIGFzIGFueTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzR2V0QWNjZXNzb3JEZWNsYXJhdGlvbihub2RlKSAmJiBub2RlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RhdGVtZW50cyA9IHRoaXMuZ2V0U3RhdGVtZW50c0ZvckRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgdGhpcy53YXJuaW5nQ2FsbHNXZXJlSW5qZWN0ZWQgPVxuICAgICAgICB0aGlzLndhcm5pbmdDYWxsc1dlcmVJbmplY3RlZCB8fCBzdGF0ZW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgICByZXR1cm4gdHMudXBkYXRlR2V0QWNjZXNzb3IoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUuZGVjb3JhdG9ycyxcbiAgICAgICAgbm9kZS5tb2RpZmllcnMsXG4gICAgICAgIG5vZGUubmFtZSxcbiAgICAgICAgbm9kZS5wYXJhbWV0ZXJzLFxuICAgICAgICBub2RlLnR5cGUsXG4gICAgICAgIHRzLnVwZGF0ZUJsb2NrKFxuICAgICAgICAgIG5vZGUuYm9keSxcbiAgICAgICAgICB0cy5jcmVhdGVOb2RlQXJyYXkoWy4uLnN0YXRlbWVudHMsIC4uLm5vZGUuYm9keS5zdGF0ZW1lbnRzXSksXG4gICAgICAgICksXG4gICAgICApIGFzIGFueTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzU2V0QWNjZXNzb3JEZWNsYXJhdGlvbihub2RlKSAmJiBub2RlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RhdGVtZW50cyA9IHRoaXMuZ2V0U3RhdGVtZW50c0ZvckRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgdGhpcy53YXJuaW5nQ2FsbHNXZXJlSW5qZWN0ZWQgPVxuICAgICAgICB0aGlzLndhcm5pbmdDYWxsc1dlcmVJbmplY3RlZCB8fCBzdGF0ZW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgICByZXR1cm4gdHMudXBkYXRlU2V0QWNjZXNzb3IoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUuZGVjb3JhdG9ycyxcbiAgICAgICAgbm9kZS5tb2RpZmllcnMsXG4gICAgICAgIG5vZGUubmFtZSxcbiAgICAgICAgbm9kZS5wYXJhbWV0ZXJzLFxuICAgICAgICB0cy51cGRhdGVCbG9jayhcbiAgICAgICAgICBub2RlLmJvZHksXG4gICAgICAgICAgdHMuY3JlYXRlTm9kZUFycmF5KFsuLi5zdGF0ZW1lbnRzLCAuLi5ub2RlLmJvZHkuc3RhdGVtZW50c10pLFxuICAgICAgICApLFxuICAgICAgKSBhcyBhbnk7XG4gICAgfSBlbHNlIGlmICh0cy5pc0NvbnN0cnVjdG9yRGVjbGFyYXRpb24obm9kZSkgJiYgbm9kZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSB0aGlzLmdldFN0YXRlbWVudHNGb3JEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHRoaXMud2FybmluZ0NhbGxzV2VyZUluamVjdGVkID1cbiAgICAgICAgdGhpcy53YXJuaW5nQ2FsbHNXZXJlSW5qZWN0ZWQgfHwgc3RhdGVtZW50cy5sZW5ndGggPiAwO1xuICAgICAgcmV0dXJuIHRzLnVwZGF0ZUNvbnN0cnVjdG9yKFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlLmRlY29yYXRvcnMsXG4gICAgICAgIG5vZGUubW9kaWZpZXJzLFxuICAgICAgICBub2RlLnBhcmFtZXRlcnMsXG4gICAgICAgIHRzLnVwZGF0ZUJsb2NrKG5vZGUuYm9keSwgaW5zZXJ0U3RhdGVtZW50cyhub2RlLmJvZHksIHN0YXRlbWVudHMpKSxcbiAgICAgICkgYXMgYW55O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnZpc2l0RWFjaENoaWxkKG5vZGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdGF0ZW1lbnRzRm9yRGVjbGFyYXRpb24oXG4gICAgbm9kZTpcbiAgICAgIHwgdHMuTWV0aG9kRGVjbGFyYXRpb25cbiAgICAgIHwgdHMuR2V0QWNjZXNzb3JEZWNsYXJhdGlvblxuICAgICAgfCB0cy5TZXRBY2Nlc3NvckRlY2xhcmF0aW9uXG4gICAgICB8IHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24sXG4gICk6IHRzLlN0YXRlbWVudFtdIHtcbiAgICBjb25zdCBrbGFzcyA9IG5vZGUucGFyZW50O1xuICAgIGNvbnN0IGNsYXNzU3ltYm9sSWQgPSBzeW1ib2xJZGVudGlmaWVyKFxuICAgICAgdGhpcy50eXBlQ2hlY2tlcixcbiAgICAgIHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24oa2xhc3MpLnN5bWJvbCxcbiAgICApO1xuICAgIGlmIChjbGFzc1N5bWJvbElkICYmIHRoaXMudHlwZUluZGV4LmhhcyhjbGFzc1N5bWJvbElkKSkge1xuICAgICAgY29uc3QgY2xhc3NUeXBlID0gdGhpcy50eXBlSW5kZXguZ2V0KGNsYXNzU3ltYm9sSWQpISBhcyBzcGVjLkNsYXNzVHlwZTtcblxuICAgICAgaWYgKHRzLmlzQ29uc3RydWN0b3JEZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgICBjb25zdCBpbml0aWFsaXplciA9IGNsYXNzVHlwZT8uaW5pdGlhbGl6ZXI7XG4gICAgICAgIGlmIChpbml0aWFsaXplcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlbWVudHMoY2xhc3NUeXBlLCBpbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbWV0aG9kcyA9IGNsYXNzVHlwZT8ubWV0aG9kcyA/PyBbXTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IG1ldGhvZHMuZmluZChcbiAgICAgICAgKG1ldGhvZCkgPT4gbWV0aG9kLm5hbWUgPT09IG5vZGUubmFtZT8uZ2V0VGV4dCgpLFxuICAgICAgKTtcbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVtZW50cyhjbGFzc1R5cGUsIG1ldGhvZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBjbGFzc1R5cGU/LnByb3BlcnRpZXMgPz8gW107XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZmluZChcbiAgICAgICAgKHByb3BlcnR5KSA9PiBwcm9wZXJ0eS5uYW1lID09PSBub2RlLm5hbWU/LmdldFRleHQoKSxcbiAgICAgICk7XG4gICAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdhcm5pbmdTdGF0ZW1lbnRGb3JFbGVtZW50KHByb3BlcnR5LCBjbGFzc1R5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBwcml2YXRlIGdldFN0YXRlbWVudHMoXG4gICAgY2xhc3NUeXBlOiBzcGVjLkNsYXNzVHlwZSxcbiAgICBtZXRob2Q6IHNwZWMuTWV0aG9kIHwgc3BlYy5Jbml0aWFsaXplcixcbiAgKSB7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IGNyZWF0ZVdhcm5pbmdTdGF0ZW1lbnRGb3JFbGVtZW50KG1ldGhvZCwgY2xhc3NUeXBlKTtcblxuICAgIGZvciAoY29uc3QgcGFyYW1ldGVyIG9mIE9iamVjdC52YWx1ZXMobWV0aG9kLnBhcmFtZXRlcnMgPz8ge30pKSB7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJUeXBlID1cbiAgICAgICAgdGhpcy5hc3NlbWJseS50eXBlcyAmJiBzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHBhcmFtZXRlci50eXBlKVxuICAgICAgICAgID8gdGhpcy5hc3NlbWJseS50eXBlc1twYXJhbWV0ZXIudHlwZS5mcW5dXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChwYXJhbWV0ZXJUeXBlKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke05BTUVTUEFDRX0uJHtmbk5hbWUocGFyYW1ldGVyVHlwZS5mcW4pfWA7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChcbiAgICAgICAgICB0cy5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgICAgICAgdHMuY3JlYXRlQ2FsbChcbiAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcihmdW5jdGlvbk5hbWUpLFxuICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgW3RzLmNyZWF0ZUlkZW50aWZpZXIocGFyYW1ldGVyLm5hbWUpXSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXJuaW5nU3RhdGVtZW50Rm9yRWxlbWVudChcbiAgZWxlbWVudDogc3BlYy5DYWxsYWJsZSB8IHNwZWMuUHJvcGVydHksXG4gIGNsYXNzVHlwZTogc3BlYy5DbGFzc1R5cGUsXG4pOiB0cy5TdGF0ZW1lbnRbXSB7XG4gIGlmIChzcGVjLmlzRGVwcmVjYXRlZChlbGVtZW50KSkge1xuICAgIGNvbnN0IGVsZW1lbnROYW1lID0gKGVsZW1lbnQgYXMgc3BlYy5NZXRob2QgfCBzcGVjLlByb3BlcnR5KS5uYW1lO1xuICAgIGNvbnN0IGZxbiA9IGVsZW1lbnROYW1lID8gYCR7Y2xhc3NUeXBlLmZxbn0jJHtlbGVtZW50TmFtZX1gIDogY2xhc3NUeXBlLmZxbjtcbiAgICBjb25zdCBtZXNzYWdlID0gZWxlbWVudC5kb2NzPy5kZXByZWNhdGVkID8/IGNsYXNzVHlwZS5kb2NzPy5kZXByZWNhdGVkO1xuICAgIHJldHVybiBbY3JlYXRlV2FybmluZ0Z1bmN0aW9uQ2FsbChmcW4sIG1lc3NhZ2UsIHVuZGVmaW5lZCwgdHJ1ZSldO1xuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgbGlzdCBvZiBzdGF0ZW1lbnRzIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluc2lkZSBhIGJsb2NrIG9mIHN0YXRlbWVudHMuXG4gKiBJZiB0aGVyZSBpcyBhIGBzdXBlcmAgY2FsbCwgSXQgaW5zZXJ0cyB0aGUgc3RhdGVtZW50cyBqdXN0IGFmdGVyIGl0LiBPdGhlcndpc2UsXG4gKiBpbnNlcnQgdGhlIHN0YXRlbWVudHMgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluc2VydFN0YXRlbWVudHMoYmxvY2s6IHRzLkJsb2NrLCBuZXdTdGF0ZW1lbnRzOiB0cy5TdGF0ZW1lbnRbXSkge1xuICBmdW5jdGlvbiBzcGxpY2VQb2ludChzdGF0ZW1lbnQ6IHRzLlN0YXRlbWVudCB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBpc1N1cGVyID0gZmFsc2U7XG4gICAgc3RhdGVtZW50LmZvckVhY2hDaGlsZCgobm9kZSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0cy5pc0NhbGxFeHByZXNzaW9uKG5vZGUpICYmXG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbi5raW5kID09PSB0cy5TeW50YXhLaW5kLlN1cGVyS2V5d29yZFxuICAgICAgKSB7XG4gICAgICAgIGlzU3VwZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc1N1cGVyID8gMSA6IDA7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBbLi4uYmxvY2suc3RhdGVtZW50c107XG4gIHJlc3VsdC5zcGxpY2Uoc3BsaWNlUG9pbnQoYmxvY2suc3RhdGVtZW50c1swXSksIDAsIC4uLm5ld1N0YXRlbWVudHMpO1xuICByZXR1cm4gdHMuY3JlYXRlTm9kZUFycmF5KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1SZXF1aXJlU3RhdGVtZW50KHR5cGVMb2NhdGlvbjogc3RyaW5nKTogdHMuU3RhdGVtZW50IHtcbiAgY29uc3QgeyBleHQgfSA9IHBhdGgucGFyc2UodHlwZUxvY2F0aW9uKTtcbiAgY29uc3QganNGaWxlTmFtZSA9IHR5cGVMb2NhdGlvbi5yZXBsYWNlKGV4dCwgJy5qcycpO1xuXG4gIHJldHVybiBjcmVhdGVSZXF1aXJlU3RhdGVtZW50KExPQ0FMX0VOVU1fTkFNRVNQQUNFLCBgLi8ke2pzRmlsZU5hbWV9YCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmVTdGF0ZW1lbnQoXG4gIG5hbWU6IHN0cmluZyxcbiAgaW1wb3J0UGF0aDogc3RyaW5nLFxuKTogdHMuU3RhdGVtZW50IHtcbiAgcmV0dXJuIHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgIHVuZGVmaW5lZCxcbiAgICB0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChcbiAgICAgIFtcbiAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB0cy5jcmVhdGVDYWxsKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ3JlcXVpcmUnKSwgdW5kZWZpbmVkLCBbXG4gICAgICAgICAgICB0cy5jcmVhdGVMaXRlcmFsKGltcG9ydFBhdGgpLFxuICAgICAgICAgIF0pLFxuICAgICAgICApLFxuICAgICAgXSxcbiAgICAgIHRzLk5vZGVGbGFncy5Db25zdCxcbiAgICApLFxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByZWFkeS10by11c2VkIGZ1bmN0aW9uIG5hbWUgKGluY2x1ZGluZyBhIGByZXF1aXJlYCwgaWYgbmVjZXNzYXJ5KVxuICovXG5mdW5jdGlvbiBpbXBvcnRlZEZ1bmN0aW9uTmFtZShcbiAgdHlwZU5hbWU6IHN0cmluZyxcbiAgYXNzZW1ibHk6IEFzc2VtYmx5LFxuICBwcm9qZWN0SW5mbzogUHJvamVjdEluZm8sXG4pIHtcbiAgY29uc3QgYXNzZW1ibGllcyA9IHByb2plY3RJbmZvLmRlcGVuZGVuY3lDbG9zdXJlLmNvbmNhdChhc3NlbWJseSk7XG4gIGNvbnN0IHsgdHlwZSwgbW9kdWxlTmFtZSB9ID0gZmluZFR5cGUodHlwZU5hbWUsIGFzc2VtYmxpZXMpO1xuICBpZiAodHlwZSkge1xuICAgIHJldHVybiBtb2R1bGVOYW1lICE9PSBhc3NlbWJseS5uYW1lXG4gICAgICA/IGByZXF1aXJlKFwiJHttb2R1bGVOYW1lfS8ke1dBUk5JTkdTQ09ERV9GSUxFX05BTUV9XCIpLiR7Zm5OYW1lKHR5cGUuZnFuKX1gXG4gICAgICA6IGZuTmFtZSh0eXBlLmZxbik7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSB0eXBlIGFuZCBtb2R1bGUgbmFtZSBpbiBhbiBhcnJheSBvZiBhc3NlbWJsaWVzXG4gKiBtYXRjaGluZyBhIGdpdmVuIHR5cGUgbmFtZVxuICovXG5mdW5jdGlvbiBmaW5kVHlwZSh0eXBlTmFtZTogc3RyaW5nLCBhc3NlbWJsaWVzOiBBc3NlbWJseVtdKSB7XG4gIGZvciAoY29uc3QgYXNtIG9mIGFzc2VtYmxpZXMpIHtcbiAgICBpZiAoYXNtLm1ldGFkYXRhPy5qc2lpPy5jb21waWxlZFdpdGhEZXByZWNhdGlvbldhcm5pbmdzKSB7XG4gICAgICBjb25zdCB0eXBlcyA9IGFzbS50eXBlcyA/PyB7fTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh0eXBlcykpIHtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZXNbbmFtZV0sIG1vZHVsZU5hbWU6IGFzbS5uYW1lIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUeXBlSGFuZGxlckNhbGwoXG4gIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuICBwYXJhbWV0ZXI6IHN0cmluZyxcbik6IHRzLlN0YXRlbWVudCB7XG4gIHJldHVybiB0cy5jcmVhdGVJZihcbiAgICB0cy5jcmVhdGVJZGVudGlmaWVyKGAhJHtWSVNJVEVEX09CSkVDVFNfU0VUX05BTUV9Lmhhcygke3BhcmFtZXRlcn0pYCksXG4gICAgdHMuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgIHRzLmNyZWF0ZUNhbGwoXG4gICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoZnVuY3Rpb25OYW1lKSxcbiAgICAgICAgW10sXG4gICAgICAgIFt0cy5jcmVhdGVJZGVudGlmaWVyKHBhcmFtZXRlcildLFxuICAgICAgKSxcbiAgICApLFxuICApO1xufVxuXG4vKipcbiAqIFRoZXJlIGlzIGEgY2hhbmNlIGFuIGVudW0gY29udGFpbnMgZHVwbGljYXRlcyB2YWx1ZXMgd2l0aCBkaXN0aW5jdCBrZXlzLFxuICogd2l0aCBvbmUgb2YgdGhvc2Uga2V5cyBiZWluZyBkZXByZWNhdGVkLiBUaGlzIGlzIGEgcG90ZW50aWFsIHBhdHRlcm4gdG8gXCJyZW5hbWVcIiBhbiBlbnVtLlxuICogSW4gdGhpcyBjYXNlLCB3ZSBjYW4ndCBjb25jcmV0ZWx5IGRldGVybWluZSBpZiB0aGUgZGVwcmVjYXRlZCBtZW1iZXIgd2FzIHVzZWQgb3Igbm90LFxuICogc28gaW4gdGhvc2UgY2FzZXMgd2Ugc2tpcCB0aGUgd2FybmluZ3MgYWx0b2dldGhlciwgcmF0aGVyIHRoYW4gZXJyb25lb3VzbHkgd2FybmluZyBmb3IgdmFsaWQgdXNhZ2UuXG4gKiBUaGlzIGNyZWF0ZSBhIHN0YXRlbWVudCB0byBjaGVjayBpZiB0aGUgZW51bSB2YWx1ZSBpcyBhIGR1cGxpY2F0ZTpcbiAqXG4gKiBpZiAoT2JqZWN0LnZhbHVlcyhGb28pLmZpbHRlcih4ID0+IHggPT09IHApLmxlbmd0aCA+IDEpIHsgcmV0dXJuOyB9XG4gKlxuICogTm90ZSB0aGF0IHdlIGNhbid0IGp1c3QgY2hlY2sgdGhlIGFzc2VtYmx5IGZvciB0aGVzZSBkdXBsaWNhdGVzLCBkdWUgdG86XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2pzaWkvaXNzdWVzLzI3ODJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlRW51bVZhbHVlc0NoZWNrKFxuICB0eXBlOiBzcGVjLlR5cGVCYXNlICYgc3BlYy5FbnVtVHlwZSxcbik6IHRzLlN0YXRlbWVudCB7XG4gIHJldHVybiB0cy5jcmVhdGVJZihcbiAgICB0cy5jcmVhdGVCaW5hcnkoXG4gICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgdHMuY3JlYXRlQ2FsbChcbiAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgIHRzLmNyZWF0ZUNhbGwodHMuY3JlYXRlSWRlbnRpZmllcignT2JqZWN0LnZhbHVlcycpLCB1bmRlZmluZWQsIFtcbiAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcihgJHtMT0NBTF9FTlVNX05BTUVTUEFDRX0uJHt0eXBlLm5hbWV9YCksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2ZpbHRlcicpLFxuICAgICAgICAgICksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHRzLmNyZWF0ZUFycm93RnVuY3Rpb24oXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBbdHMuY3JlYXRlUGFyYW1ldGVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsICd4JyldLFxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZVRva2VuKHRzLlN5bnRheEtpbmQuRXF1YWxzR3JlYXRlclRoYW5Ub2tlbiksXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZUJpbmFyeShcbiAgICAgICAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKCd4JyksXG4gICAgICAgICAgICAgICAgdHMuY3JlYXRlVG9rZW4odHMuU3ludGF4S2luZC5FcXVhbHNFcXVhbHNFcXVhbHNUb2tlbiksXG4gICAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcihQQVJBTUVURVJfTkFNRSksXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0sXG4gICAgICAgICksXG4gICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2xlbmd0aCcpLFxuICAgICAgKSxcbiAgICAgIHRzLmNyZWF0ZVRva2VuKHRzLlN5bnRheEtpbmQuR3JlYXRlclRoYW5Ub2tlbiksXG4gICAgICB0cy5jcmVhdGVOdW1lcmljTGl0ZXJhbCgnMScpLFxuICAgICksXG4gICAgdHMuY3JlYXRlUmV0dXJuKCksXG4gICk7XG59XG5cbi8qKlxuICogRm9yY2UgYSBwYXRoIHRvIGJlIFVOSVh5ICh1c2UgYC9gIGFzIGEgc2VwYXJhdG9yKVxuICpcbiAqIGBwYXRoLmpvaW4oKWAgZXRjLiB3aWxsIHVzZSB0aGUgc3lzdGVtLWRlcGVuZGVudCBwYXRoIHNlcGFyYXRvciAoZWl0aGVyIGAvYCBvciBgXFxgXG4gKiBkZXBlbmRpbmcgb24geW91ciBwbGF0Zm9ybSkuXG4gKlxuICogSG93ZXZlciwgaWYgd2UgYWN0dWFsbHkgZW1pdCB0aGUgcGF0aC1kZXBlbmRlbnQgc2VwYXJhdG9yIHRvIHRoZSBgLmpzYCBmaWxlcywgdGhlblxuICogZmlsZXMgY29tcGlsZWQgd2l0aCBqc2lpIG9uIFdpbmRvd3MgY2Fubm90IGJlIHVzZWQgb24gYW55IG90aGVyIHBsYXRmb3JtLiBUaGF0IHNlZW1zXG4gKiBsaWtlIGFuIHVubmVjZXNzYXJ5IHJlc3RyaWN0aW9uLCBlc3BlY2lhbGx5IHNpbmNlIGEgYC9gIHdpbGwgd29yayBmaW5lIG9uIFdpbmRvd3MsXG4gKiBzbyBtYWtlIHN1cmUgdG8gYWx3YXlzIGVtaXQgYC9gLlxuICpcbiAqIFRTQyBpdHNlbGYgYWx3YXlzIHN0cmljdGx5IGVtaXRzIGAvYCAob3IgYXQgbGVhc3QsIGVtaXRzIHRoZSBzYW1lIHdoYXQgeW91IHB1dCBpbikuXG4gKi9cbmZ1bmN0aW9uIHVuaXhQYXRoKGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgaWYgKHBhdGguc2VwID09PSAnXFxcXCcpIHtcbiAgICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICB9XG4gIHJldHVybiBmaWxlUGF0aDtcbn1cbiJdfQ==