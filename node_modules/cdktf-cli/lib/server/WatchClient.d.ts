import { SynthesizedStack } from "../../bin/cmds/helper/synth-stack";
import { DeployingResource } from "../../bin/cmds/ui/models/terraform";
import { TerraformJson } from "../../bin/cmds/ui/terraform-json";
interface WatchClientOptions {
    targetDir: string;
    synthCommand: string;
    autoApprove: boolean;
    targetStack?: string;
}
declare type Action = "INIT" | "SYNTH" | "DEPLOY";
declare type Stack = SynthesizedStack & {
    json: TerraformJson;
};
export declare type TimestampedDeployingResource = DeployingResource & {
    changedAt: number;
};
declare type WatchStateStatus = "IDLE" | "SYNTHESIZING" | "INITIALIZING" | "PLANNING" | "DEPLOYING";
export declare type WatchErrorOrigin = WatchStateStatus;
declare type WatchError = {
    message: string;
    origin: WatchErrorOrigin;
    recoverable: boolean;
    timestamp: number;
};
export interface WatchState {
    status: WatchStateStatus;
    stacks: Stack[];
    resources: Map<TimestampedDeployingResource["id"], TimestampedDeployingResource>;
    error?: WatchError;
}
export declare type SubscriptionHandler = (state: WatchState) => void | Promise<void>;
export declare class WatchClient {
    readonly targetDir: string;
    readonly synthCommand: string;
    readonly autoApprove: boolean;
    readonly targetStack?: string;
    private subscribers;
    private running;
    private needsInit;
    private actionQueue;
    private lastTargetStackHash?;
    private readonly state;
    private sourceFileWatcher?;
    private outDirWatcher?;
    constructor(options: WatchClientOptions);
    isRunning(): boolean;
    subscribe(handler: SubscriptionHandler): () => void;
    private updateState;
    private runSynth;
    private runInit;
    private runDeploy;
    private handleTerraformOutput;
    private getTargetStack;
    private getTerraform;
    start(): Promise<void>;
    queueAction(action: Action, priority?: boolean): Promise<void>;
    private startHandlingActions;
    stop(): Promise<void>;
}
export {};
