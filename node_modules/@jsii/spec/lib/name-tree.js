"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NameTree = void 0;
/**
 * A tree of all names in a module. A node represent a type (terminal)
 * and may represent another node in the namespace (at the same time).
 * Therefore, a key of '_' represents a terminal and references the fqn
 * of the type.
 *
 * For example, say we have the following types:
 *   - aws.ec2.Host
 *   - aws.ec2.Instance
 *   - aws.ec2.Instance.Subtype
 *
 * the the name tree will look like this:
 *
 * module: {
 *   children: {
 *     aws: {
 *       children {
 *         ec2: {
 *           children: {
 *             Host: {
 *               fqn: 'aws.ec2.Host',
 *               children: {}
 *             },
 *             Instance: {
 *               fqn: 'aws.ec2.Host',
 *               children: {
 *                 Subtype: {
 *                   fqn: 'aws.ec2.Host.Subtype',
 *                   children: {}
 *                 }
 *               }
 *             }
 *           }
 *         }
 *       }
 *     }
 *   }
 * }
 */
class NameTree {
    /* NameTree.of(assembly) should be used. */
    constructor() {
        this._children = {};
    }
    static of(assm) {
        var _a;
        const nameTree = new NameTree();
        for (const type of Object.values((_a = assm.types) !== null && _a !== void 0 ? _a : {})) {
            nameTree.register(type.fqn);
        }
        return nameTree;
    }
    /** The children of this node, by name. */
    get children() {
        return this._children;
    }
    /** The fully qualified name of the type at this node, if there is one. */
    get fqn() {
        return this._fqn;
    }
    /**
     * Adds a type to this ``NameTree``.
     *
     * @param type the type to be added.
     * @param path the path at which to add the node under this tree.
     */
    register(fqn, path = fqn.split('.')) {
        if (path.length === 0) {
            this._fqn = fqn;
        }
        else {
            const [head, ...rest] = path;
            if (!this._children[head]) {
                this._children[head] = new NameTree();
            }
            this._children[head].register(fqn, rest);
        }
        return this;
    }
}
exports.NameTree = NameTree;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmFtZS10cmVlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibmFtZS10cmVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNDRztBQUNILE1BQWEsUUFBUTtJQVluQiwyQ0FBMkM7SUFDM0M7UUFKUSxjQUFTLEdBQWlDLEVBQUUsQ0FBQztJQUk5QixDQUFDO0lBWmpCLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBbUI7O1FBQ2xDLE1BQU0sUUFBUSxHQUFHLElBQUksUUFBUSxFQUFFLENBQUM7UUFDaEMsS0FBSyxNQUFNLElBQUksSUFBSSxNQUFNLENBQUMsTUFBTSxPQUFDLElBQUksQ0FBQyxLQUFLLG1DQUFJLEVBQUUsQ0FBQyxFQUFFO1lBQ2xELFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzdCO1FBQ0QsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQVFELDBDQUEwQztJQUMxQyxJQUFXLFFBQVE7UUFDakIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3hCLENBQUM7SUFFRCwwRUFBMEU7SUFDMUUsSUFBVyxHQUFHO1FBQ1osT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLFFBQVEsQ0FBQyxHQUFXLEVBQUUsT0FBaUIsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDM0QsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNyQixJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztTQUNqQjthQUFNO1lBQ0wsTUFBTSxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQztZQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLFFBQVEsRUFBRSxDQUFDO2FBQ3ZDO1lBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzNDO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0Y7QUEzQ0QsNEJBMkNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3BlYyBmcm9tICcuL2Fzc2VtYmx5JztcblxuLyoqXG4gKiBBIHRyZWUgb2YgYWxsIG5hbWVzIGluIGEgbW9kdWxlLiBBIG5vZGUgcmVwcmVzZW50IGEgdHlwZSAodGVybWluYWwpXG4gKiBhbmQgbWF5IHJlcHJlc2VudCBhbm90aGVyIG5vZGUgaW4gdGhlIG5hbWVzcGFjZSAoYXQgdGhlIHNhbWUgdGltZSkuXG4gKiBUaGVyZWZvcmUsIGEga2V5IG9mICdfJyByZXByZXNlbnRzIGEgdGVybWluYWwgYW5kIHJlZmVyZW5jZXMgdGhlIGZxblxuICogb2YgdGhlIHR5cGUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHNheSB3ZSBoYXZlIHRoZSBmb2xsb3dpbmcgdHlwZXM6XG4gKiAgIC0gYXdzLmVjMi5Ib3N0XG4gKiAgIC0gYXdzLmVjMi5JbnN0YW5jZVxuICogICAtIGF3cy5lYzIuSW5zdGFuY2UuU3VidHlwZVxuICpcbiAqIHRoZSB0aGUgbmFtZSB0cmVlIHdpbGwgbG9vayBsaWtlIHRoaXM6XG4gKlxuICogbW9kdWxlOiB7XG4gKiAgIGNoaWxkcmVuOiB7XG4gKiAgICAgYXdzOiB7XG4gKiAgICAgICBjaGlsZHJlbiB7XG4gKiAgICAgICAgIGVjMjoge1xuICogICAgICAgICAgIGNoaWxkcmVuOiB7XG4gKiAgICAgICAgICAgICBIb3N0OiB7XG4gKiAgICAgICAgICAgICAgIGZxbjogJ2F3cy5lYzIuSG9zdCcsXG4gKiAgICAgICAgICAgICAgIGNoaWxkcmVuOiB7fVxuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIEluc3RhbmNlOiB7XG4gKiAgICAgICAgICAgICAgIGZxbjogJ2F3cy5lYzIuSG9zdCcsXG4gKiAgICAgICAgICAgICAgIGNoaWxkcmVuOiB7XG4gKiAgICAgICAgICAgICAgICAgU3VidHlwZToge1xuICogICAgICAgICAgICAgICAgICAgZnFuOiAnYXdzLmVjMi5Ib3N0LlN1YnR5cGUnLFxuICogICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHt9XG4gKiAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgfVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lVHJlZSB7XG4gIHB1YmxpYyBzdGF0aWMgb2YoYXNzbTogc3BlYy5Bc3NlbWJseSk6IE5hbWVUcmVlIHtcbiAgICBjb25zdCBuYW1lVHJlZSA9IG5ldyBOYW1lVHJlZSgpO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3QudmFsdWVzKGFzc20udHlwZXMgPz8ge30pKSB7XG4gICAgICBuYW1lVHJlZS5yZWdpc3Rlcih0eXBlLmZxbik7XG4gICAgfVxuICAgIHJldHVybiBuYW1lVHJlZTtcbiAgfVxuXG4gIHByaXZhdGUgX2NoaWxkcmVuOiB7IFtuYW1lOiBzdHJpbmddOiBOYW1lVHJlZSB9ID0ge307XG4gIHByaXZhdGUgX2Zxbj86IHN0cmluZztcblxuICAvKiBOYW1lVHJlZS5vZihhc3NlbWJseSkgc2hvdWxkIGJlIHVzZWQuICovXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKiBUaGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCBieSBuYW1lLiAqL1xuICBwdWJsaWMgZ2V0IGNoaWxkcmVuKCk6IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE5hbWVUcmVlIH0ge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgfVxuXG4gIC8qKiBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb2YgdGhlIHR5cGUgYXQgdGhpcyBub2RlLCBpZiB0aGVyZSBpcyBvbmUuICovXG4gIHB1YmxpYyBnZXQgZnFuKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2ZxbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdHlwZSB0byB0aGlzIGBgTmFtZVRyZWVgYC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgdG8gYmUgYWRkZWQuXG4gICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIGF0IHdoaWNoIHRvIGFkZCB0aGUgbm9kZSB1bmRlciB0aGlzIHRyZWUuXG4gICAqL1xuICBwcml2YXRlIHJlZ2lzdGVyKGZxbjogc3RyaW5nLCBwYXRoOiBzdHJpbmdbXSA9IGZxbi5zcGxpdCgnLicpKTogdGhpcyB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9mcW4gPSBmcW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtoZWFkLCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICBpZiAoIXRoaXMuX2NoaWxkcmVuW2hlYWRdKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2hlYWRdID0gbmV3IE5hbWVUcmVlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGlsZHJlbltoZWFkXSEucmVnaXN0ZXIoZnFuLCByZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiJdfQ==